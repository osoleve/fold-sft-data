{"id": "sparse_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-coo-ref`\nSpec: Lookup COO element at (i,j); return 0 if coordinate is absent.\n\nWrite exactly one Scheme function definition for `sparse-coo-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "sparse-coo-ref"], "split": "eval"}
{"id": "sparse_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-csr-ref`\nSpec: Lookup CSR element at (i,j) by scanning the row segment.\n\nWrite exactly one Scheme function definition for `sparse-csr-ref`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "sparse-csr-ref"], "split": "eval"}
{"id": "sparse_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-coo-add-impl`\nSpec: Add two COO matrices via HAMT accumulation and tolerance-based near-zero dropping.\n\nWrite exactly one Scheme function definition for `sparse-coo-add-impl`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))\n  (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "sparse-coo-add-impl"], "split": "eval"}
{"id": "sparse_translation_001", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-coo-from-triplets`\n\n```python\ndef sparse_coo_from_triplets(rows, cols, triplets):\n    n = len(triplets)\n    r = [0] * n\n    c = [0] * n\n    v = [0] * n\n    for i, t in enumerate(triplets):\n        r[i] = t[0]\n        c[i] = t[1]\n        v[i] = t[2]\n    return make_sparse_coo(rows, cols, list_to_vector(r), list_to_vector(c), list_to_vector(v))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "python", "sparse-coo-from-triplets"], "split": "eval"}
{"id": "sparse_translation_009", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `dense->sparse-coo`\n\n```python\ndef dense_to_sparse_coo(m, tol=0):\n    rows = matrix_rows(m)\n    cols = matrix_cols(m)\n    data = matrix_data(m)\n    r, c, v = [], [], []\n    for i, x in enumerate(data):\n        if abs(x) > tol:\n            r.append(i // cols)\n            c.append(i % cols)\n            v.append(x)\n    return make_sparse_coo(rows, cols, list_to_vector(r), list_to_vector(c), list_to_vector(v))\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))\n  (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "python", "dense->sparse-coo"], "split": "eval"}
{"id": "sparse_translation_016", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-coo-drop-below`\n\n```scheme\n(define (coo-drop tol coo)\n  (let* ((rows (sparse-coo-rows coo))\n         (cols (sparse-coo-cols coo))\n         (row-idx (sparse-coo-row-indices coo))\n         (col-idx (sparse-coo-col-indices coo))\n         (vals (sparse-coo-values coo))\n         (nnz (sparse-coo-nnz coo))\n         (keep-count (let loop ((k 0) (count 0))\n                       (if (= k nnz)\n                           count\n                           (loop (+ k 1)\n                                 (if (>= (abs (vector-ref vals k)) tol)\n                                     (+ count 1)\n                                     count)))))\n         (new-rows (make-vector keep-count 0))\n         (new-cols (make-vector keep-count 0))\n         (new-vals (make-vector keep-count 0)))\n    (let loop ((k 0) (j 0))\n      (if (= k nnz)\n          (make-sparse-coo rows cols new-rows new-cols new-vals)\n          (let ((v (vector-ref vals k)))\n            (if (>= (abs v) tol)\n                (begin\n                  (vector-set! new-rows j (vector-ref row-idx k))\n                  (vector-set! new-cols j (vector-ref col-idx k))\n                  (vector-set! new-vals j v)\n                  (loop (+ k 1) (+ j 1)))\n                (loop (+ k 1) j))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "chez", "sparse-coo-drop-below"], "split": "eval"}
{"id": "sparse_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-from-triplets` in `lattice/linalg/sparse.ss`.\nKnown issue: Row and column indices are swapped while loading triplets.\n\n```scheme\n(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)] [row-idx (make-vector n 0)] [col-idx (make-vector n 0)] [vals (make-vector n 0)])\n    (do ([i 0 (+ i 1)] [ts triplets (cdr ts)])\n        ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n      (let ([t (car ts)])\n        (vector-set! row-idx i (cadr t))\n        (vector-set! col-idx i (car t))\n        (vector-set! vals i (caddr t))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-from-triplets"], "split": "eval"}
{"id": "sparse_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dense->sparse-coo` in `lattice/linalg/sparse.ss`.\nKnown issue: Conversion must skip entries below tolerance and size arrays to true nnz.\n\n```scheme\n(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))] [rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)] [nnz (vector-length data)] [row-idx (make-vector nnz 0)] [col-idx (make-vector nnz 0)] [vals (make-vector nnz 0)])\n    (let loop ([i 0] [k 0])\n      (if (= i (vector-length data))\n          (make-sparse-coo rows cols row-idx col-idx vals)\n          (let ([v (vector-ref data i)])\n            (vector-set! row-idx k (quotient i cols))\n            (vector-set! col-idx k (remainder i cols))\n            (vector-set! vals k v)\n            (loop (+ i 1) (+ k 1)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Conversion must skip entries below tolerance and size arrays to true nnz.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))\n  (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "dense->sparse-coo"], "split": "eval"}
{"id": "sparse_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-drop-below` in `lattice/linalg/sparse.ss`.\nKnown issue: Keep condition is inverted; entries with magnitude >= tol should be retained.\n\n```scheme\n(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)] [cols (sparse-coo-cols coo)] [row-idx (sparse-coo-row-indices coo)] [col-idx (sparse-coo-col-indices coo)] [vals (sparse-coo-values coo)] [nnz (sparse-coo-nnz coo)] [keep-count (let loop ([k 0] [count 0]) (if (= k nnz) count (loop (+ k 1) (if (< (abs (vector-ref vals k)) tol) (+ count 1) count))))] [new-rows (make-vector keep-count 0)] [new-cols (make-vector keep-count 0)] [new-vals (make-vector keep-count 0)])\n    (let loop ([k 0] [j 0])\n      (if (= k nnz)\n          (make-sparse-coo rows cols new-rows new-cols new-vals)\n          (let ([v (vector-ref vals k)])\n            (if (< (abs v) tol)\n                (begin (vector-set! new-rows j (vector-ref row-idx k)) (vector-set! new-cols j (vector-ref col-idx k)) (vector-set! new-vals j v) (loop (+ k 1) (+ j 1)))\n                (loop (+ k 1) j)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-drop-below"], "split": "eval"}
{"id": "sparse_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild COO from three triplets and return nnz.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-coo-nnz (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9))))", "verify_expr": "(equal? (sparse-coo-nnz (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))) 3)", "tags": ["linalg", "sparse", "composition", "sparse-coo-from-triplets", "direct"], "split": "eval"}
{"id": "sparse_composition_009", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert unsorted COO to CSR and read (0,2).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-csr-ref (coo->csr (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))) 0 2)", "verify_expr": "(equal? (sparse-csr-ref (coo->csr (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))) 0 2) 2)", "tags": ["linalg", "sparse", "composition", "coo->csr", "direct"], "split": "eval"}
{"id": "sparse_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert dense matrix ((1 0 2)(0 3 0)) to COO and return nnz.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-coo-nnz (dense->sparse-coo (matrix-from-lists '((1 0 2) (0 3 0)))))", "verify_expr": "(equal? (sparse-coo-nnz (dense->sparse-coo (matrix-from-lists '((1 0 2) (0 3 0))))) 3)", "tags": ["linalg", "sparse", "composition", "dense->sparse-coo", "direct"], "split": "eval"}
{"id": "sparse_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: compose existing APIs into one expression.\n\nMatvec with zero vector should return zero vector.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-csr-vec-mul (coo->csr (sparse-coo-from-triplets 2 2 '((0 0 3) (1 1 4)))) (vec 0 0))", "verify_expr": "(equal? (sparse-csr-vec-mul (coo->csr (sparse-coo-from-triplets 2 2 '((0 0 3) (1 1 4)))) (vec 0 0)) (vec 0 0))", "tags": ["linalg", "sparse", "composition", "sparse-csr-vec-mul", "property"], "split": "eval"}
{"id": "sparse_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDropping after add should match direct cancellation behavior.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-coo-nnz (sparse-coo-drop-below 1e-14 (sparse-coo-add-impl (sparse-coo-from-triplets 1 1 '((0 0 0.1))) (sparse-coo-from-triplets 1 1 '((0 0 -0.1))))))", "verify_expr": "(equal? (sparse-coo-nnz (sparse-coo-drop-below 1e-14 (sparse-coo-add-impl (sparse-coo-from-triplets 1 1 '((0 0 0.1))) (sparse-coo-from-triplets 1 1 '((0 0 -0.1)))))) 0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-drop-below", "integration"], "split": "eval"}
