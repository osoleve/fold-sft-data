{"id": "sparse_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-coo-from-triplets`\nSpec: Build COO sparse matrix from list of (row col value) triplets.\n\nWrite exactly one Scheme function definition for `sparse-coo-from-triplets`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "sparse-coo-from-triplets"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-coo-from-triplets`\nSpec: Build COO sparse matrix from list of (row col value) triplets.\n\nWrite exactly one Scheme function definition for `sparse-coo-from-triplets`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sparse_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-from-triplets`\nBehavior contract: Build COO sparse matrix from list of (row col value) triplets.\n\n```scheme\n(define (sparse-coo-from-triplets rows cols triplets)\n  ;; TODO: fill row/col/value vectors from triplets\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "sparse-coo-from-triplets"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-from-triplets`\nBehavior contract: Build COO sparse matrix from list of (row col value) triplets.\n\n```scheme\n(define (sparse-coo-from-triplets rows cols triplets)\n  ;; TODO: fill row/col/value vectors from triplets\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "sparse_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-ref`\nBehavior contract: Lookup COO element at (i,j); return 0 if coordinate is absent.\n\n```scheme\n(define (sparse-coo-ref m i j)\n  ;; TODO: scan COO entries for coordinate, else return 0\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "sparse-coo-ref"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-ref`\nBehavior contract: Lookup COO element at (i,j); return 0 if coordinate is absent.\n\n```scheme\n(define (sparse-coo-ref m i j)\n  ;; TODO: scan COO entries for coordinate, else return 0\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sparse_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `coo->csr`\nSpec: Convert COO to CSR, sorting by (row,col) and building row pointers.\n\nWrite exactly one Scheme function definition for `coo->csr`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))", "tags": ["linalg", "sparse", "spec-to-code", "coo->csr"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `coo->csr`\nSpec: Convert COO to CSR, sorting by (row,col) and building row pointers.\n\nWrite exactly one Scheme function definition for `coo->csr`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sparse_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `coo->csr`\nBehavior contract: Convert COO to CSR, sorting by (row,col) and building row pointers.\n\n```scheme\n(define (coo->csr coo)\n  ;; TODO: sort COO indices and build CSR row pointers and payload arrays\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "coo->csr"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `coo->csr`\nBehavior contract: Convert COO to CSR, sorting by (row,col) and building row pointers.\n\n```scheme\n(define (coo->csr coo)\n  ;; TODO: sort COO indices and build CSR row pointers and payload arrays\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sparse_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-csr-ref`\nBehavior contract: Lookup CSR element at (i,j) by scanning the row segment.\n\n```scheme\n(define (sparse-csr-ref m i j)\n  ;; TODO: search row segment in CSR\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "sparse-csr-ref"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-csr-ref`\nBehavior contract: Lookup CSR element at (i,j) by scanning the row segment.\n\n```scheme\n(define (sparse-csr-ref m i j)\n  ;; TODO: search row segment in CSR\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sparse_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `dense->sparse-coo`\nSpec: Convert dense matrix to COO, dropping values with |v| <= tolerance (default 0).\n\nWrite exactly one Scheme function definition for `dense->sparse-coo`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))\n  (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "dense->sparse-coo"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `dense->sparse-coo`\nSpec: Convert dense matrix to COO, dropping values with |v| <= tolerance (default 0).\n\nWrite exactly one Scheme function definition for `dense->sparse-coo`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sparse_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `dense->sparse-coo`\nBehavior contract: Convert dense matrix to COO, dropping values with |v| <= tolerance (default 0).\n\n```scheme\n(define (dense->sparse-coo m . tol-arg)\n  ;; TODO: two-pass dense->COO conversion with tolerance\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))\n  (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "dense->sparse-coo"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `dense->sparse-coo`\nBehavior contract: Convert dense matrix to COO, dropping values with |v| <= tolerance (default 0).\n\n```scheme\n(define (dense->sparse-coo m . tol-arg)\n  ;; TODO: two-pass dense->COO conversion with tolerance\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "sparse_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-csr-vec-mul`\nSpec: Multiply CSR matrix by vector; return dimension mismatch error when incompatible.\n\nWrite exactly one Scheme function definition for `sparse-csr-vec-mul`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-rows m)\n  (list-ref m 1))\n  (define (sparse-csr-cols m)\n  (list-ref m 2))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))", "tags": ["linalg", "sparse", "spec-to-code", "sparse-csr-vec-mul"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-csr-vec-mul`\nSpec: Multiply CSR matrix by vector; return dimension mismatch error when incompatible.\n\nWrite exactly one Scheme function definition for `sparse-csr-vec-mul`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sparse_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-csr-vec-mul`\nBehavior contract: Multiply CSR matrix by vector; return dimension mismatch error when incompatible.\n\n```scheme\n(define (sparse-csr-vec-mul m v)\n  ;; TODO: CSR matrix-vector multiply with dimension check\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-rows m)\n  (list-ref m 1))\n  (define (sparse-csr-cols m)\n  (list-ref m 2))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "sparse-csr-vec-mul"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-csr-vec-mul`\nBehavior contract: Multiply CSR matrix by vector; return dimension mismatch error when incompatible.\n\n```scheme\n(define (sparse-csr-vec-mul m v)\n  ;; TODO: CSR matrix-vector multiply with dimension check\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sparse_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-add-impl`\nBehavior contract: Add two COO matrices via HAMT accumulation and tolerance-based near-zero dropping.\n\n```scheme\n(define (sparse-coo-add-impl a b . eps-arg)\n  ;; TODO: accumulate sums by coordinate and drop near-zeros\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))\n  (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "sparse-coo-add-impl"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-add-impl`\nBehavior contract: Add two COO matrices via HAMT accumulation and tolerance-based near-zero dropping.\n\n```scheme\n(define (sparse-coo-add-impl a b . eps-arg)\n  ;; TODO: accumulate sums by coordinate and drop near-zeros\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sparse_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-coo-drop-below`\nSpec: Remove COO entries with magnitude below tolerance.\n\nWrite exactly one Scheme function definition for `sparse-coo-drop-below`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "sparse-coo-drop-below"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/sparse.ss\nFunction: `sparse-coo-drop-below`\nSpec: Remove COO entries with magnitude below tolerance.\n\nWrite exactly one Scheme function definition for `sparse-coo-drop-below`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "sparse_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-drop-below`\nBehavior contract: Remove COO entries with magnitude below tolerance.\n\n```scheme\n(define (sparse-coo-drop-below tol coo)\n  ;; TODO: filter COO entries by magnitude threshold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))", "tags": ["linalg", "sparse", "spec-to-code", "skeleton", "sparse-coo-drop-below"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/sparse.ss\nFunction target: `sparse-coo-drop-below`\nBehavior contract: Remove COO entries with magnitude below tolerance.\n\n```scheme\n(define (sparse-coo-drop-below tol coo)\n  ;; TODO: filter COO entries by magnitude threshold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "sparse_translation_002", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-coo-from-triplets`\n\n```scheme\n(define (coo-from-triplets r c ts)\n  (let* ((n (length ts))\n         (ri (make-vector n 0))\n         (ci (make-vector n 0))\n         (vs (make-vector n 0)))\n    (do ((i 0 (+ i 1))\n         (xs ts (cdr xs)))\n        ((= i n) (make-sparse-coo r c ri ci vs))\n      (let ((t (car xs)))\n        (vector-set! ri i (car t))\n        (vector-set! ci i (cadr t))\n        (vector-set! vs i (caddr t))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "chez", "sparse-coo-from-triplets"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-coo-from-triplets`\n\n```scheme\n(define (coo-from-triplets r c ts)\n  (let* ((n (length ts))\n         (ri (make-vector n 0))\n         (ci (make-vector n 0))\n         (vs (make-vector n 0)))\n    (do ((i 0 (+ i 1))\n         (xs ts (cdr xs)))\n        ((= i n) (make-sparse-coo r c ri ci vs))\n      (let ((t (car xs)))\n        (vector-set! ri i (car t))\n        (vector-set! ci i (cadr t))\n        (vector-set! vs i (caddr t))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sparse_translation_003", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-coo-ref`\n\n```python\ndef sparse_coo_ref(m, i, j):\n    row_idx = sparse_coo_row_indices(m)\n    col_idx = sparse_coo_col_indices(m)\n    vals = sparse_coo_values(m)\n    nnz = sparse_coo_nnz(m)\n    k = 0\n    while k < nnz:\n        if row_idx[k] == i and col_idx[k] == j:\n            return vals[k]\n        k += 1\n    return 0\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))", "tags": ["linalg", "sparse", "translation", "python", "sparse-coo-ref"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-coo-ref`\n\n```python\ndef sparse_coo_ref(m, i, j):\n    row_idx = sparse_coo_row_indices(m)\n    col_idx = sparse_coo_col_indices(m)\n    vals = sparse_coo_values(m)\n    nnz = sparse_coo_nnz(m)\n    k = 0\n    while k < nnz:\n        if row_idx[k] == i and col_idx[k] == j:\n            return vals[k]\n        k += 1\n    return 0\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sparse_translation_004", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-coo-ref`\n\n```scheme\n(define (coo-ref m i j)\n  (let ((ri (sparse-coo-row-indices m))\n        (ci (sparse-coo-col-indices m))\n        (vs (sparse-coo-values m))\n        (n (sparse-coo-nnz m)))\n    (let loop ((k 0))\n      (cond ((= k n) 0)\n            ((and (= (vector-ref ri k) i) (= (vector-ref ci k) j)) (vector-ref vs k))\n            (else (loop (+ k 1)))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))", "tags": ["linalg", "sparse", "translation", "chez", "sparse-coo-ref"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-coo-ref`\n\n```scheme\n(define (coo-ref m i j)\n  (let ((ri (sparse-coo-row-indices m))\n        (ci (sparse-coo-col-indices m))\n        (vs (sparse-coo-values m))\n        (n (sparse-coo-nnz m)))\n    (let loop ((k 0))\n      (cond ((= k n) 0)\n            ((and (= (vector-ref ri k) i) (= (vector-ref ci k) j)) (vector-ref vs k))\n            (else (loop (+ k 1)))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sparse_translation_005", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `coo->csr`\n\n```python\ndef coo_to_csr(coo):\n    rows = sparse_coo_rows(coo)\n    cols = sparse_coo_cols(coo)\n    row_idx = sparse_coo_row_indices(coo)\n    col_idx = sparse_coo_col_indices(coo)\n    vals = sparse_coo_values(coo)\n    nnz = sparse_coo_nnz(coo)\n    if nnz == 0:\n        return make_sparse_csr(rows, cols, list_to_vector([0] * (rows + 1)), list_to_vector([]), list_to_vector([]))\n    idxs = list(range(nnz))\n    idxs.sort(key=lambda k: (row_idx[k], col_idx[k]))\n    row_ptrs = [0] * (rows + 1)\n    out_cols = [0] * nnz\n    out_vals = [0] * nnz\n    current_row = 0\n    for k, idx in enumerate(idxs):\n        r = row_idx[idx]\n        c = col_idx[idx]\n        v = vals[idx]\n        while current_row < r:\n            current_row += 1\n            row_ptrs[current_row] = k\n        out_cols[k] = c\n        out_vals[k] = v\n    for r in range(current_row + 1, rows + 1):\n        row_ptrs[r] = nnz\n    return make_sparse_csr(rows, cols, list_to_vector(row_ptrs), list_to_vector(out_cols), list_to_vector(out_vals))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))", "tags": ["linalg", "sparse", "translation", "python", "coo->csr"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `coo->csr`\n\n```python\ndef coo_to_csr(coo):\n    rows = sparse_coo_rows(coo)\n    cols = sparse_coo_cols(coo)\n    row_idx = sparse_coo_row_indices(coo)\n    col_idx = sparse_coo_col_indices(coo)\n    vals = sparse_coo_values(coo)\n    nnz = sparse_coo_nnz(coo)\n    if nnz == 0:\n        return make_sparse_csr(rows, cols, list_to_vector([0] * (rows + 1)), list_to_vector([]), list_to_vector([]))\n    idxs = list(range(nnz))\n    idxs.sort(key=lambda k: (row_idx[k], col_idx[k]))\n    row_ptrs = [0] * (rows + 1)\n    out_cols = [0] * nnz\n    out_vals = [0] * nnz\n    current_row = 0\n    for k, idx in enumerate(idxs):\n        r = row_idx[idx]\n        c = col_idx[idx]\n        v = vals[idx]\n        while current_row < r:\n            current_row += 1\n            row_ptrs[current_row] = k\n        out_cols[k] = c\n        out_vals[k] = v\n    for r in range(current_row + 1, rows + 1):\n        row_ptrs[r] = nnz\n    return make_sparse_csr(rows, cols, list_to_vector(row_ptrs), list_to_vector(out_cols), list_to_vector(out_vals))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sparse_translation_006", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `coo->csr`\n\n```scheme\n(define (coo->csr0 coo)\n  (let* ((rows (sparse-coo-rows coo))\n         (cols (sparse-coo-cols coo))\n         (row-idx (sparse-coo-row-indices coo))\n         (col-idx (sparse-coo-col-indices coo))\n         (vals (sparse-coo-values coo))\n         (nnz (sparse-coo-nnz coo)))\n    (if (= nnz 0)\n        (let ((row-ptrs (make-vector (+ rows 1) 0)))\n          (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n        (let* ((indices (make-vector nnz 0)))\n          (do ((k 0 (+ k 1)))\n              ((= k nnz))\n            (vector-set! indices k k))\n          (vector-sort-by!\n           (lambda (a b)\n             (let ((ra (vector-ref row-idx a))\n                   (rb (vector-ref row-idx b)))\n               (or (< ra rb)\n                   (and (= ra rb)\n                        (< (vector-ref col-idx a)\n                           (vector-ref col-idx b))))))\n           indices)\n          (let ((row-ptrs (make-vector (+ rows 1) 0))\n                (out-cols (make-vector nnz 0))\n                (out-vals (make-vector nnz 0)))\n            (do ((k 0 (+ k 1))\n                 (current-row 0 (vector-ref row-idx (vector-ref indices k))))\n                ((= k nnz)\n                 (do ((r (+ current-row 1) (+ r 1)))\n                     ((> r rows))\n                   (vector-set! row-ptrs r nnz))\n                 (make-sparse-csr rows cols row-ptrs out-cols out-vals))\n              (let* ((idx (vector-ref indices k))\n                     (r (vector-ref row-idx idx))\n                     (c (vector-ref col-idx idx))\n                     (v (vector-ref vals idx)))\n                (when (> r current-row)\n                  (do ((prev-row (+ current-row 1) (+ prev-row 1)))\n                      ((> prev-row r))\n                    (vector-set! row-ptrs prev-row k)))\n                (vector-set! out-cols k c)\n                (vector-set! out-vals k v))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))", "tags": ["linalg", "sparse", "translation", "chez", "coo->csr"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `coo->csr`\n\n```scheme\n(define (coo->csr0 coo)\n  (let* ((rows (sparse-coo-rows coo))\n         (cols (sparse-coo-cols coo))\n         (row-idx (sparse-coo-row-indices coo))\n         (col-idx (sparse-coo-col-indices coo))\n         (vals (sparse-coo-values coo))\n         (nnz (sparse-coo-nnz coo)))\n    (if (= nnz 0)\n        (let ((row-ptrs (make-vector (+ rows 1) 0)))\n          (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n        (let* ((indices (make-vector nnz 0)))\n          (do ((k 0 (+ k 1)))\n              ((= k nnz))\n            (vector-set! indices k k))\n          (vector-sort-by!\n           (lambda (a b)\n             (let ((ra (vector-ref row-idx a))\n                   (rb (vector-ref row-idx b)))\n               (or (< ra rb)\n                   (and (= ra rb)\n                        (< (vector-ref col-idx a)\n                           (vector-ref col-idx b))))))\n           indices)\n          (let ((row-ptrs (make-vector (+ rows 1) 0))\n                (out-cols (make-vector nnz 0))\n                (out-vals (make-vector nnz 0)))\n            (do ((k 0 (+ k 1))\n                 (current-row 0 (vector-ref row-idx (vector-ref indices k))))\n                ((= k nnz)\n                 (do ((r (+ current-row 1) (+ r 1)))\n                     ((> r rows))\n                   (vector-set! row-ptrs r nnz))\n                 (make-sparse-csr rows cols row-ptrs out-cols out-vals))\n              (let* ((idx (vector-ref indices k))\n                     (r (vector-ref row-idx idx))\n                     (c (vector-ref col-idx idx))\n                     (v (vector-ref vals idx)))\n                (when (> r current-row)\n                  (do ((prev-row (+ current-row 1) (+ prev-row 1)))\n                      ((> prev-row r))\n                    (vector-set! row-ptrs prev-row k)))\n                (vector-set! out-cols k c)\n                (vector-set! out-vals k v))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sparse_translation_007", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-csr-ref`\n\n```python\ndef sparse_csr_ref(m, i, j):\n    row_ptrs = sparse_csr_row_ptrs(m)\n    col_idx = sparse_csr_col_indices(m)\n    vals = sparse_csr_values(m)\n    start = row_ptrs[i]\n    end = row_ptrs[i + 1]\n    k = start\n    while k < end:\n        if col_idx[k] == j:\n            return vals[k]\n        k += 1\n    return 0\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "python", "sparse-csr-ref"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-csr-ref`\n\n```python\ndef sparse_csr_ref(m, i, j):\n    row_ptrs = sparse_csr_row_ptrs(m)\n    col_idx = sparse_csr_col_indices(m)\n    vals = sparse_csr_values(m)\n    start = row_ptrs[i]\n    end = row_ptrs[i + 1]\n    k = start\n    while k < end:\n        if col_idx[k] == j:\n            return vals[k]\n        k += 1\n    return 0\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sparse_translation_008", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-csr-ref`\n\n```scheme\n(define (csr-ref m i j)\n  (let* ((rp (sparse-csr-row-ptrs m))\n         (ci (sparse-csr-col-indices m))\n         (vs (sparse-csr-values m))\n         (start (vector-ref rp i))\n         (end (vector-ref rp (+ i 1))))\n    (let loop ((k start))\n      (cond ((= k end) 0)\n            ((= (vector-ref ci k) j) (vector-ref vs k))\n            (else (loop (+ k 1)))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "chez", "sparse-csr-ref"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-csr-ref`\n\n```scheme\n(define (csr-ref m i j)\n  (let* ((rp (sparse-csr-row-ptrs m))\n         (ci (sparse-csr-col-indices m))\n         (vs (sparse-csr-values m))\n         (start (vector-ref rp i))\n         (end (vector-ref rp (+ i 1))))\n    (let loop ((k start))\n      (cond ((= k end) 0)\n            ((= (vector-ref ci k) j) (vector-ref vs k))\n            (else (loop (+ k 1)))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sparse_translation_010", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `dense->sparse-coo`\n\n```scheme\n(define (dense->coo m . tol-arg)\n  (let* ((tol (if (null? tol-arg) 0 (car tol-arg)))\n         (rows (matrix-rows m))\n         (cols (matrix-cols m))\n         (data (matrix-data m))\n         (nnz (let loop ((i 0) (count 0))\n                (if (= i (vector-length data))\n                    count\n                    (loop (+ i 1)\n                          (if (> (abs (vector-ref data i)) tol) (+ count 1) count)))))\n         (ri (make-vector nnz 0))\n         (ci (make-vector nnz 0))\n         (vs (make-vector nnz 0)))\n    (let loop ((i 0) (k 0))\n      (if (= i (vector-length data))\n          (make-sparse-coo rows cols ri ci vs)\n          (let ((v (vector-ref data i)))\n            (if (> (abs v) tol)\n                (begin\n                  (vector-set! ri k (quotient i cols))\n                  (vector-set! ci k (remainder i cols))\n                  (vector-set! vs k v)\n                  (loop (+ i 1) (+ k 1)))\n                (loop (+ i 1) k)))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))\n  (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "chez", "dense->sparse-coo"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `dense->sparse-coo`\n\n```scheme\n(define (dense->coo m . tol-arg)\n  (let* ((tol (if (null? tol-arg) 0 (car tol-arg)))\n         (rows (matrix-rows m))\n         (cols (matrix-cols m))\n         (data (matrix-data m))\n         (nnz (let loop ((i 0) (count 0))\n                (if (= i (vector-length data))\n                    count\n                    (loop (+ i 1)\n                          (if (> (abs (vector-ref data i)) tol) (+ count 1) count)))))\n         (ri (make-vector nnz 0))\n         (ci (make-vector nnz 0))\n         (vs (make-vector nnz 0)))\n    (let loop ((i 0) (k 0))\n      (if (= i (vector-length data))\n          (make-sparse-coo rows cols ri ci vs)\n          (let ((v (vector-ref data i)))\n            (if (> (abs v) tol)\n                (begin\n                  (vector-set! ri k (quotient i cols))\n                  (vector-set! ci k (remainder i cols))\n                  (vector-set! vs k v)\n                  (loop (+ i 1) (+ k 1)))\n                (loop (+ i 1) k)))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sparse_translation_011", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-csr-vec-mul`\n\n```python\ndef sparse_csr_vec_mul(m, v):\n    rows = sparse_csr_rows(m)\n    cols = sparse_csr_cols(m)\n    if cols != len(v):\n        return ['error', 'dimension-mismatch', cols, len(v)]\n    row_ptrs = sparse_csr_row_ptrs(m)\n    col_idx = sparse_csr_col_indices(m)\n    vals = sparse_csr_values(m)\n    out = [0] * rows\n    for i in range(rows):\n        s = 0\n        for k in range(row_ptrs[i], row_ptrs[i + 1]):\n            s += vals[k] * v[col_idx[k]]\n        out[i] = s\n    return list_to_vector(out)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-rows m)\n  (list-ref m 1))\n  (define (sparse-csr-cols m)\n  (list-ref m 2))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))", "tags": ["linalg", "sparse", "translation", "python", "sparse-csr-vec-mul"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-csr-vec-mul`\n\n```python\ndef sparse_csr_vec_mul(m, v):\n    rows = sparse_csr_rows(m)\n    cols = sparse_csr_cols(m)\n    if cols != len(v):\n        return ['error', 'dimension-mismatch', cols, len(v)]\n    row_ptrs = sparse_csr_row_ptrs(m)\n    col_idx = sparse_csr_col_indices(m)\n    vals = sparse_csr_values(m)\n    out = [0] * rows\n    for i in range(rows):\n        s = 0\n        for k in range(row_ptrs[i], row_ptrs[i + 1]):\n            s += vals[k] * v[col_idx[k]]\n        out[i] = s\n    return list_to_vector(out)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sparse_translation_012", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-csr-vec-mul`\n\n```scheme\n(define (csr-mv m v)\n  (let* ((rows (sparse-csr-rows m))\n         (cols (sparse-csr-cols m))\n         (n (vector-length v)))\n    (if (not (= cols n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ((rp (sparse-csr-row-ptrs m))\n              (ci (sparse-csr-col-indices m))\n              (vs (sparse-csr-values m)))\n          (vec-tabulate rows i\n            (let ((start (vector-ref rp i))\n                  (end (vector-ref rp (+ i 1))))\n              (range-fold sum 0 k start end\n                (+ sum (* (vector-ref vs k)\n                          (vector-ref v (vector-ref ci k)))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-rows m)\n  (list-ref m 1))\n  (define (sparse-csr-cols m)\n  (list-ref m 2))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))", "tags": ["linalg", "sparse", "translation", "chez", "sparse-csr-vec-mul"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-csr-vec-mul`\n\n```scheme\n(define (csr-mv m v)\n  (let* ((rows (sparse-csr-rows m))\n         (cols (sparse-csr-cols m))\n         (n (vector-length v)))\n    (if (not (= cols n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ((rp (sparse-csr-row-ptrs m))\n              (ci (sparse-csr-col-indices m))\n              (vs (sparse-csr-values m)))\n          (vec-tabulate rows i\n            (let ((start (vector-ref rp i))\n                  (end (vector-ref rp (+ i 1))))\n              (range-fold sum 0 k start end\n                (+ sum (* (vector-ref vs k)\n                          (vector-ref v (vector-ref ci k)))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sparse_translation_013", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-coo-add-impl`\n\n```python\ndef sparse_coo_add_impl(a, b, eps=1e-15):\n    rows = sparse_coo_rows(a)\n    cols = sparse_coo_cols(a)\n    acc = {}\n    for k in range(sparse_coo_nnz(a)):\n        key = (sparse_coo_row_indices(a)[k], sparse_coo_col_indices(a)[k])\n        acc[key] = acc.get(key, 0) + sparse_coo_values(a)[k]\n    for k in range(sparse_coo_nnz(b)):\n        key = (sparse_coo_row_indices(b)[k], sparse_coo_col_indices(b)[k])\n        acc[key] = acc.get(key, 0) + sparse_coo_values(b)[k]\n    triplets = [(i, j, v) for (i, j), v in acc.items() if abs(v) >= eps]\n    triplets.sort(key=lambda t: (t[0], t[1]))\n    return sparse_coo_from_triplets(rows, cols, triplets)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))\n  (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))", "tags": ["linalg", "sparse", "translation", "python", "sparse-coo-add-impl"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-coo-add-impl`\n\n```python\ndef sparse_coo_add_impl(a, b, eps=1e-15):\n    rows = sparse_coo_rows(a)\n    cols = sparse_coo_cols(a)\n    acc = {}\n    for k in range(sparse_coo_nnz(a)):\n        key = (sparse_coo_row_indices(a)[k], sparse_coo_col_indices(a)[k])\n        acc[key] = acc.get(key, 0) + sparse_coo_values(a)[k]\n    for k in range(sparse_coo_nnz(b)):\n        key = (sparse_coo_row_indices(b)[k], sparse_coo_col_indices(b)[k])\n        acc[key] = acc.get(key, 0) + sparse_coo_values(b)[k]\n    triplets = [(i, j, v) for (i, j), v in acc.items() if abs(v) >= eps]\n    triplets.sort(key=lambda t: (t[0], t[1]))\n    return sparse_coo_from_triplets(rows, cols, triplets)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sparse_translation_014", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-coo-add-impl`\n\n```scheme\n(define (coo-add-impl0 a b . eps-arg)\n  (let* ((eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg)))\n         (rows (sparse-coo-rows a))\n         (cols (sparse-coo-cols a))\n         (acc-a (let ((row-idx (sparse-coo-row-indices a))\n                      (col-idx (sparse-coo-col-indices a))\n                      (vals (sparse-coo-values a))\n                      (nnz-a (sparse-coo-nnz a)))\n                  (let loop ((k 0) (acc hamt-empty))\n                    (if (= k nnz-a)\n                        acc\n                        (let* ((i (vector-ref row-idx k))\n                               (j (vector-ref col-idx k))\n                               (key (cons i j))\n                               (old (hamt-lookup-or key acc 0)))\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc)))))))\n         (acc (let ((row-idx (sparse-coo-row-indices b))\n                    (col-idx (sparse-coo-col-indices b))\n                    (vals (sparse-coo-values b))\n                    (nnz-b (sparse-coo-nnz b)))\n                (let loop ((k 0) (h acc-a))\n                  (if (= k nnz-b)\n                      h\n                      (let* ((i (vector-ref row-idx k))\n                             (j (vector-ref col-idx k))\n                             (key (cons i j))\n                             (old (hamt-lookup-or key h 0)))\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))))\n    (let* ((entries (hamt-entries acc))\n           (triplets (filter-map\n                      (lambda (entry)\n                        (let ((v (cdr entry)))\n                          (if (< (abs v) eps)\n                              #f\n                              (let ((key (car entry)))\n                                (list (car key) (cdr key) v)))))\n                      entries))\n           (sorted (sort-by (lambda (x y)\n                              (or (< (car x) (car y))\n                                  (and (= (car x) (car y))\n                                       (< (cadr x) (cadr y)))))\n                            triplets))\n           (nnz (length sorted))\n           (out-rows (make-vector nnz 0))\n           (out-cols (make-vector nnz 0))\n           (out-vals (make-vector nnz 0)))\n      (do ((k 0 (+ k 1))\n           (ts sorted (cdr ts)))\n          ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n        (let ((t (car ts)))\n          (vector-set! out-rows k (car t))\n          (vector-set! out-cols k (cadr t))\n          (vector-set! out-vals k (caddr t))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))\n  (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))", "tags": ["linalg", "sparse", "translation", "chez", "sparse-coo-add-impl"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `sparse-coo-add-impl`\n\n```scheme\n(define (coo-add-impl0 a b . eps-arg)\n  (let* ((eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg)))\n         (rows (sparse-coo-rows a))\n         (cols (sparse-coo-cols a))\n         (acc-a (let ((row-idx (sparse-coo-row-indices a))\n                      (col-idx (sparse-coo-col-indices a))\n                      (vals (sparse-coo-values a))\n                      (nnz-a (sparse-coo-nnz a)))\n                  (let loop ((k 0) (acc hamt-empty))\n                    (if (= k nnz-a)\n                        acc\n                        (let* ((i (vector-ref row-idx k))\n                               (j (vector-ref col-idx k))\n                               (key (cons i j))\n                               (old (hamt-lookup-or key acc 0)))\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc)))))))\n         (acc (let ((row-idx (sparse-coo-row-indices b))\n                    (col-idx (sparse-coo-col-indices b))\n                    (vals (sparse-coo-values b))\n                    (nnz-b (sparse-coo-nnz b)))\n                (let loop ((k 0) (h acc-a))\n                  (if (= k nnz-b)\n                      h\n                      (let* ((i (vector-ref row-idx k))\n                             (j (vector-ref col-idx k))\n                             (key (cons i j))\n                             (old (hamt-lookup-or key h 0)))\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))))\n    (let* ((entries (hamt-entries acc))\n           (triplets (filter-map\n                      (lambda (entry)\n                        (let ((v (cdr entry)))\n                          (if (< (abs v) eps)\n                              #f\n                              (let ((key (car entry)))\n                                (list (car key) (cdr key) v)))))\n                      entries))\n           (sorted (sort-by (lambda (x y)\n                              (or (< (car x) (car y))\n                                  (and (= (car x) (car y))\n                                       (< (cadr x) (cadr y)))))\n                            triplets))\n           (nnz (length sorted))\n           (out-rows (make-vector nnz 0))\n           (out-cols (make-vector nnz 0))\n           (out-vals (make-vector nnz 0)))\n      (do ((k 0 (+ k 1))\n           (ts sorted (cdr ts)))\n          ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n        (let ((t (car ts)))\n          (vector-set! out-rows k (car t))\n          (vector-set! out-cols k (cadr t))\n          (vector-set! out-vals k (caddr t))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sparse_translation_015", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-coo-drop-below`\n\n```python\ndef sparse_coo_drop_below(tol, coo):\n    rows = sparse_coo_rows(coo)\n    cols = sparse_coo_cols(coo)\n    triplets = []\n    for k in range(sparse_coo_nnz(coo)):\n        v = sparse_coo_values(coo)[k]\n        if abs(v) >= tol:\n            triplets.append((sparse_coo_row_indices(coo)[k], sparse_coo_col_indices(coo)[k], v))\n    return sparse_coo_from_triplets(rows, cols, triplets)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))", "tags": ["linalg", "sparse", "translation", "python", "sparse-coo-drop-below"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including sparse zero/default semantics.\n\nTarget function name: `sparse-coo-drop-below`\n\n```python\ndef sparse_coo_drop_below(tol, coo):\n    rows = sparse_coo_rows(coo)\n    cols = sparse_coo_cols(coo)\n    triplets = []\n    for k in range(sparse_coo_nnz(coo)):\n        v = sparse_coo_values(coo)[k]\n        if abs(v) >= tol:\n            triplets.append((sparse_coo_row_indices(coo)[k], sparse_coo_col_indices(coo)[k], v))\n    return sparse_coo_from_triplets(rows, cols, triplets)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sparse_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-from-triplets` in `lattice/linalg/sparse.ss`.\nKnown issue: Values vector is not populated from triplets.\n\n```scheme\n(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)] [row-idx (make-vector n 0)] [col-idx (make-vector n 0)] [vals (make-vector n 0)])\n    (do ([i 0 (+ i 1)] [ts triplets (cdr ts)])\n        ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n      (let ([t (car ts)])\n        (vector-set! row-idx i (car t))\n        (vector-set! col-idx i (cadr t))\n        (vector-set! vals i 0)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-from-triplets"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-from-triplets` in `lattice/linalg/sparse.ss`.\nKnown issue: Values vector is not populated from triplets.\n\n```scheme\n(define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)] [row-idx (make-vector n 0)] [col-idx (make-vector n 0)] [vals (make-vector n 0)])\n    (do ([i 0 (+ i 1)] [ts triplets (cdr ts)])\n        ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n      (let ([t (car ts)])\n        (vector-set! row-idx i (car t))\n        (vector-set! col-idx i (cadr t))\n        (vector-set! vals i 0)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-nnz m) 3) (= (sparse-coo-ref m 1 2) 7) (= (sparse-coo-ref m 0 1) 0))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "sparse_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Lookup compares coordinates with i/j swapped.\n\n```scheme\n(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)] [col-idx (sparse-coo-col-indices m)] [vals (sparse-coo-values m)] [nnz (sparse-coo-nnz m)])\n    (let loop ([k 0])\n      (cond [(= k nnz) 0]\n            [(and (= (vector-ref row-idx k) j) (= (vector-ref col-idx k) i)) (vector-ref vals k)]\n            [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Lookup compares coordinates with i/j swapped.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-ref"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Lookup compares coordinates with i/j swapped.\n\n```scheme\n(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)] [col-idx (sparse-coo-col-indices m)] [vals (sparse-coo-values m)] [nnz (sparse-coo-nnz m)])\n    (let loop ([k 0])\n      (cond [(= k nnz) 0]\n            [(and (= (vector-ref row-idx k) j) (= (vector-ref col-idx k) i)) (vector-ref vals k)]\n            [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Lookup compares coordinates with i/j swapped.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sparse_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Absent entries should return numeric zero, not #f.\n\n```scheme\n(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)] [col-idx (sparse-coo-col-indices m)] [vals (sparse-coo-values m)] [nnz (sparse-coo-nnz m)])\n    (let loop ([k 0])\n      (cond [(= k nnz) #f]\n            [(and (= (vector-ref row-idx k) i) (= (vector-ref col-idx k) j)) (vector-ref vals k)]\n            [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Absent entries should return numeric zero, not #f.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-ref"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Absent entries should return numeric zero, not #f.\n\n```scheme\n(define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)] [col-idx (sparse-coo-col-indices m)] [vals (sparse-coo-values m)] [nnz (sparse-coo-nnz m)])\n    (let loop ([k 0])\n      (cond [(= k nnz) #f]\n            [(and (= (vector-ref row-idx k) i) (= (vector-ref col-idx k) j)) (vector-ref vals k)]\n            [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Absent entries should return numeric zero, not #f.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))]) (and (= (sparse-coo-ref m 0 0) 5) (= (sparse-coo-ref m 2 1) 9) (= (sparse-coo-ref m 1 1) 0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sparse_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coo->csr` in `lattice/linalg/sparse.ss`.\nKnown issue: Sorting for CSR must be row-major (row then col), and empty row-ptrs needs length rows+1.\n\n```scheme\n(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)] [cols (sparse-coo-cols coo)] [row-idx (sparse-coo-row-indices coo)] [col-idx (sparse-coo-col-indices coo)] [vals (sparse-coo-values coo)] [nnz (sparse-coo-nnz coo)])\n    (if (= nnz 0)\n        (make-sparse-csr rows cols (make-vector rows 0) (make-vector 0 0) (make-vector 0 0))\n        (let* ([indices (make-vector nnz 0)])\n          (do ([k 0 (+ k 1)]) ((= k nnz)) (vector-set! indices k k))\n          (vector-sort-by! (lambda (a b) (< (vector-ref col-idx a) (vector-ref col-idx b))) indices)\n          (let ([row-ptrs (make-vector (+ rows 1) 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n            (do ([k 0 (+ k 1)] [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                ((= k nnz) (make-sparse-csr rows cols row-ptrs out-cols out-vals))\n              (let* ([idx (vector-ref indices k)] [r (vector-ref row-idx idx)] [c (vector-ref col-idx idx)] [v (vector-ref vals idx)])\n                (when (> r current-row)\n                  (do ([prev-row (+ current-row 1) (+ prev-row 1)]) ((> prev-row r)) (vector-set! row-ptrs prev-row k)))\n                (vector-set! out-cols k c)\n                (vector-set! out-vals k v))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))", "tags": ["linalg", "sparse", "bugfix", "coo->csr"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coo->csr` in `lattice/linalg/sparse.ss`.\nKnown issue: Sorting for CSR must be row-major (row then col), and empty row-ptrs needs length rows+1.\n\n```scheme\n(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)] [cols (sparse-coo-cols coo)] [row-idx (sparse-coo-row-indices coo)] [col-idx (sparse-coo-col-indices coo)] [vals (sparse-coo-values coo)] [nnz (sparse-coo-nnz coo)])\n    (if (= nnz 0)\n        (make-sparse-csr rows cols (make-vector rows 0) (make-vector 0 0) (make-vector 0 0))\n        (let* ([indices (make-vector nnz 0)])\n          (do ([k 0 (+ k 1)]) ((= k nnz)) (vector-set! indices k k))\n          (vector-sort-by! (lambda (a b) (< (vector-ref col-idx a) (vector-ref col-idx b))) indices)\n          (let ([row-ptrs (make-vector (+ rows 1) 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n            (do ([k 0 (+ k 1)] [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                ((= k nnz) (make-sparse-csr rows cols row-ptrs out-cols out-vals))\n              (let* ([idx (vector-ref indices k)] [r (vector-ref row-idx idx)] [c (vector-ref col-idx idx)] [v (vector-ref vals idx)])\n                (when (> r current-row)\n                  (do ([prev-row (+ current-row 1) (+ prev-row 1)]) ((> prev-row r)) (vector-set! row-ptrs prev-row k)))\n                (vector-set! out-cols k c)\n                (vector-set! out-vals k v))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sparse_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coo->csr` in `lattice/linalg/sparse.ss`.\nKnown issue: Row pointer updates should record current write index k, not k+1.\n\n```scheme\n(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)] [cols (sparse-coo-cols coo)] [row-idx (sparse-coo-row-indices coo)] [col-idx (sparse-coo-col-indices coo)] [vals (sparse-coo-values coo)] [nnz (sparse-coo-nnz coo)])\n    (if (= nnz 0)\n        (let ([row-ptrs (make-vector (+ rows 1) 0)]) (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n        (let* ([indices (make-vector nnz 0)])\n          (do ([k 0 (+ k 1)]) ((= k nnz)) (vector-set! indices k k))\n          (vector-sort-by! (lambda (a b) (let ([ra (vector-ref row-idx a)] [rb (vector-ref row-idx b)]) (or (< ra rb) (and (= ra rb) (< (vector-ref col-idx a) (vector-ref col-idx b)))))) indices)\n          (let ([row-ptrs (make-vector (+ rows 1) 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n            (do ([k 0 (+ k 1)] [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                ((= k nnz) (make-sparse-csr rows cols row-ptrs out-cols out-vals))\n              (let* ([idx (vector-ref indices k)] [r (vector-ref row-idx idx)] [c (vector-ref col-idx idx)] [v (vector-ref vals idx)])\n                (when (> r current-row)\n                  (do ([prev-row (+ current-row 1) (+ prev-row 1)]) ((> prev-row r)) (vector-set! row-ptrs prev-row (+ k 1))))\n                (vector-set! out-cols k c)\n                (vector-set! out-vals k v))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))", "tags": ["linalg", "sparse", "bugfix", "coo->csr"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `coo->csr` in `lattice/linalg/sparse.ss`.\nKnown issue: Row pointer updates should record current write index k, not k+1.\n\n```scheme\n(define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)] [cols (sparse-coo-cols coo)] [row-idx (sparse-coo-row-indices coo)] [col-idx (sparse-coo-col-indices coo)] [vals (sparse-coo-values coo)] [nnz (sparse-coo-nnz coo)])\n    (if (= nnz 0)\n        (let ([row-ptrs (make-vector (+ rows 1) 0)]) (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n        (let* ([indices (make-vector nnz 0)])\n          (do ([k 0 (+ k 1)]) ((= k nnz)) (vector-set! indices k k))\n          (vector-sort-by! (lambda (a b) (let ([ra (vector-ref row-idx a)] [rb (vector-ref row-idx b)]) (or (< ra rb) (and (= ra rb) (< (vector-ref col-idx a) (vector-ref col-idx b)))))) indices)\n          (let ([row-ptrs (make-vector (+ rows 1) 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n            (do ([k 0 (+ k 1)] [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                ((= k nnz) (make-sparse-csr rows cols row-ptrs out-cols out-vals))\n              (let* ([idx (vector-ref indices k)] [r (vector-ref row-idx idx)] [c (vector-ref col-idx idx)] [v (vector-ref vals idx)])\n                (when (> r current-row)\n                  (do ([prev-row (+ current-row 1) (+ prev-row 1)]) ((> prev-row r)) (vector-set! row-ptrs prev-row (+ k 1))))\n                (vector-set! out-cols k c)\n                (vector-set! out-vals k v))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 2 2) (0 0 1) (1 1 3) (2 2 5) (2 0 4)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 0) 1) (= (sparse-csr-ref csr 0 2) 2) (= (sparse-csr-ref csr 2 0) 4) (equal? (vector->list (sparse-csr-row-ptrs csr)) '(0 2 3 5)))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "sparse_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Search must start at row-specific start pointer, not always 0.\n\n```scheme\n(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)] [start 0] [end (vector-ref row-ptrs (+ i 1))])\n    (let loop ([k start])\n      (cond [(= k end) 0] [(= (vector-ref col-idx k) j) (vector-ref vals k)] [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-csr-ref"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Search must start at row-specific start pointer, not always 0.\n\n```scheme\n(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)] [start 0] [end (vector-ref row-ptrs (+ i 1))])\n    (let loop ([k start])\n      (cond [(= k end) 0] [(= (vector-ref col-idx k) j) (vector-ref vals k)] [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sparse_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Inner comparison must match requested column j, not row i.\n\n```scheme\n(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)] [start (vector-ref row-ptrs i)] [end (vector-ref row-ptrs (+ i 1))])\n    (let loop ([k start])\n      (cond [(= k end) 0] [(= (vector-ref col-idx k) i) (vector-ref vals k)] [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)]\n         [col-idx (sparse-csr-col-indices m)]\n         [vals (sparse-csr-values m)]\n         [start (vector-ref row-ptrs i)]\n         [end (vector-ref row-ptrs (+ i 1))])\n        (let loop ([k start])\n             (cond\n              [(= k end) 0]\n              [(= (vector-ref col-idx k) j) (vector-ref vals k)]\n              [else (loop (+ k 1))]))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-csr-ref"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-ref` in `lattice/linalg/sparse.ss`.\nKnown issue: Inner comparison must match requested column j, not row i.\n\n```scheme\n(define (sparse-csr-ref m i j)\n  (let* ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)] [start (vector-ref row-ptrs i)] [end (vector-ref row-ptrs (+ i 1))])\n    (let loop ([k start])\n      (cond [(= k end) 0] [(= (vector-ref col-idx k) i) (vector-ref vals k)] [else (loop (+ k 1))]))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 5) (0 2 3) (1 1 7) (2 0 2) (2 2 9)))] [csr (coo->csr coo)]) (and (= (sparse-csr-ref csr 0 2) 3) (= (sparse-csr-ref csr 1 1) 7) (= (sparse-csr-ref csr 0 1) 0))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "sparse_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dense->sparse-coo` in `lattice/linalg/sparse.ss`.\nKnown issue: Dense linear index decoding uses row=quotient, col=remainder (not swapped).\n\n```scheme\n(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))] [rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)] [nnz (let loop ([i 0] [count 0]) (if (= i (vector-length data)) count (loop (+ i 1) (if (> (abs (vector-ref data i)) tol) (+ count 1) count))))] [row-idx (make-vector nnz 0)] [col-idx (make-vector nnz 0)] [vals (make-vector nnz 0)])\n    (let loop ([i 0] [k 0])\n      (if (= i (vector-length data))\n          (make-sparse-coo rows cols row-idx col-idx vals)\n          (let ([v (vector-ref data i)])\n            (if (> (abs v) tol)\n                (begin\n                  (vector-set! row-idx k (remainder i cols))\n                  (vector-set! col-idx k (quotient i cols))\n                  (vector-set! vals k v)\n                  (loop (+ i 1) (+ k 1)))\n                (loop (+ i 1) k)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Dense linear index decoding uses row=quotient, col=remainder (not swapped).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))]\n         [rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [nnz (let loop ([i 0] [count 0])\n                   (if (= i (vector-length data))\n                       count\n                       (loop (+ i 1)\n                             (if (> (abs (vector-ref data i)) tol)\n                                 (+ count 1)\n                                 count))))]\n         [row-idx (make-vector nnz 0)]\n         [col-idx (make-vector nnz 0)]\n         [vals (make-vector nnz 0)])\n        (let loop ([i 0] [k 0])\n             (if (= i (vector-length data))\n                 (make-sparse-coo rows cols row-idx col-idx vals)\n                 (let ([v (vector-ref data i)])\n                      (if (> (abs v) tol)\n                          (begin\n                           (vector-set! row-idx k (quotient i cols))\n                           (vector-set! col-idx k (remainder i cols))\n                           (vector-set! vals k v)\n                           (loop (+ i 1) (+ k 1)))\n                          (loop (+ i 1) k)))))))\n  (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "dense->sparse-coo"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dense->sparse-coo` in `lattice/linalg/sparse.ss`.\nKnown issue: Dense linear index decoding uses row=quotient, col=remainder (not swapped).\n\n```scheme\n(define (dense->sparse-coo m . tol-arg)\n  (let* ([tol (if (null? tol-arg) 0 (car tol-arg))] [rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)] [nnz (let loop ([i 0] [count 0]) (if (= i (vector-length data)) count (loop (+ i 1) (if (> (abs (vector-ref data i)) tol) (+ count 1) count))))] [row-idx (make-vector nnz 0)] [col-idx (make-vector nnz 0)] [vals (make-vector nnz 0)])\n    (let loop ([i 0] [k 0])\n      (if (= i (vector-length data))\n          (make-sparse-coo rows cols row-idx col-idx vals)\n          (let ([v (vector-ref data i)])\n            (if (> (abs v) tol)\n                (begin\n                  (vector-set! row-idx k (remainder i cols))\n                  (vector-set! col-idx k (quotient i cols))\n                  (vector-set! vals k v)\n                  (loop (+ i 1) (+ k 1)))\n                (loop (+ i 1) k)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Dense linear index decoding uses row=quotient, col=remainder (not swapped).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([dense (matrix-from-lists '((1 0 2) (0 3 0) (4 0 5)))] [coo (dense->sparse-coo dense)]) (and (= (sparse-coo-nnz coo) 5) (= (sparse-coo-ref coo 0 0) 1) (= (sparse-coo-ref coo 1 1) 3) (= (sparse-coo-ref coo 0 1) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sparse_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-vec-mul` in `lattice/linalg/sparse.ss`.\nKnown issue: Dimension check must compare matrix cols to vector length.\n\n```scheme\n(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)] [cols (sparse-csr-cols m)] [n (vector-length v)])\n    (if (not (= rows n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)])\n          (vec-tabulate rows i\n            (let ([start (vector-ref row-ptrs i)] [end (vector-ref row-ptrs (+ i 1))])\n              (range-fold sum 0 k start end\n                (+ sum (* (vector-ref vals k) (vector-ref v (vector-ref col-idx k)))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Dimension check must compare matrix cols to vector length.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-rows m)\n  (list-ref m 1))\n  (define (sparse-csr-cols m)\n  (list-ref m 2))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))", "tags": ["linalg", "sparse", "bugfix", "sparse-csr-vec-mul"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-vec-mul` in `lattice/linalg/sparse.ss`.\nKnown issue: Dimension check must compare matrix cols to vector length.\n\n```scheme\n(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)] [cols (sparse-csr-cols m)] [n (vector-length v)])\n    (if (not (= rows n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)])\n          (vec-tabulate rows i\n            (let ([start (vector-ref row-ptrs i)] [end (vector-ref row-ptrs (+ i 1))])\n              (range-fold sum 0 k start end\n                (+ sum (* (vector-ref vals k) (vector-ref v (vector-ref col-idx k)))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Dimension check must compare matrix cols to vector length.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "sparse_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-vec-mul` in `lattice/linalg/sparse.ss`.\nKnown issue: Each term must index vector by sparse column index, not current row.\n\n```scheme\n(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)] [cols (sparse-csr-cols m)] [n (vector-length v)])\n    (if (not (= cols n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)])\n          (vec-tabulate rows i\n            (let ([start (vector-ref row-ptrs i)] [end (vector-ref row-ptrs (+ i 1))])\n              (range-fold sum 0 k start end\n                (+ sum (* (vector-ref vals k) (vector-ref v i))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-csr-rows m)\n  (list-ref m 1))\n  (define (sparse-csr-cols m)\n  (list-ref m 2))\n  (define (sparse-csr-row-ptrs m)\n  (list-ref m 3))\n  (define (sparse-csr-col-indices m)\n  (list-ref m 4))\n  (define (sparse-csr-values m)\n  (list-ref m 5))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-csr rows cols row-ptrs col-indices values)\n  (list 'sparse-csr rows cols row-ptrs col-indices values))\n  (define (coo->csr coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)])\n        (if (= nnz 0)\n            (let ([row-ptrs (make-vector (+ rows 1) 0)])\n                 (make-sparse-csr rows cols row-ptrs (make-vector 0 0) (make-vector 0 0)))\n            (let* ([indices (make-vector nnz 0)])\n                  (do ([k 0 (+ k 1)])\n                      ((= k nnz))\n                      (vector-set! indices k k))\n                  (vector-sort-by!\n                   (lambda (a b)\n                           (let ([ra (vector-ref row-idx a)]\n                                 [rb (vector-ref row-idx b)])\n                                (or (< ra rb)\n                                    (and (= ra rb)\n                                         (< (vector-ref col-idx a)\n                                            (vector-ref col-idx b))))))\n                   indices)\n                  (let ([row-ptrs (make-vector (+ rows 1) 0)]\n                        [out-cols (make-vector nnz 0)]\n                        [out-vals (make-vector nnz 0)])\n                       (do ([k 0 (+ k 1)]\n                            [current-row 0 (vector-ref row-idx (vector-ref indices k))])\n                           ((= k nnz)\n                            (do ([r (+ current-row 1) (+ r 1)])\n                                ((> r rows))\n                                (vector-set! row-ptrs r nnz)))\n                           (let* ([idx (vector-ref indices k)]\n                                  [r (vector-ref row-idx idx)]\n                                  [c (vector-ref col-idx idx)]\n                                  [v (vector-ref vals idx)])\n                                 (when (> r current-row)\n                                       (do ([prev-row (+ current-row 1) (+ prev-row 1)])\n                                           ((> prev-row r))\n                                           (vector-set! row-ptrs prev-row k)))\n                                 (vector-set! out-cols k c)\n                                 (vector-set! out-vals k v)))\n                       (make-sparse-csr rows cols row-ptrs out-cols out-vals))))))\n  (define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)]\n         [cols (sparse-csr-cols m)]\n         [n (vector-length v)])\n        (if (not (= cols n))\n            `(error dimension-mismatch ,cols ,n)\n            (let ([row-ptrs (sparse-csr-row-ptrs m)]\n                  [col-idx (sparse-csr-col-indices m)]\n                  [vals (sparse-csr-values m)])\n                 (vec-tabulate rows i\n                   (let ([start (vector-ref row-ptrs i)]\n                         [end (vector-ref row-ptrs (+ i 1))])\n                        (range-fold sum 0 k start end\n                          (+ sum (* (vector-ref vals k)\n                                    (vector-ref v (vector-ref col-idx k)))))))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))", "tags": ["linalg", "sparse", "bugfix", "sparse-csr-vec-mul"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-csr-vec-mul` in `lattice/linalg/sparse.ss`.\nKnown issue: Each term must index vector by sparse column index, not current row.\n\n```scheme\n(define (sparse-csr-vec-mul m v)\n  (let* ([rows (sparse-csr-rows m)] [cols (sparse-csr-cols m)] [n (vector-length v)])\n    (if (not (= cols n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ([row-ptrs (sparse-csr-row-ptrs m)] [col-idx (sparse-csr-col-indices m)] [vals (sparse-csr-values m)])\n          (vec-tabulate rows i\n            (let ([start (vector-ref row-ptrs i)] [end (vector-ref row-ptrs (+ i 1))])\n              (range-fold sum 0 k start end\n                (+ sum (* (vector-ref vals k) (vector-ref v i))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))] [csr (coo->csr coo)]) (and (equal? (sparse-csr-vec-mul csr (vec 1 2 3)) (vec 5 6 19)) (equal? (sparse-csr-vec-mul csr (vec 1 2)) '(error dimension-mismatch 3 2)))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sparse_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-add-impl` in `lattice/linalg/sparse.ss`.\nKnown issue: Accumulator must add into existing coordinate value when B has duplicates/overlaps.\n\n```scheme\n(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))] [rows (sparse-coo-rows a)] [cols (sparse-coo-cols a)] [acc-a (let ([row-idx (sparse-coo-row-indices a)] [col-idx (sparse-coo-col-indices a)] [vals (sparse-coo-values a)] [nnz-a (sparse-coo-nnz a)]) (let loop ([k 0] [acc hamt-empty]) (if (= k nnz-a) acc (let* ([i (vector-ref row-idx k)] [j (vector-ref col-idx k)] [key (cons i j)] [old (hamt-lookup-or key acc 0)]) (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))] [acc (let ([row-idx (sparse-coo-row-indices b)] [col-idx (sparse-coo-col-indices b)] [vals (sparse-coo-values b)] [nnz-b (sparse-coo-nnz b)]) (let loop ([k 0] [h acc-a]) (if (= k nnz-b) h (let* ([i (vector-ref row-idx k)] [j (vector-ref col-idx k)] [key (cons i j)]) (loop (+ k 1) (hamt-assoc key (vector-ref vals k) h))))))])\n    (let* ([entries (hamt-entries acc)] [triplets (filter-map (lambda (entry) (let ([v (cdr entry)]) (if (< (abs v) eps) #f (let ([key (car entry)]) (list (car key) (cdr key) v))))) entries)] [sorted (sort-by (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cadr a) (cadr b))))) triplets)] [nnz (length sorted)] [out-rows (make-vector nnz 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n      (do ([k 0 (+ k 1)] [ts sorted (cdr ts)]) ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals)) (let ([t (car ts)]) (vector-set! out-rows k (car t)) (vector-set! out-cols k (cadr t)) (vector-set! out-vals k (caddr t)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))\n  (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-add-impl"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-add-impl` in `lattice/linalg/sparse.ss`.\nKnown issue: Accumulator must add into existing coordinate value when B has duplicates/overlaps.\n\n```scheme\n(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))] [rows (sparse-coo-rows a)] [cols (sparse-coo-cols a)] [acc-a (let ([row-idx (sparse-coo-row-indices a)] [col-idx (sparse-coo-col-indices a)] [vals (sparse-coo-values a)] [nnz-a (sparse-coo-nnz a)]) (let loop ([k 0] [acc hamt-empty]) (if (= k nnz-a) acc (let* ([i (vector-ref row-idx k)] [j (vector-ref col-idx k)] [key (cons i j)] [old (hamt-lookup-or key acc 0)]) (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))] [acc (let ([row-idx (sparse-coo-row-indices b)] [col-idx (sparse-coo-col-indices b)] [vals (sparse-coo-values b)] [nnz-b (sparse-coo-nnz b)]) (let loop ([k 0] [h acc-a]) (if (= k nnz-b) h (let* ([i (vector-ref row-idx k)] [j (vector-ref col-idx k)] [key (cons i j)]) (loop (+ k 1) (hamt-assoc key (vector-ref vals k) h))))))])\n    (let* ([entries (hamt-entries acc)] [triplets (filter-map (lambda (entry) (let ([v (cdr entry)]) (if (< (abs v) eps) #f (let ([key (car entry)]) (list (car key) (cdr key) v))))) entries)] [sorted (sort-by (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cadr a) (cadr b))))) triplets)] [nnz (length sorted)] [out-rows (make-vector nnz 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n      (do ([k 0 (+ k 1)] [ts sorted (cdr ts)]) ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals)) (let ([t (car ts)]) (vector-set! out-rows k (car t)) (vector-set! out-cols k (cadr t)) (vector-set! out-vals k (caddr t)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sparse_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-add-impl` in `lattice/linalg/sparse.ss`.\nKnown issue: B-side accumulation is missing and the tolerance filter is reversed; both break addition semantics.\n\n```scheme\n(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))] [rows (sparse-coo-rows a)] [cols (sparse-coo-cols a)] [acc-a (let ([row-idx (sparse-coo-row-indices a)] [col-idx (sparse-coo-col-indices a)] [vals (sparse-coo-values a)] [nnz-a (sparse-coo-nnz a)]) (let loop ([k 0] [acc hamt-empty]) (if (= k nnz-a) acc (let* ([i (vector-ref row-idx k)] [j (vector-ref col-idx k)] [key (cons i j)] [old (hamt-lookup-or key acc 0)]) (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))] [acc acc-a])\n    (let* ([entries (hamt-entries acc)] [triplets (filter-map (lambda (entry) (let ([v (cdr entry)]) (if (> (abs v) eps) #f (let ([key (car entry)]) (list (car key) (cdr key) v))))) entries)] [sorted (sort-by (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cadr a) (cadr b))))) triplets)] [nnz (length sorted)] [out-rows (make-vector nnz 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n      (do ([k 0 (+ k 1)] [ts sorted (cdr ts)]) ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals)) (let ([t (car ts)]) (vector-set! out-rows k (car t)) (vector-set! out-cols k (cadr t)) (vector-set! out-vals k (caddr t)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: B-side accumulation is missing and the tolerance filter is reversed; both break addition semantics.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))]\n         [rows (sparse-coo-rows a)]\n         [cols (sparse-coo-cols a)]\n         [acc-a (let ([row-idx (sparse-coo-row-indices a)]\n                      [col-idx (sparse-coo-col-indices a)]\n                      [vals (sparse-coo-values a)]\n                      [nnz-a (sparse-coo-nnz a)])\n                  (let loop ([k 0] [acc hamt-empty])\n                    (if (= k nnz-a) acc\n                        (let* ([i (vector-ref row-idx k)]\n                               [j (vector-ref col-idx k)]\n                               [key (cons i j)]\n                               [old (hamt-lookup-or key acc 0)])\n                          (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))]\n         [acc (let ([row-idx (sparse-coo-row-indices b)]\n                    [col-idx (sparse-coo-col-indices b)]\n                    [vals (sparse-coo-values b)]\n                    [nnz-b (sparse-coo-nnz b)])\n                (let loop ([k 0] [h acc-a])\n                  (if (= k nnz-b) h\n                      (let* ([i (vector-ref row-idx k)]\n                             [j (vector-ref col-idx k)]\n                             [key (cons i j)]\n                             [old (hamt-lookup-or key h 0)])\n                        (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) h))))))])\n        (let* ([entries (hamt-entries acc)]\n               [triplets (filter-map\n                          (lambda (entry)\n                            (let ([v (cdr entry)])\n                              (if (< (abs v) eps)\n                                  #f\n                                  (let ([key (car entry)])\n                                    (list (car key) (cdr key) v)))))\n                          entries)]\n               [sorted (sort-by (lambda (a b)\n                                          (or (< (car a) (car b))\n                                              (and (= (car a) (car b))\n                                                   (< (cadr a) (cadr b)))))\n                                triplets)]\n               [nnz (length sorted)]\n               [out-rows (make-vector nnz 0)]\n               [out-cols (make-vector nnz 0)]\n               [out-vals (make-vector nnz 0)])\n              (do ([k 0 (+ k 1)]\n                   [ts sorted (cdr ts)])\n                  ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals))\n                  (let ([t (car ts)])\n                       (vector-set! out-rows k (car t))\n                       (vector-set! out-cols k (cadr t))\n                       (vector-set! out-vals k (caddr t)))))))\n  (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-add-impl"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-add-impl` in `lattice/linalg/sparse.ss`.\nKnown issue: B-side accumulation is missing and the tolerance filter is reversed; both break addition semantics.\n\n```scheme\n(define (sparse-coo-add-impl a b . eps-arg)\n  (let* ([eps (if (null? eps-arg) *sparse-epsilon* (car eps-arg))] [rows (sparse-coo-rows a)] [cols (sparse-coo-cols a)] [acc-a (let ([row-idx (sparse-coo-row-indices a)] [col-idx (sparse-coo-col-indices a)] [vals (sparse-coo-values a)] [nnz-a (sparse-coo-nnz a)]) (let loop ([k 0] [acc hamt-empty]) (if (= k nnz-a) acc (let* ([i (vector-ref row-idx k)] [j (vector-ref col-idx k)] [key (cons i j)] [old (hamt-lookup-or key acc 0)]) (loop (+ k 1) (hamt-assoc key (+ old (vector-ref vals k)) acc))))))] [acc acc-a])\n    (let* ([entries (hamt-entries acc)] [triplets (filter-map (lambda (entry) (let ([v (cdr entry)]) (if (> (abs v) eps) #f (let ([key (car entry)]) (list (car key) (cdr key) v))))) entries)] [sorted (sort-by (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cadr a) (cadr b))))) triplets)] [nnz (length sorted)] [out-rows (make-vector nnz 0)] [out-cols (make-vector nnz 0)] [out-vals (make-vector nnz 0)])\n      (do ([k 0 (+ k 1)] [ts sorted (cdr ts)]) ((= k nnz) (make-sparse-coo rows cols out-rows out-cols out-vals)) (let ([t (car ts)]) (vector-set! out-rows k (car t)) (vector-set! out-cols k (cadr t)) (vector-set! out-vals k (caddr t)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: B-side accumulation is missing and the tolerance filter is reversed; both break addition semantics.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0)))] [b (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))] [c (sparse-coo-add-impl a b)] [z (sparse-coo-add-impl a (sparse-coo-from-triplets 2 2 '((0 0 -1.0) (1 1 -2.0))))]) (and (= (sparse-coo-ref c 0 0) 4.0) (= (sparse-coo-ref c 0 1) 4.0) (= (sparse-coo-ref c 1 1) 2.0) (= (sparse-coo-nnz z) 0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault."}
{"id": "sparse_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-drop-below` in `lattice/linalg/sparse.ss`.\nKnown issue: Copied entries should preserve original values; zeroing output values corrupts kept coordinates.\n\n```scheme\n(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)] [cols (sparse-coo-cols coo)] [row-idx (sparse-coo-row-indices coo)] [col-idx (sparse-coo-col-indices coo)] [vals (sparse-coo-values coo)] [nnz (sparse-coo-nnz coo)] [keep-count (let loop ([k 0] [count 0]) (if (= k nnz) count (loop (+ k 1) (if (>= (abs (vector-ref vals k)) tol) (+ count 1) count))))] [new-rows (make-vector keep-count 0)] [new-cols (make-vector keep-count 0)] [new-vals (make-vector keep-count 0)])\n    (let loop ([k 0] [j 0])\n      (if (= k nnz)\n          (make-sparse-coo rows cols new-rows new-cols new-vals)\n          (let ([v (vector-ref vals k)])\n            (if (>= (abs v) tol)\n                (begin (vector-set! new-rows j (vector-ref row-idx k)) (vector-set! new-cols j (vector-ref col-idx k)) (vector-set! new-vals j 0) (loop (+ k 1) (+ j 1)))\n                (loop (+ k 1) j)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))", "verify_expr": "(let ()\n  (define *sparse-epsilon* 1e-15)\n  (define (sparse-coo-rows m)\n  (list-ref m 1))\n  (define (sparse-coo-cols m)\n  (list-ref m 2))\n  (define (sparse-coo-row-indices m)\n  (list-ref m 3))\n  (define (sparse-coo-col-indices m)\n  (list-ref m 4))\n  (define (sparse-coo-values m)\n  (list-ref m 5))\n  (define (sparse-coo-nnz m)\n  (vector-length (sparse-coo-values m)))\n  (define (make-sparse-coo rows cols row-indices col-indices values)\n  (list 'sparse-coo rows cols row-indices col-indices values))\n  (define (sparse-coo-from-triplets rows cols triplets)\n  (let* ([n (length triplets)]\n         [row-idx (make-vector n 0)]\n         [col-idx (make-vector n 0)]\n         [vals (make-vector n 0)])\n        (do ([i 0 (+ i 1)]\n             [ts triplets (cdr ts)])\n            ((= i n) (make-sparse-coo rows cols row-idx col-idx vals))\n            (let ([t (car ts)])\n                 (vector-set! row-idx i (car t))\n                 (vector-set! col-idx i (cadr t))\n                 (vector-set! vals i (caddr t))))))\n  (define (sparse-coo-ref m i j)\n  (let ([row-idx (sparse-coo-row-indices m)]\n        [col-idx (sparse-coo-col-indices m)]\n        [vals (sparse-coo-values m)]\n        [nnz (sparse-coo-nnz m)])\n       (let loop ([k 0])\n            (cond\n             [(= k nnz) 0]\n             [(and (= (vector-ref row-idx k) i)\n                   (= (vector-ref col-idx k) j))\n              (vector-ref vals k)]\n             [else (loop (+ k 1))]))))\n  (define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)]\n         [cols (sparse-coo-cols coo)]\n         [row-idx (sparse-coo-row-indices coo)]\n         [col-idx (sparse-coo-col-indices coo)]\n         [vals (sparse-coo-values coo)]\n         [nnz (sparse-coo-nnz coo)]\n         [keep-count (let loop ([k 0] [count 0])\n                          (if (= k nnz)\n                              count\n                              (loop (+ k 1)\n                                    (if (>= (abs (vector-ref vals k)) tol)\n                                        (+ count 1)\n                                        count))))]\n         [new-rows (make-vector keep-count 0)]\n         [new-cols (make-vector keep-count 0)]\n         [new-vals (make-vector keep-count 0)])\n        (let loop ([k 0] [j 0])\n             (if (= k nnz)\n                 (make-sparse-coo rows cols new-rows new-cols new-vals)\n                 (let ([v (vector-ref vals k)])\n                      (if (>= (abs v) tol)\n                          (begin\n                           (vector-set! new-rows j (vector-ref row-idx k))\n                           (vector-set! new-cols j (vector-ref col-idx k))\n                           (vector-set! new-vals j v)\n                           (loop (+ k 1) (+ j 1)))\n                          (loop (+ k 1) j)))))))\n  (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))", "tags": ["linalg", "sparse", "bugfix", "sparse-coo-drop-below"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sparse-coo-drop-below` in `lattice/linalg/sparse.ss`.\nKnown issue: Copied entries should preserve original values; zeroing output values corrupts kept coordinates.\n\n```scheme\n(define (sparse-coo-drop-below tol coo)\n  (let* ([rows (sparse-coo-rows coo)] [cols (sparse-coo-cols coo)] [row-idx (sparse-coo-row-indices coo)] [col-idx (sparse-coo-col-indices coo)] [vals (sparse-coo-values coo)] [nnz (sparse-coo-nnz coo)] [keep-count (let loop ([k 0] [count 0]) (if (= k nnz) count (loop (+ k 1) (if (>= (abs (vector-ref vals k)) tol) (+ count 1) count))))] [new-rows (make-vector keep-count 0)] [new-cols (make-vector keep-count 0)] [new-vals (make-vector keep-count 0)])\n    (let loop ([k 0] [j 0])\n      (if (= k nnz)\n          (make-sparse-coo rows cols new-rows new-cols new-vals)\n          (let ([v (vector-ref vals k)])\n            (if (>= (abs v) tol)\n                (begin (vector-set! new-rows j (vector-ref row-idx k)) (vector-set! new-cols j (vector-ref col-idx k)) (vector-set! new-vals j 0) (loop (+ k 1) (+ j 1)))\n                (loop (+ k 1) j)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([coo (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))] [cleaned (sparse-coo-drop-below 1e-14 coo)]) (and (= (sparse-coo-nnz cleaned) 2) (= (sparse-coo-ref cleaned 0 0) 1.0) (= (sparse-coo-ref cleaned 1 1) 2.0) (= (sparse-coo-ref cleaned 0 1) 0))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sparse_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild COO and read value at (1,2).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-coo-ref (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9))) 1 2)", "verify_expr": "(equal? (sparse-coo-ref (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9))) 1 2) 7)", "tags": ["linalg", "sparse", "composition", "sparse-coo-from-triplets", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild COO and read value at (1,2).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: small integration task across module primitives.\n\nCreate empty COO from empty triplet list and return nnz.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-coo-nnz (sparse-coo-from-triplets 4 5 '()))", "verify_expr": "(equal? (sparse-coo-nnz (sparse-coo-from-triplets 4 5 '())) 0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-from-triplets", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCreate empty COO from empty triplet list and return nnz.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_004", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild COO then convert to CSR and query (2,1).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-csr-ref (coo->csr (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))) 2 1)", "verify_expr": "(equal? (sparse-csr-ref (coo->csr (sparse-coo-from-triplets 3 3 '((0 0 5) (1 2 7) (2 1 9)))) 2 1) 9)", "tags": ["linalg", "sparse", "composition", "coo->csr", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild COO then convert to CSR and query (2,1).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRead present entry (0,0) from COO.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-coo-ref (sparse-coo-from-triplets 2 2 '((0 0 4) (1 1 6))) 0 0)", "verify_expr": "(equal? (sparse-coo-ref (sparse-coo-from-triplets 2 2 '((0 0 4) (1 1 6))) 0 0) 4)", "tags": ["linalg", "sparse", "composition", "sparse-coo-ref", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nRead present entry (0,0) from COO.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: small integration task across module primitives.\n\nRead missing entry (0,1) from COO and get zero.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-coo-ref (sparse-coo-from-triplets 2 2 '((0 0 4) (1 1 6))) 0 1)", "verify_expr": "(equal? (sparse-coo-ref (sparse-coo-from-triplets 2 2 '((0 0 4) (1 1 6))) 0 1) 0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-ref", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nRead missing entry (0,1) from COO and get zero.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nRead from COO after dense->sparse conversion.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-coo-ref (dense->sparse-coo (matrix-from-lists '((1 0) (0 2)))) 1 1)", "verify_expr": "(equal? (sparse-coo-ref (dense->sparse-coo (matrix-from-lists '((1 0) (0 2)))) 1 1) 2)", "tags": ["linalg", "sparse", "composition", "sparse-coo-ref", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nRead from COO after dense->sparse conversion.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff ref returns zero for guaranteed absent coordinate.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (sparse-coo-ref (sparse-coo-from-triplets 3 3 '((0 0 1))) 2 2) 0)", "verify_expr": "(equal? (= (sparse-coo-ref (sparse-coo-from-triplets 3 3 '((0 0 1))) 2 2) 0) #t)", "tags": ["linalg", "sparse", "composition", "sparse-coo-ref", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff ref returns zero for guaranteed absent coordinate.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert empty COO to CSR and return row-ptrs list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vector->list (sparse-csr-row-ptrs (coo->csr (sparse-coo-from-triplets 3 4 '()))))", "verify_expr": "(equal? (vector->list (sparse-csr-row-ptrs (coo->csr (sparse-coo-from-triplets 3 4 '())))) '(0 0 0 0))", "tags": ["linalg", "sparse", "composition", "coo->csr", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nConvert empty COO to CSR and return row-ptrs list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-from-triplets", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild single-triplet COO, convert to CSR, and read (2,0).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(sparse-csr-ref (coo->csr (sparse-coo-from-triplets 3 3 '((2 0 9)))) 2 0)", "verify_expr": "(equal? (sparse-csr-ref (coo->csr (sparse-coo-from-triplets 3 3 '((2 0 9)))) 2 0) 9)", "tags": ["linalg", "sparse", "composition", "sparse-coo-from-triplets", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild single-triplet COO, convert to CSR, and read (2,0).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "coo->csr", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff CSR nnz equals COO nnz after conversion.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (1 1 2) (2 2 3)))]) (= (sparse-csr-nnz (coo->csr coo)) (sparse-coo-nnz coo)))", "verify_expr": "(equal? (let ([coo (sparse-coo-from-triplets 3 3 '((0 0 1) (1 1 2) (2 2 3)))]) (= (sparse-csr-nnz (coo->csr coo)) (sparse-coo-nnz coo))) #t)", "tags": ["linalg", "sparse", "composition", "coo->csr", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn #t iff CSR nnz equals COO nnz after conversion.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nRead existing (1,1) from CSR matrix.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([csr (coo->csr (sparse-coo-from-triplets 3 3 '((1 1 7))))]) (sparse-csr-ref csr 1 1))", "verify_expr": "(equal? (let* ([csr (coo->csr (sparse-coo-from-triplets 3 3 '((1 1 7))))]) (sparse-csr-ref csr 1 1)) 7)", "tags": ["linalg", "sparse", "composition", "sparse-csr-ref", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nRead existing (1,1) from CSR matrix.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nRead missing CSR coordinate and get zero.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([csr (coo->csr (sparse-coo-from-triplets 3 3 '((1 1 7))))]) (sparse-csr-ref csr 0 2))", "verify_expr": "(equal? (let* ([csr (coo->csr (sparse-coo-from-triplets 3 3 '((1 1 7))))]) (sparse-csr-ref csr 0 2)) 0)", "tags": ["linalg", "sparse", "composition", "sparse-csr-ref", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nRead missing CSR coordinate and get zero.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRead from CSR produced by dense->sparse conversion.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-csr-ref (coo->csr (dense->sparse-coo (matrix-from-lists '((0 2) (3 0))))) 1 0)", "verify_expr": "(equal? (sparse-csr-ref (coo->csr (dense->sparse-coo (matrix-from-lists '((0 2) (3 0))))) 1 0) 3)", "tags": ["linalg", "sparse", "composition", "sparse-csr-ref", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nRead from CSR produced by dense->sparse conversion.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff csr-ref equals coo-ref after conversion.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([coo (sparse-coo-from-triplets 2 3 '((0 1 4) (1 2 5)))] [csr (coo->csr coo)]) (= (sparse-csr-ref csr 1 2) (sparse-coo-ref coo 1 2)))", "verify_expr": "(equal? (let* ([coo (sparse-coo-from-triplets 2 3 '((0 1 4) (1 2 5)))] [csr (coo->csr coo)]) (= (sparse-csr-ref csr 1 2) (sparse-coo-ref coo 1 2))) #t)", "tags": ["linalg", "sparse", "composition", "sparse-csr-ref", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff csr-ref equals coo-ref after conversion.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: small integration task across module primitives.\n\nConvert all-zero dense matrix to COO and return nnz.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-coo-nnz (dense->sparse-coo (matrix-from-lists '((0 0) (0 0)))))", "verify_expr": "(equal? (sparse-coo-nnz (dense->sparse-coo (matrix-from-lists '((0 0) (0 0))))) 0)", "tags": ["linalg", "sparse", "composition", "dense->sparse-coo", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nConvert all-zero dense matrix to COO and return nnz.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: small integration task across module primitives.\n\nUse tolerance 1e-14 to drop tiny value 1e-16.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(sparse-coo-nnz (dense->sparse-coo (matrix-from-lists '((1.0 1e-16) (0.0 2.0))) 1e-14))", "verify_expr": "(equal? (sparse-coo-nnz (dense->sparse-coo (matrix-from-lists '((1.0 1e-16) (0.0 2.0))) 1e-14)) 2)", "tags": ["linalg", "sparse", "composition", "dense->sparse-coo", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nUse tolerance 1e-14 to drop tiny value 1e-16.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "dense->sparse-coo", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert dense to COO then CSR and read (0,2).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-csr-ref (coo->csr (dense->sparse-coo (matrix-from-lists '((1 0 2) (0 3 0))))) 0 2)", "verify_expr": "(equal? (sparse-csr-ref (coo->csr (dense->sparse-coo (matrix-from-lists '((1 0 2) (0 3 0))))) 0 2) 2)", "tags": ["linalg", "sparse", "composition", "dense->sparse-coo", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nConvert dense to COO then CSR and read (0,2).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: small integration task across module primitives.\n\nMultiply CSR by vector #(1 2 3) and return result.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-csr-vec-mul (coo->csr (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))) (vec 1 2 3))", "verify_expr": "(equal? (sparse-csr-vec-mul (coo->csr (sparse-coo-from-triplets 3 3 '((0 0 1) (0 1 2) (1 1 3) (2 0 4) (2 2 5)))) (vec 1 2 3)) (vec 5 6 19))", "tags": ["linalg", "sparse", "composition", "sparse-csr-vec-mul", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nMultiply CSR by vector #(1 2 3) and return result.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn dimension mismatch for wrong vector length.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-csr-vec-mul (coo->csr (sparse-coo-from-triplets 2 3 '((0 0 1)))) (vec 1 2))", "verify_expr": "(equal? (sparse-csr-vec-mul (coo->csr (sparse-coo-from-triplets 2 3 '((0 0 1)))) (vec 1 2)) '(error dimension-mismatch 3 2))", "tags": ["linalg", "sparse", "composition", "sparse-csr-vec-mul", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn dimension mismatch for wrong vector length.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-csr-vec-mul", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompare sparse matvec with dense matrix-vec-mul on same data.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([dense (matrix-from-lists '((2 0 1) (0 3 0) (4 0 2)))] [csr (coo->csr (dense->sparse-coo dense))] [v (vec 1 2 3)]) (equal? (sparse-csr-vec-mul csr v) (matrix-vec-mul dense v)))", "verify_expr": "(equal? (let* ([dense (matrix-from-lists '((2 0 1) (0 3 0) (4 0 2)))] [csr (coo->csr (dense->sparse-coo dense))] [v (vec 1 2 3)]) (equal? (sparse-csr-vec-mul csr v) (matrix-vec-mul dense v))) #t)", "tags": ["linalg", "sparse", "composition", "sparse-csr-vec-mul", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompare sparse matvec with dense matrix-vec-mul on same data.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd two COO matrices and read (0,0).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-coo-ref (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0))) (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))) 0 0)", "verify_expr": "(equal? (sparse-coo-ref (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 2.0))) (sparse-coo-from-triplets 2 2 '((0 0 3.0) (0 1 4.0)))) 0 0) 4.0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-add-impl", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nAdd two COO matrices and read (0,0).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sparse_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: small integration task across module primitives.\n\nCancellation should produce nnz 0 under default epsilon.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(sparse-coo-nnz (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((0 0 1.0))) (sparse-coo-from-triplets 2 2 '((0 0 -1.0)))))", "verify_expr": "(equal? (sparse-coo-nnz (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((0 0 1.0))) (sparse-coo-from-triplets 2 2 '((0 0 -1.0))))) 0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-add-impl", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCancellation should produce nnz 0 under default epsilon.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd with duplicate coordinates across inputs and read sum.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-coo-ref (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((0 1 2.0) (0 1 3.0))) (sparse-coo-from-triplets 2 2 '((0 1 4.0)))) 0 1)", "verify_expr": "(equal? (sparse-coo-ref (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((0 1 2.0) (0 1 3.0))) (sparse-coo-from-triplets 2 2 '((0 1 4.0)))) 0 1) 9.0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-add-impl", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nAdd with duplicate coordinates across inputs and read sum.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-add-impl", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd A and B, convert result to CSR, and read (1,1).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(sparse-csr-ref (coo->csr (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((1 1 2.0))) (sparse-coo-from-triplets 2 2 '((1 1 5.0))))) 1 1)", "verify_expr": "(equal? (sparse-csr-ref (coo->csr (sparse-coo-add-impl (sparse-coo-from-triplets 2 2 '((1 1 2.0))) (sparse-coo-from-triplets 2 2 '((1 1 5.0))))) 1 1) 7.0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-add-impl", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nAdd A and B, convert result to CSR, and read (1,1).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: compose existing APIs into one expression.\n\nDrop entries below 1e-14 and return nnz.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(sparse-coo-nnz (sparse-coo-drop-below 1e-14 (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20)))))", "verify_expr": "(equal? (sparse-coo-nnz (sparse-coo-drop-below 1e-14 (sparse-coo-from-triplets 3 3 '((0 0 1.0) (0 1 1e-16) (1 1 2.0) (2 2 1e-20))))) 2)", "tags": ["linalg", "sparse", "composition", "sparse-coo-drop-below", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nDrop entries below 1e-14 and return nnz.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sparse_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWith tol=0, keep all nonzero values from COO.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(sparse-coo-nnz (sparse-coo-drop-below 0 (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 -2.0)))))", "verify_expr": "(equal? (sparse-coo-nnz (sparse-coo-drop-below 0 (sparse-coo-from-triplets 2 2 '((0 0 1.0) (1 1 -2.0))))) 2)", "tags": ["linalg", "sparse", "composition", "sparse-coo-drop-below", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWith tol=0, keep all nonzero values from COO.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sparse_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/sparse.ss", "source_test": "lattice/linalg/test-sparse.ss", "source_function": "sparse-coo-drop-below", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDrop tiny entries then read surviving (1,1).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sparse-coo-ref (sparse-coo-drop-below 1e-10 (sparse-coo-from-triplets 2 2 '((0 0 1e-12) (1 1 3.0)))) 1 1)", "verify_expr": "(equal? (sparse-coo-ref (sparse-coo-drop-below 1e-10 (sparse-coo-from-triplets 2 2 '((0 0 1e-12) (1 1 3.0)))) 1 1) 3.0)", "tags": ["linalg", "sparse", "composition", "sparse-coo-drop-below", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nDrop tiny entries then read surviving (1,1).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
