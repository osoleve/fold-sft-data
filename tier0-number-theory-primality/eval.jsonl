{"id": "primality_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `miller-rabin?`\nSpec: Deterministic/probabilistic Miller-Rabin primality test with optional rounds argument.\n\nWrite exactly one Scheme function definition for `miller-rabin?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (miller-rabin-witness? a n)\n  (let* ([n-1 (- n 1)]\n         [factor-result (factor-out-2s n-1)]\n         [d (car factor-result)]\n         [r (cdr factor-result)]\n         [x (mod-expt a d n)])\n    (cond\n     [(or (= x 1) (= x n-1)) #f]\n     [else\n      (let loop ([x x] [i 0])\n        (cond\n         [(>= i (- r 1)) #t]\n         [else\n          (let ([x-new (mod-expt x 2 n)])\n            (cond\n             [(= x-new 1) #t]\n             [(= x-new n-1) #f]\n             [else (loop x-new (+ i 1))]))]))])))\n  (define (deterministic-witnesses n k)\n  (let ([small-primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)])\n    (take (min k (length small-primes)) small-primes)))\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n  (and (miller-rabin? 104729) (miller-rabin? 1299709 5) (not (miller-rabin? 561)) (not (miller-rabin? 1105)) (equal? (miller-rabin? 997) (prime? 997)) (equal? (miller-rabin? 1000) (prime? 1000))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "miller-rabin?"], "split": "eval"}
{"id": "primality_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `factorize`\nSpec: General integer factorization: small-factor extraction plus Pollard-rho fallback.\n\nWrite exactly one Scheme function definition for `factorize`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (factorize 1) '()))\n(let () (equal? (factorize 100) '(2 2 5 5)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (and (equal? (factorize 1) '()) (equal? (factorize 100) '(2 2 5 5)) (equal? (factorize 997) '(997)) (= (apply * (factorize 12345)) 12345)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "factorize"], "split": "eval"}
{"id": "primality_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `euler-totient`\nSpec: Compute Euler's totient Ï†(n) from prime factorization.\n\nWrite exactly one Scheme function definition for `euler-totient`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (euler-totient 1) 1))\n(let () (= (euler-totient 2) 1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))\n  (and (= (euler-totient 1) 1) (= (euler-totient 2) 1) (= (euler-totient 10) 4) (= (euler-totient 36) 12) (= (euler-totient 13) 12)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "euler-totient"], "split": "eval"}
{"id": "primality_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `prime?`\n\n```python\ndef is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    if n == 3:\n        return True\n    d = 3\n    limit = isqrt(n)\n    while d <= limit:\n        if n % d == 0:\n            return False\n        d += 2\n    return True\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (and (not (prime? 0)) (not (prime? 1)) (prime? 2) (prime? 3) (not (prime? 4)) (prime? 97) (not (prime? 1001))))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "prime?"], "split": "eval"}
{"id": "primality_translation_009", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `prime-factorization`\n\n```python\ndef prime_factorization(n):\n    factors = factorize(n)\n    if not factors:\n        return []\n    out = []\n    current = factors[0]\n    count = 1\n    for x in factors[1:]:\n        if x == current:\n            count += 1\n        else:\n            out.append((current, count))\n            current = x\n            count = 1\n    out.append((current, count))\n    return out\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (and (equal? (prime-factorization 1) '()) (equal? (prime-factorization 12) '((2 . 2) (3 . 1))) (equal? (prime-factorization 360) '((2 . 3) (3 . 2) (5 . 1)))))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "prime-factorization"], "split": "eval"}
{"id": "primality_translation_016", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `jacobi-symbol`\n\n```scheme\n(define (jacobi0 a n)\n  (cond ((not (and (odd? n) (> n 0))) 0)\n        ((= n 1) 1)\n        ((= a 0) 0)\n        ((= a 1) 1)\n        (else\n         (let ((a (modulo a n)))\n           (cond ((= a 0) 0)\n                 ((= a 1) 1)\n                 (else\n                  (let* ((tw (factor-out-2s a))\n                         (a-odd (car tw))\n                         (e (cdr tw))\n                         (two (if (even? e) 1 (if (or (= (modulo n 8) 1) (= (modulo n 8) 7)) 1 -1))))\n                    (if (= a-odd 1)\n                        two\n                        (let* ((flip (if (and (= (modulo a-odd 4) 3) (= (modulo n 4) 3)) -1 1))\n                               (recur (jacobi0 (modulo n a-odd) a-odd)))\n                          (* two flip recur))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n  (and (= (jacobi-symbol 2 15) 1) (= (jacobi-symbol 11 15) -1) (= (jacobi-symbol 14 15) -1) (= (jacobi-symbol 3 10) 0) (= (jacobi-symbol (+ 14 15) 15) (jacobi-symbol 14 15))))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "jacobi-symbol"], "split": "eval"}
{"id": "primality_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prime?` in `lattice/number-theory/primality.ss`.\nKnown issue: The n=2 special case must be checked before the even-number rejection.\n\n```scheme\n(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(even? n) #f]\n   [(= n 2) #t]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (and (not (prime? 0)) (not (prime? 1)) (prime? 2) (prime? 3) (not (prime? 4)) (prime? 97) (not (prime? 1001))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "prime?"], "split": "eval"}
{"id": "primality_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prime-factorization` in `lattice/number-theory/primality.ss`.\nKnown issue: Repeated prime factors must be grouped into exponent counts.\n\n```scheme\n(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (map (lambda (p) (cons p 1)) factors)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (prime-factorization 1) '()))\n(let () (equal? (prime-factorization 12) '((2 . 2) (3 . 1))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (and (equal? (prime-factorization 1) '()) (equal? (prime-factorization 12) '((2 . 2) (3 . 1))) (equal? (prime-factorization 360) '((2 . 3) (3 . 2) (5 . 1)))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "prime-factorization"], "split": "eval"}
{"id": "primality_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `jacobi-symbol` in `lattice/number-theory/primality.ss`.\nKnown issue: The (2/n) contribution for odd exponent e is +1 when n mod 8 is 1 or 7, otherwise -1.\n\n```scheme\n(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          -1\n                          1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The (2/n) contribution for odd exponent e is +1 when n mod 8 is 1 or 7, otherwise -1.\n\nExpected behavior after patch:\n```scheme\n(let () (= (jacobi-symbol 2 15) 1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (jacobi-symbol 2 15) 1))\n(let () (= (jacobi-symbol 11 15) -1))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n  (and (= (jacobi-symbol 2 15) 1) (= (jacobi-symbol 11 15) -1) (= (jacobi-symbol 14 15) -1) (= (jacobi-symbol 3 10) 0) (= (jacobi-symbol (+ 14 15) 15) (jacobi-symbol 14 15))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "jacobi-symbol"], "split": "eval"}
{"id": "primality_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck whether integer 97 is prime.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(prime? 97)", "verify_expr": "(equal? (prime? 97) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "prime?", "direct"], "split": "eval"}
{"id": "primality_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFactor 360 with trial division.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(trial-division 360)", "verify_expr": "(equal? (trial-division 360) '(2 2 2 3 3 5))", "tags": ["tier0", "number-theory", "primality", "composition", "trial-division", "direct"], "split": "eval"}
{"id": "primality_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute exponent-form factorization of 360.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(prime-factorization 360)", "verify_expr": "(equal? (prime-factorization 360) '((2 . 3) (3 . 2) (5 . 1)))", "tags": ["tier0", "number-theory", "primality", "composition", "prime-factorization", "direct"], "split": "eval"}
{"id": "primality_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: small integration task across module primitives.\n\nVerify each divisor of 28 divides 28.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(null? (filter (lambda (d) (not (zero? (modulo 28 d)))) (divisors 28)))", "verify_expr": "(equal? (null? (filter (lambda (d) (not (zero? (modulo 28 d)))) (divisors 28))) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "divisors", "integration"], "split": "eval"}
{"id": "primality_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck periodicity in first argument modulo n.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (jacobi-symbol (+ 14 (* 3 15)) 15) (jacobi-symbol 14 15))", "verify_expr": "(equal? (= (jacobi-symbol (+ 14 (* 3 15)) 15) (jacobi-symbol 14 15)) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "jacobi-symbol", "property"], "split": "eval"}
