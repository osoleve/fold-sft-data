{"id": "primality_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `prime?`\nSpec: Deterministic primality test via trial division up to integer square root.\n\nWrite exactly one Scheme function definition for `prime?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(not (prime? 0))\n(not (prime? 1))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (and (not (prime? 0)) (not (prime? 1)) (prime? 2) (prime? 3) (not (prime? 4)) (prime? 97) (not (prime? 1001))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "prime?"], "split": "train"}
{"id": "primality_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `prime?`\nBehavior contract: Deterministic primality test via trial division up to integer square root.\n\n```scheme\n(define (prime? n)\n  ;; TODO: trial-division primality test\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(not (prime? 0))\n(not (prime? 1))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (and (not (prime? 0)) (not (prime? 1)) (prime? 2) (prime? 3) (not (prime? 4)) (prime? 97) (not (prime? 1001))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "prime?"], "split": "train"}
{"id": "primality_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `miller-rabin?`\nBehavior contract: Deterministic/probabilistic Miller-Rabin primality test with optional rounds argument.\n\n```scheme\n(define (miller-rabin? n . args)\n  ;; TODO: Miller-Rabin with deterministic witness sets for bounded ranges\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (miller-rabin-witness? a n)\n  (let* ([n-1 (- n 1)]\n         [factor-result (factor-out-2s n-1)]\n         [d (car factor-result)]\n         [r (cdr factor-result)]\n         [x (mod-expt a d n)])\n    (cond\n     [(or (= x 1) (= x n-1)) #f]\n     [else\n      (let loop ([x x] [i 0])\n        (cond\n         [(>= i (- r 1)) #t]\n         [else\n          (let ([x-new (mod-expt x 2 n)])\n            (cond\n             [(= x-new 1) #t]\n             [(= x-new n-1) #f]\n             [else (loop x-new (+ i 1))]))]))])))\n  (define (deterministic-witnesses n k)\n  (let ([small-primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)])\n    (take (min k (length small-primes)) small-primes)))\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n  (and (miller-rabin? 104729) (miller-rabin? 1299709 5) (not (miller-rabin? 561)) (not (miller-rabin? 1105)) (equal? (miller-rabin? 997) (prime? 997)) (equal? (miller-rabin? 1000) (prime? 1000))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "miller-rabin?"], "split": "train"}
{"id": "primality_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `trial-division`\nSpec: Factor integer n into sorted prime factors with repetition using trial division.\n\nWrite exactly one Scheme function definition for `trial-division`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (trial-division 1) '())\n(equal? (trial-division 12) '(2 2 3))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))", "verify_expr": "(let ()\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (and (equal? (trial-division 1) '()) (equal? (trial-division 12) '(2 2 3)) (equal? (trial-division 1001) '(7 11 13)) (= (apply * (trial-division 360)) 360)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "trial-division"], "split": "train"}
{"id": "primality_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `trial-division`\nBehavior contract: Factor integer n into sorted prime factors with repetition using trial division.\n\n```scheme\n(define (trial-division n)\n  ;; TODO: factor n by dividing out small factors repeatedly\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))", "verify_expr": "(let ()\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (and (equal? (trial-division 1) '()) (equal? (trial-division 12) '(2 2 3)) (equal? (trial-division 1001) '(7 11 13)) (= (apply * (trial-division 360)) 360)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "trial-division"], "split": "train"}
{"id": "primality_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `factorize`\nBehavior contract: General integer factorization: small-factor extraction plus Pollard-rho fallback.\n\n```scheme\n(define (factorize n)\n  ;; TODO: combine small-factor extraction and Pollard-rho fallback\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (factorize 1) '())\n(equal? (factorize 100) '(2 2 5 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (and (equal? (factorize 1) '()) (equal? (factorize 100) '(2 2 5 5)) (equal? (factorize 997) '(997)) (= (apply * (factorize 12345)) 12345)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "factorize"], "split": "train"}
{"id": "primality_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `prime-factorization`\nSpec: Return factorization as sorted (prime . exponent) pairs.\n\nWrite exactly one Scheme function definition for `prime-factorization`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (and (equal? (prime-factorization 1) '()) (equal? (prime-factorization 12) '((2 . 2) (3 . 1))) (equal? (prime-factorization 360) '((2 . 3) (3 . 2) (5 . 1)))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "prime-factorization"], "split": "train"}
{"id": "primality_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `prime-factorization`\nBehavior contract: Return factorization as sorted (prime . exponent) pairs.\n\n```scheme\n(define (prime-factorization n)\n  ;; TODO: compress factor list into (prime . exponent) pairs\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (prime-factorization 1) '())\n(equal? (prime-factorization 12) '((2 . 2) (3 . 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (and (equal? (prime-factorization 1) '()) (equal? (prime-factorization 12) '((2 . 2) (3 . 1))) (equal? (prime-factorization 360) '((2 . 3) (3 . 2) (5 . 1)))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "prime-factorization"], "split": "train"}
{"id": "primality_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `divisors`\nSpec: Generate all positive divisors of n in ascending order.\n\nWrite exactly one Scheme function definition for `divisors`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (divisors 1) '(1))\n(equal? (divisors 12) '(1 2 3 4 6 12))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (prime-powers p e)\n  (let loop ([i 0] [pw 1] [result '()])\n    (if (> i e)\n        (reverse result)\n        (loop (+ i 1) (* pw p) (cons pw result)))))\n  (define (generate-divisors pf)\n  (if (null? pf)\n      '(1)\n      (let* ([p (caar pf)]\n             [e (cdar pf)]\n             [rest (generate-divisors (cdr pf))]\n             [powers (prime-powers p e)])\n        (append-map (lambda (pw)\n                      (map (lambda (d) (* pw d)) rest))\n                    powers))))\n  (define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))\n  (and (equal? (divisors 1) '(1)) (equal? (divisors 12) '(1 2 3 4 6 12)) (= (length (divisors 360)) 24) (= (car (reverse (divisors 28))) 28)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "divisors"], "split": "train"}
{"id": "primality_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `divisors`\nBehavior contract: Generate all positive divisors of n in ascending order.\n\n```scheme\n(define (divisors n)\n  ;; TODO: derive all divisors from prime-factorization\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (divisors 1) '(1))\n(equal? (divisors 12) '(1 2 3 4 6 12))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (prime-powers p e)\n  (let loop ([i 0] [pw 1] [result '()])\n    (if (> i e)\n        (reverse result)\n        (loop (+ i 1) (* pw p) (cons pw result)))))\n  (define (generate-divisors pf)\n  (if (null? pf)\n      '(1)\n      (let* ([p (caar pf)]\n             [e (cdar pf)]\n             [rest (generate-divisors (cdr pf))]\n             [powers (prime-powers p e)])\n        (append-map (lambda (pw)\n                      (map (lambda (d) (* pw d)) rest))\n                    powers))))\n  (define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))\n  (and (equal? (divisors 1) '(1)) (equal? (divisors 12) '(1 2 3 4 6 12)) (= (length (divisors 360)) 24) (= (car (reverse (divisors 28))) 28)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "divisors"], "split": "train"}
{"id": "primality_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `euler-totient`\nBehavior contract: Compute Euler's totient Ï†(n) from prime factorization.\n\n```scheme\n(define (euler-totient n)\n  ;; TODO: compute phi(n) from prime powers\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (euler-totient 1) 1)\n(= (euler-totient 2) 1)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))\n  (and (= (euler-totient 1) 1) (= (euler-totient 2) 1) (= (euler-totient 10) 4) (= (euler-totient 36) 12) (= (euler-totient 13) 12)))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "euler-totient"], "split": "train"}
{"id": "primality_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/primality.ss\nFunction: `jacobi-symbol`\nSpec: Compute Jacobi symbol (a/n) for odd positive n using reciprocity and power-of-two extraction.\n\nWrite exactly one Scheme function definition for `jacobi-symbol`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (jacobi-symbol 2 15) 1)\n(= (jacobi-symbol 11 15) -1)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n  (and (= (jacobi-symbol 2 15) 1) (= (jacobi-symbol 11 15) -1) (= (jacobi-symbol 14 15) -1) (= (jacobi-symbol 3 10) 0) (= (jacobi-symbol (+ 14 15) 15) (jacobi-symbol 14 15))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "jacobi-symbol"], "split": "train"}
{"id": "primality_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/number-theory/primality.ss\nFunction target: `jacobi-symbol`\nBehavior contract: Compute Jacobi symbol (a/n) for odd positive n using reciprocity and power-of-two extraction.\n\n```scheme\n(define (jacobi-symbol a n)\n  ;; TODO: implement Jacobi symbol recursion with reciprocity\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n  (and (= (jacobi-symbol 2 15) 1) (= (jacobi-symbol 11 15) -1) (= (jacobi-symbol 14 15) -1) (= (jacobi-symbol 3 10) 0) (= (jacobi-symbol (+ 14 15) 15) (jacobi-symbol 14 15))))", "tags": ["tier0", "number-theory", "primality", "spec-to-code", "skeleton", "jacobi-symbol"], "split": "train"}
{"id": "primality_translation_002", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `prime?`\n\n```scheme\n(define (is-prime n)\n  (cond ((< n 2) #f)\n        ((= n 2) #t)\n        ((even? n) #f)\n        ((= n 3) #t)\n        (else\n         (let ((limit (isqrt n)))\n           (let loop ((d 3))\n             (cond ((> d limit) #t)\n                   ((zero? (modulo n d)) #f)\n                   (else (loop (+ d 2)))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (and (not (prime? 0)) (not (prime? 1)) (prime? 2) (prime? 3) (not (prime? 4)) (prime? 97) (not (prime? 1001))))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "prime?"], "split": "train"}
{"id": "primality_translation_003", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `miller-rabin?`\n\n```python\ndef miller_rabin(n, rounds=20):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    if n == 3:\n        return True\n    if n < 2047:\n        return not mr_witness(2, n)\n    if n < 1373653:\n        return not (mr_witness(2, n) or mr_witness(3, n))\n    if n < 9080191:\n        return not (mr_witness(31, n) or mr_witness(73, n))\n    if n < 25326001:\n        return not (mr_witness(2, n) or mr_witness(3, n) or mr_witness(5, n))\n    if n < 3215031751:\n        return not (mr_witness(2, n) or mr_witness(3, n) or mr_witness(5, n) or mr_witness(7, n))\n    if n < 4759123141:\n        return not (mr_witness(2, n) or mr_witness(7, n) or mr_witness(61, n))\n    if n < 3317044064679887385961981:\n        witnesses = [2,3,5,7,11,13,17,19,23,29,31,37]\n    else:\n        witnesses = deterministic_witnesses(n, rounds)\n    return not any(mr_witness(a, n) for a in witnesses)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(miller-rabin? 104729)\n(miller-rabin? 1299709 5)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (miller-rabin-witness? a n)\n  (let* ([n-1 (- n 1)]\n         [factor-result (factor-out-2s n-1)]\n         [d (car factor-result)]\n         [r (cdr factor-result)]\n         [x (mod-expt a d n)])\n    (cond\n     [(or (= x 1) (= x n-1)) #f]\n     [else\n      (let loop ([x x] [i 0])\n        (cond\n         [(>= i (- r 1)) #t]\n         [else\n          (let ([x-new (mod-expt x 2 n)])\n            (cond\n             [(= x-new 1) #t]\n             [(= x-new n-1) #f]\n             [else (loop x-new (+ i 1))]))]))])))\n  (define (deterministic-witnesses n k)\n  (let ([small-primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)])\n    (take (min k (length small-primes)) small-primes)))\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n  (and (miller-rabin? 104729) (miller-rabin? 1299709 5) (not (miller-rabin? 561)) (not (miller-rabin? 1105)) (equal? (miller-rabin? 997) (prime? 997)) (equal? (miller-rabin? 1000) (prime? 1000))))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "miller-rabin?"], "split": "train"}
{"id": "primality_translation_004", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `miller-rabin?`\n\n```scheme\n(define (mr? n . args)\n  (let ((rounds (if (null? args) 20 (car args))))\n    (cond ((< n 2) #f)\n          ((= n 2) #t)\n          ((even? n) #f)\n          ((= n 3) #t)\n          ((< n 2047) (not (miller-rabin-witness? 2 n)))\n          ((< n 1373653) (not (or (miller-rabin-witness? 2 n) (miller-rabin-witness? 3 n))))\n          ((< n 9080191) (not (or (miller-rabin-witness? 31 n) (miller-rabin-witness? 73 n))))\n          ((< n 25326001) (not (or (miller-rabin-witness? 2 n) (miller-rabin-witness? 3 n) (miller-rabin-witness? 5 n))))\n          ((< n 3215031751) (not (or (miller-rabin-witness? 2 n) (miller-rabin-witness? 3 n) (miller-rabin-witness? 5 n) (miller-rabin-witness? 7 n))))\n          ((< n 4759123141) (not (or (miller-rabin-witness? 2 n) (miller-rabin-witness? 7 n) (miller-rabin-witness? 61 n))))\n          ((< n 3317044064679887385961981)\n           (not (exists (lambda (a) (miller-rabin-witness? a n)) '(2 3 5 7 11 13 17 19 23 29 31 37))))\n          (else\n           (let ((ws (deterministic-witnesses n rounds)))\n             (not (exists (lambda (a) (miller-rabin-witness? a n)) ws)))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (miller-rabin-witness? a n)\n  (let* ([n-1 (- n 1)]\n         [factor-result (factor-out-2s n-1)]\n         [d (car factor-result)]\n         [r (cdr factor-result)]\n         [x (mod-expt a d n)])\n    (cond\n     [(or (= x 1) (= x n-1)) #f]\n     [else\n      (let loop ([x x] [i 0])\n        (cond\n         [(>= i (- r 1)) #t]\n         [else\n          (let ([x-new (mod-expt x 2 n)])\n            (cond\n             [(= x-new 1) #t]\n             [(= x-new n-1) #f]\n             [else (loop x-new (+ i 1))]))]))])))\n  (define (deterministic-witnesses n k)\n  (let ([small-primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)])\n    (take (min k (length small-primes)) small-primes)))\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n  (and (miller-rabin? 104729) (miller-rabin? 1299709 5) (not (miller-rabin? 561)) (not (miller-rabin? 1105)) (equal? (miller-rabin? 997) (prime? 997)) (equal? (miller-rabin? 1000) (prime? 1000))))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "miller-rabin?"], "split": "train"}
{"id": "primality_translation_005", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `trial-division`\n\n```python\ndef trial_division(n):\n    if n < 2:\n        return []\n    factors = []\n    d = 2\n    while n > 1:\n        if d * d > n:\n            factors.append(n)\n            break\n        if n % d == 0:\n            factors.append(d)\n            n //= d\n        else:\n            d = 3 if d == 2 else d + 2\n    return factors\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (trial-division 1) '())\n(equal? (trial-division 12) '(2 2 3))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))", "verify_expr": "(let ()\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (and (equal? (trial-division 1) '()) (equal? (trial-division 12) '(2 2 3)) (equal? (trial-division 1001) '(7 11 13)) (= (apply * (trial-division 360)) 360)))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "trial-division"], "split": "train"}
{"id": "primality_translation_006", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `trial-division`\n\n```scheme\n(define (trial-div n)\n  (cond ((< n 2) '())\n        (else\n         (let loop ((n n) (d 2) (factors '()))\n           (cond ((= n 1) (reverse factors))\n                 ((> (* d d) n) (reverse (cons n factors)))\n                 ((zero? (modulo n d)) (loop (quotient n d) d (cons d factors)))\n                 (else (loop n (if (= d 2) 3 (+ d 2)) factors)))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))", "verify_expr": "(let ()\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (and (equal? (trial-division 1) '()) (equal? (trial-division 12) '(2 2 3)) (equal? (trial-division 1001) '(7 11 13)) (= (apply * (trial-division 360)) 360)))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "trial-division"], "split": "train"}
{"id": "primality_translation_007", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `factorize`\n\n```python\ndef factorize(n):\n    if n < 2:\n        return []\n    if is_prime(n):\n        return [n]\n    remaining, small = extract_small_factors(n, 1000)\n    if remaining == 1:\n        return sorted(small)\n    return sorted(small + pollard_rho_factorize(remaining))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (factorize 1) '())\n(equal? (factorize 100) '(2 2 5 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (and (equal? (factorize 1) '()) (equal? (factorize 100) '(2 2 5 5)) (equal? (factorize 997) '(997)) (= (apply * (factorize 12345)) 12345)))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "factorize"], "split": "train"}
{"id": "primality_translation_008", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `factorize`\n\n```scheme\n(define (factorize0 n)\n  (cond ((< n 2) '())\n        ((prime? n) (list n))\n        (else\n         (let* ((r (extract-small-factors n 1000))\n                (remaining (car r))\n                (small (cdr r)))\n           (if (= remaining 1)\n               (sort-by < small)\n               (sort-by < (append small (pollard-rho-factorize remaining))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (factorize 1) '())\n(equal? (factorize 100) '(2 2 5 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (and (equal? (factorize 1) '()) (equal? (factorize 100) '(2 2 5 5)) (equal? (factorize 997) '(997)) (= (apply * (factorize 12345)) 12345)))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "factorize"], "split": "train"}
{"id": "primality_translation_010", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `prime-factorization`\n\n```scheme\n(define (pf0 n)\n  (let ((factors (factorize n)))\n    (if (null? factors)\n        '()\n        (let loop ((fs (cdr factors)) (current (car factors)) (count 1) (result '()))\n          (cond ((null? fs) (reverse (cons (cons current count) result)))\n                ((= (car fs) current) (loop (cdr fs) current (+ count 1) result))\n                (else (loop (cdr fs) (car fs) 1 (cons (cons current count) result))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (and (equal? (prime-factorization 1) '()) (equal? (prime-factorization 12) '((2 . 2) (3 . 1))) (equal? (prime-factorization 360) '((2 . 3) (3 . 2) (5 . 1)))))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "prime-factorization"], "split": "train"}
{"id": "primality_translation_011", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `divisors`\n\n```python\ndef divisors(n):\n    if n < 1:\n        return []\n    pf = prime_factorization(n)\n    return sorted(generate_divisors(pf))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (divisors 1) '(1))\n(equal? (divisors 12) '(1 2 3 4 6 12))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (prime-powers p e)\n  (let loop ([i 0] [pw 1] [result '()])\n    (if (> i e)\n        (reverse result)\n        (loop (+ i 1) (* pw p) (cons pw result)))))\n  (define (generate-divisors pf)\n  (if (null? pf)\n      '(1)\n      (let* ([p (caar pf)]\n             [e (cdar pf)]\n             [rest (generate-divisors (cdr pf))]\n             [powers (prime-powers p e)])\n        (append-map (lambda (pw)\n                      (map (lambda (d) (* pw d)) rest))\n                    powers))))\n  (define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))\n  (and (equal? (divisors 1) '(1)) (equal? (divisors 12) '(1 2 3 4 6 12)) (= (length (divisors 360)) 24) (= (car (reverse (divisors 28))) 28)))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "divisors"], "split": "train"}
{"id": "primality_translation_012", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `divisors`\n\n```scheme\n(define (divisors0 n)\n  (if (< n 1)\n      '()\n      (let ((pf (prime-factorization n)))\n        (sort-by < (generate-divisors pf)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (divisors 1) '(1))\n(equal? (divisors 12) '(1 2 3 4 6 12))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (prime-powers p e)\n  (let loop ([i 0] [pw 1] [result '()])\n    (if (> i e)\n        (reverse result)\n        (loop (+ i 1) (* pw p) (cons pw result)))))\n  (define (generate-divisors pf)\n  (if (null? pf)\n      '(1)\n      (let* ([p (caar pf)]\n             [e (cdar pf)]\n             [rest (generate-divisors (cdr pf))]\n             [powers (prime-powers p e)])\n        (append-map (lambda (pw)\n                      (map (lambda (d) (* pw d)) rest))\n                    powers))))\n  (define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))\n  (and (equal? (divisors 1) '(1)) (equal? (divisors 12) '(1 2 3 4 6 12)) (= (length (divisors 360)) 24) (= (car (reverse (divisors 28))) 28)))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "divisors"], "split": "train"}
{"id": "primality_translation_013", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `euler-totient`\n\n```python\ndef euler_totient(n):\n    if n < 1:\n        return 0\n    out = 1\n    for p, e in prime_factorization(n):\n        out *= (p - 1) * (p ** (e - 1))\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (euler-totient 1) 1)\n(= (euler-totient 2) 1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))\n  (and (= (euler-totient 1) 1) (= (euler-totient 2) 1) (= (euler-totient 10) 4) (= (euler-totient 36) 12) (= (euler-totient 13) 12)))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "euler-totient"], "split": "train"}
{"id": "primality_translation_014", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `euler-totient`\n\n```scheme\n(define (phi n)\n  (if (< n 1)\n      0\n      (fold-left (lambda (acc pe)\n                   (let ((p (car pe)) (e (cdr pe)))\n                     (* acc (- p 1) (expt p (- e 1)))))\n                 1\n                 (prime-factorization n))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (euler-totient 1) 1)\n(= (euler-totient 2) 1)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))\n  (and (= (euler-totient 1) 1) (= (euler-totient 2) 1) (= (euler-totient 10) 4) (= (euler-totient 36) 12) (= (euler-totient 13) 12)))", "tags": ["tier0", "number-theory", "primality", "translation", "chez", "euler-totient"], "split": "train"}
{"id": "primality_translation_015", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `jacobi-symbol`\n\n```python\ndef jacobi_symbol(a, n):\n    if n <= 0 or n % 2 == 0:\n        return 0\n    if n == 1:\n        return 1\n    if a == 0:\n        return 0\n    if a == 1:\n        return 1\n    a %= n\n    if a == 0:\n        return 0\n    if a == 1:\n        return 1\n    a_odd, e = factor_out_2s(a)\n    if e % 2 == 0:\n        two = 1\n    else:\n        two = 1 if n % 8 in (1, 7) else -1\n    if a_odd == 1:\n        return two\n    flip = -1 if (a_odd % 4 == 3 and n % 4 == 3) else 1\n    return two * flip * jacobi_symbol(n % a_odd, a_odd)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n  (and (= (jacobi-symbol 2 15) 1) (= (jacobi-symbol 11 15) -1) (= (jacobi-symbol 14 15) -1) (= (jacobi-symbol 3 10) 0) (= (jacobi-symbol (+ 14 15) 15) (jacobi-symbol 14 15))))", "tags": ["tier0", "number-theory", "primality", "translation", "python", "jacobi-symbol"], "split": "train"}
{"id": "primality_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prime?` in `lattice/number-theory/primality.ss`.\nKnown issue: If no divisor is found up to sqrt(n), the number is prime (#t), not composite.\n\n```scheme\n(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #f]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (and (not (prime? 0)) (not (prime? 1)) (prime? 2) (prime? 3) (not (prime? 4)) (prime? 97) (not (prime? 1001))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "prime?"], "split": "train"}
{"id": "primality_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `miller-rabin?` in `lattice/number-theory/primality.ss`.\nKnown issue: Even numbers greater than 2 are composite and must return #f.\n\n```scheme\n(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #t]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (miller-rabin-witness? a n)\n  (let* ([n-1 (- n 1)]\n         [factor-result (factor-out-2s n-1)]\n         [d (car factor-result)]\n         [r (cdr factor-result)]\n         [x (mod-expt a d n)])\n    (cond\n     [(or (= x 1) (= x n-1)) #f]\n     [else\n      (let loop ([x x] [i 0])\n        (cond\n         [(>= i (- r 1)) #t]\n         [else\n          (let ([x-new (mod-expt x 2 n)])\n            (cond\n             [(= x-new 1) #t]\n             [(= x-new n-1) #f]\n             [else (loop x-new (+ i 1))]))]))])))\n  (define (deterministic-witnesses n k)\n  (let ([small-primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)])\n    (take (min k (length small-primes)) small-primes)))\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n  (and (miller-rabin? 104729) (miller-rabin? 1299709 5) (not (miller-rabin? 561)) (not (miller-rabin? 1105)) (equal? (miller-rabin? 997) (prime? 997)) (equal? (miller-rabin? 1000) (prime? 1000))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "miller-rabin?"], "split": "train"}
{"id": "primality_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `miller-rabin?` in `lattice/number-theory/primality.ss`.\nKnown issue: Witness check returns compositeness evidence; primality result must negate it.\n\n```scheme\n(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (miller-rabin-witness? 2 n)]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (miller-rabin-witness? a n)\n  (let* ([n-1 (- n 1)]\n         [factor-result (factor-out-2s n-1)]\n         [d (car factor-result)]\n         [r (cdr factor-result)]\n         [x (mod-expt a d n)])\n    (cond\n     [(or (= x 1) (= x n-1)) #f]\n     [else\n      (let loop ([x x] [i 0])\n        (cond\n         [(>= i (- r 1)) #t]\n         [else\n          (let ([x-new (mod-expt x 2 n)])\n            (cond\n             [(= x-new 1) #t]\n             [(= x-new n-1) #f]\n             [else (loop x-new (+ i 1))]))]))])))\n  (define (deterministic-witnesses n k)\n  (let ([small-primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97)])\n    (take (min k (length small-primes)) small-primes)))\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (miller-rabin? n . args)\n  (let ([rounds (if (null? args) 20 (car args))])\n    (cond\n     [(< n 2) #f]\n     [(= n 2) #t]\n     [(even? n) #f]\n     [(= n 3) #t]\n     [(< n 2047)\n      (not (miller-rabin-witness? 2 n))]\n     [(< n 1373653)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)))]\n     [(< n 9080191)\n      (not (or (miller-rabin-witness? 31 n)\n               (miller-rabin-witness? 73 n)))]\n     [(< n 25326001)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)))]\n     [(< n 3215031751)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 3 n)\n               (miller-rabin-witness? 5 n)\n               (miller-rabin-witness? 7 n)))]\n     [(< n 4759123141)\n      (not (or (miller-rabin-witness? 2 n)\n               (miller-rabin-witness? 7 n)\n               (miller-rabin-witness? 61 n)))]\n     [(< n 3317044064679887385961981)\n      (let ([witnesses '(2 3 5 7 11 13 17 19 23 29 31 37)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))]\n     [else\n      (let ([witnesses (deterministic-witnesses n rounds)])\n        (not (exists (lambda (a) (miller-rabin-witness? a n)) witnesses)))])))\n  (and (miller-rabin? 104729) (miller-rabin? 1299709 5) (not (miller-rabin? 561)) (not (miller-rabin? 1105)) (equal? (miller-rabin? 997) (prime? 997)) (equal? (miller-rabin? 1000) (prime? 1000))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "miller-rabin?"], "split": "train"}
{"id": "primality_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `trial-division` in `lattice/number-theory/primality.ss`.\nKnown issue: When a factor divides n, keep dividing by the same d to preserve multiplicity.\n\n```scheme\n(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) (if (= d 2) 3 (+ d 2)) (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (trial-division 1) '())\n(equal? (trial-division 12) '(2 2 3))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))", "verify_expr": "(let ()\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (and (equal? (trial-division 1) '()) (equal? (trial-division 12) '(2 2 3)) (equal? (trial-division 1001) '(7 11 13)) (= (apply * (trial-division 360)) 360)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "trial-division"], "split": "train"}
{"id": "primality_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `trial-division` in `lattice/number-theory/primality.ss`.\nKnown issue: When d^2 > n and n>1, the remaining n is a prime factor and must be included.\n\n```scheme\n(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse factors)]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))", "verify_expr": "(let ()\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (and (equal? (trial-division 1) '()) (equal? (trial-division 12) '(2 2 3)) (equal? (trial-division 1001) '(7 11 13)) (= (apply * (trial-division 360)) 360)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "trial-division"], "split": "train"}
{"id": "primality_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `factorize` in `lattice/number-theory/primality.ss`.\nKnown issue: Prime input should return a singleton factor list, not empty.\n\n```scheme\n(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) '()]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (factorize 1) '())\n(equal? (factorize 100) '(2 2 5 5))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (and (equal? (factorize 1) '()) (equal? (factorize 100) '(2 2 5 5)) (equal? (factorize 997) '(997)) (= (apply * (factorize 12345)) 12345)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "factorize"], "split": "train"}
{"id": "primality_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `factorize` in `lattice/number-theory/primality.ss`.\nKnown issue: If a composite remainder survives small extraction, it must be fully factored, not appended as one factor.\n\n```scheme\n(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (list remaining)))))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (factorize 1) '())\n(equal? (factorize 100) '(2 2 5 5))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (and (equal? (factorize 1) '()) (equal? (factorize 100) '(2 2 5 5)) (equal? (factorize 997) '(997)) (= (apply * (factorize 12345)) 12345)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "factorize"], "split": "train"}
{"id": "primality_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prime-factorization` in `lattice/number-theory/primality.ss`.\nKnown issue: The final accumulated (prime . exponent) pair must be emitted when traversal ends.\n\n```scheme\n(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)] [current (car factors)] [count 1] [result '()])\n          (cond\n           [(null? fs) (reverse result)]\n           [(= (car fs) current) (loop (cdr fs) current (+ count 1) result)]\n           [else (loop (cdr fs) (car fs) 1 (cons (cons current count) result))])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (and (equal? (prime-factorization 1) '()) (equal? (prime-factorization 12) '((2 . 2) (3 . 1))) (equal? (prime-factorization 360) '((2 . 3) (3 . 2) (5 . 1)))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "prime-factorization"], "split": "train"}
{"id": "primality_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `divisors` in `lattice/number-theory/primality.ss`.\nKnown issue: Divisors output is expected in sorted ascending order.\n\n```scheme\n(define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (generate-divisors pf))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (divisors 1) '(1))\n(equal? (divisors 12) '(1 2 3 4 6 12))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (prime-powers p e)\n  (let loop ([i 0] [pw 1] [result '()])\n    (if (> i e)\n        (reverse result)\n        (loop (+ i 1) (* pw p) (cons pw result)))))\n  (define (generate-divisors pf)\n  (if (null? pf)\n      '(1)\n      (let* ([p (caar pf)]\n             [e (cdar pf)]\n             [rest (generate-divisors (cdr pf))]\n             [powers (prime-powers p e)])\n        (append-map (lambda (pw)\n                      (map (lambda (d) (* pw d)) rest))\n                    powers))))\n  (define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))\n  (and (equal? (divisors 1) '(1)) (equal? (divisors 12) '(1 2 3 4 6 12)) (= (length (divisors 360)) 24) (= (car (reverse (divisors 28))) 28)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "divisors"], "split": "train"}
{"id": "primality_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `divisors` in `lattice/number-theory/primality.ss`.\nKnown issue: Divisors are integers, not exponent pairs.\n\n```scheme\n(define (divisors n)\n  (if (< n 1)\n      '()\n      (prime-factorization n)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (divisors 1) '(1))\n(equal? (divisors 12) '(1 2 3 4 6 12))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (prime-powers p e)\n  (let loop ([i 0] [pw 1] [result '()])\n    (if (> i e)\n        (reverse result)\n        (loop (+ i 1) (* pw p) (cons pw result)))))\n  (define (generate-divisors pf)\n  (if (null? pf)\n      '(1)\n      (let* ([p (caar pf)]\n             [e (cdar pf)]\n             [rest (generate-divisors (cdr pf))]\n             [powers (prime-powers p e)])\n        (append-map (lambda (pw)\n                      (map (lambda (d) (* pw d)) rest))\n                    powers))))\n  (define (divisors n)\n  (if (< n 1)\n      '()\n      (let* ([pf (prime-factorization n)])\n        (sort-by < (generate-divisors pf)))))\n  (and (equal? (divisors 1) '(1)) (equal? (divisors 12) '(1 2 3 4 6 12)) (= (length (divisors 360)) 24) (= (car (reverse (divisors 28))) 28)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "divisors"], "split": "train"}
{"id": "primality_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `euler-totient` in `lattice/number-theory/primality.ss`.\nKnown issue: Each prime-power contribution is (p-1)*p^(e-1), not p*p^(e-1).\n\n```scheme\n(define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc p (expt p (- e 1)))))\n         1\n         pf))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(= (euler-totient 1) 1)\n(= (euler-totient 2) 1)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))\n  (and (= (euler-totient 1) 1) (= (euler-totient 2) 1) (= (euler-totient 10) 4) (= (euler-totient 36) 12) (= (euler-totient 13) 12)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "euler-totient"], "split": "train"}
{"id": "primality_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `euler-totient` in `lattice/number-theory/primality.ss`.\nKnown issue: By contract, phi(n) is 0 for n < 1.\n\n```scheme\n(define (euler-totient n)\n  (if (< n 1)\n      1\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(= (euler-totient 1) 1)\n(= (euler-totient 2) 1)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))", "verify_expr": "(let ()\n  (define (isqrt n)\n  (cond\n   [(< n 0) 0]\n   [(= n 0) 0]\n   [(= n 1) 1]\n   [else\n    (let loop ([x n])\n      (let ([x1 (quotient (+ x (quotient n x)) 2)])\n        (if (>= x1 x)\n            x\n            (loop x1))))]))\n  (define (prime? n)\n  (cond\n   [(< n 2) #f]\n   [(= n 2) #t]\n   [(even? n) #f]\n   [(= n 3) #t]\n   [else\n    (let ([limit (isqrt n)])\n      (let loop ([d 3])\n        (cond\n         [(> d limit) #t]\n         [(zero? (modulo n d)) #f]\n         [else (loop (+ d 2))])))]))\n  (define (extract-small-factors n limit)\n  (let loop ([n n] [d 2] [factors '()])\n    (cond\n     [(or (= n 1) (> d limit)) (cons n factors)]\n     [(zero? (modulo n d))\n      (loop (quotient n d) d (cons d factors))]\n     [else\n      (loop n (if (= d 2) 3 (+ d 2)) factors)])))\n  (define (pollard-rho-backtrack n c xs-history ys-history)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))])\n    (let loop ([xs xs-history] [ys ys-history] [x (if (null? xs-history) 2 (car xs-history))]\n               [y (if (null? ys-history) 2 (car ys-history))])\n      (if (null? xs)\n          n\n          (let* ([x-new (f x)]\n                 [y-new (f (f y))]\n                 [d (gcd (abs (- x-new y-new)) n)])\n            (cond\n             [(= d 1)\n              (loop (cdr xs) (cdr ys) x-new y-new)]\n             [(and (> d 1) (< d n)) d]\n             [else n]))))))\n  (define (pollard-rho-single n c)\n  (let ([f (lambda (x) (modulo (+ (* x x) c) n))]\n        [batch-size 128])\n    (let outer-loop ([x 2] [y 2] [iter 0])\n      (if (> iter 1000000)\n          n\n          (let inner-loop ([x x] [y y] [prod 1] [batch-count 0]\n                           [xs-history '()] [ys-history '()])\n            (if (= batch-count batch-size)\n                (let ([d (gcd prod n)])\n                  (cond\n                   [(= d 1)\n                    (outer-loop x y (+ iter batch-size))]\n                   [(and (> d 1) (< d n)) d]\n                   [else\n                    (pollard-rho-backtrack n c (reverse xs-history) (reverse ys-history))]))\n                (let* ([x-new (f x)]\n                       [y-new (f (f y))]\n                       [diff (abs (- x-new y-new))]\n                       [prod-new (modulo (* prod diff) n)])\n                  (inner-loop x-new y-new prod-new (+ batch-count 1)\n                              (cons x xs-history) (cons y ys-history)))))))))\n  (define (pollard-rho n)\n  (cond\n   [(even? n) 2]\n   [else\n    (let try-c ([c 1])\n      (if (> c 20)\n          n\n          (let ([result (pollard-rho-single n c)])\n            (if (and (> result 1) (< result n))\n                result\n                (try-c (+ c 1))))))]))\n  (define (trial-division n)\n  (cond\n   [(< n 2) '()]\n   [else\n    (let loop ([n n] [d 2] [factors '()])\n      (cond\n       [(= n 1) (reverse factors)]\n       [(> (* d d) n) (reverse (cons n factors))]\n       [(zero? (modulo n d))\n        (loop (quotient n d) d (cons d factors))]\n       [else\n        (loop n (if (= d 2) 3 (+ d 2)) factors)]))]))\n  (define (pollard-rho-factorize n)\n  (cond\n   [(= n 1) '()]\n   [(prime? n) (list n)]\n   [else\n    (let ([d (pollard-rho n)])\n      (if (= d n)\n          (trial-division n)\n          (append (pollard-rho-factorize d)\n                  (pollard-rho-factorize (quotient n d)))))]))\n  (define (factorize n)\n  (cond\n   [(< n 2) '()]\n   [(prime? n) (list n)]\n   [else\n    (let* ([small-factor-result (extract-small-factors n 1000)]\n           [remaining (car small-factor-result)]\n           [small-factors (cdr small-factor-result)])\n      (if (= remaining 1)\n          (sort-by < small-factors)\n          (sort-by < (append small-factors (pollard-rho-factorize remaining)))))]))\n  (define (prime-factorization n)\n  (let ([factors (factorize n)])\n    (if (null? factors)\n        '()\n        (let loop ([fs (cdr factors)]\n                   [current (car factors)]\n                   [count 1]\n                   [result '()])\n          (cond\n           [(null? fs)\n            (reverse (cons (cons current count) result))]\n           [(= (car fs) current)\n            (loop (cdr fs) current (+ count 1) result)]\n           [else\n            (loop (cdr fs)\n                  (car fs)\n                  1\n                  (cons (cons current count) result))])))))\n  (define (euler-totient n)\n  (if (< n 1)\n      0\n      (let ([pf (prime-factorization n)])\n        (fold-left\n         (lambda (acc pe)\n           (let ([p (car pe)]\n                 [e (cdr pe)])\n             (* acc (- p 1) (expt p (- e 1)))))\n         1\n         pf))))\n  (and (= (euler-totient 1) 1) (= (euler-totient 2) 1) (= (euler-totient 10) 4) (= (euler-totient 36) 12) (= (euler-totient 13) 12)))", "tags": ["tier0", "number-theory", "primality", "bugfix", "euler-totient"], "split": "train"}
{"id": "primality_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `jacobi-symbol` in `lattice/number-theory/primality.ss`.\nKnown issue: Jacobi symbol is only defined for odd positive n here; invalid inputs should return 0.\n\n```scheme\n(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 1]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))", "verify_expr": "(let ()\n  (define (factor-out-2s n)\n  (let loop ([d n] [r 0])\n    (if (even? d)\n        (loop (quotient d 2) (+ r 1))\n        (cons d r))))\n  (define (jacobi-symbol a n)\n  (cond\n   [(not (and (odd? n) (> n 0))) 0]\n   [(= n 1) 1]\n   [(= a 0) 0]\n   [(= a 1) 1]\n   [else\n    (let ([a (modulo a n)])\n      (cond\n       [(= a 0) 0]\n       [(= a 1) 1]\n       [else\n        (let* ([twos-result (factor-out-2s a)]\n               [a-odd (car twos-result)]\n               [e (cdr twos-result)]\n               [two-contrib\n                (if (even? e)\n                    1\n                    (let ([n-mod-8 (modulo n 8)])\n                      (if (or (= n-mod-8 1) (= n-mod-8 7))\n                          1\n                          -1)))])\n          (if (= a-odd 1)\n              two-contrib\n              (let* ([flip-sign\n                      (if (and (= (modulo a-odd 4) 3)\n                               (= (modulo n 4) 3))\n                          -1\n                          1)]\n                     [recur (jacobi-symbol (modulo n a-odd) a-odd)])\n                (* two-contrib flip-sign recur))))]))]))\n  (and (= (jacobi-symbol 2 15) 1) (= (jacobi-symbol 11 15) -1) (= (jacobi-symbol 14 15) -1) (= (jacobi-symbol 3 10) 0) (= (jacobi-symbol (+ 14 15) 15) (jacobi-symbol 14 15))))", "tags": ["tier0", "number-theory", "primality", "bugfix", "jacobi-symbol"], "split": "train"}
{"id": "primality_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck primality at edge value n=1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (prime? 1) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(prime? 1)", "verify_expr": "(equal? (prime? 1) #f)", "tags": ["tier0", "number-theory", "primality", "composition", "prime?", "edge-case"], "split": "train"}
{"id": "primality_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck primality of next-prime after 100.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (prime? (next-prime 100)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(prime? (next-prime 100))", "verify_expr": "(equal? (prime? (next-prime 100)) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "prime?", "integration"], "split": "train"}
{"id": "primality_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime?", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff product 17*19 is not prime.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (not (prime? (* 17 19))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(not (prime? (* 17 19)))", "verify_expr": "(equal? (not (prime? (* 17 19))) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "prime?", "property"], "split": "train"}
{"id": "primality_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: small integration task across module primitives.\n\nRun Miller-Rabin on known prime 104729.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (miller-rabin? 104729) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(miller-rabin? 104729)", "verify_expr": "(equal? (miller-rabin? 104729) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "miller-rabin?", "direct"], "split": "train"}
{"id": "primality_composition_006", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun Miller-Rabin on Carmichael number 561.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (miller-rabin? 561) #f)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(miller-rabin? 561)", "verify_expr": "(equal? (miller-rabin? 561) #f)", "tags": ["tier0", "number-theory", "primality", "composition", "miller-rabin?", "edge-case"], "split": "train"}
{"id": "primality_composition_007", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that Miller-Rabin agrees with prime? on 997.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(list (miller-rabin? 997) (prime? 997))", "verify_expr": "(equal? (list (miller-rabin? 997) (prime? 997)) '(#t #t))", "tags": ["tier0", "number-theory", "primality", "composition", "miller-rabin?", "integration"], "split": "train"}
{"id": "primality_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "miller-rabin?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun Miller-Rabin with explicit round count on 1299709.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (miller-rabin? 1299709 5) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(miller-rabin? 1299709 5)", "verify_expr": "(equal? (miller-rabin? 1299709 5) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "miller-rabin?", "direct"], "split": "train"}
{"id": "primality_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: compose existing APIs into one expression.\n\nFactor edge case n=1 with trial division.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (trial-division 1) '())\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(trial-division 1)", "verify_expr": "(equal? (trial-division 1) '())", "tags": ["tier0", "number-theory", "primality", "composition", "trial-division", "edge-case"], "split": "train"}
{"id": "primality_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify product of trial-division factors equals original n for 12345.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (= (apply * (trial-division 12345)) 12345) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (apply * (trial-division 12345)) 12345)", "verify_expr": "(equal? (= (apply * (trial-division 12345)) 12345) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "trial-division", "property"], "split": "train"}
{"id": "primality_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "trial-division", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompare trial-division and factorize on 360.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (list (trial-division 360) (factorize 360)) '((2 2 2 3 3 5) (2 2 2 3 3 5)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (trial-division 360) (factorize 360))", "verify_expr": "(equal? (list (trial-division 360) (factorize 360)) '((2 2 2 3 3 5) (2 2 2 3 3 5)))", "tags": ["tier0", "number-theory", "primality", "composition", "trial-division", "integration"], "split": "train"}
{"id": "primality_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: compose existing APIs into one expression.\n\nFactor 1001 using factorize.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(factorize 1001)", "verify_expr": "(equal? (factorize 1001) '(7 11 13))", "tags": ["tier0", "number-theory", "primality", "composition", "factorize", "direct"], "split": "train"}
{"id": "primality_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFactor a prime input 997.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (factorize 997) '(997))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(factorize 997)", "verify_expr": "(equal? (factorize 997) '(997))", "tags": ["tier0", "number-theory", "primality", "composition", "factorize", "edge-case"], "split": "train"}
{"id": "primality_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: small integration task across module primitives.\n\nVerify factorize factors multiply back to 1000.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (apply * (factorize 1000)) 1000)", "verify_expr": "(equal? (= (apply * (factorize 1000)) 1000) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "factorize", "property"], "split": "train"}
{"id": "primality_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "factorize", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck factorize agrees with trial-division on 360.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (factorize 360) (trial-division 360))", "verify_expr": "(equal? (list (factorize 360) (trial-division 360)) '((2 2 2 3 3 5) (2 2 2 3 3 5)))", "tags": ["tier0", "number-theory", "primality", "composition", "factorize", "integration"], "split": "train"}
{"id": "primality_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: small integration task across module primitives.\n\nCompute exponent-form factorization of 1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (prime-factorization 1) '())\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(prime-factorization 1)", "verify_expr": "(equal? (prime-factorization 1) '())", "tags": ["tier0", "number-theory", "primality", "composition", "prime-factorization", "edge-case"], "split": "train"}
{"id": "primality_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReconstruct 1000 from prime-factorization output.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (fold-left * 1 (append-map (lambda (pe) (make-list (cdr pe) (car pe))) (prime-factorization 1000))) 1000)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(fold-left * 1 (append-map (lambda (pe) (make-list (cdr pe) (car pe))) (prime-factorization 1000)))", "verify_expr": "(equal? (fold-left * 1 (append-map (lambda (pe) (make-list (cdr pe) (car pe))) (prime-factorization 1000))) 1000)", "tags": ["tier0", "number-theory", "primality", "composition", "prime-factorization", "property"], "split": "train"}
{"id": "primality_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "prime-factorization", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse prime-factorization terms to rederive phi(36).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([pf (prime-factorization 36)]) (fold-left * 1 (map (lambda (pe) (* (- (car pe) 1) (expt (car pe) (- (cdr pe) 1)))) pf))) (euler-totient 36))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([pf (prime-factorization 36)]) (fold-left * 1 (map (lambda (pe) (* (- (car pe) 1) (expt (car pe) (- (cdr pe) 1)))) pf)))", "verify_expr": "(equal? (let ([pf (prime-factorization 36)]) (fold-left * 1 (map (lambda (pe) (* (- (car pe) 1) (expt (car pe) (- (cdr pe) 1)))) pf))) (euler-totient 36))", "tags": ["tier0", "number-theory", "primality", "composition", "prime-factorization", "integration"], "split": "train"}
{"id": "primality_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: small integration task across module primitives.\n\nList all positive divisors of 12.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (divisors 12) '(1 2 3 4 6 12))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(divisors 12)", "verify_expr": "(equal? (divisors 12) '(1 2 3 4 6 12))", "tags": ["tier0", "number-theory", "primality", "composition", "divisors", "direct"], "split": "train"}
{"id": "primality_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: small integration task across module primitives.\n\nList all positive divisors of 1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (divisors 1) '(1))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(divisors 1)", "verify_expr": "(equal? (divisors 1) '(1))", "tags": ["tier0", "number-theory", "primality", "composition", "divisors", "edge-case"], "split": "train"}
{"id": "primality_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "divisors", "prompt": "Task mode: small integration task across module primitives.\n\nReturn number of divisors of 360.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (length (divisors 360)) 24)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(length (divisors 360))", "verify_expr": "(equal? (length (divisors 360)) 24)", "tags": ["tier0", "number-theory", "primality", "composition", "divisors", "property"], "split": "train"}
{"id": "primality_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute Euler totient phi(36).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (euler-totient 36) 12)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(euler-totient 36)", "verify_expr": "(equal? (euler-totient 36) 12)", "tags": ["tier0", "number-theory", "primality", "composition", "euler-totient", "direct"], "split": "train"}
{"id": "primality_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute Euler totient phi(1).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (euler-totient 1) 1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(euler-totient 1)", "verify_expr": "(equal? (euler-totient 1) 1)", "tags": ["tier0", "number-theory", "primality", "composition", "euler-totient", "edge-case"], "split": "train"}
{"id": "primality_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse prime rule phi(p)=p-1 for p=13.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (euler-totient 13) 12)", "verify_expr": "(equal? (= (euler-totient 13) 12) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "euler-totient", "property"], "split": "train"}
{"id": "primality_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "euler-totient", "prompt": "Task mode: small integration task across module primitives.\n\nCross-check phi(10) with brute-force coprime count.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (euler-totient 10) (length (filter (lambda (k) (= (gcd k 10) 1)) (range 1 11))))", "verify_expr": "(equal? (= (euler-totient 10) (length (filter (lambda (k) (= (gcd k 10) 1)) (range 1 11)))) #t)", "tags": ["tier0", "number-theory", "primality", "composition", "euler-totient", "integration"], "split": "train"}
{"id": "primality_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute Jacobi symbol (2/15).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (jacobi-symbol 2 15) 1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(jacobi-symbol 2 15)", "verify_expr": "(equal? (jacobi-symbol 2 15) 1)", "tags": ["tier0", "number-theory", "primality", "composition", "jacobi-symbol", "direct"], "split": "train"}
{"id": "primality_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute Jacobi symbol (11/15).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (jacobi-symbol 11 15) -1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(jacobi-symbol 11 15)", "verify_expr": "(equal? (jacobi-symbol 11 15) -1)", "tags": ["tier0", "number-theory", "primality", "composition", "jacobi-symbol", "direct"], "split": "train"}
{"id": "primality_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/primality.ss", "source_test": "lattice/number-theory/test-primality.ss", "source_function": "jacobi-symbol", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn 0 for invalid even modulus in Jacobi symbol.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (jacobi-symbol 3 10) 0)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(jacobi-symbol 3 10)", "verify_expr": "(equal? (jacobi-symbol 3 10) 0)", "tags": ["tier0", "number-theory", "primality", "composition", "jacobi-symbol", "edge-case"], "split": "train"}
