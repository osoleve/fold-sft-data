{"id": "queue_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-enqueue`\nSpec: Add an element at queue back while preserving queue invariants.\n\nWrite exactly one Scheme function definition for `queue-enqueue`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))\n  (and (equal? (queue-enqueue 'x (cons '() '())) '((x))) (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z))))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue-enqueue"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-enqueue`\nSpec: Add an element at queue back while preserving queue invariants.\n\nWrite exactly one Scheme function definition for `queue-enqueue`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "queue_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-size`\nSpec: Return the number of elements in queue.\n\nWrite exactly one Scheme function definition for `queue-size`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))\n  (and (= (queue-size (cons '() '())) 0) (= (queue-size (cons '(a b) '(d c))) 4)))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue-size"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-size`\nSpec: Return the number of elements in queue.\n\nWrite exactly one Scheme function definition for `queue-size`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "queue_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue->list`\nSpec: Convert queue to front-to-back list order.\n\nWrite exactly one Scheme function definition for `queue->list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))", "verify_expr": "(let ()\n  (define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))\n  (and (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)) (equal? (queue->list (cons '() '())) '())))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue->list"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue->list`\nSpec: Convert queue to front-to-back list order.\n\nWrite exactly one Scheme function definition for `queue->list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "queue_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-queue`.\nReturn only the Scheme definition.\n\n```python\ndef make_queue(front, back):\n    if len(front) == 0:\n        return list(reversed(back)), []\n    return front, back\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "make-queue"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-queue`.\nReturn only the Scheme definition.\n\n```python\ndef make_queue(front, back):\n    if len(front) == 0:\n        return list(reversed(back)), []\n    return front, back\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "queue_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue-peek`.\nReturn only the Scheme definition.\n\n```python\ndef queue_peek(queue):\n    front, back = queue\n    if len(front) == 0:\n        raise ValueError('empty queue')\n    return front[0]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "queue-peek"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue-peek`.\nReturn only the Scheme definition.\n\n```python\ndef queue_peek(queue):\n    front, back = queue\n    if len(front) == 0:\n        raise ValueError('empty queue')\n    return front[0]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "queue_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `list->queue`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (from-list xs)\n  (cons xs '()))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "chez-to-fold", "list->queue"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `list->queue`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (from-list xs)\n  (cons xs '()))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "queue_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-queue` in `lattice/data/queue.ss`.\nKnown issue: When front is empty, back must be reversed into front.\n\n```scheme\n(define (make-queue front back)\n  (cons front back))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: When front is empty, back must be reversed into front.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n(let () (equal? (make-queue '() '(x y z)) '((z y x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "bugfix", "make-queue"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-queue` in `lattice/data/queue.ss`.\nKnown issue: When front is empty, back must be reversed into front.\n\n```scheme\n(define (make-queue front back)\n  (cons front back))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: When front is empty, back must be reversed into front.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n(let () (equal? (make-queue '() '(x y z)) '((z y x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "queue_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-peek` in `lattice/data/queue.ss`.\nKnown issue: Peeking empty queue must raise an error.\n\n```scheme\n(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        #f\n        (car front))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Peeking empty queue must raise an error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n(let () (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-peek"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-peek` in `lattice/data/queue.ss`.\nKnown issue: Peeking empty queue must raise an error.\n\n```scheme\n(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        #f\n        (car front))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Peeking empty queue must raise an error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n(let () (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "queue_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->queue` in `lattice/data/queue.ss`.\nKnown issue: Queue representation is (front . back), with list in front and empty back.\n\n```scheme\n(define (list->queue lst)\n  (cons '() lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "bugfix", "list->queue"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->queue` in `lattice/data/queue.ss`.\nKnown issue: Queue representation is (front . back), with list in front and empty back.\n\n```scheme\n(define (list->queue lst)\n  (cons '() lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault."}
{"id": "queue_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether `queue-empty` is empty.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(queue-empty? queue-empty)", "verify_expr": "(equal? (queue-empty? queue-empty) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-empty?", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether `queue-empty` is empty.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "queue_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: compose existing APIs into one expression.\n\nDequeue from queue `(cons '(a) '(c b))` and return `(list popped rest-list)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (list x (queue->list q))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (list x (queue->list q)))) '(a (b c)))", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "direct"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nDequeue from queue `(cons '(a) '(c b))` and return `(list popped rest-list)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "queue_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff first list element stays at queue front after conversion.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (queue-peek (list->queue '(h i j))) 'h)", "verify_expr": "(equal? (queue-peek (list->queue '(h i j))) 'h)", "tags": ["tier0", "data", "queue", "composition", "list->queue", "property"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff first list element stays at queue front after conversion.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "queue_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConsume `(list->queue '(x y z))` with repeated dequeue and collect popped elements.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([q (list->queue '(x y z))] [acc '()]) (if (queue-empty? q) (reverse acc) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (cons x acc))))))", "verify_expr": "(equal? (let loop ([q (list->queue '(x y z))] [acc '()]) (if (queue-empty? q) (reverse acc) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (cons x acc)))))) '(x y z))", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "loop"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nConsume `(list->queue '(x y z))` with repeated dequeue and collect popped elements.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "queue_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff dequeuing all elements from `(list->queue '(1 2 3 4))` yields them in insertion order.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([q (list->queue '(1 2 3 4))] [expected '(1 2 3 4)]) (if (null? expected) (queue-empty? q) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (and (= x (car expected)) (loop q2 (cdr expected)))))))", "verify_expr": "(equal? (let loop ([q (list->queue '(1 2 3 4))] [expected '(1 2 3 4)]) (if (null? expected) (queue-empty? q) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (and (= x (car expected)) (loop q2 (cdr expected))))))) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "integration"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn #t iff dequeuing all elements from `(list->queue '(1 2 3 4))` yields them in insertion order.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
