{"id": "queue_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `make-queue`\nSpec: Internal constructor: if front is empty, reverse back into front and clear back.\n\nWrite exactly one Scheme function definition for `make-queue`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n(let () (equal? (make-queue '() '(x y z)) '((z y x))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "spec-to-code", "make-queue"], "split": "train"}
{"id": "queue_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-queue front back)\n  ;; TODO: maintain two-list queue invariant\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-queue`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n(let () (equal? (make-queue '() '(x y z)) '((z y x))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "skeleton-completion", "make-queue"], "split": "train"}
{"id": "queue_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-empty?`\nSpec: Return #t iff both internal lists (front/back) are empty.\n\nWrite exactly one Scheme function definition for `queue-empty?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (queue-empty? (cons '() '())))\n(let () (not (queue-empty? (cons '(a) '()))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))\n  (and (queue-empty? (cons '() '())) (not (queue-empty? (cons '(a) '()))) (not (queue-empty? (cons '() '(a))))))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue-empty?"], "split": "train"}
{"id": "queue_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (queue-empty? queue)\n  ;; TODO: return whether both internal lists are empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `queue-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (queue-empty? (cons '() '())))\n(let () (not (queue-empty? (cons '(a) '()))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))\n  (and (queue-empty? (cons '() '())) (not (queue-empty? (cons '(a) '()))) (not (queue-empty? (cons '() '(a))))))", "tags": ["tier0", "data", "queue", "skeleton-completion", "queue-empty?"], "split": "train"}
{"id": "queue_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-enqueue`\nSpec: Add an element at queue back while preserving queue invariants.\n\nWrite exactly one Scheme function definition for `queue-enqueue`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))\n  (and (equal? (queue-enqueue 'x (cons '() '())) '((x))) (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z))))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue-enqueue"], "split": "eval"}
{"id": "queue_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (queue-enqueue elem queue)\n  ;; TODO: enqueue element and preserve invariant\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `queue-enqueue`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (queue-enqueue 'x (cons '() '())) '((x))))\n(let () (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))\n  (and (equal? (queue-enqueue 'x (cons '() '())) '((x))) (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z))))", "tags": ["tier0", "data", "queue", "skeleton-completion", "queue-enqueue"], "split": "train"}
{"id": "queue_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-dequeue`\nSpec: Remove front element and return two values: (new-queue, dequeued-elem). Raise error on empty queue.\n\nWrite exactly one Scheme function definition for `queue-dequeue`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))))\n(let () (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))\n  (and (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (guard (ex [else #t]) (begin (queue-dequeue (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue-dequeue"], "split": "train"}
{"id": "queue_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (queue-dequeue queue)\n  ;; TODO: dequeue front, return (values new-queue elem), error if empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `queue-dequeue`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))))\n(let () (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))\n  (and (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (guard (ex [else #t]) (begin (queue-dequeue (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "skeleton-completion", "queue-dequeue"], "split": "train"}
{"id": "queue_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-peek`\nSpec: Return front element without removing it. Raise error on empty queue.\n\nWrite exactly one Scheme function definition for `queue-peek`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n(let () (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue-peek"], "split": "train"}
{"id": "queue_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (queue-peek queue)\n  ;; TODO: return front element, error if empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `queue-peek`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n(let () (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "skeleton-completion", "queue-peek"], "split": "train"}
{"id": "queue_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue-size`\nSpec: Return the number of elements in queue.\n\nWrite exactly one Scheme function definition for `queue-size`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))\n  (and (= (queue-size (cons '() '())) 0) (= (queue-size (cons '(a b) '(d c))) 4)))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue-size"], "split": "eval"}
{"id": "queue_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (queue-size queue)\n  ;; TODO: compute element count\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `queue-size`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))\n  (and (= (queue-size (cons '() '())) 0) (= (queue-size (cons '(a b) '(d c))) 4)))", "tags": ["tier0", "data", "queue", "skeleton-completion", "queue-size"], "split": "train"}
{"id": "queue_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `queue->list`\nSpec: Convert queue to front-to-back list order.\n\nWrite exactly one Scheme function definition for `queue->list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))", "verify_expr": "(let ()\n  (define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))\n  (and (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)) (equal? (queue->list (cons '() '())) '())))", "tags": ["tier0", "data", "queue", "spec-to-code", "queue->list"], "split": "eval"}
{"id": "queue_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (queue->list queue)\n  ;; TODO: convert queue to front-to-back list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `queue->list`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))", "verify_expr": "(let ()\n  (define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))\n  (and (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)) (equal? (queue->list (cons '() '())) '())))", "tags": ["tier0", "data", "queue", "skeleton-completion", "queue->list"], "split": "train"}
{"id": "queue_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 queue code in Fold-native Scheme.\n\nTarget module: lattice/data/queue.ss\nFunction: `list->queue`\nSpec: Convert list to queue with first list element at the queue front.\n\nWrite exactly one Scheme function definition for `list->queue`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (list->queue '(1 2 3)) '((1 2 3))))\n(let () (equal? (list->queue '()) '(())))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "spec-to-code", "list->queue"], "split": "train"}
{"id": "queue_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (list->queue lst)\n  ;; TODO: convert list to queue representation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `list->queue`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "skeleton-completion", "list->queue"], "split": "train"}
{"id": "queue_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-queue`.\nReturn only the Scheme definition.\n\n```python\ndef make_queue(front, back):\n    if len(front) == 0:\n        return list(reversed(back)), []\n    return front, back\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "make-queue"], "split": "eval"}
{"id": "queue_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-queue`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mkq f b)\n  (if (null? f)\n      (cons (reverse b) '())\n      (cons f b)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n(let () (equal? (make-queue '() '(x y z)) '((z y x))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "chez-to-fold", "make-queue"], "split": "train"}
{"id": "queue_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef queue_empty(queue):\n    front, back = queue\n    return len(front) == 0 and len(back) == 0\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))\n  (and (queue-empty? (cons '() '())) (not (queue-empty? (cons '(a) '()))) (not (queue-empty? (cons '() '(a))))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "queue-empty?"], "split": "train"}
{"id": "queue_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `queue-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? q)\n  (and (null? (car q))\n       (null? (cdr q))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (queue-empty? (cons '() '())))\n(let () (not (queue-empty? (cons '(a) '()))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))\n  (and (queue-empty? (cons '() '())) (not (queue-empty? (cons '(a) '()))) (not (queue-empty? (cons '() '(a))))))", "tags": ["tier0", "data", "queue", "chez-to-fold", "queue-empty?"], "split": "train"}
{"id": "queue_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue-enqueue`.\nReturn only the Scheme definition.\n\n```python\ndef queue_enqueue(elem, queue):\n    front, back = queue\n    return make_queue(front, [elem] + back)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))\n  (and (equal? (queue-enqueue 'x (cons '() '())) '((x))) (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "queue-enqueue"], "split": "train"}
{"id": "queue_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `queue-enqueue`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (enqueue x q)\n  (let ([f (car q)] [b (cdr q)])\n    (make-queue f (cons x b))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (queue-enqueue 'x (cons '() '())) '((x))))\n(let () (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))\n  (and (equal? (queue-enqueue 'x (cons '() '())) '((x))) (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z))))", "tags": ["tier0", "data", "queue", "chez-to-fold", "queue-enqueue"], "split": "train"}
{"id": "queue_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue-dequeue`.\nReturn only the Scheme definition.\n\n```python\ndef queue_dequeue(queue):\n    front, back = queue\n    if len(front) == 0:\n        raise ValueError('empty queue')\n    return make_queue(front[1:], back), front[0]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))))\n(let () (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))\n  (and (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (guard (ex [else #t]) (begin (queue-dequeue (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "queue-dequeue"], "split": "train"}
{"id": "queue_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `queue-dequeue`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (dequeue q)\n  (let ([f (car q)] [b (cdr q)])\n    (if (null? f)\n        (error 'dequeue \"empty\")\n        (values (make-queue (cdr f) b) (car f)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))\n  (and (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (guard (ex [else #t]) (begin (queue-dequeue (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "chez-to-fold", "queue-dequeue"], "split": "train"}
{"id": "queue_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue-peek`.\nReturn only the Scheme definition.\n\n```python\ndef queue_peek(queue):\n    front, back = queue\n    if len(front) == 0:\n        raise ValueError('empty queue')\n    return front[0]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "queue-peek"], "split": "eval"}
{"id": "queue_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `queue-peek`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (peek q)\n  (if (null? (car q))\n      (error 'peek \"empty\")\n      (car (car q))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "chez-to-fold", "queue-peek"], "split": "train"}
{"id": "queue_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue-size`.\nReturn only the Scheme definition.\n\n```python\ndef queue_size(queue):\n    front, back = queue\n    return len(front) + len(back)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))\n  (and (= (queue-size (cons '() '())) 0) (= (queue-size (cons '(a b) '(d c))) 4)))", "tags": ["tier0", "data", "queue", "python-to-scheme", "queue-size"], "split": "train"}
{"id": "queue_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `queue-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (size q)\n  (+ (length (car q)) (length (cdr q))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))\n  (and (= (queue-size (cons '() '())) 0) (= (queue-size (cons '(a b) '(d c))) 4)))", "tags": ["tier0", "data", "queue", "chez-to-fold", "queue-size"], "split": "train"}
{"id": "queue_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `queue->list`.\nReturn only the Scheme definition.\n\n```python\ndef queue_to_list(queue):\n    front, back = queue\n    return front + list(reversed(back))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)))\n(let () (equal? (queue->list (cons '() '())) '()))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))", "verify_expr": "(let ()\n  (define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))\n  (and (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)) (equal? (queue->list (cons '() '())) '())))", "tags": ["tier0", "data", "queue", "python-to-scheme", "queue->list"], "split": "train"}
{"id": "queue_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `queue->list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (to-list q)\n  (append (car q) (reverse (cdr q))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))", "verify_expr": "(let ()\n  (define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))\n  (and (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)) (equal? (queue->list (cons '() '())) '())))", "tags": ["tier0", "data", "queue", "chez-to-fold", "queue->list"], "split": "train"}
{"id": "queue_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `list->queue`.\nReturn only the Scheme definition.\n\n```python\ndef list_to_queue(lst):\n    return lst, []\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "python-to-scheme", "list->queue"], "split": "train"}
{"id": "queue_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `list->queue`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (from-list xs)\n  (cons xs '()))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "chez-to-fold", "list->queue"], "split": "eval"}
{"id": "queue_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-queue` in `lattice/data/queue.ss`.\nKnown issue: When front is empty, back must be reversed into front.\n\n```scheme\n(define (make-queue front back)\n  (cons front back))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: When front is empty, back must be reversed into front.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n(let () (equal? (make-queue '() '(x y z)) '((z y x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "bugfix", "make-queue"], "split": "eval"}
{"id": "queue_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "make-queue", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-queue` in `lattice/data/queue.ss`.\nKnown issue: Back must be reversed before becoming new front.\n\n```scheme\n(define (make-queue front back)\n  (if (null? front)\n      (cons back '())\n      (cons front back)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (make-queue '(a b) '(c d)) '((a b) c d)))\n(let () (equal? (make-queue '() '(x y z)) '((z y x))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (and (equal? (make-queue '(a b) '(c d)) '((a b) c d)) (equal? (make-queue '() '(x y z)) '((z y x)))))", "tags": ["tier0", "data", "queue", "bugfix", "make-queue"], "split": "train"}
{"id": "queue_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-empty?` in `lattice/data/queue.ss`.\nKnown issue: Queue is empty only when both front and back are empty.\n\n```scheme\n(define (queue-empty? queue)\n  (null? (car queue)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (queue-empty? (cons '() '())))\n(let () (not (queue-empty? (cons '(a) '()))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))\n  (and (queue-empty? (cons '() '())) (not (queue-empty? (cons '(a) '()))) (not (queue-empty? (cons '() '(a))))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-empty?"], "split": "train"}
{"id": "queue_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-empty?` in `lattice/data/queue.ss`.\nKnown issue: Front list must also be checked.\n\n```scheme\n(define (queue-empty? queue)\n  (null? (cdr queue)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (queue-empty? (cons '() '())))\n(let () (not (queue-empty? (cons '(a) '()))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-empty? queue)\n  (and (null? (car queue))\n       (null? (cdr queue))))\n  (and (queue-empty? (cons '() '())) (not (queue-empty? (cons '(a) '()))) (not (queue-empty? (cons '() '(a))))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-empty?"], "split": "train"}
{"id": "queue_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-enqueue` in `lattice/data/queue.ss`.\nKnown issue: Enqueue must add at back, not front.\n\n```scheme\n(define (queue-enqueue elem queue)\n  (let ([front (car queue)] [back (cdr queue)])\n    (cons (cons elem front) back)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Enqueue must add at back, not front.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (queue-enqueue 'x (cons '() '())) '((x))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (queue-enqueue 'x (cons '() '())) '((x))))\n(let () (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))\n  (and (equal? (queue-enqueue 'x (cons '() '())) '((x))) (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-enqueue"], "split": "train"}
{"id": "queue_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-enqueue` in `lattice/data/queue.ss`.\nKnown issue: The enqueued element is ignored.\n\n```scheme\n(define (queue-enqueue elem queue)\n  queue)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The enqueued element is ignored.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (queue-enqueue 'x (cons '() '())) '((x))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (queue-enqueue 'x (cons '() '())) '((x))))\n(let () (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-enqueue elem queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (make-queue front (cons elem back))))\n  (and (equal? (queue-enqueue 'x (cons '() '())) '((x))) (equal? (queue-enqueue 'z (cons '(x y) '())) '((x y) z))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-enqueue"], "split": "train"}
{"id": "queue_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-dequeue` in `lattice/data/queue.ss`.\nKnown issue: Queue must advance after dequeue.\n\n```scheme\n(define (queue-dequeue queue)\n  (let ([front (car queue)] [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values queue (car front)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))\n  (and (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (guard (ex [else #t]) (begin (queue-dequeue (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-dequeue"], "split": "train"}
{"id": "queue_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-dequeue` in `lattice/data/queue.ss`.\nKnown issue: Dequeuing must call make-queue to preserve invariant when front empties.\n\n```scheme\n(define (queue-dequeue queue)\n  (let ([front (car queue)] [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (cons (cdr front) back) (car front)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Dequeuing must call make-queue to preserve invariant when front empties.\n\nExpected behavior after patch:\n```scheme\n(let () (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))", "verify_expr": "(let ()\n  (define (make-queue front back)\n  (if (null? front)\n      (cons (reverse back) '())\n      (cons front back)))\n  (define (queue-dequeue queue)\n  (let ([front (car queue)]\n        [back (cdr queue)])\n    (if (null? front)\n        (error 'queue-dequeue \"Cannot dequeue from empty queue\")\n        (values (make-queue (cdr front) back)\n                (car front)))))\n  (and (call-with-values (lambda () (queue-dequeue '((a b c)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (and (equal? q '((b c))) (equal? x 'a)))) (guard (ex [else #t]) (begin (queue-dequeue (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-dequeue"], "split": "train"}
{"id": "queue_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-peek` in `lattice/data/queue.ss`.\nKnown issue: Peeking empty queue must raise an error.\n\n```scheme\n(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        #f\n        (car front))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Peeking empty queue must raise an error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n(let () (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-peek"], "split": "eval"}
{"id": "queue_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-peek` in `lattice/data/queue.ss`.\nKnown issue: Peek should return the front element, not the last front element.\n\n```scheme\n(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (last front))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Peek should return the front element, not the last front element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (queue-peek '((x y z))) 'x))\n(let () (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))", "verify_expr": "(let ()\n  (define (queue-peek queue)\n  (let ([front (car queue)])\n    (if (null? front)\n        (error 'queue-peek \"Cannot peek empty queue\")\n        (car front))))\n  (and (equal? (queue-peek '((x y z))) 'x) (guard (ex [else #t]) (begin (queue-peek (cons '() '())) #f))))", "tags": ["tier0", "data", "queue", "bugfix", "queue-peek"], "split": "train"}
{"id": "queue_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-size` in `lattice/data/queue.ss`.\nKnown issue: Size must include both front and back lengths.\n\n```scheme\n(define (queue-size queue)\n  (length (car queue)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Size must include both front and back lengths.\n\nExpected behavior after patch:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))\n  (and (= (queue-size (cons '() '())) 0) (= (queue-size (cons '(a b) '(d c))) 4)))", "tags": ["tier0", "data", "queue", "bugfix", "queue-size"], "split": "train"}
{"id": "queue_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue-size` in `lattice/data/queue.ss`.\nKnown issue: Do not add an extra offset.\n\n```scheme\n(define (queue-size queue)\n  (+ 1 (length (car queue)) (length (cdr queue))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (queue-size (cons '() '())) 0))\n(let () (= (queue-size (cons '(a b) '(d c))) 4))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))", "verify_expr": "(let ()\n  (define (queue-size queue)\n  (+ (length (car queue))\n     (length (cdr queue))))\n  (and (= (queue-size (cons '() '())) 0) (= (queue-size (cons '(a b) '(d c))) 4)))", "tags": ["tier0", "data", "queue", "bugfix", "queue-size"], "split": "train"}
{"id": "queue_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue->list` in `lattice/data/queue.ss`.\nKnown issue: Back list must be reversed to recover queue order.\n\n```scheme\n(define (queue->list queue)\n  (append (car queue) (cdr queue)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Back list must be reversed to recover queue order.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))", "verify_expr": "(let ()\n  (define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))\n  (and (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)) (equal? (queue->list (cons '() '())) '())))", "tags": ["tier0", "data", "queue", "bugfix", "queue->list"], "split": "train"}
{"id": "queue_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `queue->list` in `lattice/data/queue.ss`.\nKnown issue: Conversion must include both front and back elements in FIFO order.\n\n```scheme\n(define (queue->list queue)\n  (reverse (car queue)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))", "verify_expr": "(let ()\n  (define (queue->list queue)\n  (append (car queue) (reverse (cdr queue))))\n  (and (equal? (queue->list (cons '(a b) '(d c))) '(a b c d)) (equal? (queue->list (cons '() '())) '())))", "tags": ["tier0", "data", "queue", "bugfix", "queue->list"], "split": "train"}
{"id": "queue_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->queue` in `lattice/data/queue.ss`.\nKnown issue: First list element must stay at queue front.\n\n```scheme\n(define (list->queue lst)\n  (cons (reverse lst) '()))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (list->queue '(1 2 3)) '((1 2 3))))\n(let () (equal? (list->queue '()) '(())))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "bugfix", "list->queue"], "split": "train"}
{"id": "queue_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `list->queue` in `lattice/data/queue.ss`.\nKnown issue: Queue representation is (front . back), with list in front and empty back.\n\n```scheme\n(define (list->queue lst)\n  (cons '() lst))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (list->queue lst)\n  (cons lst '()))", "verify_expr": "(let ()\n  (define (list->queue lst)\n  (cons lst '()))\n  (and (equal? (list->queue '(1 2 3)) '((1 2 3))) (equal? (list->queue '()) '(()))))", "tags": ["tier0", "data", "queue", "bugfix", "list->queue"], "split": "eval"}
{"id": "queue_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether `queue-empty` is empty.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(queue-empty? queue-empty)", "verify_expr": "(equal? (queue-empty? queue-empty) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-empty?", "direct"], "split": "eval"}
{"id": "queue_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: small integration task across module primitives.\n\nEnqueue `'x` into `queue-empty`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(queue-enqueue 'x queue-empty)", "verify_expr": "(equal? (queue-enqueue 'x queue-empty) '((x)))", "tags": ["tier0", "data", "queue", "composition", "queue-enqueue", "direct"], "split": "train"}
{"id": "queue_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: compose existing APIs into one expression.\n\nEnqueue `'x`, `'y`, `'z` into empty queue and return queue order as list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(queue->list (queue-enqueue 'z (queue-enqueue 'y (queue-enqueue 'x queue-empty))))", "verify_expr": "(equal? (queue->list (queue-enqueue 'z (queue-enqueue 'y (queue-enqueue 'x queue-empty)))) '(x y z))", "tags": ["tier0", "data", "queue", "composition", "queue->list", "direct"], "split": "train"}
{"id": "queue_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: small integration task across module primitives.\n\nReturn front element of queue built from list `'(a b c)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(queue-peek (list->queue '(a b c)))", "verify_expr": "(equal? (queue-peek (list->queue '(a b c))) 'a)", "tags": ["tier0", "data", "queue", "composition", "queue-peek", "direct"], "split": "train"}
{"id": "queue_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn queue size for `(list->queue '(p q r s))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(queue-size (list->queue '(p q r s)))", "verify_expr": "(equal? (queue-size (list->queue '(p q r s))) 4)", "tags": ["tier0", "data", "queue", "composition", "queue-size", "direct"], "split": "train"}
{"id": "queue_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: small integration task across module primitives.\n\nDequeue once from `(list->queue '(m n o))` and return `(list popped rest-list)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (list->queue '(m n o)))) (lambda (q x) (list x (queue->list q))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (list->queue '(m n o)))) (lambda (q x) (list x (queue->list q)))) '(m (n o)))", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "direct"], "split": "train"}
{"id": "queue_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: small integration task across module primitives.\n\nConvert list `'(1 2 3)` to queue.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list->queue '(1 2 3))", "verify_expr": "(equal? (list->queue '(1 2 3)) '((1 2 3)))", "tags": ["tier0", "data", "queue", "composition", "list->queue", "direct"], "split": "train"}
{"id": "queue_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: small integration task across module primitives.\n\nConvert queue representation `(cons '(a b) '(d c))` to list.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(queue->list (cons '(a b) '(d c)))", "verify_expr": "(equal? (queue->list (cons '(a b) '(d c))) '(a b c d))", "tags": ["tier0", "data", "queue", "composition", "queue->list", "direct"], "split": "train"}
{"id": "queue_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: compose existing APIs into one expression.\n\nDequeue from queue `(cons '(a) '(c b))` and return `(list popped rest-list)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (list x (queue->list q))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (cons '(a) '(c b)))) (lambda (q x) (list x (queue->list q)))) '(a (b c)))", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "direct"], "split": "eval"}
{"id": "queue_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck if queue `(list->queue '(only))` is empty.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(queue-empty? (list->queue '(only)))", "verify_expr": "(equal? (queue-empty? (list->queue '(only))) #f)", "tags": ["tier0", "data", "queue", "composition", "queue-empty?", "direct"], "split": "train"}
{"id": "queue_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: compose existing APIs into one expression.\n\nRound-trip `list->queue->queue->list` for `'(u v w)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(queue->list (list->queue '(u v w)))", "verify_expr": "(equal? (queue->list (list->queue '(u v w))) '(u v w))", "tags": ["tier0", "data", "queue", "composition", "queue->list", "direct"], "split": "train"}
{"id": "queue_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn the size of `queue-empty`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(queue-size queue-empty)", "verify_expr": "(equal? (queue-size queue-empty) 0)", "tags": ["tier0", "data", "queue", "composition", "queue-size", "direct"], "split": "train"}
{"id": "queue_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff two dequeues from `(list->queue '(1 2 3))` produce `1` then `2`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (list->queue '(1 2 3)))) (lambda (q1 x1) (call-with-values (lambda () (queue-dequeue q1)) (lambda (q2 x2) (and (= x1 1) (= x2 2) (equal? (queue->list q2) '(3)))))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (list->queue '(1 2 3)))) (lambda (q1 x1) (call-with-values (lambda () (queue-dequeue q1)) (lambda (q2 x2) (and (= x1 1) (= x2 2) (equal? (queue->list q2) '(3))))))) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "property"], "split": "train"}
{"id": "queue_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that enqueue increases queue size by one.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (queue-size (queue-enqueue 'z (list->queue '(a b)))) (+ 1 (queue-size (list->queue '(a b)))))", "verify_expr": "(equal? (= (queue-size (queue-enqueue 'z (list->queue '(a b)))) (+ 1 (queue-size (list->queue '(a b))))) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-size", "property"], "split": "train"}
{"id": "queue_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that dequeue decreases size by one for non-empty queue.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (list->queue '(a b c d)))) (lambda (q x) (= (queue-size q) 3)))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (list->queue '(a b c d)))) (lambda (q x) (= (queue-size q) 3))) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-size", "property"], "split": "train"}
{"id": "queue_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff peeking after enqueue on empty queue returns the new element.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (queue-peek (queue-enqueue 'n queue-empty)) 'n)", "verify_expr": "(equal? (queue-peek (queue-enqueue 'n queue-empty)) 'n)", "tags": ["tier0", "data", "queue", "composition", "queue-peek", "property"], "split": "train"}
{"id": "queue_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "list->queue", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff first list element stays at queue front after conversion.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (queue-peek (list->queue '(h i j))) 'h)", "verify_expr": "(equal? (queue-peek (list->queue '(h i j))) 'h)", "tags": ["tier0", "data", "queue", "composition", "list->queue", "property"], "split": "eval"}
{"id": "queue_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff dequeuing single-element queue yields empty queue and that element.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (list->queue '(solo)))) (lambda (q x) (and (queue-empty? q) (equal? x 'solo))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (list->queue '(solo)))) (lambda (q x) (and (queue-empty? q) (equal? x 'solo)))) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "property"], "split": "train"}
{"id": "queue_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff dequeuing empty queue raises an exception.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(guard (ex [else #t]) (begin (queue-dequeue queue-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (queue-dequeue queue-empty) #f)) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "edge-case"], "split": "train"}
{"id": "queue_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-peek", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff peeking empty queue raises an exception.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(guard (ex [else #t]) (begin (queue-peek queue-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (queue-peek queue-empty) #f)) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-peek", "edge-case"], "split": "train"}
{"id": "queue_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue->list", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that queue->list after enqueue appends at end.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (queue->list (queue-enqueue 'd (list->queue '(a b c)))) '(a b c d))", "verify_expr": "(equal? (queue->list (queue-enqueue 'd (list->queue '(a b c)))) '(a b c d))", "tags": ["tier0", "data", "queue", "composition", "queue->list", "property"], "split": "train"}
{"id": "queue_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that `queue-size` equals `(length (queue->list q))` for q = `(cons '(a b) '(d c))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([q (cons '(a b) '(d c))]) (= (queue-size q) (length (queue->list q))))", "verify_expr": "(equal? (let ([q (cons '(a b) '(d c))]) (= (queue-size q) (length (queue->list q)))) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-size", "property"], "split": "train"}
{"id": "queue_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild queue from `'(1 2 3 4)` using `fold-left` and `queue-enqueue`, then return list form.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(queue->list (fold-left (lambda (q x) (queue-enqueue x q)) queue-empty '(1 2 3 4)))", "verify_expr": "(equal? (queue->list (fold-left (lambda (q x) (queue-enqueue x q)) queue-empty '(1 2 3 4))) '(1 2 3 4))", "tags": ["tier0", "data", "queue", "composition", "queue-enqueue", "fold"], "split": "train"}
{"id": "queue_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConsume `(list->queue '(x y z))` with repeated dequeue and collect popped elements.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([q (list->queue '(x y z))] [acc '()]) (if (queue-empty? q) (reverse acc) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (cons x acc))))))", "verify_expr": "(equal? (let loop ([q (list->queue '(x y z))] [acc '()]) (if (queue-empty? q) (reverse acc) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (cons x acc)))))) '(x y z))", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "loop"], "split": "eval"}
{"id": "queue_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCount how many dequeues empty `(list->queue '(a b c d))`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let loop ([q (list->queue '(a b c d))] [n 0]) (if (queue-empty? q) n (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (+ n 1))))))", "verify_expr": "(equal? (let loop ([q (list->queue '(a b c d))] [n 0]) (if (queue-empty? q) n (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (+ n 1)))))) 4)", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "loop"], "split": "train"}
{"id": "queue_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSum all elements by repeatedly dequeuing `(list->queue '(2 4 6))`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let loop ([q (list->queue '(2 4 6))] [acc 0]) (if (queue-empty? q) acc (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (+ acc x))))))", "verify_expr": "(equal? (let loop ([q (list->queue '(2 4 6))] [acc 0]) (if (queue-empty? q) acc (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (loop q2 (+ acc x)))))) 12)", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "loop"], "split": "train"}
{"id": "queue_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap queue sizes over queues `'((() . ()) ((a b) . ()) ((x) . (z y)))`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map queue-size (list (cons '() '()) (cons '(a b) '()) (cons '(x) '(z y))))", "verify_expr": "(equal? (map queue-size (list (cons '() '()) (cons '(a b) '()) (cons '(x) '(z y)))) '(0 2 3))", "tags": ["tier0", "data", "queue", "composition", "queue-size", "list"], "split": "train"}
{"id": "queue_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse a loop to enqueue all numbers in `'(5 6 7)` and return queue->list.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let loop ([xs '(5 6 7)] [q queue-empty]) (if (null? xs) (queue->list q) (loop (cdr xs) (queue-enqueue (car xs) q))))", "verify_expr": "(equal? (let loop ([xs '(5 6 7)] [q queue-empty]) (if (null? xs) (queue->list q) (loop (cdr xs) (queue-enqueue (car xs) q)))) '(5 6 7))", "tags": ["tier0", "data", "queue", "composition", "queue-enqueue", "loop"], "split": "train"}
{"id": "queue_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFrom `(list->queue '(a b c))`, dequeue once then enqueue `'d`; return queue order.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (list->queue '(a b c)))) (lambda (q x) (queue->list (queue-enqueue 'd q))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (list->queue '(a b c)))) (lambda (q x) (queue->list (queue-enqueue 'd q)))) '(b c d))", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "integration"], "split": "train"}
{"id": "queue_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDequeue twice from `(list->queue '(q r s t))` and return `(list first second remaining-list)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (list->queue '(q r s t)))) (lambda (q1 x1) (call-with-values (lambda () (queue-dequeue q1)) (lambda (q2 x2) (list x1 x2 (queue->list q2))))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (list->queue '(q r s t)))) (lambda (q1 x1) (call-with-values (lambda () (queue-dequeue q1)) (lambda (q2 x2) (list x1 x2 (queue->list q2)))))) '(q r (s t)))", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "integration"], "split": "train"}
{"id": "queue_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-enqueue", "prompt": "Task mode: compose existing APIs into one expression.\n\nSimulate operations: enqueue `1`, enqueue `2`, dequeue once, enqueue `3`; return queue order.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(call-with-values (lambda () (queue-dequeue (queue-enqueue 2 (queue-enqueue 1 queue-empty)))) (lambda (q x) (queue->list (queue-enqueue 3 q))))", "verify_expr": "(equal? (call-with-values (lambda () (queue-dequeue (queue-enqueue 2 (queue-enqueue 1 queue-empty)))) (lambda (q x) (queue->list (queue-enqueue 3 q)))) '(2 3))", "tags": ["tier0", "data", "queue", "composition", "queue-enqueue", "integration"], "split": "train"}
{"id": "queue_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/queue.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "queue-dequeue", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff dequeuing all elements from `(list->queue '(1 2 3 4))` yields them in insertion order.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([q (list->queue '(1 2 3 4))] [expected '(1 2 3 4)]) (if (null? expected) (queue-empty? q) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (and (= x (car expected)) (loop q2 (cdr expected)))))))", "verify_expr": "(equal? (let loop ([q (list->queue '(1 2 3 4))] [expected '(1 2 3 4)]) (if (null? expected) (queue-empty? q) (call-with-values (lambda () (queue-dequeue q)) (lambda (q2 x) (and (= x (car expected)) (loop q2 (cdr expected))))))) #t)", "tags": ["tier0", "data", "queue", "composition", "queue-dequeue", "integration"], "split": "eval"}
