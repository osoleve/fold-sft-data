{"id": "info_statistical_measures_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `bhattacharyya-distance`\nSpec: Compute D_B(P,Q)=-ln(BC(P,Q)) and return +inf.0 when BC<=0.\n\nWrite exactly one Scheme function definition for `bhattacharyya-distance`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-distance '(1 0) '(0 1))]\n      [p '(0.6 0.3 0.1)]\n      [q '(0.4 0.4 0.2)])\n  (let ([bc (bhattacharyya-coefficient p q)]\n        [bd (bhattacharyya-distance p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= disjoint +inf.0)\n         (approx=? (- (log-num bc)) bd 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "bhattacharyya-distance"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `bhattacharyya-distance`\nSpec: Compute D_B(P,Q)=-ln(BC(P,Q)) and return +inf.0 when BC<=0.\n\nWrite exactly one Scheme function definition for `bhattacharyya-distance`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `total-variation-distance`\nSpec: Compute TV(P,Q)=0.5*sum(|p_i-q_i|) with empty inputs returning 1.\n\nWrite exactly one Scheme function definition for `total-variation-distance`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))]\n      [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([tv1 (total-variation-distance p q)]\n        [tv2 (total-variation-distance q p)])\n    (and (approx=? 0.0 tv-same 0.000001)\n         (approx=? 0.3 tv-known 0.000001)\n         (approx=? tv1 tv2 0.000001)\n         (<= tv1 1.0)\n         (>= tv1 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "total-variation-distance"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `total-variation-distance`\nSpec: Compute TV(P,Q)=0.5*sum(|p_i-q_i|) with empty inputs returning 1.\n\nWrite exactly one Scheme function definition for `total-variation-distance`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_statistical_measures_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `jeffreys-divergence`\nSpec: Compute Jeffreys divergence J(P,Q)=KL(P||Q)+KL(Q||P).\n\nWrite exactly one Scheme function definition for `jeffreys-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([j1 (jeffreys-divergence p q)]\n        [j2 (jeffreys-divergence q p)]\n        [sum-kl (+ (kl-divergence p q) (kl-divergence q p))])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? j1 j2 0.000001)\n         (approx=? j1 sum-kl 0.000001)\n         (>= j1 0)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "jeffreys-divergence"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `jeffreys-divergence`\nSpec: Compute Jeffreys divergence J(P,Q)=KL(P||Q)+KL(Q||P).\n\nWrite exactly one Scheme function definition for `jeffreys-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bhattacharyya-coefficient`.\nReturn only the Scheme definition.\n\n```python\ndef bhattacharyya_coefficient(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    return sum(0 if (pi < 0 or qi < 0) else (pi * qi) ** 0.5 for pi, qi in zip(p, q))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "bhattacharyya-coefficient"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bhattacharyya-coefficient`.\nReturn only the Scheme definition.\n\n```python\ndef bhattacharyya_coefficient(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    return sum(0 if (pi < 0 or qi < 0) else (pi * qi) ** 0.5 for pi, qi in zip(p, q))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `chi-squared-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef chi_squared_divergence(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    total = 0.0\n    for pi, qi in zip(p, q):\n        if qi <= 0:\n            if pi > 0:\n                return float('inf')\n            continue\n        diff = pi - qi\n        total += (diff * diff) / qi\n    return total\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "chi-squared-divergence"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `chi-squared-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef chi_squared_divergence(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    total = 0.0\n    for pi, qi in zip(p, q):\n        if qi <= 0:\n            if pi > 0:\n                return float('inf')\n            continue\n        diff = pi - qi\n        total += (diff * diff) / qi\n    return total\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_statistical_measures_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `alpha-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (alpha-div a p q)\n  (cond\n    [(or (null? p) (null? q)) 0]\n    [(= a 1)\n     (kl-divergence p q)]\n    [(= a 0)\n     (- (log-num (fold-left + 0\n                            (map (lambda (pi qi)\n                                   (if (and (> pi 0) (> qi 0)) qi 0))\n                                 p q))))]\n    [else\n     (let ([s (fold-left + 0\n                         (map (lambda (pi qi)\n                                (if (or (<= pi 0) (<= qi 0))\n                                    0\n                                    (* (expt pi a) (expt qi (- 1 a)))))\n                              p q))])\n       (if (<= s 0)\n           +inf.0\n           (/ (log-num s)\n              (* a (- a 1)))))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "alpha-divergence"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `alpha-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (alpha-div a p q)\n  (cond\n    [(or (null? p) (null? q)) 0]\n    [(= a 1)\n     (kl-divergence p q)]\n    [(= a 0)\n     (- (log-num (fold-left + 0\n                            (map (lambda (pi qi)\n                                   (if (and (> pi 0) (> qi 0)) qi 0))\n                                 p q))))]\n    [else\n     (let ([s (fold-left + 0\n                         (map (lambda (pi qi)\n                                (if (or (<= pi 0) (<= qi 0))\n                                    0\n                                    (* (expt pi a) (expt qi (- 1 a)))))\n                              p q))])\n       (if (<= s 0)\n           +inf.0\n           (/ (log-num s)\n              (* a (- a 1)))))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-coefficient`\nKnown issue: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (* pi qi)))\n                      p q))))\n```\n\nReturn only the corrected definition for `bhattacharyya-coefficient`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "bhattacharyya-coefficient"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-coefficient`\nKnown issue: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (* pi qi)))\n                      p q))))\n```\n\nReturn only the corrected definition for `bhattacharyya-coefficient`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `chi-squared-divergence`\nKnown issue: Denominator must be q_i, not p_i.\n\nBuggy implementation:\n```scheme\n(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) pi))]))\n                      p q))))\n```\n\nReturn only the corrected definition for `chi-squared-divergence`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "chi-squared-divergence"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `chi-squared-divergence`\nKnown issue: Denominator must be q_i, not p_i.\n\nBuggy implementation:\n```scheme\n(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) pi))]))\n                      p q))))\n```\n\nReturn only the corrected definition for `chi-squared-divergence`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `alpha-divergence`\nKnown issue: The general-case denominator should be alpha*(alpha-1), not alpha*(1-alpha).\n\nBuggy implementation:\n```scheme\n(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- 1 alpha)))))]))\n```\n\nReturn only the corrected definition for `alpha-divergence`.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "alpha-divergence"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `alpha-divergence`\nKnown issue: The general-case denominator should be alpha*(alpha-1), not alpha*(1-alpha).\n\nBuggy implementation:\n```scheme\n(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- 1 alpha)))))]))\n```\n\nReturn only the corrected definition for `alpha-divergence`.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Normalize two non-negative weight vectors and compute their Bhattacharyya coefficient.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (normalize-distribution '(2 3 5))] [q (normalize-distribution '(3 3 4))]) (bhattacharyya-coefficient p q))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(2 3 5))] [q (normalize-distribution '(3 3 4))] [bc (bhattacharyya-coefficient p q)]) (and (>= bc 0) (<= bc 1) (approx=? bc (bhattacharyya-coefficient q p) 0.000001))))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-coefficient", "normalization", "range"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Normalize two non-negative weight vectors and compute their Bhattacharyya coefficient.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Normalize two vectors and compute Hellinger distance.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (normalize-distribution '(2 1 1))] [q (normalize-distribution '(1 2 1))]) (hellinger-distance p q))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(2 1 1))] [q (normalize-distribution '(1 2 1))] [h (hellinger-distance p q)]) (and (>= h 0) (<= h 1) (approx=? h (hellinger-distance q p) 0.000001))))", "tags": ["tier1", "info", "statistical-measures", "composition", "hellinger-distance", "normalization", "range"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Normalize two vectors and compute Hellinger distance.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Normalize two vectors (strictly positive target) and compute forward chi-squared divergence.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (normalize-distribution '(5 3 2))] [q (normalize-distribution '(4 4 2))]) (chi-squared-divergence p q))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(5 3 2))] [q (normalize-distribution '(4 4 2))] [v (chi-squared-divergence p q)]) (and (>= v 0) (not (= v +inf.0)))))", "tags": ["tier1", "info", "statistical-measures", "composition", "chi-squared-divergence", "normalization", "finite"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Normalize two vectors (strictly positive target) and compute forward chi-squared divergence.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: For identical distributions, assert both symmetric chi-squared and Jeffreys divergence are zero.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.5 0.3 0.2)]) (and (approx=? 0.0 (symmetric-chi-squared p p) 0.000001) (approx=? 0.0 (jeffreys-divergence p p) 0.000001)))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.5 0.3 0.2)]) (and (approx=? 0.0 (symmetric-chi-squared p p) 0.000001) (approx=? 0.0 (jeffreys-divergence p p) 0.000001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "symmetric-chi-squared", "identity", "cross-measure"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: For identical distributions, assert both symmetric chi-squared and Jeffreys divergence are zero.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: For an identical distribution pair, assert alpha-divergence is zero for alpha=0.5 and alpha=2.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.333333 0.333333 0.333334)]) (and (approx=? 0.0 (alpha-divergence 0.5 p p) 0.000001) (approx=? 0.0 (alpha-divergence 2 p p) 0.000001)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.333333 0.333333 0.333334)]) (and (approx=? 0.0 (alpha-divergence 0.5 p p) 0.000001) (approx=? 0.0 (alpha-divergence 2 p p) 0.000001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "alpha-divergence", "identity", "multi-alpha"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: For an identical distribution pair, assert alpha-divergence is zero for alpha=0.5 and alpha=2.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
