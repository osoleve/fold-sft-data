{"id": "info_statistical_measures_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `bhattacharyya-coefficient`\nSpec: Compute BC(P,Q)=sum(sqrt(p_i*q_i)) with empty inputs returning 0 and negative coordinates contributing 0 per term.\n\nWrite exactly one Scheme function definition for `bhattacharyya-coefficient`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "bhattacharyya-coefficient"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `bhattacharyya-coefficient`\nSpec: Compute BC(P,Q)=sum(sqrt(p_i*q_i)) with empty inputs returning 0 and negative coordinates contributing 0 per term.\n\nWrite exactly one Scheme function definition for `bhattacharyya-coefficient`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_statistical_measures_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (bhattacharyya-coefficient p q)\n  ;; TODO: sum sqrt(p_i * q_i) with empty-list and negative-value handling\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `bhattacharyya-coefficient`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "bhattacharyya-coefficient"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (bhattacharyya-coefficient p q)\n  ;; TODO: sum sqrt(p_i * q_i) with empty-list and negative-value handling\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `bhattacharyya-coefficient`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_statistical_measures_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `bhattacharyya-distance`\nSpec: Compute D_B(P,Q)=-ln(BC(P,Q)) and return +inf.0 when BC<=0.\n\nWrite exactly one Scheme function definition for `bhattacharyya-distance`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-distance '(1 0) '(0 1))]\n      [p '(0.6 0.3 0.1)]\n      [q '(0.4 0.4 0.2)])\n  (let ([bc (bhattacharyya-coefficient p q)]\n        [bd (bhattacharyya-distance p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= disjoint +inf.0)\n         (approx=? (- (log-num bc)) bd 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "bhattacharyya-distance"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `bhattacharyya-distance`\nSpec: Compute D_B(P,Q)=-ln(BC(P,Q)) and return +inf.0 when BC<=0.\n\nWrite exactly one Scheme function definition for `bhattacharyya-distance`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (bhattacharyya-distance p q)\n  ;; TODO: compute -ln(BC), and return +inf.0 when BC <= 0\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `bhattacharyya-distance`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-distance '(1 0) '(0 1))]\n      [p '(0.6 0.3 0.1)]\n      [q '(0.4 0.4 0.2)])\n  (let ([bc (bhattacharyya-coefficient p q)]\n        [bd (bhattacharyya-distance p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= disjoint +inf.0)\n         (approx=? (- (log-num bc)) bd 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "bhattacharyya-distance"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (bhattacharyya-distance p q)\n  ;; TODO: compute -ln(BC), and return +inf.0 when BC <= 0\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `bhattacharyya-distance`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `hellinger-distance`\nSpec: Compute Hellinger distance H(P,Q)=sqrt(0.5 * sum((sqrt(max(0,p_i))-sqrt(max(0,q_i)))^2)) with empty inputs returning 1.\n\nWrite exactly one Scheme function definition for `hellinger-distance`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))]\n      [disjoint (hellinger-distance '(1 0 0) '(0 1 0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([h (hellinger-distance p q)]\n        [bc (bhattacharyya-coefficient p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? 1.0 disjoint 0.000001)\n         (approx=? (* h h) (- 1 bc) 0.000001)\n         (<= h 1.0)\n         (>= h 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "hellinger-distance"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `hellinger-distance`\nSpec: Compute Hellinger distance H(P,Q)=sqrt(0.5 * sum((sqrt(max(0,p_i))-sqrt(max(0,q_i)))^2)) with empty inputs returning 1.\n\nWrite exactly one Scheme function definition for `hellinger-distance`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_statistical_measures_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (hellinger-distance p q)\n  ;; TODO: implement Hellinger distance using sqrt(max 0 x) per coordinate\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `hellinger-distance`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))]\n      [disjoint (hellinger-distance '(1 0 0) '(0 1 0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([h (hellinger-distance p q)]\n        [bc (bhattacharyya-coefficient p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? 1.0 disjoint 0.000001)\n         (approx=? (* h h) (- 1 bc) 0.000001)\n         (<= h 1.0)\n         (>= h 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "hellinger-distance"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (hellinger-distance p q)\n  ;; TODO: implement Hellinger distance using sqrt(max 0 x) per coordinate\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `hellinger-distance`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_statistical_measures_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `total-variation-distance`\nSpec: Compute TV(P,Q)=0.5*sum(|p_i-q_i|) with empty inputs returning 1.\n\nWrite exactly one Scheme function definition for `total-variation-distance`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))]\n      [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([tv1 (total-variation-distance p q)]\n        [tv2 (total-variation-distance q p)])\n    (and (approx=? 0.0 tv-same 0.000001)\n         (approx=? 0.3 tv-known 0.000001)\n         (approx=? tv1 tv2 0.000001)\n         (<= tv1 1.0)\n         (>= tv1 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "total-variation-distance"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `total-variation-distance`\nSpec: Compute TV(P,Q)=0.5*sum(|p_i-q_i|) with empty inputs returning 1.\n\nWrite exactly one Scheme function definition for `total-variation-distance`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_statistical_measures_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (total-variation-distance p q)\n  ;; TODO: implement TV = 1/2 * L1 distance with empty-list behavior\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `total-variation-distance`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))]\n      [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([tv1 (total-variation-distance p q)]\n        [tv2 (total-variation-distance q p)])\n    (and (approx=? 0.0 tv-same 0.000001)\n         (approx=? 0.3 tv-known 0.000001)\n         (approx=? tv1 tv2 0.000001)\n         (<= tv1 1.0)\n         (>= tv1 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "total-variation-distance"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (total-variation-distance p q)\n  ;; TODO: implement TV = 1/2 * L1 distance with empty-list behavior\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `total-variation-distance`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_statistical_measures_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `chi-squared-divergence`\nSpec: Compute Pearson chi-squared divergence sum((p_i-q_i)^2/q_i) with qi<=0 and pi>0 yielding +inf.0.\n\nWrite exactly one Scheme function definition for `chi-squared-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "chi-squared-divergence"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `chi-squared-divergence`\nSpec: Compute Pearson chi-squared divergence sum((p_i-q_i)^2/q_i) with qi<=0 and pi>0 yielding +inf.0.\n\nWrite exactly one Scheme function definition for `chi-squared-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_statistical_measures_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (chi-squared-divergence p q)\n  ;; TODO: implement chi-squared divergence with qi<=0 edge handling\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `chi-squared-divergence`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "chi-squared-divergence"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (chi-squared-divergence p q)\n  ;; TODO: implement chi-squared divergence with qi<=0 edge handling\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `chi-squared-divergence`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_statistical_measures_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `symmetric-chi-squared`\nSpec: Compute symmetric chi-squared as (chi2(P||Q)+chi2(Q||P))/2, propagating +inf.0 if either direction is infinite.\n\nWrite exactly one Scheme function definition for `symmetric-chi-squared`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([s1 (symmetric-chi-squared p q)]\n        [s2 (symmetric-chi-squared q p)]\n        [avg (/ (+ (chi-squared-divergence p q)\n                   (chi-squared-divergence q p))\n                2)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? s1 s2 0.000001)\n         (approx=? s1 avg 0.000001)\n         (>= s1 0)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "symmetric-chi-squared"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `symmetric-chi-squared`\nSpec: Compute symmetric chi-squared as (chi2(P||Q)+chi2(Q||P))/2, propagating +inf.0 if either direction is infinite.\n\nWrite exactly one Scheme function definition for `symmetric-chi-squared`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (symmetric-chi-squared p q)\n  ;; TODO: average forward and reverse chi-squared divergence\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `symmetric-chi-squared`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([s1 (symmetric-chi-squared p q)]\n        [s2 (symmetric-chi-squared q p)]\n        [avg (/ (+ (chi-squared-divergence p q)\n                   (chi-squared-divergence q p))\n                2)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? s1 s2 0.000001)\n         (approx=? s1 avg 0.000001)\n         (>= s1 0)))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "symmetric-chi-squared"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (symmetric-chi-squared p q)\n  ;; TODO: average forward and reverse chi-squared divergence\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `symmetric-chi-squared`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `jeffreys-divergence`\nSpec: Compute Jeffreys divergence J(P,Q)=KL(P||Q)+KL(Q||P).\n\nWrite exactly one Scheme function definition for `jeffreys-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([j1 (jeffreys-divergence p q)]\n        [j2 (jeffreys-divergence q p)]\n        [sum-kl (+ (kl-divergence p q) (kl-divergence q p))])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? j1 j2 0.000001)\n         (approx=? j1 sum-kl 0.000001)\n         (>= j1 0)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "jeffreys-divergence"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `jeffreys-divergence`\nSpec: Compute Jeffreys divergence J(P,Q)=KL(P||Q)+KL(Q||P).\n\nWrite exactly one Scheme function definition for `jeffreys-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (jeffreys-divergence p q)\n  ;; TODO: sum forward and reverse KL divergence\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `jeffreys-divergence`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([j1 (jeffreys-divergence p q)]\n        [j2 (jeffreys-divergence q p)]\n        [sum-kl (+ (kl-divergence p q) (kl-divergence q p))])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? j1 j2 0.000001)\n         (approx=? j1 sum-kl 0.000001)\n         (>= j1 0)))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "jeffreys-divergence"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (jeffreys-divergence p q)\n  ;; TODO: sum forward and reverse KL divergence\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `jeffreys-divergence`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "info_statistical_measures_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `alpha-divergence`\nSpec: Compute alpha-divergence with branches alpha=1 -> KL, alpha=0 -> -ln(overlap mass in Q over P support), otherwise log-sum term divided by alpha(alpha-1).\n\nWrite exactly one Scheme function definition for `alpha-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "spec-to-code", "alpha-divergence"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this statistical measure in Fold-native Scheme.\n\nTarget module: lattice/info/statistical-measures.ss\nFunction: `alpha-divergence`\nSpec: Compute alpha-divergence with branches alpha=1 -> KL, alpha=0 -> -ln(overlap mass in Q over P support), otherwise log-sum term divided by alpha(alpha-1).\n\nWrite exactly one Scheme function definition for `alpha-divergence`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "info_statistical_measures_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alpha-divergence alpha p q)\n  ;; TODO: handle alpha=1, alpha=0, and generic alpha branches\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alpha-divergence`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "skeleton-completion", "alpha-divergence"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alpha-divergence alpha p q)\n  ;; TODO: handle alpha=1, alpha=0, and generic alpha branches\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alpha-divergence`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "info_statistical_measures_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bhattacharyya-coefficient`.\nReturn only the Scheme definition.\n\n```python\ndef bhattacharyya_coefficient(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    return sum(0 if (pi < 0 or qi < 0) else (pi * qi) ** 0.5 for pi, qi in zip(p, q))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "bhattacharyya-coefficient"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bhattacharyya-coefficient`.\nReturn only the Scheme definition.\n\n```python\ndef bhattacharyya_coefficient(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    return sum(0 if (pi < 0 or qi < 0) else (pi * qi) ** 0.5 for pi, qi in zip(p, q))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `bhattacharyya-coefficient`.\nReturn only the function definition.\n\n```scheme\n(define (bc p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                        (if (or (< pi 0) (< qi 0))\n                            0\n                            (sqrt (* pi qi))))\n                      p q))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "bhattacharyya-coefficient"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `bhattacharyya-coefficient`.\nReturn only the function definition.\n\n```scheme\n(define (bc p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                        (if (or (< pi 0) (< qi 0))\n                            0\n                            (sqrt (* pi qi))))\n                      p q))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_statistical_measures_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bhattacharyya-distance`.\nReturn only the Scheme definition.\n\n```python\ndef bhattacharyya_distance(p, q):\n    bc = bhattacharyya_coefficient(p, q)\n    if bc <= 0:\n        return float('inf')\n    return -log(bc)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-distance '(1 0) '(0 1))]\n      [p '(0.6 0.3 0.1)]\n      [q '(0.4 0.4 0.2)])\n  (let ([bc (bhattacharyya-coefficient p q)]\n        [bd (bhattacharyya-distance p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= disjoint +inf.0)\n         (approx=? (- (log-num bc)) bd 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "bhattacharyya-distance"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bhattacharyya-distance`.\nReturn only the Scheme definition.\n\n```python\ndef bhattacharyya_distance(p, q):\n    bc = bhattacharyya_coefficient(p, q)\n    if bc <= 0:\n        return float('inf')\n    return -log(bc)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `bhattacharyya-distance`.\nReturn only the function definition.\n\n```scheme\n(define (bd p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n    (if (<= bc 0)\n        +inf.0\n        (- (log-num bc)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-distance '(1 0) '(0 1))]\n      [p '(0.6 0.3 0.1)]\n      [q '(0.4 0.4 0.2)])\n  (let ([bc (bhattacharyya-coefficient p q)]\n        [bd (bhattacharyya-distance p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= disjoint +inf.0)\n         (approx=? (- (log-num bc)) bd 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "bhattacharyya-distance"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `bhattacharyya-distance`.\nReturn only the function definition.\n\n```scheme\n(define (bd p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n    (if (<= bc 0)\n        +inf.0\n        (- (log-num bc)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `hellinger-distance`.\nReturn only the Scheme definition.\n\n```python\ndef hellinger_distance(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 1\n    sq = sum((max(0.0, pi) ** 0.5 - max(0.0, qi) ** 0.5) ** 2 for pi, qi in zip(p, q))\n    return (0.5 * sq) ** 0.5\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))]\n      [disjoint (hellinger-distance '(1 0 0) '(0 1 0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([h (hellinger-distance p q)]\n        [bc (bhattacharyya-coefficient p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? 1.0 disjoint 0.000001)\n         (approx=? (* h h) (- 1 bc) 0.000001)\n         (<= h 1.0)\n         (>= h 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "hellinger-distance"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `hellinger-distance`.\nReturn only the Scheme definition.\n\n```python\ndef hellinger_distance(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 1\n    sq = sum((max(0.0, pi) ** 0.5 - max(0.0, qi) ** 0.5) ** 2 for pi, qi in zip(p, q))\n    return (0.5 * sq) ** 0.5\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_statistical_measures_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `hellinger-distance`.\nReturn only the function definition.\n\n```scheme\n(define (hellinger p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                      (let ([diff (- (sqrt (max 0 pi))\n                                                     (sqrt (max 0 qi)))])\n                                        (* diff diff)))\n                                    p q))])\n        (sqrt (* 0.5 sum-sq)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))]\n      [disjoint (hellinger-distance '(1 0 0) '(0 1 0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([h (hellinger-distance p q)]\n        [bc (bhattacharyya-coefficient p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? 1.0 disjoint 0.000001)\n         (approx=? (* h h) (- 1 bc) 0.000001)\n         (<= h 1.0)\n         (>= h 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "hellinger-distance"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `hellinger-distance`.\nReturn only the function definition.\n\n```scheme\n(define (hellinger p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                      (let ([diff (- (sqrt (max 0 pi))\n                                                     (sqrt (max 0 qi)))])\n                                        (* diff diff)))\n                                    p q))])\n        (sqrt (* 0.5 sum-sq)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_statistical_measures_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `total-variation-distance`.\nReturn only the Scheme definition.\n\n```python\ndef total_variation_distance(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 1\n    return 0.5 * sum(abs(pi - qi) for pi, qi in zip(p, q))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))]\n      [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([tv1 (total-variation-distance p q)]\n        [tv2 (total-variation-distance q p)])\n    (and (approx=? 0.0 tv-same 0.000001)\n         (approx=? 0.3 tv-known 0.000001)\n         (approx=? tv1 tv2 0.000001)\n         (<= tv1 1.0)\n         (>= tv1 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "total-variation-distance"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `total-variation-distance`.\nReturn only the Scheme definition.\n\n```python\ndef total_variation_distance(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 1\n    return 0.5 * sum(abs(pi - qi) for pi, qi in zip(p, q))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_statistical_measures_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `total-variation-distance`.\nReturn only the function definition.\n\n```scheme\n(define (tv-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                               (abs (- pi qi)))\n                             p q)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))]\n      [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([tv1 (total-variation-distance p q)]\n        [tv2 (total-variation-distance q p)])\n    (and (approx=? 0.0 tv-same 0.000001)\n         (approx=? 0.3 tv-known 0.000001)\n         (approx=? tv1 tv2 0.000001)\n         (<= tv1 1.0)\n         (>= tv1 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "total-variation-distance"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `total-variation-distance`.\nReturn only the function definition.\n\n```scheme\n(define (tv-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                               (abs (- pi qi)))\n                             p q)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `chi-squared-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef chi_squared_divergence(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    total = 0.0\n    for pi, qi in zip(p, q):\n        if qi <= 0:\n            if pi > 0:\n                return float('inf')\n            continue\n        diff = pi - qi\n        total += (diff * diff) / qi\n    return total\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "chi-squared-divergence"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `chi-squared-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef chi_squared_divergence(p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    total = 0.0\n    for pi, qi in zip(p, q):\n        if qi <= 0:\n            if pi > 0:\n                return float('inf')\n            continue\n        diff = pi - qi\n        total += (diff * diff) / qi\n    return total\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_statistical_measures_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `chi-squared-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (chi2-div p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                        (cond\n                          [(<= qi 0)\n                           (if (> pi 0) +inf.0 0)]\n                          [else\n                           (let ([diff (- pi qi)])\n                             (/ (* diff diff) qi))]))\n                      p q))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "chi-squared-divergence"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `chi-squared-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (chi2-div p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                        (cond\n                          [(<= qi 0)\n                           (if (> pi 0) +inf.0 0)]\n                          [else\n                           (let ([diff (- pi qi)])\n                             (/ (* diff diff) qi))]))\n                      p q))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_statistical_measures_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `symmetric-chi-squared`.\nReturn only the Scheme definition.\n\n```python\ndef symmetric_chi_squared(p, q):\n    pq = chi_squared_divergence(p, q)\n    qp = chi_squared_divergence(q, p)\n    if pq == float('inf') or qp == float('inf'):\n        return float('inf')\n    return (pq + qp) / 2\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([s1 (symmetric-chi-squared p q)]\n        [s2 (symmetric-chi-squared q p)]\n        [avg (/ (+ (chi-squared-divergence p q)\n                   (chi-squared-divergence q p))\n                2)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? s1 s2 0.000001)\n         (approx=? s1 avg 0.000001)\n         (>= s1 0)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "symmetric-chi-squared"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `symmetric-chi-squared`.\nReturn only the Scheme definition.\n\n```python\ndef symmetric_chi_squared(p, q):\n    pq = chi_squared_divergence(p, q)\n    qp = chi_squared_divergence(q, p)\n    if pq == float('inf') or qp == float('inf'):\n        return float('inf')\n    return (pq + qp) / 2\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_statistical_measures_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `symmetric-chi-squared`.\nReturn only the function definition.\n\n```scheme\n(define (sym-chi2 p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n    (if (or (= pq +inf.0) (= qp +inf.0))\n        +inf.0\n        (/ (+ pq qp) 2))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([s1 (symmetric-chi-squared p q)]\n        [s2 (symmetric-chi-squared q p)]\n        [avg (/ (+ (chi-squared-divergence p q)\n                   (chi-squared-divergence q p))\n                2)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? s1 s2 0.000001)\n         (approx=? s1 avg 0.000001)\n         (>= s1 0)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "symmetric-chi-squared"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `symmetric-chi-squared`.\nReturn only the function definition.\n\n```scheme\n(define (sym-chi2 p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n    (if (or (= pq +inf.0) (= qp +inf.0))\n        +inf.0\n        (/ (+ pq qp) 2))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_statistical_measures_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `jeffreys-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef jeffreys_divergence(p, q):\n    return kl_divergence(p, q) + kl_divergence(q, p)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([j1 (jeffreys-divergence p q)]\n        [j2 (jeffreys-divergence q p)]\n        [sum-kl (+ (kl-divergence p q) (kl-divergence q p))])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? j1 j2 0.000001)\n         (approx=? j1 sum-kl 0.000001)\n         (>= j1 0)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "jeffreys-divergence"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `jeffreys-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef jeffreys_divergence(p, q):\n    return kl_divergence(p, q) + kl_divergence(q, p)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "info_statistical_measures_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `jeffreys-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (jeffreys p q)\n  (let ([fwd (kl-divergence p q)]\n        [rev (kl-divergence q p)])\n    (+ fwd rev)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([j1 (jeffreys-divergence p q)]\n        [j2 (jeffreys-divergence q p)]\n        [sum-kl (+ (kl-divergence p q) (kl-divergence q p))])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? j1 j2 0.000001)\n         (approx=? j1 sum-kl 0.000001)\n         (>= j1 0)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "jeffreys-divergence"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `jeffreys-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (jeffreys p q)\n  (let ([fwd (kl-divergence p q)]\n        [rev (kl-divergence q p)])\n    (+ fwd rev)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "info_statistical_measures_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `alpha-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef alpha_divergence(alpha, p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    if alpha == 1:\n        return kl_divergence(p, q)\n    if alpha == 0:\n        overlap = sum(qi for pi, qi in zip(p, q) if pi > 0 and qi > 0)\n        return -log(overlap)\n    total = sum(\n        0 if (pi <= 0 or qi <= 0) else (pi ** alpha) * (qi ** (1 - alpha))\n        for pi, qi in zip(p, q)\n    )\n    if total <= 0:\n        return float('inf')\n    return log(total) / (alpha * (alpha - 1))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "python-to-scheme", "alpha-divergence"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `alpha-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef alpha_divergence(alpha, p, q):\n    if len(p) == 0 or len(q) == 0:\n        return 0\n    if alpha == 1:\n        return kl_divergence(p, q)\n    if alpha == 0:\n        overlap = sum(qi for pi, qi in zip(p, q) if pi > 0 and qi > 0)\n        return -log(overlap)\n    total = sum(\n        0 if (pi <= 0 or qi <= 0) else (pi ** alpha) * (qi ** (1 - alpha))\n        for pi, qi in zip(p, q)\n    )\n    if total <= 0:\n        return float('inf')\n    return log(total) / (alpha * (alpha - 1))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `alpha-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (alpha-div a p q)\n  (cond\n    [(or (null? p) (null? q)) 0]\n    [(= a 1)\n     (kl-divergence p q)]\n    [(= a 0)\n     (- (log-num (fold-left + 0\n                            (map (lambda (pi qi)\n                                   (if (and (> pi 0) (> qi 0)) qi 0))\n                                 p q))))]\n    [else\n     (let ([s (fold-left + 0\n                         (map (lambda (pi qi)\n                                (if (or (<= pi 0) (<= qi 0))\n                                    0\n                                    (* (expt pi a) (expt qi (- 1 a)))))\n                              p q))])\n       (if (<= s 0)\n           +inf.0\n           (/ (log-num s)\n              (* a (- a 1)))))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "chez-to-fold", "alpha-divergence"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nThe following Chez-style helper captures the desired behavior.\nRewrite it as Fold-native Scheme and name the function `alpha-divergence`.\nReturn only the function definition.\n\n```scheme\n(define (alpha-div a p q)\n  (cond\n    [(or (null? p) (null? q)) 0]\n    [(= a 1)\n     (kl-divergence p q)]\n    [(= a 0)\n     (- (log-num (fold-left + 0\n                            (map (lambda (pi qi)\n                                   (if (and (> pi 0) (> qi 0)) qi 0))\n                                 p q))))]\n    [else\n     (let ([s (fold-left + 0\n                         (map (lambda (pi qi)\n                                (if (or (<= pi 0) (<= qi 0))\n                                    0\n                                    (* (expt pi a) (expt qi (- 1 a)))))\n                              p q))])\n       (if (<= s 0)\n           +inf.0\n           (/ (log-num s)\n              (* a (- a 1)))))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "info_statistical_measures_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-coefficient`\nKnown issue: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (* pi qi)))\n                      p q))))\n```\n\nReturn only the corrected definition for `bhattacharyya-coefficient`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "bhattacharyya-coefficient"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-coefficient`\nKnown issue: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (* pi qi)))\n                      p q))))\n```\n\nReturn only the corrected definition for `bhattacharyya-coefficient`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Each term must be sqrt(p_i*q_i), not p_i*q_i.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-coefficient`\nKnown issue: Empty-list behavior must return 0, not 1.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      1\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n```\n\nReturn only the corrected definition for `bhattacharyya-coefficient`.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))]\n      [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))])\n  (and (approx=? 1.0 same 0.000001)\n       (approx=? ab ba 0.000001)\n       (approx=? 0.0 disjoint 0.000001)\n       (<= ab 1.0)\n       (>= ab 0.0))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "bhattacharyya-coefficient"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-coefficient`\nKnown issue: Empty-list behavior must return 0, not 1.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      1\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n```\n\nReturn only the corrected definition for `bhattacharyya-coefficient`.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [ab (bhattacharyya-coefficient '(0.5 0.3 0.2) '(0.4 0.35 0.25))] [ba (bhattacharyya-coefficient '(0.4 0.35 0.25) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-coefficient '(1 0) '(0 1))]) (and (approx=? 1.0 same 0.000001) (approx=? ab ba 0.000001) (approx=? 0.0 disjoint 0.000001) (<= ab 1.0) (>= ab 0.0))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_statistical_measures_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-distance`\nKnown issue: Distance is -ln(BC), so the log term must be negated.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (log-num bc))))\n```\n\nReturn only the corrected definition for `bhattacharyya-distance`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Distance is -ln(BC), so the log term must be negated.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-distance '(1 0) '(0 1))]\n      [p '(0.6 0.3 0.1)]\n      [q '(0.4 0.4 0.2)])\n  (let ([bc (bhattacharyya-coefficient p q)]\n        [bd (bhattacharyya-distance p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= disjoint +inf.0)\n         (approx=? (- (log-num bc)) bd 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "bhattacharyya-distance"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-distance`\nKnown issue: Distance is -ln(BC), so the log term must be negated.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (log-num bc))))\n```\n\nReturn only the corrected definition for `bhattacharyya-distance`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Distance is -ln(BC), so the log term must be negated.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-distance`\nKnown issue: When BC<=0, the function must return +inf.0.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           0\n           (- (log-num bc)))))\n```\n\nReturn only the corrected definition for `bhattacharyya-distance`.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [disjoint (bhattacharyya-distance '(1 0) '(0 1))]\n      [p '(0.6 0.3 0.1)]\n      [q '(0.4 0.4 0.2)])\n  (let ([bc (bhattacharyya-coefficient p q)]\n        [bd (bhattacharyya-distance p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= disjoint +inf.0)\n         (approx=? (- (log-num bc)) bd 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "bhattacharyya-distance"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `bhattacharyya-distance`\nKnown issue: When BC<=0, the function must return +inf.0.\n\nBuggy implementation:\n```scheme\n(define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           0\n           (- (log-num bc)))))\n```\n\nReturn only the corrected definition for `bhattacharyya-distance`.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (bhattacharyya-distance '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [disjoint (bhattacharyya-distance '(1 0) '(0 1))] [p '(0.6 0.3 0.1)] [q '(0.4 0.4 0.2)]) (let ([bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? 0.0 same 0.000001) (= disjoint +inf.0) (approx=? (- (log-num bc)) bd 0.000001)))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_statistical_measures_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `hellinger-distance`\nKnown issue: Hellinger needs the 0.5 factor inside the square root.\n\nBuggy implementation:\n```scheme\n(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt sum-sq))))\n```\n\nReturn only the corrected definition for `hellinger-distance`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Hellinger needs the 0.5 factor inside the square root.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))]\n      [disjoint (hellinger-distance '(1 0 0) '(0 1 0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([h (hellinger-distance p q)]\n        [bc (bhattacharyya-coefficient p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? 1.0 disjoint 0.000001)\n         (approx=? (* h h) (- 1 bc) 0.000001)\n         (<= h 1.0)\n         (>= h 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "hellinger-distance"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `hellinger-distance`\nKnown issue: Hellinger needs the 0.5 factor inside the square root.\n\nBuggy implementation:\n```scheme\n(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt sum-sq))))\n```\n\nReturn only the corrected definition for `hellinger-distance`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Hellinger needs the 0.5 factor inside the square root.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `hellinger-distance`\nKnown issue: Empty-list behavior should be 1 for this API, not 0.\n\nBuggy implementation:\n```scheme\n(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      0\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n```\n\nReturn only the corrected definition for `hellinger-distance`.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))]\n      [disjoint (hellinger-distance '(1 0 0) '(0 1 0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([h (hellinger-distance p q)]\n        [bc (bhattacharyya-coefficient p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? 1.0 disjoint 0.000001)\n         (approx=? (* h h) (- 1 bc) 0.000001)\n         (<= h 1.0)\n         (>= h 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "hellinger-distance"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `hellinger-distance`\nKnown issue: Empty-list behavior should be 1 for this API, not 0.\n\nBuggy implementation:\n```scheme\n(define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      0\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n```\n\nReturn only the corrected definition for `hellinger-distance`.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (hellinger-distance '(0.5 0.5) '(0.5 0.5))] [disjoint (hellinger-distance '(1 0 0) '(0 1 0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([h (hellinger-distance p q)] [bc (bhattacharyya-coefficient p q)]) (and (approx=? 0.0 same 0.000001) (approx=? 1.0 disjoint 0.000001) (approx=? (* h h) (- 1 bc) 0.000001) (<= h 1.0) (>= h 0.0)))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_statistical_measures_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `total-variation-distance`\nKnown issue: TV requires absolute differences before summation.\n\nBuggy implementation:\n```scheme\n(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (- pi qi))\n                             p q)))))\n```\n\nReturn only the corrected definition for `total-variation-distance`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: TV requires absolute differences before summation.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))]\n      [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([tv1 (total-variation-distance p q)]\n        [tv2 (total-variation-distance q p)])\n    (and (approx=? 0.0 tv-same 0.000001)\n         (approx=? 0.3 tv-known 0.000001)\n         (approx=? tv1 tv2 0.000001)\n         (<= tv1 1.0)\n         (>= tv1 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "total-variation-distance"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `total-variation-distance`\nKnown issue: TV requires absolute differences before summation.\n\nBuggy implementation:\n```scheme\n(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (- pi qi))\n                             p q)))))\n```\n\nReturn only the corrected definition for `total-variation-distance`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: TV requires absolute differences before summation.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))] [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([tv1 (total-variation-distance p q)] [tv2 (total-variation-distance q p)]) (and (approx=? 0.0 tv-same 0.000001) (approx=? 0.3 tv-known 0.000001) (approx=? tv1 tv2 0.000001) (<= tv1 1.0) (>= tv1 0.0)))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "info_statistical_measures_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `total-variation-distance`\nKnown issue: The total variation formula includes a leading factor of 0.5.\n\nBuggy implementation:\n```scheme\n(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (abs (- pi qi)))\n                      p q))))\n```\n\nReturn only the corrected definition for `total-variation-distance`.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([tv-same (total-variation-distance '(0.5 0.5) '(0.5 0.5))]\n      [tv-known (total-variation-distance '(0.5 0.5) '(0.8 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([tv1 (total-variation-distance p q)]\n        [tv2 (total-variation-distance q p)])\n    (and (approx=? 0.0 tv-same 0.000001)\n         (approx=? 0.3 tv-known 0.000001)\n         (approx=? tv1 tv2 0.000001)\n         (<= tv1 1.0)\n         (>= tv1 0.0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "total-variation-distance"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `total-variation-distance`\nKnown issue: The total variation formula includes a leading factor of 0.5.\n\nBuggy implementation:\n```scheme\n(define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (abs (- pi qi)))\n                      p q))))\n```\n\nReturn only the corrected definition for `total-variation-distance`.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_statistical_measures_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `chi-squared-divergence`\nKnown issue: Denominator must be q_i, not p_i.\n\nBuggy implementation:\n```scheme\n(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) pi))]))\n                      p q))))\n```\n\nReturn only the corrected definition for `chi-squared-divergence`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "chi-squared-divergence"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `chi-squared-divergence`\nKnown issue: Denominator must be q_i, not p_i.\n\nBuggy implementation:\n```scheme\n(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) pi))]))\n                      p q))))\n```\n\nReturn only the corrected definition for `chi-squared-divergence`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([chi (chi-squared-divergence p q)]) (and (approx=? 0.0 same 0.000001) (= inf-case +inf.0) (>= chi 0)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `chi-squared-divergence`\nKnown issue: If q_i<=0 while p_i>0, the divergence must be +inf.0.\n\nBuggy implementation:\n```scheme\n(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0) 0]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n```\n\nReturn only the corrected definition for `chi-squared-divergence`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (chi-squared-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [inf-case (chi-squared-divergence '(0.5 0.5) '(1.0 0.0))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([chi (chi-squared-divergence p q)])\n    (and (approx=? 0.0 same 0.000001)\n         (= inf-case +inf.0)\n         (>= chi 0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "chi-squared-divergence"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `chi-squared-divergence`\nKnown issue: If q_i<=0 while p_i>0, the divergence must be +inf.0.\n\nBuggy implementation:\n```scheme\n(define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0) 0]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n```\n\nReturn only the corrected definition for `chi-squared-divergence`.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `symmetric-chi-squared`\nKnown issue: Symmetric chi-squared is the average, so divide by 2.\n\nBuggy implementation:\n```scheme\n(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (+ pq qp))))\n```\n\nReturn only the corrected definition for `symmetric-chi-squared`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Symmetric chi-squared is the average, so divide by 2.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([s1 (symmetric-chi-squared p q)]\n        [s2 (symmetric-chi-squared q p)]\n        [avg (/ (+ (chi-squared-divergence p q)\n                   (chi-squared-divergence q p))\n                2)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? s1 s2 0.000001)\n         (approx=? s1 avg 0.000001)\n         (>= s1 0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "symmetric-chi-squared"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `symmetric-chi-squared`\nKnown issue: Symmetric chi-squared is the average, so divide by 2.\n\nBuggy implementation:\n```scheme\n(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (+ pq qp))))\n```\n\nReturn only the corrected definition for `symmetric-chi-squared`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Symmetric chi-squared is the average, so divide by 2.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([s1 (symmetric-chi-squared p q)] [s2 (symmetric-chi-squared q p)] [avg (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2)]) (and (approx=? 0.0 same 0.000001) (approx=? s1 s2 0.000001) (approx=? s1 avg 0.000001) (>= s1 0)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `symmetric-chi-squared`\nKnown issue: This loses symmetry by dropping the reverse-direction term.\n\nBuggy implementation:\n```scheme\n(define (symmetric-chi-squared p q)\n  (chi-squared-divergence p q))\n```\n\nReturn only the corrected definition for `symmetric-chi-squared`.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (symmetric-chi-squared '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([s1 (symmetric-chi-squared p q)]\n        [s2 (symmetric-chi-squared q p)]\n        [avg (/ (+ (chi-squared-divergence p q)\n                   (chi-squared-divergence q p))\n                2)])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? s1 s2 0.000001)\n         (approx=? s1 avg 0.000001)\n         (>= s1 0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "symmetric-chi-squared"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `symmetric-chi-squared`\nKnown issue: This loses symmetry by dropping the reverse-direction term.\n\nBuggy implementation:\n```scheme\n(define (symmetric-chi-squared p q)\n  (chi-squared-divergence p q))\n```\n\nReturn only the corrected definition for `symmetric-chi-squared`.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_statistical_measures_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `jeffreys-divergence`\nKnown issue: Jeffreys divergence sums forward and reverse KL; it does not subtract.\n\nBuggy implementation:\n```scheme\n(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (- kl-pq kl-qp)))\n```\n\nReturn only the corrected definition for `jeffreys-divergence`.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([j1 (jeffreys-divergence p q)]\n        [j2 (jeffreys-divergence q p)]\n        [sum-kl (+ (kl-divergence p q) (kl-divergence q p))])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? j1 j2 0.000001)\n         (approx=? j1 sum-kl 0.000001)\n         (>= j1 0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "jeffreys-divergence"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `jeffreys-divergence`\nKnown issue: Jeffreys divergence sums forward and reverse KL; it does not subtract.\n\nBuggy implementation:\n```scheme\n(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (- kl-pq kl-qp)))\n```\n\nReturn only the corrected definition for `jeffreys-divergence`.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))] [p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (let ([j1 (jeffreys-divergence p q)] [j2 (jeffreys-divergence q p)] [sum-kl (+ (kl-divergence p q) (kl-divergence q p))]) (and (approx=? 0.0 same 0.000001) (approx=? j1 j2 0.000001) (approx=? j1 sum-kl 0.000001) (>= j1 0)))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_statistical_measures_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `jeffreys-divergence`\nKnown issue: The reverse KL term is missing.\n\nBuggy implementation:\n```scheme\n(define (jeffreys-divergence p q)\n  (kl-divergence p q))\n```\n\nReturn only the corrected definition for `jeffreys-divergence`.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([same (jeffreys-divergence '(0.5 0.3 0.2) '(0.5 0.3 0.2))]\n      [p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)])\n  (let ([j1 (jeffreys-divergence p q)]\n        [j2 (jeffreys-divergence q p)]\n        [sum-kl (+ (kl-divergence p q) (kl-divergence q p))])\n    (and (approx=? 0.0 same 0.000001)\n         (approx=? j1 j2 0.000001)\n         (approx=? j1 sum-kl 0.000001)\n         (>= j1 0)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "jeffreys-divergence"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `jeffreys-divergence`\nKnown issue: The reverse KL term is missing.\n\nBuggy implementation:\n```scheme\n(define (jeffreys-divergence p q)\n  (kl-divergence p q))\n```\n\nReturn only the corrected definition for `jeffreys-divergence`.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_statistical_measures_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `alpha-divergence`\nKnown issue: At alpha=1 this branch must reduce to KL(P||Q), not KL(Q||P).\n\nBuggy implementation:\n```scheme\n(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence q p)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n```\n\nReturn only the corrected definition for `alpha-divergence`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: At alpha=1 this branch must reduce to KL(P||Q), not KL(Q||P).\n\nExpected behavior after patch:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "alpha-divergence"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `alpha-divergence`\nKnown issue: At alpha=1 this branch must reduce to KL(P||Q), not KL(Q||P).\n\nBuggy implementation:\n```scheme\n(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence q p)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n```\n\nReturn only the corrected definition for `alpha-divergence`.\n\nRepair the defect without broad refactoring.\n\nBug report summary: At alpha=1 this branch must reduce to KL(P||Q), not KL(Q||P).\n\nExpected behavior after patch:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "info_statistical_measures_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `alpha-divergence`\nKnown issue: The general-case denominator should be alpha*(alpha-1), not alpha*(1-alpha).\n\nBuggy implementation:\n```scheme\n(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- 1 alpha)))))]))\n```\n\nReturn only the corrected definition for `alpha-divergence`.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.3 0.2)]\n      [q '(0.4 0.35 0.25)]\n      [same '(0.333333 0.333333 0.333334)])\n  (let ([alpha1 (alpha-divergence 1 p q)]\n        [kl (kl-divergence p q)]\n        [alpha-close (alpha-divergence 0.9999 p q)]\n        [alpha-half (alpha-divergence 0.5 p q)]\n        [alpha-same (alpha-divergence 0.5 same same)])\n    (and (approx=? alpha1 kl 0.000001)\n         (approx=? alpha-close kl 0.1)\n         (>= alpha-half 0)\n         (approx=? 0.0 alpha-same 0.000001)))))", "tags": ["tier1", "info", "statistical-measures", "bugfix", "alpha-divergence"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nRepair this Fold function with a minimal, focused patch.\n\nFunction: `alpha-divergence`\nKnown issue: The general-case denominator should be alpha*(alpha-1), not alpha*(1-alpha).\n\nBuggy implementation:\n```scheme\n(define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- 1 alpha)))))]))\n```\n\nReturn only the corrected definition for `alpha-divergence`.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [same '(0.333333 0.333333 0.333334)]) (let ([alpha1 (alpha-divergence 1 p q)] [kl (kl-divergence p q)] [alpha-close (alpha-divergence 0.9999 p q)] [alpha-half (alpha-divergence 0.5 p q)] [alpha-same (alpha-divergence 0.5 same same)]) (and (approx=? alpha1 kl 0.000001) (approx=? alpha-close kl 0.1) (>= alpha-half 0) (approx=? 0.0 alpha-same 0.000001)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "info_statistical_measures_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Normalize two non-negative weight vectors and compute their Bhattacharyya coefficient.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (normalize-distribution '(2 3 5))] [q (normalize-distribution '(3 3 4))]) (bhattacharyya-coefficient p q))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(2 3 5))] [q (normalize-distribution '(3 3 4))] [bc (bhattacharyya-coefficient p q)]) (and (>= bc 0) (<= bc 1) (approx=? bc (bhattacharyya-coefficient q p) 0.000001))))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-coefficient", "normalization", "range"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Normalize two non-negative weight vectors and compute their Bhattacharyya coefficient.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_002", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Use BC to reconstruct squared Hellinger distance through H = sqrt(1 - BC). Return a Boolean assertion.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [bc (bhattacharyya-coefficient p q)] [h (hellinger-distance-from-bc bc)]) (approx=? (* h h) (- 1 bc) 0.000001))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (hellinger-distance-from-bc bc)\n  (sqrt (- 1 (max 0 (min 1 bc)))))\n  (equal? (let* ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [bc (bhattacharyya-coefficient p q)] [h (hellinger-distance-from-bc bc)]) (approx=? (* h h) (- 1 bc) 0.000001)) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-coefficient", "cross-measure", "hellinger"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Use BC to reconstruct squared Hellinger distance through H = sqrt(1 - BC). Return a Boolean assertion.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: For disjoint support distributions, return whether BC is zero and Bhattacharyya distance is infinite.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p '(1 0 0 0)] [q '(0 0 1 0)] [bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? bc 0.0 0.000001) (= bd +inf.0)))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let* ([p '(1 0 0 0)] [q '(0 0 1 0)] [bc (bhattacharyya-coefficient p q)] [bd (bhattacharyya-distance p q)]) (and (approx=? bc 0.0 0.000001) (= bd +inf.0))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-coefficient", "edge-case", "distance-link"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: For disjoint support distributions, return whether BC is zero and Bhattacharyya distance is infinite.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-coefficient", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Compute the symmetry residual |BC(P,Q) - BC(Q,P)| for two ternary distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.6 0.25 0.15)] [q '(0.45 0.35 0.20)]) (abs (- (bhattacharyya-coefficient p q) (bhattacharyya-coefficient q p))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let ([p '(0.6 0.25 0.15)] [q '(0.45 0.35 0.20)]) (abs (- (bhattacharyya-coefficient p q) (bhattacharyya-coefficient q p)))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-coefficient", "symmetry", "residual"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-coefficient`\nTask: Compute the symmetry residual |BC(P,Q) - BC(Q,P)| for two ternary distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: Normalize two weight vectors and compute Bhattacharyya distance.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (normalize-distribution '(1 4 5))] [q (normalize-distribution '(2 3 5))]) (bhattacharyya-distance p q))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(1 4 5))] [q (normalize-distribution '(2 3 5))] [bc (bhattacharyya-coefficient p q)] [d (bhattacharyya-distance p q)]) (and (approx=? d (- (log-num bc)) 0.000001) (>= d 0))))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-distance", "normalization", "formula"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: Normalize two weight vectors and compute Bhattacharyya distance.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_006", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: Return whether a highly mismatched pair has larger Bhattacharyya distance than a nearby pair.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([near-p '(0.5 0.3 0.2)] [near-q '(0.45 0.3 0.25)] [far-p '(0.9 0.05 0.05)] [far-q '(0.333333 0.333333 0.333334)] [d-near (bhattacharyya-distance near-p near-q)] [d-far (bhattacharyya-distance far-p far-q)]) (> d-far d-near))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (equal? (let* ([near-p '(0.5 0.3 0.2)] [near-q '(0.45 0.3 0.25)] [far-p '(0.9 0.05 0.05)] [far-q '(0.333333 0.333333 0.333334)] [d-near (bhattacharyya-distance near-p near-q)] [d-far (bhattacharyya-distance far-p far-q)]) (> d-far d-near)) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-distance", "ordering", "contrast"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: Return whether a highly mismatched pair has larger Bhattacharyya distance than a nearby pair.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: Return the residual between D_B(P,Q) and -ln(BC(P,Q)) for one pair.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.7 0.2 0.1)] [q '(0.5 0.3 0.2)]) (- (bhattacharyya-distance p q) (- (log-num (bhattacharyya-coefficient p q)))))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let ([p '(0.7 0.2 0.1)] [q '(0.5 0.3 0.2)]) (- (bhattacharyya-distance p q) (- (log-num (bhattacharyya-coefficient p q))))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-distance", "consistency", "residual"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: Return the residual between D_B(P,Q) and -ln(BC(P,Q)) for one pair.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "bhattacharyya-distance", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: For identical distributions, assert that distance is zero and coefficient is one.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.4 0.35 0.25)]) (and (approx=? 0.0 (bhattacharyya-distance p p) 0.000001) (approx=? 1.0 (bhattacharyya-coefficient p p) 0.000001)))", "verify_expr": "(let ()\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (bhattacharyya-distance p q)\n  (let ([bc (bhattacharyya-coefficient p q)])\n       (if (<= bc 0)\n           +inf.0\n           (- (log-num bc)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.4 0.35 0.25)]) (and (approx=? 0.0 (bhattacharyya-distance p p) 0.000001) (approx=? 1.0 (bhattacharyya-coefficient p p) 0.000001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "bhattacharyya-distance", "identity", "cross-check"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `bhattacharyya-distance`\nTask: For identical distributions, assert that distance is zero and coefficient is one.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Normalize two vectors and compute Hellinger distance.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (normalize-distribution '(2 1 1))] [q (normalize-distribution '(1 2 1))]) (hellinger-distance p q))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(2 1 1))] [q (normalize-distribution '(1 2 1))] [h (hellinger-distance p q)]) (and (>= h 0) (<= h 1) (approx=? h (hellinger-distance q p) 0.000001))))", "tags": ["tier1", "info", "statistical-measures", "composition", "hellinger-distance", "normalization", "range"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Normalize two vectors and compute Hellinger distance.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Return whether direct Hellinger distance matches the BC-derived form sqrt(1 - BC).\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [h (hellinger-distance p q)] [h2 (hellinger-distance-from-bc (bhattacharyya-coefficient p q))]) (approx=? h h2 0.000001))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (bhattacharyya-coefficient p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (< pi 0) (< qi 0))\n                                  0\n                                  (sqrt (* pi qi))))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (hellinger-distance-from-bc bc)\n  (sqrt (- 1 (max 0 (min 1 bc)))))\n  (equal? (let* ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [h (hellinger-distance p q)] [h2 (hellinger-distance-from-bc (bhattacharyya-coefficient p q))]) (approx=? h h2 0.000001)) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "hellinger-distance", "relation", "bhattacharyya"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Return whether direct Hellinger distance matches the BC-derived form sqrt(1 - BC).\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "info_statistical_measures_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Check the triangle inequality H(P,R) <= H(P,Q) + H(Q,R) for three distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [r '(0.9 0.05 0.05)]) (<= (hellinger-distance p r) (+ (hellinger-distance p q) (hellinger-distance q r) 0.001)))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (equal? (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [r '(0.9 0.05 0.05)]) (<= (hellinger-distance p r) (+ (hellinger-distance p q) (hellinger-distance q r) 0.001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "hellinger-distance", "triangle-inequality", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Check the triangle inequality H(P,R) <= H(P,Q) + H(Q,R) for three distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "hellinger-distance", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Compute matusita-distance/sqrt(2) for one pair (it should match Hellinger distance).\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (hellinger-distance p q) (/ (matusita-distance p q) (sqrt 2))))", "verify_expr": "(let ()\n  (define (hellinger-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt (* 0.5 sum-sq)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (matusita-distance p q)\n  (if (or (null? p) (null? q))\n      0\n      (let ([sum-sq (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (let ([diff (- (sqrt (max 0 pi))\n                                                           (sqrt (max 0 qi)))])\n                                                 (* diff diff)))\n                                    p q))])\n           (sqrt sum-sq))))\n  (approx=? 0.0 (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (hellinger-distance p q) (/ (matusita-distance p q) (sqrt 2)))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "hellinger-distance", "matusita", "conversion"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `hellinger-distance`\nTask: Compute matusita-distance/sqrt(2) for one pair (it should match Hellinger distance).\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Normalize two weight vectors and compute total variation distance.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (normalize-distribution '(4 3 3))] [q (normalize-distribution '(3 4 3))]) (total-variation-distance p q))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(4 3 3))] [q (normalize-distribution '(3 4 3))] [tv (total-variation-distance p q)]) (and (>= tv 0) (<= tv 1) (approx=? tv (total-variation-distance q p) 0.000001))))", "tags": ["tier1", "info", "statistical-measures", "composition", "total-variation-distance", "normalization", "range"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Normalize two weight vectors and compute total variation distance.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Return the residual between TV(P,Q) and its manual 0.5*L1 formula for a binary pair.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p '(0.5 0.5)] [q '(0.8 0.2)] [tv (total-variation-distance p q)] [manual (* 0.5 (+ (abs (- 0.5 0.8)) (abs (- 0.5 0.2))))]) (- tv manual))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let* ([p '(0.5 0.5)] [q '(0.8 0.2)] [tv (total-variation-distance p q)] [manual (* 0.5 (+ (abs (- 0.5 0.8)) (abs (- 0.5 0.2))))]) (- tv manual)) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "total-variation-distance", "formula", "residual"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Return the residual between TV(P,Q) and its manual 0.5*L1 formula for a binary pair.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_statistical_measures_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Compute |TV(P,Q) - TV(Q,P)| for two ternary distributions.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (abs (- (total-variation-distance p q) (total-variation-distance q p))))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (abs (- (total-variation-distance p q) (total-variation-distance q p)))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "total-variation-distance", "symmetry", "residual"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Compute |TV(P,Q) - TV(Q,P)| for two ternary distributions.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "total-variation-distance", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Check the TV triangle inequality TV(P,R) <= TV(P,Q) + TV(Q,R) for three distributions.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [r '(0.9 0.05 0.05)]) (<= (total-variation-distance p r) (+ (total-variation-distance p q) (total-variation-distance q r) 0.001)))", "verify_expr": "(let ()\n  (define (total-variation-distance p q)\n  (if (or (null? p) (null? q))\n      1\n      (* 0.5 (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (abs (- pi qi)))\n                             p q)))))\n  (equal? (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)] [r '(0.9 0.05 0.05)]) (<= (total-variation-distance p r) (+ (total-variation-distance p q) (total-variation-distance q r) 0.001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "total-variation-distance", "triangle-inequality", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `total-variation-distance`\nTask: Check the TV triangle inequality TV(P,R) <= TV(P,Q) + TV(Q,R) for three distributions.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Normalize two vectors (strictly positive target) and compute forward chi-squared divergence.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (normalize-distribution '(5 3 2))] [q (normalize-distribution '(4 4 2))]) (chi-squared-divergence p q))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(5 3 2))] [q (normalize-distribution '(4 4 2))] [v (chi-squared-divergence p q)]) (and (>= v 0) (not (= v +inf.0)))))", "tags": ["tier1", "info", "statistical-measures", "composition", "chi-squared-divergence", "normalization", "finite"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Normalize two vectors (strictly positive target) and compute forward chi-squared divergence.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: For one support-mismatch pair, assert forward chi-squared is infinite while reverse remains finite/non-negative.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p '(0.5 0.5)] [q '(1.0 0.0)]) (and (= (chi-squared-divergence p q) +inf.0) (>= (chi-squared-divergence q p) 0)))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (equal? (let ([p '(0.5 0.5)] [q '(1.0 0.0)]) (and (= (chi-squared-divergence p q) +inf.0) (>= (chi-squared-divergence q p) 0))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "chi-squared-divergence", "support-mismatch", "asymmetry"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: For one support-mismatch pair, assert forward chi-squared is infinite while reverse remains finite/non-negative.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_statistical_measures_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Return whether chi-squared is asymmetric on two close ternary distributions.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (not (approx=? (chi-squared-divergence p q) (chi-squared-divergence q p) 0.000001)))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (not (approx=? (chi-squared-divergence p q) (chi-squared-divergence q p) 0.000001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "chi-squared-divergence", "asymmetry", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Return whether chi-squared is asymmetric on two close ternary distributions.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "info_statistical_measures_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "chi-squared-divergence", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Return residual between manual average of forward/reverse chi-squared and symmetric-chi-squared.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2) (symmetric-chi-squared p q)))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2) (symmetric-chi-squared p q))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "chi-squared-divergence", "consistency", "symmetrization"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `chi-squared-divergence`\nTask: Return residual between manual average of forward/reverse chi-squared and symmetric-chi-squared.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "info_statistical_measures_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: Normalize two vectors and compute symmetric chi-squared divergence.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (normalize-distribution '(5 3 2))] [q (normalize-distribution '(4 4 2))]) (symmetric-chi-squared p q))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(5 3 2))] [q (normalize-distribution '(4 4 2))] [v (symmetric-chi-squared p q)]) (and (>= v 0) (approx=? v (symmetric-chi-squared q p) 0.000001))))", "tags": ["tier1", "info", "statistical-measures", "composition", "symmetric-chi-squared", "normalization", "symmetry"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: Normalize two vectors and compute symmetric chi-squared divergence.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: Return whether symmetric chi-squared equals the arithmetic mean of forward and reverse chi-squared.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (approx=? (symmetric-chi-squared p q) (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2) 0.000001))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (approx=? (symmetric-chi-squared p q) (/ (+ (chi-squared-divergence p q) (chi-squared-divergence q p)) 2) 0.000001)) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "symmetric-chi-squared", "mean-identity", "formula"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: Return whether symmetric chi-squared equals the arithmetic mean of forward and reverse chi-squared.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: Compute symmetric chi-squared on disjoint support distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(symmetric-chi-squared '(0.5 0.5 0 0) '(0 0 0.5 0.5))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (equal? (symmetric-chi-squared '(0.5 0.5 0 0) '(0 0 0.5 0.5)) +inf.0))", "tags": ["tier1", "info", "statistical-measures", "composition", "symmetric-chi-squared", "edge-case", "infinite"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: Compute symmetric chi-squared on disjoint support distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "symmetric-chi-squared", "prompt": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: For identical distributions, assert both symmetric chi-squared and Jeffreys divergence are zero.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.5 0.3 0.2)]) (and (approx=? 0.0 (symmetric-chi-squared p p) 0.000001) (approx=? 0.0 (jeffreys-divergence p p) 0.000001)))", "verify_expr": "(let ()\n  (define (chi-squared-divergence p q)\n  (if (or (null? p) (null? q))\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= qi 0)\n                                (if (> pi 0) +inf.0 0)]\n                               [else\n                                (let ([diff (- pi qi)])\n                                     (/ (* diff diff) qi))]))\n                      p q))))\n  (define (symmetric-chi-squared p q)\n  (let ([pq (chi-squared-divergence p q)]\n        [qp (chi-squared-divergence q p)])\n       (if (or (= pq +inf.0) (= qp +inf.0))\n           +inf.0\n           (/ (+ pq qp) 2))))\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.5 0.3 0.2)]) (and (approx=? 0.0 (symmetric-chi-squared p p) 0.000001) (approx=? 0.0 (jeffreys-divergence p p) 0.000001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "symmetric-chi-squared", "identity", "cross-measure"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `symmetric-chi-squared`\nTask: For identical distributions, assert both symmetric chi-squared and Jeffreys divergence are zero.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Normalize two vectors and compute Jeffreys divergence.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (normalize-distribution '(6 3 1))] [q (normalize-distribution '(4 4 2))]) (jeffreys-divergence p q))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(6 3 1))] [q (normalize-distribution '(4 4 2))] [j (jeffreys-divergence p q)]) (approx=? j (+ (kl-divergence p q) (kl-divergence q p)) 0.000001)))", "tags": ["tier1", "info", "statistical-measures", "composition", "jeffreys-divergence", "normalization", "kl-relation"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Normalize two vectors and compute Jeffreys divergence.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Compute symmetry residual |J(P,Q) - J(Q,P)| for two distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (abs (- (jeffreys-divergence p q) (jeffreys-divergence q p))))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (abs (- (jeffreys-divergence p q) (jeffreys-divergence q p)))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "jeffreys-divergence", "symmetry", "residual"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Compute symmetry residual |J(P,Q) - J(Q,P)| for two distributions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Return whether Jeffreys divergence is at least as large as forward KL on one pair.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (>= (jeffreys-divergence p q) (kl-divergence p q)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (equal? (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (>= (jeffreys-divergence p q) (kl-divergence p q))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "jeffreys-divergence", "bound", "kl"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Return whether Jeffreys divergence is at least as large as forward KL on one pair.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "info_statistical_measures_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "jeffreys-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Return the residual between Jeffreys divergence and alpha-divergence at alpha=1 in both directions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (jeffreys-divergence p q) (+ (alpha-divergence 1 p q) (alpha-divergence 1 q p))))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jeffreys-divergence p q)\n  (let ([kl-pq (kl-divergence p q)]\n        [kl-qp (kl-divergence q p)])\n       (+ kl-pq kl-qp)))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (jeffreys-divergence p q) (+ (alpha-divergence 1 p q) (alpha-divergence 1 q p)))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "jeffreys-divergence", "alpha-link", "consistency"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `jeffreys-divergence`\nTask: Return the residual between Jeffreys divergence and alpha-divergence at alpha=1 in both directions.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: Normalize two vectors and compute alpha-divergence for alpha=0.5.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (normalize-distribution '(6 3 1))] [q (normalize-distribution '(4 4 2))]) (alpha-divergence 0.5 p q))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (normalize-distribution weights)\n  (let ([total (fold-left + 0 weights)])\n       (if (<= total 0)\n           (let ([n (length weights)])\n                (map (lambda (_) (/ 1.0 n)) weights))\n           (map (lambda (w) (/ w total)) weights))))\n  (let* ([p (normalize-distribution '(6 3 1))] [q (normalize-distribution '(4 4 2))] [a (alpha-divergence 0.5 p q)]) (and (>= a 0) (not (= a +inf.0)))))", "tags": ["tier1", "info", "statistical-measures", "composition", "alpha-divergence", "normalization", "finite"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: Normalize two vectors and compute alpha-divergence for alpha=0.5.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "info_statistical_measures_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: Return residual between alpha-divergence at alpha=1 and KL divergence.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (alpha-divergence 1 p q) (kl-divergence p q)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (- (alpha-divergence 1 p q) (kl-divergence p q))) 0.000001))", "tags": ["tier1", "info", "statistical-measures", "composition", "alpha-divergence", "limit-case", "kl"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: Return residual between alpha-divergence at alpha=1 and KL divergence.\n\nReturn only the expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "info_statistical_measures_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: Check whether alpha-divergence at alpha=0.9999 is close to KL divergence for one pair.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (approx=? (alpha-divergence 0.9999 p q) (kl-divergence p q) 0.1))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.5 0.3 0.2)] [q '(0.4 0.35 0.25)]) (approx=? (alpha-divergence 0.9999 p q) (kl-divergence p q) 0.1)) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "alpha-divergence", "continuity", "limit"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: Check whether alpha-divergence at alpha=0.9999 is close to KL divergence for one pair.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "info_statistical_measures_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/statistical-measures.ss", "source_test": "lattice/info/test-statistical-measures.ss", "source_function": "alpha-divergence", "prompt": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: For an identical distribution pair, assert alpha-divergence is zero for alpha=0.5 and alpha=2.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.333333 0.333333 0.333334)]) (and (approx=? 0.0 (alpha-divergence 0.5 p p) 0.000001) (approx=? 0.0 (alpha-divergence 2 p p) 0.000001)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (alpha-divergence alpha p q)\n  (cond\n   [(or (null? p) (null? q)) 0]\n   [(= alpha 1)\n    (kl-divergence p q)]\n   [(= alpha 0)\n    (- (log-num (fold-left + 0\n                           (map (lambda (pi qi)\n                                        (if (and (> pi 0) (> qi 0))\n                                            qi\n                                            0))\n                                p q))))]\n   [else\n    (let ([sum-term (fold-left + 0\n                               (map (lambda (pi qi)\n                                            (cond\n                                             [(and (<= pi 0) (<= qi 0)) 0]\n                                             [(or (<= pi 0) (<= qi 0)) 0]\n                                             [else\n                                              (* (expt pi alpha)\n                                                 (expt qi (- 1 alpha)))]))\n                                    p q))])\n         (if (<= sum-term 0)\n             +inf.0\n             (/ (log-num sum-term)\n                (* alpha (- alpha 1)))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.333333 0.333333 0.333334)]) (and (approx=? 0.0 (alpha-divergence 0.5 p p) 0.000001) (approx=? 0.0 (alpha-divergence 2 p p) 0.000001))) #t))", "tags": ["tier1", "info", "statistical-measures", "composition", "alpha-divergence", "identity", "multi-alpha"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nWrite one Fold expression (no helper definitions) for this task.\n\nPrimary function: `alpha-divergence`\nTask: For an identical distribution pair, assert alpha-divergence is zero for alpha=0.5 and alpha=2.\n\nReturn only the expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
