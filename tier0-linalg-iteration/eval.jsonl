{"id": "iteration_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-fold-idx`\nSpec: Left-fold over vector indices, updating accumulator with each index.\n\nWrite exactly one `define-syntax` form for `vec-fold-idx`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))", "tags": ["linalg", "iteration", "spec-to-code", "vec-fold-idx"], "split": "eval"}
{"id": "iteration_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `matrix-do!`\nSpec: Execute body for each matrix coordinate (i,j) in row-major nested loops.\n\nWrite exactly one `define-syntax` form for `matrix-do!`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n  (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))", "tags": ["linalg", "iteration", "spec-to-code", "matrix-do!"], "split": "eval"}
{"id": "iteration_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-tabulate`\nSpec: Construct vector of length size where element i is body evaluated with idx=i.\n\nWrite exactly one `define-syntax` form for `vec-tabulate`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))", "tags": ["linalg", "iteration", "spec-to-code", "vec-tabulate"], "split": "eval"}
{"id": "iteration_translation_001", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-map-idx`\n\n```python\ndef vec_map_idx(v, f):\n    n = len(v)\n    out = [0] * n\n    for i in range(n):\n        out[i] = f(i, v)\n    return out\n```\n\nReturn only the Scheme macro definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))", "tags": ["linalg", "iteration", "translation", "python", "vec-map-idx"], "split": "eval"}
{"id": "iteration_translation_009", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `range-fold`\n\n```python\ndef range_fold(init, start, end, step):\n    acc = init\n    i = start\n    while i < end:\n        acc = step(acc, i)\n        i += 1\n    return acc\n```\n\nReturn only the Scheme macro definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (range-fold s 0 i 1 11 (+ s i)) 55)\n(equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (and (= (range-fold s 0 i 1 11 (+ s i)) 55) (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))))", "tags": ["linalg", "iteration", "translation", "python", "range-fold"], "split": "eval"}
{"id": "iteration_translation_016", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-scan`\n\n```scheme\n(define-syntax vscan\n  (syntax-rules ()\n    ((_ size init i acc expr)\n     (let* ((n size)\n            (out (make-vector n 0)))\n       (if (= n 0)\n           out\n           (begin\n             (vector-set! out 0 init)\n             (let loop ((i 1) (acc init))\n               (if (= i n)\n                   out\n                   (let ((acc expr))\n                     (vector-set! out i acc)\n                     (loop (+ i 1) acc))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n  (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))", "tags": ["linalg", "iteration", "translation", "chez", "vec-scan"], "split": "eval"}
{"id": "iteration_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-map-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Macro ignores body and copies input unchanged.\n\n```scheme\n(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx (vector-ref v idx))))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))", "tags": ["linalg", "iteration", "bugfix", "vec-map-idx"], "split": "eval"}
{"id": "iteration_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `range-fold` in `lattice/linalg/iteration.ss`.\nKnown issue: Range starts at start+1, dropping the first term.\n\n```scheme\n(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var (+ start 1) (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(= (range-fold s 0 i 1 11 (+ s i)) 55)\n(equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (and (= (range-fold s 0 i 1 11 (+ s i)) 55) (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))))", "tags": ["linalg", "iteration", "bugfix", "range-fold"], "split": "eval"}
{"id": "iteration_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-scan` in `lattice/linalg/iteration.ss`.\nKnown issue: Recursive step feeds init instead of the updated accumulator.\n\n```scheme\n(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) init)))))))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n  (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))", "tags": ["linalg", "iteration", "bugfix", "vec-scan"], "split": "eval"}
{"id": "iteration_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap square over #(1 2 3 4) using vec-map-idx.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([v (vector 1 2 3 4)]) (vec-map-idx i v (* (vector-ref v i) (vector-ref v i))))", "verify_expr": "(equal? (let ([v (vector 1 2 3 4)]) (vec-map-idx i v (* (vector-ref v i) (vector-ref v i)))) (vector 1 4 9 16))", "tags": ["linalg", "iteration", "composition", "vec-map-idx", "direct"], "split": "eval"}
{"id": "iteration_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: small integration task across module primitives.\n\nAdd #(1 2 3) and #(10 20 30) with vec-zip-map-idx.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([a (vector 1 2 3)] [b (vector 10 20 30)]) (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))) (vector 11 22 33))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([a (vector 1 2 3)] [b (vector 10 20 30)]) (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i))))", "verify_expr": "(equal? (let ([a (vector 1 2 3)] [b (vector 10 20 30)]) (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))) (vector 11 22 33))", "tags": ["linalg", "iteration", "composition", "vec-zip-map-idx", "direct"], "split": "eval"}
{"id": "iteration_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute sum of integers from 1 to 10 using range-fold.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (range-fold s 0 i 1 11 (+ s i)) 55)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(range-fold s 0 i 1 11 (+ s i))", "verify_expr": "(equal? (range-fold s 0 i 1 11 (+ s i)) 55)", "tags": ["linalg", "iteration", "composition", "range-fold", "direct"], "split": "eval"}
{"id": "iteration_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun dot-product-loop with length 0 and return the neutral sum.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dot-product-loop k 0 1 2)", "verify_expr": "(equal? (dot-product-loop k 0 1 2) 0)", "tags": ["linalg", "iteration", "composition", "dot-product-loop", "edge-case"], "split": "eval"}
{"id": "iteration_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse vec-scan to build fibonacci state pairs, then project first component into a vector.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([pairs (vec-scan 6 (cons 1 0) i acc (cons (+ (car acc) (cdr acc)) (car acc)))]) (vec-tabulate 6 j (car (vector-ref pairs j)))) (vector 1 1 2 3 5 8))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([pairs (vec-scan 6 (cons 1 0) i acc (cons (+ (car acc) (cdr acc)) (car acc)))]) (vec-tabulate 6 j (car (vector-ref pairs j))))", "verify_expr": "(equal? (let ([pairs (vec-scan 6 (cons 1 0) i acc (cons (+ (car acc) (cdr acc)) (car acc)))]) (vec-tabulate 6 j (car (vector-ref pairs j)))) (vector 1 1 2 3 5 8))", "tags": ["linalg", "iteration", "composition", "vec-scan", "integration"], "split": "eval"}
