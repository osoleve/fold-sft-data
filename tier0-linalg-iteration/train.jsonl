{"id": "iteration_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-map-idx`\nSpec: Map over a vector with index access and return a newly allocated vector.\n\nWrite exactly one `define-syntax` form for `vec-map-idx`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))", "tags": ["linalg", "iteration", "spec-to-code", "vec-map-idx"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-map-idx`\nSpec: Map over a vector with index access and return a newly allocated vector.\n\nWrite exactly one `define-syntax` form for `vec-map-idx`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "iteration_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-map-idx`\nBehavior contract: Map over a vector with index access and return a newly allocated vector.\n\n```scheme\n(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 ;; TODO: allocate result and map body at each idx\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "vec-map-idx"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-map-idx`\nBehavior contract: Map over a vector with index access and return a newly allocated vector.\n\n```scheme\n(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 ;; TODO: allocate result and map body at each idx\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "iteration_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-fold-idx`\nBehavior contract: Left-fold over vector indices, updating accumulator with each index.\n\n```scheme\n(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 ;; TODO: iterate indices and thread accumulator\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "vec-fold-idx"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-fold-idx`\nBehavior contract: Left-fold over vector indices, updating accumulator with each index.\n\n```scheme\n(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 ;; TODO: iterate indices and thread accumulator\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "iteration_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-zip-map-idx`\nSpec: Zip-map two vectors by index into a new vector of the first vector's length.\n\nWrite exactly one `define-syntax` form for `vec-zip-map-idx`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))", "tags": ["linalg", "iteration", "spec-to-code", "vec-zip-map-idx"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-zip-map-idx`\nSpec: Zip-map two vectors by index into a new vector of the first vector's length.\n\nWrite exactly one `define-syntax` form for `vec-zip-map-idx`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "iteration_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-zip-map-idx`\nBehavior contract: Zip-map two vectors by index into a new vector of the first vector's length.\n\n```scheme\n(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 ;; TODO: zip two vectors by index into new result\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "vec-zip-map-idx"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-zip-map-idx`\nBehavior contract: Zip-map two vectors by index into a new vector of the first vector's length.\n\n```scheme\n(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 ;; TODO: zip two vectors by index into new result\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "iteration_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `matrix-do!`\nBehavior contract: Execute body for each matrix coordinate (i,j) in row-major nested loops.\n\n```scheme\n(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 ;; TODO: nested i/j loops over rows x cols\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n  (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "matrix-do!"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `matrix-do!`\nBehavior contract: Execute body for each matrix coordinate (i,j) in row-major nested loops.\n\n```scheme\n(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 ;; TODO: nested i/j loops over rows x cols\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "iteration_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `range-fold`\nSpec: Fold over integer range [start, end), updating accumulator each step.\n\nWrite exactly one `define-syntax` form for `range-fold`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (and (= (range-fold s 0 i 1 11 (+ s i)) 55) (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))))", "tags": ["linalg", "iteration", "spec-to-code", "range-fold"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `range-fold`\nSpec: Fold over integer range [start, end), updating accumulator each step.\n\nWrite exactly one `define-syntax` form for `range-fold`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "iteration_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `range-fold`\nBehavior contract: Fold over integer range [start, end), updating accumulator each step.\n\n```scheme\n(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 ;; TODO: fold over var from start to end-1\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (and (= (range-fold s 0 i 1 11 (+ s i)) 55) (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "range-fold"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `range-fold`\nBehavior contract: Fold over integer range [start, end), updating accumulator each step.\n\n```scheme\n(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 ;; TODO: fold over var from start to end-1\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "iteration_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `dot-product-loop`\nSpec: Accumulate sum_{k=0..len-1} get-a(k) * get-b(k).\n\nWrite exactly one `define-syntax` form for `dot-product-loop`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))", "verify_expr": "(let ()\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))", "tags": ["linalg", "iteration", "spec-to-code", "dot-product-loop"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `dot-product-loop`\nSpec: Accumulate sum_{k=0..len-1} get-a(k) * get-b(k).\n\nWrite exactly one `define-syntax` form for `dot-product-loop`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "iteration_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `dot-product-loop`\nBehavior contract: Accumulate sum_{k=0..len-1} get-a(k) * get-b(k).\n\n```scheme\n(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 ;; TODO: accumulate sum of pairwise products\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))", "verify_expr": "(let ()\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "dot-product-loop"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `dot-product-loop`\nBehavior contract: Accumulate sum_{k=0..len-1} get-a(k) * get-b(k).\n\n```scheme\n(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 ;; TODO: accumulate sum of pairwise products\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "iteration_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-tabulate`\nBehavior contract: Construct vector of length size where element i is body evaluated with idx=i.\n\n```scheme\n(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 ;; TODO: allocate vector and fill each element from body\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "vec-tabulate"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-tabulate`\nBehavior contract: Construct vector of length size where element i is body evaluated with idx=i.\n\n```scheme\n(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 ;; TODO: allocate vector and fill each element from body\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "iteration_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-scan`\nSpec: Construct prefix-accumulation vector with element 0=init and iterative updates from idx=1.\n\nWrite exactly one `define-syntax` form for `vec-scan`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n  (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))", "tags": ["linalg", "iteration", "spec-to-code", "vec-scan"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this macro in Fold-native Scheme.\n\nTarget module: lattice/linalg/iteration.ss\nMacro: `vec-scan`\nSpec: Construct prefix-accumulation vector with element 0=init and iterative updates from idx=1.\n\nWrite exactly one `define-syntax` form for `vec-scan`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "iteration_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-scan`\nBehavior contract: Construct prefix-accumulation vector with element 0=init and iterative updates from idx=1.\n\n```scheme\n(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 ;; TODO: handle empty case, seed init, iterate idx>=1\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n  (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))", "tags": ["linalg", "iteration", "spec-to-code", "skeleton", "vec-scan"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme macro skeleton.\n\nModule: lattice/linalg/iteration.ss\nMacro target: `vec-scan`\nBehavior contract: Construct prefix-accumulation vector with element 0=init and iterative updates from idx=1.\n\n```scheme\n(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 ;; TODO: handle empty case, seed init, iterate idx>=1\n                 <TODO>]))\n```\n\nOutput only the completed macro definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "iteration_translation_002", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-map-idx`\n\n```scheme\n(define-syntax vmap-idx\n  (syntax-rules ()\n    ((_ i v expr)\n     (let* ((src v)\n            (n (vector-length src))\n            (out (make-vector n 0)))\n       (do ((i 0 (+ i 1)))\n           ((= i n) out)\n         (vector-set! out i expr))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))", "tags": ["linalg", "iteration", "translation", "chez", "vec-map-idx"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-map-idx`\n\n```scheme\n(define-syntax vmap-idx\n  (syntax-rules ()\n    ((_ i v expr)\n     (let* ((src v)\n            (n (vector-length src))\n            (out (make-vector n 0)))\n       (do ((i 0 (+ i 1)))\n           ((= i n) out)\n         (vector-set! out i expr))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "iteration_translation_003", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-fold-idx`\n\n```python\ndef vec_fold_idx(init, v, step):\n    acc = init\n    for i in range(len(v)):\n        acc = step(acc, i, v)\n    return acc\n```\n\nReturn only the Scheme macro definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))", "tags": ["linalg", "iteration", "translation", "python", "vec-fold-idx"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-fold-idx`\n\n```python\ndef vec_fold_idx(init, v, step):\n    acc = init\n    for i in range(len(v)):\n        acc = step(acc, i, v)\n    return acc\n```\n\nReturn only the Scheme macro definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "iteration_translation_004", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-fold-idx`\n\n```scheme\n(define-syntax vfold-idx\n  (syntax-rules ()\n    ((_ acc init i v expr)\n     (let* ((src v)\n            (n (vector-length src)))\n       (do ((i 0 (+ i 1))\n            (acc init expr))\n           ((= i n) acc))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))", "tags": ["linalg", "iteration", "translation", "chez", "vec-fold-idx"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-fold-idx`\n\n```scheme\n(define-syntax vfold-idx\n  (syntax-rules ()\n    ((_ acc init i v expr)\n     (let* ((src v)\n            (n (vector-length src)))\n       (do ((i 0 (+ i 1))\n            (acc init expr))\n           ((= i n) acc))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "iteration_translation_005", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-zip-map-idx`\n\n```python\ndef vec_zip_map_idx(v1, v2, f):\n    n = len(v1)\n    out = [0] * n\n    for i in range(n):\n        out[i] = f(i, v1, v2)\n    return out\n```\n\nReturn only the Scheme macro definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))", "tags": ["linalg", "iteration", "translation", "python", "vec-zip-map-idx"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-zip-map-idx`\n\n```python\ndef vec_zip_map_idx(v1, v2, f):\n    n = len(v1)\n    out = [0] * n\n    for i in range(n):\n        out[i] = f(i, v1, v2)\n    return out\n```\n\nReturn only the Scheme macro definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "iteration_translation_006", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-zip-map-idx`\n\n```scheme\n(define-syntax vzip-map-idx\n  (syntax-rules ()\n    ((_ i a b expr)\n     (let* ((v1 a)\n            (v2 b)\n            (n (vector-length v1))\n            (out (make-vector n 0)))\n       (do ((i 0 (+ i 1)))\n           ((= i n) out)\n         (vector-set! out i expr))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))", "tags": ["linalg", "iteration", "translation", "chez", "vec-zip-map-idx"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-zip-map-idx`\n\n```scheme\n(define-syntax vzip-map-idx\n  (syntax-rules ()\n    ((_ i a b expr)\n     (let* ((v1 a)\n            (v2 b)\n            (n (vector-length v1))\n            (out (make-vector n 0)))\n       (do ((i 0 (+ i 1)))\n           ((= i n) out)\n         (vector-set! out i expr))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "iteration_translation_007", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `matrix-do!`\n\n```python\ndef matrix_do(rows, cols, body):\n    for i in range(rows):\n        for j in range(cols):\n            body(i, j)\n```\n\nReturn only the Scheme macro definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n  (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))", "tags": ["linalg", "iteration", "translation", "python", "matrix-do!"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `matrix-do!`\n\n```python\ndef matrix_do(rows, cols, body):\n    for i in range(rows):\n        for j in range(cols):\n            body(i, j)\n```\n\nReturn only the Scheme macro definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "iteration_translation_008", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `matrix-do!`\n\n```scheme\n(define-syntax mat-do!\n  (syntax-rules ()\n    ((_ i j rows cols body ...)\n     (let ((r rows)\n           (c cols))\n       (do ((i 0 (+ i 1)))\n           ((= i r))\n         (do ((j 0 (+ j 1)))\n             ((= j c))\n           body ...))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n  (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))", "tags": ["linalg", "iteration", "translation", "chez", "matrix-do!"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `matrix-do!`\n\n```scheme\n(define-syntax mat-do!\n  (syntax-rules ()\n    ((_ i j rows cols body ...)\n     (let ((r rows)\n           (c cols))\n       (do ((i 0 (+ i 1)))\n           ((= i r))\n         (do ((j 0 (+ j 1)))\n             ((= j c))\n           body ...))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "iteration_translation_010", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `range-fold`\n\n```scheme\n(define-syntax rfold\n  (syntax-rules ()\n    ((_ acc init i start end expr)\n     (do ((i start (+ i 1))\n          (acc init expr))\n         ((= i end) acc)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (and (= (range-fold s 0 i 1 11 (+ s i)) 55) (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))))", "tags": ["linalg", "iteration", "translation", "chez", "range-fold"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `range-fold`\n\n```scheme\n(define-syntax rfold\n  (syntax-rules ()\n    ((_ acc init i start end expr)\n     (do ((i start (+ i 1))\n          (acc init expr))\n         ((= i end) acc)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "iteration_translation_011", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `dot-product-loop`\n\n```python\ndef dot_product_loop(length, get_a, get_b):\n    s = 0\n    for k in range(length):\n        s += get_a(k) * get_b(k)\n    return s\n```\n\nReturn only the Scheme macro definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))", "verify_expr": "(let ()\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))", "tags": ["linalg", "iteration", "translation", "python", "dot-product-loop"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `dot-product-loop`\n\n```python\ndef dot_product_loop(length, get_a, get_b):\n    s = 0\n    for k in range(length):\n        s += get_a(k) * get_b(k)\n    return s\n```\n\nReturn only the Scheme macro definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "iteration_translation_012", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `dot-product-loop`\n\n```scheme\n(define-syntax dot-loop\n  (syntax-rules ()\n    ((_ k len get-a get-b)\n     (do ((k 0 (+ k 1))\n          (sum 0 (+ sum (* get-a get-b))))\n         ((= k len) sum)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))", "verify_expr": "(let ()\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))", "tags": ["linalg", "iteration", "translation", "chez", "dot-product-loop"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `dot-product-loop`\n\n```scheme\n(define-syntax dot-loop\n  (syntax-rules ()\n    ((_ k len get-a get-b)\n     (do ((k 0 (+ k 1))\n          (sum 0 (+ sum (* get-a get-b))))\n         ((= k len) sum)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "iteration_translation_013", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-tabulate`\n\n```python\ndef vec_tabulate(size, f):\n    out = [0] * size\n    for i in range(size):\n        out[i] = f(i)\n    return out\n```\n\nReturn only the Scheme macro definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))", "tags": ["linalg", "iteration", "translation", "python", "vec-tabulate"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-tabulate`\n\n```python\ndef vec_tabulate(size, f):\n    out = [0] * size\n    for i in range(size):\n        out[i] = f(i)\n    return out\n```\n\nReturn only the Scheme macro definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "iteration_translation_014", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-tabulate`\n\n```scheme\n(define-syntax vtabulate\n  (syntax-rules ()\n    ((_ size i expr)\n     (let* ((n size)\n            (out (make-vector n 0)))\n       (do ((i 0 (+ i 1)))\n           ((= i n) out)\n         (vector-set! out i expr))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))", "tags": ["linalg", "iteration", "translation", "chez", "vec-tabulate"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style macro snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget macro: `vec-tabulate`\n\n```scheme\n(define-syntax vtabulate\n  (syntax-rules ()\n    ((_ size i expr)\n     (let* ((n size)\n            (out (make-vector n 0)))\n       (do ((i 0 (+ i 1)))\n           ((= i n) out)\n         (vector-set! out i expr))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "iteration_translation_015", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-scan`\n\n```python\ndef vec_scan(size, init, step):\n    out = [0] * size\n    if size == 0:\n        return out\n    out[0] = init\n    acc = init\n    for i in range(1, size):\n        acc = step(i, acc)\n        out[i] = acc\n    return out\n```\n\nReturn only the Scheme macro definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n  (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))", "tags": ["linalg", "iteration", "translation", "python", "vec-scan"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python helper into Fold-native Scheme macro form.\nPreserve behavior exactly.\n\nTarget macro name: `vec-scan`\n\n```python\ndef vec_scan(size, init, step):\n    out = [0] * size\n    if size == 0:\n        return out\n    out[0] = init\n    acc = init\n    for i in range(1, size):\n        acc = step(i, acc)\n        out[i] = acc\n    return out\n```\n\nReturn only the Scheme macro definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "iteration_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-map-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Off-by-one termination skips filling the final element.\n\n```scheme\n(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((>= idx (- n 1)) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))", "tags": ["linalg", "iteration", "bugfix", "vec-map-idx"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-map-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Off-by-one termination skips filling the final element.\n\n```scheme\n(define-syntax vec-map-idx\n  (syntax-rules ()\n                [(_ idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((>= idx (- n 1)) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([src (vector 3 4 5)] [mapped (vec-map-idx i src (+ (vector-ref src i) i))]) (and (equal? mapped (vector 3 5 7)) (= (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))) 15))))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "iteration_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-fold-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Fold exits one iteration early and misses the last index.\n\n```scheme\n(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((>= idx (- n 1)) acc)))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Fold exits one iteration early and misses the last index.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))", "tags": ["linalg", "iteration", "bugfix", "vec-fold-idx"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-fold-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Fold exits one iteration early and misses the last index.\n\n```scheme\n(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((>= idx (- n 1)) acc)))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Fold exits one iteration early and misses the last index.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "iteration_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-fold-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Accumulator is reset to init on every step instead of threaded forward.\n\n```scheme\n(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init (let ([acc init]) body)])\n                           ((= idx n) acc)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (let ([src (vec-tabulate 5 i (+ i 1))]) (and (= (vec-fold-idx acc 0 i src (+ acc (vector-ref src i))) 15) (= (vec-fold-idx acc 0 i src (+ acc (* i (vector-ref src i)))) 40))))", "tags": ["linalg", "iteration", "bugfix", "vec-fold-idx"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-fold-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Accumulator is reset to init on every step instead of threaded forward.\n\n```scheme\n(define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init (let ([acc init]) body)])\n                           ((= idx n) acc)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "iteration_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-zip-map-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Second input vector is accidentally aliased to the first.\n\n```scheme\n(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec1]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))", "tags": ["linalg", "iteration", "bugfix", "vec-zip-map-idx"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-zip-map-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Second input vector is accidentally aliased to the first.\n\n```scheme\n(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec1]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "iteration_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-zip-map-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Loop stops before the final zipped element is written.\n\n```scheme\n(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((>= idx (- n 1)) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Loop stops before the final zipped element is written.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))", "tags": ["linalg", "iteration", "bugfix", "vec-zip-map-idx"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-zip-map-idx` in `lattice/linalg/iteration.ss`.\nKnown issue: Loop stops before the final zipped element is written.\n\n```scheme\n(define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((>= idx (- n 1)) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Loop stops before the final zipped element is written.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 10 20 30)] [z (vec-zip-map-idx i a b (+ (vector-ref a i) (vector-ref b i)))]) (and (equal? z (vector 11 22 33)) (= (dot-product-loop k 3 (vector-ref z k) 1) 66))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "iteration_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `matrix-do!` in `lattice/linalg/iteration.ss`.\nKnown issue: Inner loop uses row count instead of column count.\n\n```scheme\n(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j r))\n                              body ...)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n  (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))", "tags": ["linalg", "iteration", "bugfix", "matrix-do!"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `matrix-do!` in `lattice/linalg/iteration.ss`.\nKnown issue: Inner loop uses row count instead of column count.\n\n```scheme\n(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j r))\n                              body ...)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "iteration_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `matrix-do!` in `lattice/linalg/iteration.ss`.\nKnown issue: Row iteration starts at 1 and skips the first row.\n\n```scheme\n(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 1 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))", "verify_expr": "(let ()\n  (define-syntax vec-fold-idx\n  (syntax-rules ()\n                [(_ acc init idx vec body)\n                 (let* ([v vec]\n                        [n (vector-length v)])\n                       (do ([idx 0 (+ idx 1)]\n                            [acc init body])\n                           ((= idx n) acc)))]))\n  (define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 0 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n  (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))", "tags": ["linalg", "iteration", "bugfix", "matrix-do!"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `matrix-do!` in `lattice/linalg/iteration.ss`.\nKnown issue: Row iteration starts at 1 and skips the first row.\n\n```scheme\n(define-syntax matrix-do!\n  (syntax-rules ()\n                [(_ i j rows cols body ...)\n                 (let ([r rows]\n                       [c cols])\n                      (do ([i 1 (+ i 1)])\n                          ((= i r))\n                          (do ([j 0 (+ j 1)])\n                              ((= j c))\n                              body ...)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) (and (equal? data (vector 0 1 2 10 11 12)) (= (vec-fold-idx s 0 k data (+ s (vector-ref data k))) 36))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "iteration_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `range-fold` in `lattice/linalg/iteration.ss`.\nKnown issue: Accumulator ignores caller-provided init value.\n\n```scheme\n(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc 0 body])\n                     ((= var end) acc))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Accumulator ignores caller-provided init value.\n\nExpected behavior after patch:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))", "verify_expr": "(let ()\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (and (= (range-fold s 0 i 1 11 (+ s i)) 55) (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6))))", "tags": ["linalg", "iteration", "bugfix", "range-fold"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `range-fold` in `lattice/linalg/iteration.ss`.\nKnown issue: Accumulator ignores caller-provided init value.\n\n```scheme\n(define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc 0 body])\n                     ((= var end) acc))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Accumulator ignores caller-provided init value.\n\nExpected behavior after patch:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (range-fold s 0 i 1 11 (+ s i)) 55))\n(let () (equal? (vec-tabulate 4 i (range-fold acc 0 j 0 (+ i 1) (+ acc j))) (vector 0 1 3 6)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "iteration_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `dot-product-loop` in `lattice/linalg/iteration.ss`.\nKnown issue: Update adds terms instead of multiplying pairwise.\n\n```scheme\n(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (+ get-a get-b))])\n                     ((= k len) sum))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Update adds terms instead of multiplying pairwise.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))", "verify_expr": "(let ()\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))", "tags": ["linalg", "iteration", "bugfix", "dot-product-loop"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `dot-product-loop` in `lattice/linalg/iteration.ss`.\nKnown issue: Update adds terms instead of multiplying pairwise.\n\n```scheme\n(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (+ get-a get-b))])\n                     ((= k len) sum))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Update adds terms instead of multiplying pairwise.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "iteration_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `dot-product-loop` in `lattice/linalg/iteration.ss`.\nKnown issue: Termination condition skips the final multiply-accumulate step.\n\n```scheme\n(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((>= k (- len 1)) sum))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))", "verify_expr": "(let ()\n  (define-syntax vec-zip-map-idx\n  (syntax-rules ()\n                [(_ idx vec1 vec2 body)\n                 (let* ([v1 vec1]\n                        [v2 vec2]\n                        [n (vector-length v1)]\n                        [result (make-vector n 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx n) result)\n                           (vector-set! result idx body)))]))\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (and (= (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)) 32) (= (dot-product-loop k 3 (vector-ref p k) 1) 32))))", "tags": ["linalg", "iteration", "bugfix", "dot-product-loop"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `dot-product-loop` in `lattice/linalg/iteration.ss`.\nKnown issue: Termination condition skips the final multiply-accumulate step.\n\n```scheme\n(define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((>= k (- len 1)) sum))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "iteration_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-tabulate` in `lattice/linalg/iteration.ss`.\nKnown issue: Body is ignored and index value is stored directly.\n\n```scheme\n(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx idx)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))", "tags": ["linalg", "iteration", "bugfix", "vec-tabulate"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-tabulate` in `lattice/linalg/iteration.ss`.\nKnown issue: Body is ignored and index value is stored directly.\n\n```scheme\n(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx idx)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault."}
{"id": "iteration_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-tabulate` in `lattice/linalg/iteration.ss`.\nKnown issue: Final element is never written because of an off-by-one loop bound.\n\n```scheme\n(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((>= idx (- len 1)) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Final element is never written because of an off-by-one loop bound.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))", "verify_expr": "(let ()\n  (define-syntax range-fold\n  (syntax-rules ()\n                [(_ acc init var start end body)\n                 (do ([var start (+ var 1)]\n                      [acc init body])\n                     ((= var end) acc))]))\n  (define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((= idx len) result)\n                           (vector-set! result idx body)))]))\n  (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))", "tags": ["linalg", "iteration", "bugfix", "vec-tabulate"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-tabulate` in `lattice/linalg/iteration.ss`.\nKnown issue: Final element is never written because of an off-by-one loop bound.\n\n```scheme\n(define-syntax vec-tabulate\n  (syntax-rules ()\n                [(_ size idx body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (do ([idx 0 (+ idx 1)])\n                           ((>= idx (- len 1)) result)\n                           (vector-set! result idx body)))]))\n```\n\nReturn only the corrected macro definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Final element is never written because of an off-by-one loop bound.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([sq (vec-tabulate 5 i (* i i))]) (and (equal? sq (vector 0 1 4 9 16)) (= (range-fold s 0 i 0 5 (+ s (vector-ref sq i))) 30))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "iteration_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-scan` in `lattice/linalg/iteration.ss`.\nKnown issue: Scan loop starts at index 0 and overwrites the seeded initial element.\n\n```scheme\n(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 0] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))", "verify_expr": "(let ()\n  (define-syntax dot-product-loop\n  (syntax-rules ()\n                [(_ k len get-a get-b)\n                 (do ([k 0 (+ k 1)]\n                      [sum 0 (+ sum (* get-a get-b))])\n                     ((= k len) sum))]))\n  (define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 1] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n  (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))", "tags": ["linalg", "iteration", "bugfix", "vec-scan"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme macro with minimal semantic changes.\nTarget: `vec-scan` in `lattice/linalg/iteration.ss`.\nKnown issue: Scan loop starts at index 0 and overwrites the seeded initial element.\n\n```scheme\n(define-syntax vec-scan\n  (syntax-rules ()\n                [(_ size init idx acc body)\n                 (let* ([len size]\n                        [result (make-vector len 0)])\n                       (if (= len 0)\n                           result\n                           (begin\n                             (vector-set! result 0 init)\n                             (let loop ([idx 0] [acc init])\n                                  (if (= idx len)\n                                      result\n                                      (let ([acc body])\n                                           (vector-set! result idx acc)\n                                           (loop (+ idx 1) acc)))))))]))\n```\n\nReturn only the corrected macro definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([scan (vec-scan 5 0 i acc (+ acc i))]) (and (equal? scan (vector 0 1 3 6 10)) (= (dot-product-loop k 5 (vector-ref scan k) 1) 20) (equal? (vec-scan 0 99 i acc (+ acc 1)) (vector)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "iteration_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: small integration task across module primitives.\n\nAdd index to each element of #(10 20 30) with vec-map-idx.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([v (vector 10 20 30)]) (vec-map-idx i v (+ (vector-ref v i) i)))", "verify_expr": "(equal? (let ([v (vector 10 20 30)]) (vec-map-idx i v (+ (vector-ref v i) i))) (vector 10 21 32))", "tags": ["linalg", "iteration", "composition", "vec-map-idx", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nAdd index to each element of #(10 20 30) with vec-map-idx.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_003", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap (+ x 10) over #(1 2 3) then fold-sum the mapped vector.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([v (vector 1 2 3)] [mapped (vec-map-idx i v (+ (vector-ref v i) 10))]) (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k))))", "verify_expr": "(equal? (let* ([v (vector 1 2 3)] [mapped (vec-map-idx i v (+ (vector-ref v i) 10))]) (vec-fold-idx acc 0 k mapped (+ acc (vector-ref mapped k)))) 36)", "tags": ["linalg", "iteration", "composition", "vec-map-idx", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nMap (+ x 10) over #(1 2 3) then fold-sum the mapped vector.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-map-idx", "prompt": "Task mode: small integration task across module primitives.\n\nMap over empty vector and return the resulting vector.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-map-idx i (vector) i)", "verify_expr": "(equal? (vec-map-idx i (vector) i) (vector))", "tags": ["linalg", "iteration", "composition", "vec-map-idx", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nMap over empty vector and return the resulting vector.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: compose existing APIs into one expression.\n\nFold-sum #(1 2 3 4 5) with vec-fold-idx.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([v (vector 1 2 3 4 5)]) (vec-fold-idx acc 0 i v (+ acc (vector-ref v i))))", "verify_expr": "(equal? (let ([v (vector 1 2 3 4 5)]) (vec-fold-idx acc 0 i v (+ acc (vector-ref v i)))) 15)", "tags": ["linalg", "iteration", "composition", "vec-fold-idx", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nFold-sum #(1 2 3 4 5) with vec-fold-idx.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute weighted sum sum(i * v[i]) for #(1 2 3 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([v (vector 1 2 3 4 5)]) (vec-fold-idx acc 0 i v (+ acc (* i (vector-ref v i)))))", "verify_expr": "(equal? (let ([v (vector 1 2 3 4 5)]) (vec-fold-idx acc 0 i v (+ acc (* i (vector-ref v i))))) 40)", "tags": ["linalg", "iteration", "composition", "vec-fold-idx", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompute weighted sum sum(i * v[i]) for #(1 2 3 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: compose existing APIs into one expression.\n\nFold over empty vector and return the initial accumulator 42.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-fold-idx acc 42 i (vector) (+ acc i))", "verify_expr": "(equal? (vec-fold-idx acc 42 i (vector) (+ acc i)) 42)", "tags": ["linalg", "iteration", "composition", "vec-fold-idx", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nFold over empty vector and return the initial accumulator 42.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-fold-idx", "prompt": "Task mode: small integration task across module primitives.\n\nTabulate #(1 2 3 4) then fold-product over it.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([v (vec-tabulate 4 i (+ i 1))]) (vec-fold-idx acc 1 i v (* acc (vector-ref v i))))", "verify_expr": "(equal? (let ([v (vec-tabulate 4 i (+ i 1))]) (vec-fold-idx acc 1 i v (* acc (vector-ref v i)))) 24)", "tags": ["linalg", "iteration", "composition", "vec-fold-idx", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nTabulate #(1 2 3 4) then fold-product over it.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nZip two vectors with expression a[i]*b[i]+i.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([a (vector 2 3 4)] [b (vector 5 6 7)]) (vec-zip-map-idx i a b (+ (* (vector-ref a i) (vector-ref b i)) i)))", "verify_expr": "(equal? (let ([a (vector 2 3 4)] [b (vector 5 6 7)]) (vec-zip-map-idx i a b (+ (* (vector-ref a i) (vector-ref b i)) i))) (vector 10 19 30))", "tags": ["linalg", "iteration", "composition", "vec-zip-map-idx", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nZip two vectors with expression a[i]*b[i]+i.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: compose existing APIs into one expression.\n\nZip-multiply #(1 2 3) and #(4 5 6), then sum via dot-product-loop with ones.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (dot-product-loop k 3 (vector-ref p k) 1))", "verify_expr": "(equal? (let* ([a (vector 1 2 3)] [b (vector 4 5 6)] [p (vec-zip-map-idx i a b (* (vector-ref a i) (vector-ref b i)))]) (dot-product-loop k 3 (vector-ref p k) 1)) 32)", "tags": ["linalg", "iteration", "composition", "vec-zip-map-idx", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nZip-multiply #(1 2 3) and #(4 5 6), then sum via dot-product-loop with ones.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-zip-map-idx", "prompt": "Task mode: compose existing APIs into one expression.\n\nZip-map two empty vectors and return the result.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-zip-map-idx i (vector) (vector) i)", "verify_expr": "(equal? (vec-zip-map-idx i (vector) (vector) i) (vector))", "tags": ["linalg", "iteration", "composition", "vec-zip-map-idx", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nZip-map two empty vectors and return the result.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: small integration task across module primitives.\n\nFill a 2x3 flat data vector with value 10*i + j using matrix-do!.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) data)", "verify_expr": "(equal? (let ([rows 2] [cols 3] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) (+ (* i 10) j))) data) (vector 0 1 2 10 11 12))", "tags": ["linalg", "iteration", "composition", "matrix-do!", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nFill a 2x3 flat data vector with value 10*i + j using matrix-do!.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse matrix-do! to fill a 3x2 grid with ones, then sum all entries.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([rows 3] [cols 2] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) 1)) (vec-fold-idx s 0 k data (+ s (vector-ref data k))))", "verify_expr": "(equal? (let ([rows 3] [cols 2] [data (make-vector 6 0)]) (matrix-do! i j rows cols (vector-set! data (+ (* i cols) j) 1)) (vec-fold-idx s 0 k data (+ s (vector-ref data k)))) 6)", "tags": ["linalg", "iteration", "composition", "matrix-do!", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nUse matrix-do! to fill a 3x2 grid with ones, then sum all entries.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a 3x3 identity-pattern flat vector using matrix-do!.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([n 3] [data (make-vector 9 0)]) (matrix-do! i j n n (vector-set! data (+ (* i n) j) (if (= i j) 1 0))) data)", "verify_expr": "(equal? (let ([n 3] [data (make-vector 9 0)]) (matrix-do! i j n n (vector-set! data (+ (* i n) j) (if (= i j) 1 0))) data) (vector 1 0 0 0 1 0 0 0 1))", "tags": ["linalg", "iteration", "composition", "matrix-do!", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild a 3x3 identity-pattern flat vector using matrix-do!.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "matrix-do!", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun matrix-do! with zero rows and return the untouched empty vector.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([data (make-vector 0 0)]) (matrix-do! i j 0 5 (vector-set! data 0 1)) data)", "verify_expr": "(equal? (let ([data (make-vector 0 0)]) (matrix-do! i j 0 5 (vector-set! data 0 1)) data) (vector))", "tags": ["linalg", "iteration", "composition", "matrix-do!", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nRun matrix-do! with zero rows and return the untouched empty vector.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: small integration task across module primitives.\n\nCompute 5! using range-fold over [1,6).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(range-fold p 1 i 1 6 (* p i))", "verify_expr": "(equal? (range-fold p 1 i 1 6 (* p i)) 120)", "tags": ["linalg", "iteration", "composition", "range-fold", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompute 5! using range-fold over [1,6).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate an empty range fold and return initial accumulator 99.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(range-fold acc 99 i 5 5 (+ acc i))", "verify_expr": "(equal? (range-fold acc 99 i 5 5 (+ acc i)) 99)", "tags": ["linalg", "iteration", "composition", "range-fold", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate an empty range fold and return initial accumulator 99.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "range-fold", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse range-fold inside vec-tabulate to produce triangular numbers for i=0..4.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-tabulate 5 i (range-fold s 0 j 0 (+ i 1) (+ s j)))", "verify_expr": "(equal? (vec-tabulate 5 i (range-fold s 0 j 0 (+ i 1) (+ s j))) (vector 0 1 3 6 10))", "tags": ["linalg", "iteration", "composition", "range-fold", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nUse range-fold inside vec-tabulate to produce triangular numbers for i=0..4.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: small integration task across module primitives.\n\nCompute dot product of #(1 2 3) and #(4 5 6).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([a (vector 1 2 3)] [b (vector 4 5 6)]) (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)))", "verify_expr": "(equal? (let ([a (vector 1 2 3)] [b (vector 4 5 6)]) (dot-product-loop k 3 (vector-ref a k) (vector-ref b k))) 32)", "tags": ["linalg", "iteration", "composition", "dot-product-loop", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompute dot product of #(1 2 3) and #(4 5 6).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute dot product of orthogonal vectors #(1 0 0) and #(0 1 0).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([a (vector 1 0 0)] [b (vector 0 1 0)]) (dot-product-loop k 3 (vector-ref a k) (vector-ref b k)))", "verify_expr": "(equal? (let ([a (vector 1 0 0)] [b (vector 0 1 0)]) (dot-product-loop k 3 (vector-ref a k) (vector-ref b k))) 0)", "tags": ["linalg", "iteration", "composition", "dot-product-loop", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompute dot product of orthogonal vectors #(1 0 0) and #(0 1 0).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "dot-product-loop", "prompt": "Task mode: compose existing APIs into one expression.\n\nTabulate #(1 2 3 4) and return its self-dot-product.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([v (vec-tabulate 4 i (+ i 1))]) (dot-product-loop k 4 (vector-ref v k) (vector-ref v k)))", "verify_expr": "(equal? (let ([v (vec-tabulate 4 i (+ i 1))]) (dot-product-loop k 4 (vector-ref v k) (vector-ref v k))) 30)", "tags": ["linalg", "iteration", "composition", "dot-product-loop", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nTabulate #(1 2 3 4) and return its self-dot-product.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: small integration task across module primitives.\n\nBuild squares vector of length 5 using vec-tabulate.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-tabulate 5 i (* i i))", "verify_expr": "(equal? (vec-tabulate 5 i (* i i)) (vector 0 1 4 9 16))", "tags": ["linalg", "iteration", "composition", "vec-tabulate", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nBuild squares vector of length 5 using vec-tabulate.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: small integration task across module primitives.\n\nCopy #(10 20 30) with vec-tabulate.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([v (vector 10 20 30)]) (vec-tabulate 3 i (vector-ref v i)))", "verify_expr": "(equal? (let ([v (vector 10 20 30)]) (vec-tabulate 3 i (vector-ref v i))) (vector 10 20 30))", "tags": ["linalg", "iteration", "composition", "vec-tabulate", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCopy #(10 20 30) with vec-tabulate.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "iteration_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate an empty vector with vec-tabulate size 0.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-tabulate 0 i i)", "verify_expr": "(equal? (vec-tabulate 0 i i) (vector))", "tags": ["linalg", "iteration", "composition", "vec-tabulate", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCreate an empty vector with vec-tabulate size 0.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-tabulate", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse vec-tabulate + range-fold to generate triangular numbers #(0 1 3 6).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-tabulate 4 i (range-fold s 0 j 0 (+ i 1) (+ s j)))", "verify_expr": "(equal? (vec-tabulate 4 i (range-fold s 0 j 0 (+ i 1) (+ s j))) (vector 0 1 3 6))", "tags": ["linalg", "iteration", "composition", "vec-tabulate", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nUse vec-tabulate + range-fold to generate triangular numbers #(0 1 3 6).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute prefix sums with vec-scan where update is acc+i for size 5.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-scan 5 0 i acc (+ acc i))", "verify_expr": "(equal? (vec-scan 5 0 i acc (+ acc i)) (vector 0 1 3 6 10))", "tags": ["linalg", "iteration", "composition", "vec-scan", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompute prefix sums with vec-scan where update is acc+i for size 5.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "iteration_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun vec-scan with size 0 and return empty vector.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-scan 0 999 i acc (+ acc 1))", "verify_expr": "(equal? (vec-scan 0 999 i acc (+ acc 1)) (vector))", "tags": ["linalg", "iteration", "composition", "vec-scan", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nRun vec-scan with size 0 and return empty vector.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "iteration_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/iteration.ss", "source_test": "lattice/linalg/test-iteration.ss", "source_function": "vec-scan", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun vec-scan with size 1 and init 42.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-scan 1 42 i acc (+ acc 1))", "verify_expr": "(equal? (vec-scan 1 42 i acc (+ acc 1)) (vector 42))", "tags": ["linalg", "iteration", "composition", "vec-scan", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nRun vec-scan with size 1 and init 42.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
