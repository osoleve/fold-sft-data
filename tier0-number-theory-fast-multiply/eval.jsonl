{"id": "fast_multiply_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `integer->limbs`\nSpec: Convert integer to least-significant-first limb list; return '(0) for zero.\n\nWrite exactly one Scheme function definition for `integer->limbs`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (integer->limbs 0 10) '(0))\n(equal? (integer->limbs 5 10) '(5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))", "verify_expr": "(let ()\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (and\n  (equal? (integer->limbs 0 10) '(0))\n  (equal? (integer->limbs 5 10) '(5))\n  (equal? (integer->limbs 123 10) '(3 2 1))\n  (equal? (integer->limbs 12345 100) '(45 23 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "integer->limbs"], "split": "eval"}
{"id": "fast_multiply_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limbs-add`\nSpec: Add two limb lists with carry propagation in the given base.\n\nWrite exactly one Scheme function definition for `limbs-add`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n(equal? (limbs-add '(7) '(3) 10) '(0 1))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (and\n  (equal? (limbs-add '(2) '(3) 10) '(5))\n  (equal? (limbs-add '(7) '(3) 10) '(0 1))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) '(5 7 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limbs-add"], "split": "eval"}
{"id": "fast_multiply_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limb-scale`\nSpec: Multiply a limb list by one scalar limb with carry propagation.\n\nWrite exactly one Scheme function definition for `limb-scale`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (limb-scale '(5) 2 10) '(0 1))\n(equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (and\n  (equal? (limb-scale '(5) 2 10) '(0 1))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n  (equal? (limb-scale '(9 9) 9 10) '(1 9 8))\n  (equal? (limb-scale '(1 2 3) 0 10) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limb-scale"], "split": "eval"}
{"id": "fast_multiply_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs->integer`\n\n```python\ndef limbs_to_integer(limbs, base):\n    multiplier = 1\n    result = 0\n    for limb in limbs:\n        result += limb * multiplier\n        multiplier *= base\n    return result\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs->integer"], "split": "eval"}
{"id": "fast_multiply_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs-sub`\n\n```python\ndef limbs_sub(a, b, base):\n    out = []\n    borrow = 0\n    i = 0\n    while i < len(a) or i < len(b):\n        av = a[i] if i < len(a) else 0\n        bv = b[i] if i < len(b) else 0\n        d = av - bv - borrow\n        if d < 0:\n            d += base\n            borrow = 1\n        else:\n            borrow = 0\n        out.append(d)\n        i += 1\n    return limbs_normalize(out)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs-sub"], "split": "eval"}
{"id": "fast_multiply_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limbs-multiply-schoolbook`\n\n```scheme\n(define (mul-schoolbook a b base)\n  (let loop ([bs b] [shift 0] [res '(0)])\n    (if (null? bs)\n        (limbs-normalize res)\n        (let ([partial (limb-scale a (car bs) base)])\n          (loop (cdr bs)\n                (+ shift 1)\n                (limbs-add res (limbs-shift partial shift) base))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limbs-multiply-schoolbook"], "split": "eval"}
{"id": "fast_multiply_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs->integer` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Multiplier must start at 1 for the least-significant limb.\n\n```scheme\n(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier base] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (limbs->integer '(0) 10) 0)\n(= (limbs->integer '(5) 10) 5)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs->integer"], "split": "eval"}
{"id": "fast_multiply_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-sub` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Borrow propagation is required when a limb subtraction goes negative.\n\n```scheme\n(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [result '()])\n    (if (and (null? a) (null? b))\n        (limbs-normalize (reverse result))\n        (let* ([av (if (null? a) 0 (car a))]\n               [bv (if (null? b) 0 (car b))]\n               [diff (- av bv)])\n          (loop (if (null? a) '() (cdr a))\n                (if (null? b) '() (cdr b))\n                (cons diff result))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-sub"], "split": "eval"}
{"id": "fast_multiply_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-multiply-schoolbook` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Partial products must accumulate with addition; current code discards previous result.\n\n```scheme\n(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        result\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-shift partial shift)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n(equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-multiply-schoolbook"], "split": "eval"}
{"id": "fast_multiply_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: small integration task across module primitives.\n\nConvert '(3 2 1) in base 10 to an integer.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs->integer '(3 2 1) 10) 123)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs->integer '(3 2 1) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer '(3 2 1) 10) 123))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs->integer", "direct"], "split": "eval"}
{"id": "fast_multiply_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: compose existing APIs into one expression.\n\nNormalize '(1 2 3 0 0).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-normalize '(1 2 3 0 0))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-normalize", "direct"], "split": "eval"}
{"id": "fast_multiply_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: compose existing APIs into one expression.\n\nSubtract '(3) from '(5) in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-sub '(5) '(3) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-sub '(5) '(3) 10) '(2)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-sub", "direct"], "split": "eval"}
{"id": "fast_multiply_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: small integration task across module primitives.\n\nConvert shifted limbs '(3 2 1) by 2 (base 10) to integer.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs->integer (limbs-shift '(3 2 1) 2) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer (limbs-shift '(3 2 1) 2) 10) 12300))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-shift", "integration"], "split": "eval"}
{"id": "fast_multiply_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff schoolbook multiplication is commutative for (123,456) at base 10.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-multiply-schoolbook (integer->limbs 123 10) (integer->limbs 456 10) 10) (limbs-multiply-schoolbook (integer->limbs 456 10) (integer->limbs 123 10) 10))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (limbs-multiply-schoolbook (integer->limbs 123 10) (integer->limbs 456 10) 10) (limbs-multiply-schoolbook (integer->limbs 456 10) (integer->limbs 123 10) 10))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-multiply-schoolbook (integer->limbs 123 10) (integer->limbs 456 10) 10) (limbs-multiply-schoolbook (integer->limbs 456 10) (integer->limbs 123 10) 10)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-multiply-schoolbook", "property"], "split": "eval"}
