{"id": "fast_multiply_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limbs->integer`\nSpec: Convert least-significant-first limb list into integer under given base.\n\nWrite exactly one Scheme function definition for `limbs->integer`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (limbs->integer '(0) 10) 0)\n(= (limbs->integer '(5) 10) 5)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limbs->integer"], "split": "train"}
{"id": "fast_multiply_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (limbs->integer limbs base)\n  ;; TODO: fold least-significant-first limbs into integer\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `limbs->integer`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (limbs->integer '(0) 10) 0)\n(= (limbs->integer '(5) 10) 5)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "limbs->integer"], "split": "train"}
{"id": "fast_multiply_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `integer->limbs`\nSpec: Convert integer to least-significant-first limb list; return '(0) for zero.\n\nWrite exactly one Scheme function definition for `integer->limbs`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (integer->limbs 0 10) '(0))\n(equal? (integer->limbs 5 10) '(5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))", "verify_expr": "(let ()\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (and\n  (equal? (integer->limbs 0 10) '(0))\n  (equal? (integer->limbs 5 10) '(5))\n  (equal? (integer->limbs 123 10) '(3 2 1))\n  (equal? (integer->limbs 12345 100) '(45 23 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "integer->limbs"], "split": "eval"}
{"id": "fast_multiply_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (integer->limbs n base)\n  ;; TODO: emit least-significant-first limbs, canonical zero is '(0)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `integer->limbs`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (integer->limbs 0 10) '(0))\n(equal? (integer->limbs 5 10) '(5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))", "verify_expr": "(let ()\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (and\n  (equal? (integer->limbs 0 10) '(0))\n  (equal? (integer->limbs 5 10) '(5))\n  (equal? (integer->limbs 123 10) '(3 2 1))\n  (equal? (integer->limbs 12345 100) '(45 23 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "integer->limbs"], "split": "train"}
{"id": "fast_multiply_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limbs-normalize`\nSpec: Remove high-order trailing zeros while preserving canonical zero representation '(0).\n\nWrite exactly one Scheme function definition for `limbs-normalize`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n(equal? (limbs-normalize '(0 0 0)) '(0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (and\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n  (equal? (limbs-normalize '(0 0 0)) '(0))\n  (equal? (limbs-normalize '(5 0)) '(5))\n  (equal? (limbs-normalize '(7 8 9)) '(7 8 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limbs-normalize"], "split": "train"}
{"id": "fast_multiply_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (limbs-normalize limbs)\n  ;; TODO: drop high-order trailing zeros while keeping '(0) for zero\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `limbs-normalize`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n(equal? (limbs-normalize '(0 0 0)) '(0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (and\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n  (equal? (limbs-normalize '(0 0 0)) '(0))\n  (equal? (limbs-normalize '(5 0)) '(5))\n  (equal? (limbs-normalize '(7 8 9)) '(7 8 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "limbs-normalize"], "split": "train"}
{"id": "fast_multiply_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limbs-add`\nSpec: Add two limb lists with carry propagation in the given base.\n\nWrite exactly one Scheme function definition for `limbs-add`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n(equal? (limbs-add '(7) '(3) 10) '(0 1))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (and\n  (equal? (limbs-add '(2) '(3) 10) '(5))\n  (equal? (limbs-add '(7) '(3) 10) '(0 1))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) '(5 7 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limbs-add"], "split": "eval"}
{"id": "fast_multiply_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (limbs-add a b base)\n  ;; TODO: implement limb-wise addition with carry\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `limbs-add`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n(equal? (limbs-add '(7) '(3) 10) '(0 1))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (and\n  (equal? (limbs-add '(2) '(3) 10) '(5))\n  (equal? (limbs-add '(7) '(3) 10) '(0 1))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) '(5 7 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "limbs-add"], "split": "train"}
{"id": "fast_multiply_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limbs-sub`\nSpec: Subtract b from a (a>=b) with borrow propagation and normalized output.\n\nWrite exactly one Scheme function definition for `limbs-sub`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limbs-sub"], "split": "train"}
{"id": "fast_multiply_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (limbs-sub a b base)\n  ;; TODO: implement limb-wise subtraction with borrow (assume a>=b)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `limbs-sub`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "limbs-sub"], "split": "train"}
{"id": "fast_multiply_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limbs-shift`\nSpec: Multiply by base^k by prepending k zero limbs; keep zero canonical.\n\nWrite exactly one Scheme function definition for `limbs-shift`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n(equal? (limbs-shift '(5) 0) '(5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))", "verify_expr": "(let ()\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (and\n  (equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n  (equal? (limbs-shift '(5) 0) '(5))\n  (equal? (limbs-shift '(0) 3) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limbs-shift"], "split": "train"}
{"id": "fast_multiply_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (limbs-shift limbs k)\n  ;; TODO: multiply by base^k in limb representation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `limbs-shift`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n(equal? (limbs-shift '(5) 0) '(5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))", "verify_expr": "(let ()\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (and\n  (equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n  (equal? (limbs-shift '(5) 0) '(5))\n  (equal? (limbs-shift '(0) 3) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "limbs-shift"], "split": "train"}
{"id": "fast_multiply_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limb-scale`\nSpec: Multiply a limb list by one scalar limb with carry propagation.\n\nWrite exactly one Scheme function definition for `limb-scale`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (limb-scale '(5) 2 10) '(0 1))\n(equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (and\n  (equal? (limb-scale '(5) 2 10) '(0 1))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n  (equal? (limb-scale '(9 9) 9 10) '(1 9 8))\n  (equal? (limb-scale '(1 2 3) 0 10) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limb-scale"], "split": "eval"}
{"id": "fast_multiply_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (limb-scale limbs scalar base)\n  ;; TODO: scale limb list by one scalar limb with carry\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `limb-scale`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (limb-scale '(5) 2 10) '(0 1))\n(equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (and\n  (equal? (limb-scale '(5) 2 10) '(0 1))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n  (equal? (limb-scale '(9 9) 9 10) '(1 9 8))\n  (equal? (limb-scale '(1 2 3) 0 10) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "limb-scale"], "split": "train"}
{"id": "fast_multiply_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/number-theory/fast-multiply.ss\nFunction: `limbs-multiply-schoolbook`\nSpec: Compute O(n^2) schoolbook multiplication of two limb lists.\n\nWrite exactly one Scheme function definition for `limbs-multiply-schoolbook`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n(equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "limbs-multiply-schoolbook"], "split": "train"}
{"id": "fast_multiply_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (limbs-multiply-schoolbook a b base)\n  ;; TODO: accumulate shifted partial products\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `limbs-multiply-schoolbook`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n(equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "spec-to-code", "skeleton", "limbs-multiply-schoolbook"], "split": "train"}
{"id": "fast_multiply_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs->integer`\n\n```python\ndef limbs_to_integer(limbs, base):\n    multiplier = 1\n    result = 0\n    for limb in limbs:\n        result += limb * multiplier\n        multiplier *= base\n    return result\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs->integer"], "split": "eval"}
{"id": "fast_multiply_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limbs->integer`\n\n```scheme\n(define (to-int limbs base)\n  (let loop ([ls limbs] [m 1] [acc 0])\n    (if (null? ls)\n        acc\n        (loop (cdr ls) (* m base) (+ acc (* (car ls) m))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limbs->integer"], "split": "train"}
{"id": "fast_multiply_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `integer->limbs`\n\n```python\ndef integer_to_limbs(n, base):\n    if n == 0:\n        return [0]\n    out = []\n    while n > 0:\n        out.append(n % base)\n        n //= base\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (integer->limbs 0 10) '(0))\n(equal? (integer->limbs 5 10) '(5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))", "verify_expr": "(let ()\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (and\n  (equal? (integer->limbs 0 10) '(0))\n  (equal? (integer->limbs 5 10) '(5))\n  (equal? (integer->limbs 123 10) '(3 2 1))\n  (equal? (integer->limbs 12345 100) '(45 23 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "integer->limbs"], "split": "train"}
{"id": "fast_multiply_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `integer->limbs`\n\n```scheme\n(define (to-limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [acc '()])\n        (if (= n 0)\n            (reverse acc)\n            (loop (quotient n base) (cons (modulo n base) acc))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (integer->limbs 0 10) '(0))\n(equal? (integer->limbs 5 10) '(5))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))", "verify_expr": "(let ()\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (and\n  (equal? (integer->limbs 0 10) '(0))\n  (equal? (integer->limbs 5 10) '(5))\n  (equal? (integer->limbs 123 10) '(3 2 1))\n  (equal? (integer->limbs 12345 100) '(45 23 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "integer->limbs"], "split": "train"}
{"id": "fast_multiply_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs-normalize`\n\n```python\ndef limbs_normalize(limbs):\n    i = len(limbs) - 1\n    while i > 0 and limbs[i] == 0:\n        i -= 1\n    return limbs[: i + 1]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (and\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n  (equal? (limbs-normalize '(0 0 0)) '(0))\n  (equal? (limbs-normalize '(5 0)) '(5))\n  (equal? (limbs-normalize '(7 8 9)) '(7 8 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs-normalize"], "split": "train"}
{"id": "fast_multiply_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limbs-normalize`\n\n```scheme\n(define (normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (and\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n  (equal? (limbs-normalize '(0 0 0)) '(0))\n  (equal? (limbs-normalize '(5 0)) '(5))\n  (equal? (limbs-normalize '(7 8 9)) '(7 8 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limbs-normalize"], "split": "train"}
{"id": "fast_multiply_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs-add`\n\n```python\ndef limbs_add(a, b, base):\n    out = []\n    carry = 0\n    i = 0\n    while i < len(a) or i < len(b) or carry:\n        av = a[i] if i < len(a) else 0\n        bv = b[i] if i < len(b) else 0\n        s = av + bv + carry\n        out.append(s % base)\n        carry = s // base\n        i += 1\n    return limbs_normalize(out)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n(equal? (limbs-add '(7) '(3) 10) '(0 1))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (and\n  (equal? (limbs-add '(2) '(3) 10) '(5))\n  (equal? (limbs-add '(7) '(3) 10) '(0 1))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) '(5 7 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs-add"], "split": "train"}
{"id": "fast_multiply_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limbs-add`\n\n```scheme\n(define (add-limbs a b base)\n  (let loop ([a a] [b b] [carry 0] [out '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse (if (> carry 0) (cons carry out) out)))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (if (null? b) 0 (car b))]\n              [s (+ av bv carry)])\n         (loop (if (null? a) '() (cdr a))\n               (if (null? b) '() (cdr b))\n               (quotient s base)\n               (cons (modulo s base) out)))])))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n(equal? (limbs-add '(7) '(3) 10) '(0 1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (and\n  (equal? (limbs-add '(2) '(3) 10) '(5))\n  (equal? (limbs-add '(7) '(3) 10) '(0 1))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) '(5 7 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limbs-add"], "split": "train"}
{"id": "fast_multiply_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs-sub`\n\n```python\ndef limbs_sub(a, b, base):\n    out = []\n    borrow = 0\n    i = 0\n    while i < len(a) or i < len(b):\n        av = a[i] if i < len(a) else 0\n        bv = b[i] if i < len(b) else 0\n        d = av - bv - borrow\n        if d < 0:\n            d += base\n            borrow = 1\n        else:\n            borrow = 0\n        out.append(d)\n        i += 1\n    return limbs_normalize(out)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs-sub"], "split": "eval"}
{"id": "fast_multiply_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limbs-sub`\n\n```scheme\n(define (sub-limbs a b base)\n  (let loop ([a a] [b b] [borrow 0] [out '()])\n    (if (and (null? a) (null? b))\n        (limbs-normalize (reverse out))\n        (let* ([av (if (null? a) 0 (car a))]\n               [bv (if (null? b) 0 (car b))]\n               [d (- av bv borrow)])\n          (if (< d 0)\n              (loop (if (null? a) '() (cdr a))\n                    (if (null? b) '() (cdr b))\n                    1\n                    (cons (+ d base) out))\n              (loop (if (null? a) '() (cdr a))\n                    (if (null? b) '() (cdr b))\n                    0\n                    (cons d out)))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limbs-sub"], "split": "train"}
{"id": "fast_multiply_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs-shift`\n\n```python\ndef limbs_shift(limbs, k):\n    if len(limbs) == 1 and limbs[0] == 0:\n        return limbs\n    return ([0] * k) + limbs\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n(equal? (limbs-shift '(5) 0) '(5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))", "verify_expr": "(let ()\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (and\n  (equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n  (equal? (limbs-shift '(5) 0) '(5))\n  (equal? (limbs-shift '(0) 3) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs-shift"], "split": "train"}
{"id": "fast_multiply_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limbs-shift`\n\n```scheme\n(define (shift-limbs limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))", "verify_expr": "(let ()\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (and\n  (equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n  (equal? (limbs-shift '(5) 0) '(5))\n  (equal? (limbs-shift '(0) 3) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limbs-shift"], "split": "train"}
{"id": "fast_multiply_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limb-scale`\n\n```python\ndef limb_scale(limbs, scalar, base):\n    out = []\n    carry = 0\n    for limb in limbs:\n        p = limb * scalar + carry\n        out.append(p % base)\n        carry = p // base\n    if carry:\n        out.append(carry)\n    return limbs_normalize(out)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (limb-scale '(5) 2 10) '(0 1))\n(equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (and\n  (equal? (limb-scale '(5) 2 10) '(0 1))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n  (equal? (limb-scale '(9 9) 9 10) '(1 9 8))\n  (equal? (limb-scale '(1 2 3) 0 10) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limb-scale"], "split": "train"}
{"id": "fast_multiply_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limb-scale`\n\n```scheme\n(define (scale-limb limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [out '()])\n    (if (null? ls)\n        (limbs-normalize (reverse (if (> carry 0) (cons carry out) out)))\n        (let ([p (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient p base)\n                (cons (modulo p base) out))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (and\n  (equal? (limb-scale '(5) 2 10) '(0 1))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n  (equal? (limb-scale '(9 9) 9 10) '(1 9 8))\n  (equal? (limb-scale '(1 2 3) 0 10) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limb-scale"], "split": "train"}
{"id": "fast_multiply_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `limbs-multiply-schoolbook`\n\n```python\ndef limbs_multiply_schoolbook(a, b, base):\n    result = [0]\n    shift = 0\n    for limb in b:\n        partial = limb_scale(a, limb, base)\n        result = limbs_add(result, limbs_shift(partial, shift), base)\n        shift += 1\n    return limbs_normalize(result)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n(equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "python", "limbs-multiply-schoolbook"], "split": "train"}
{"id": "fast_multiply_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `limbs-multiply-schoolbook`\n\n```scheme\n(define (mul-schoolbook a b base)\n  (let loop ([bs b] [shift 0] [res '(0)])\n    (if (null? bs)\n        (limbs-normalize res)\n        (let ([partial (limb-scale a (car bs) base)])\n          (loop (cdr bs)\n                (+ shift 1)\n                (limbs-add res (limbs-shift partial shift) base))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "translation", "chez", "limbs-multiply-schoolbook"], "split": "eval"}
{"id": "fast_multiply_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs->integer` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Multiplier must start at 1 for the least-significant limb.\n\n```scheme\n(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier base] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (limbs->integer '(0) 10) 0)\n(= (limbs->integer '(5) 10) 5)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs->integer"], "split": "eval"}
{"id": "fast_multiply_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs->integer` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: This treats limbs as most-significant-first; representation is least-significant-first.\n\n```scheme\n(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (+ (* result base) (car ls))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (and\n  (= (limbs->integer '(0) 10) 0)\n  (= (limbs->integer '(5) 10) 5)\n  (= (limbs->integer '(3 2 1) 10) 123)\n  (= (limbs->integer '(45 23 1) 100) 12345)))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs->integer"], "split": "train"}
{"id": "fast_multiply_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `integer->limbs` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Zero must map to canonical '(0), not empty list.\n\n```scheme\n(define (integer->limbs n base)\n  (if (= n 0)\n      '()\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))", "verify_expr": "(let ()\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (and\n  (equal? (integer->limbs 0 10) '(0))\n  (equal? (integer->limbs 5 10) '(5))\n  (equal? (integer->limbs 123 10) '(3 2 1))\n  (equal? (integer->limbs 12345 100) '(45 23 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "integer->limbs"], "split": "train"}
{"id": "fast_multiply_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `integer->limbs` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Output must be least-significant-first; this returns reversed order.\n\n```scheme\n(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            limbs\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (integer->limbs 0 10) '(0))\n(equal? (integer->limbs 5 10) '(5))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))", "verify_expr": "(let ()\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (and\n  (equal? (integer->limbs 0 10) '(0))\n  (equal? (integer->limbs 5 10) '(5))\n  (equal? (integer->limbs 123 10) '(3 2 1))\n  (equal? (integer->limbs 12345 100) '(45 23 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "integer->limbs"], "split": "train"}
{"id": "fast_multiply_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-normalize` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Must remove high-order trailing zeros, not low-order leading zeros.\n\n```scheme\n(define (limbs-normalize limbs)\n  (if (null? limbs)\n      '(0)\n      (if (= (car limbs) 0)\n          (limbs-normalize (cdr limbs))\n          limbs)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n(equal? (limbs-normalize '(0 0 0)) '(0))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (and\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n  (equal? (limbs-normalize '(0 0 0)) '(0))\n  (equal? (limbs-normalize '(5 0)) '(5))\n  (equal? (limbs-normalize '(7 8 9)) '(7 8 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-normalize"], "split": "train"}
{"id": "fast_multiply_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-normalize` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Canonical zero representation must be '(0), and a single zero limb should be preserved.\n\n```scheme\n(define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '()]\n      [(= (car ls) 0) (loop (cdr ls))]\n      [else (reverse ls)])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (and\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n  (equal? (limbs-normalize '(0 0 0)) '(0))\n  (equal? (limbs-normalize '(5 0)) '(5))\n  (equal? (limbs-normalize '(7 8 9)) '(7 8 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-normalize"], "split": "train"}
{"id": "fast_multiply_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-add` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Final carry must be appended when both inputs are exhausted.\n\n```scheme\n(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (if (null? b) 0 (car b))]\n              [sum (+ av bv carry)])\n         (loop (if (null? a) '() (cdr a))\n               (if (null? b) '() (cdr b))\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n(equal? (limbs-add '(7) '(3) 10) '(0 1))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (and\n  (equal? (limbs-add '(2) '(3) 10) '(5))\n  (equal? (limbs-add '(7) '(3) 10) '(0 1))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) '(5 7 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-add"], "split": "train"}
{"id": "fast_multiply_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-add` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Carry propagation is missing; sums above base are handled incorrectly.\n\n```scheme\n(define (limbs-add a b base)\n  (let loop ([a a] [b b] [result '()])\n    (cond\n      [(and (null? a) (null? b)) (reverse result)]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (if (null? b) 0 (car b))]\n              [sum (+ av bv)])\n         (loop (if (null? a) '() (cdr a))\n               (if (null? b) '() (cdr b))\n               (cons (modulo sum base) result)))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n(equal? (limbs-add '(7) '(3) 10) '(0 1))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (and\n  (equal? (limbs-add '(2) '(3) 10) '(5))\n  (equal? (limbs-add '(7) '(3) 10) '(0 1))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) '(5 7 9))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-add"], "split": "train"}
{"id": "fast_multiply_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-sub` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Borrow propagation is required when a limb subtraction goes negative.\n\n```scheme\n(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [result '()])\n    (if (and (null? a) (null? b))\n        (limbs-normalize (reverse result))\n        (let* ([av (if (null? a) 0 (car a))]\n               [bv (if (null? b) 0 (car b))]\n               [diff (- av bv)])\n          (loop (if (null? a) '() (cdr a))\n                (if (null? b) '() (cdr b))\n                (cons diff result))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-sub"], "split": "eval"}
{"id": "fast_multiply_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-sub` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Result must be normalized to remove high-order trailing zeros.\n\n```scheme\n(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (if (and (null? a) (null? b))\n        (reverse result)\n        (let* ([av (if (null? a) 0 (car a))]\n               [bv (if (null? b) 0 (car b))]\n               [diff (- av bv borrow)])\n          (if (< diff 0)\n              (loop (if (null? a) '() (cdr a))\n                    (if (null? b) '() (cdr b))\n                    1\n                    (cons (+ diff base) result))\n              (loop (if (null? a) '() (cdr a))\n                    (if (null? b) '() (cdr b))\n                    0\n                    (cons diff result)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (and\n  (equal? (limbs-sub '(5) '(3) 10) '(2))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n  (equal? (limbs-sub '(0 0 2) '(0 0 1) 10) '(0 0 1))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-sub"], "split": "train"}
{"id": "fast_multiply_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-shift` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Least-significant-first representation requires prepending zeros, not appending.\n\n```scheme\n(define (limbs-shift limbs k)\n  (append limbs (make-list k 0)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n(equal? (limbs-shift '(5) 0) '(5))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))", "verify_expr": "(let ()\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (and\n  (equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n  (equal? (limbs-shift '(5) 0) '(5))\n  (equal? (limbs-shift '(0) 3) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-shift"], "split": "train"}
{"id": "fast_multiply_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-shift` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Canonical zero should stay '(0) after any shift, not gain extra zero limbs.\n\n```scheme\n(define (limbs-shift limbs k)\n  (append (make-list k 0) limbs))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))", "verify_expr": "(let ()\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (and\n  (equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n  (equal? (limbs-shift '(5) 0) '(5))\n  (equal? (limbs-shift '(0) 3) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-shift"], "split": "train"}
{"id": "fast_multiply_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limb-scale` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Final carry must be emitted when scaling completes.\n\n```scheme\n(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize (reverse result))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limb-scale '(5) 2 10) '(0 1))\n(equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (and\n  (equal? (limb-scale '(5) 2 10) '(0 1))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n  (equal? (limb-scale '(9 9) 9 10) '(1 9 8))\n  (equal? (limb-scale '(1 2 3) 0 10) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limb-scale"], "split": "train"}
{"id": "fast_multiply_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limb-scale` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Scaling must propagate carries and stay in-base for each limb.\n\n```scheme\n(define (limb-scale limbs scalar base)\n  (map (lambda (x) (* x scalar)) limbs))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limb-scale '(5) 2 10) '(0 1))\n(equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (and\n  (equal? (limb-scale '(5) 2 10) '(0 1))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5))\n  (equal? (limb-scale '(9 9) 9 10) '(1 9 8))\n  (equal? (limb-scale '(1 2 3) 0 10) '(0))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limb-scale"], "split": "train"}
{"id": "fast_multiply_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-multiply-schoolbook` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Each partial product must be shifted by its limb position.\n\n```scheme\n(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (limbs-add result partial base)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-multiply-schoolbook"], "split": "train"}
{"id": "fast_multiply_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `limbs-multiply-schoolbook` in `lattice/number-theory/fast-multiply.ss`.\nKnown issue: Partial products must accumulate with addition; current code discards previous result.\n\n```scheme\n(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        result\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-shift partial shift)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n(equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))", "verify_expr": "(let ()\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (and\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n  (equal? (limbs-multiply-schoolbook '(0) '(5 6 7) 10) '(0))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000)\n                                                      (integer->limbs 67890 1000)\n                                                      1000)\n                         1000)\n          (* 12345 67890))))", "tags": ["tier0", "number-theory", "fast-multiply", "bugfix", "limbs-multiply-schoolbook"], "split": "eval"}
{"id": "fast_multiply_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: small integration task across module primitives.\n\nConvert '(3 2 1) in base 10 to an integer.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs->integer '(3 2 1) 10) 123)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs->integer '(3 2 1) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer '(3 2 1) 10) 123))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs->integer", "direct"], "split": "eval"}
{"id": "fast_multiply_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert '(0 1) in base 10 to an integer.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs->integer '(0 1) 10) 10)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs->integer '(0 1) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer '(0 1) 10) 10))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs->integer", "direct"], "split": "train"}
{"id": "fast_multiply_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: small integration task across module primitives.\n\nRoundtrip 12345 through integer->limbs and back in base 100.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs->integer (integer->limbs 12345 100) 100) 12345)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs->integer (integer->limbs 12345 100) 100)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer (integer->limbs 12345 100) 100) 12345))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs->integer", "roundtrip"], "split": "train"}
{"id": "fast_multiply_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs->integer", "prompt": "Task mode: small integration task across module primitives.\n\nConvert schoolbook product limbs for 12*34 in base 10 to integer.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs->integer (limbs-multiply-schoolbook '(2 1) '(4 3) 10) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer (limbs-multiply-schoolbook '(2 1) '(4 3) 10) 10) 408))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs->integer", "integration"], "split": "train"}
{"id": "fast_multiply_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: small integration task across module primitives.\n\nConvert integer 123 in base 10 to limbs.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(integer->limbs 123 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (integer->limbs 123 10) '(3 2 1)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "integer->limbs", "direct"], "split": "train"}
{"id": "fast_multiply_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: small integration task across module primitives.\n\nConvert integer 0 in base 10 to canonical zero limbs.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (integer->limbs 0 10) '(0))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(integer->limbs 0 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (integer->limbs 0 10) '(0)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "integer->limbs", "edge-case"], "split": "train"}
{"id": "fast_multiply_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert 12345 in base 100.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (integer->limbs 12345 100) '(45 23 1))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(integer->limbs 12345 100)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (integer->limbs 12345 100) '(45 23 1)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "integer->limbs", "direct"], "split": "train"}
{"id": "fast_multiply_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "integer->limbs", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff converting then reconverting 67890 in base 1000 is identity.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (limbs->integer (integer->limbs 67890 1000) 1000) 67890)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (= (limbs->integer (integer->limbs 67890 1000) 1000) 67890) #t))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "integer->limbs", "property"], "split": "train"}
{"id": "fast_multiply_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: compose existing APIs into one expression.\n\nNormalize '(1 2 3 0 0).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-normalize '(1 2 3 0 0))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-normalize '(1 2 3 0 0)) '(1 2 3)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-normalize", "direct"], "split": "eval"}
{"id": "fast_multiply_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nNormalize all-zero limbs '(0 0 0).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-normalize '(0 0 0))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-normalize '(0 0 0)) '(0)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-normalize", "edge-case"], "split": "train"}
{"id": "fast_multiply_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: small integration task across module primitives.\n\nNormalize already-canonical limbs '(7 8 9).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-normalize '(7 8 9)) '(7 8 9))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limbs-normalize '(7 8 9))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-normalize '(7 8 9)) '(7 8 9)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-normalize", "direct"], "split": "train"}
{"id": "fast_multiply_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-normalize", "prompt": "Task mode: small integration task across module primitives.\n\nNormalize the result of subtracting '(0 0 2) - '(0 0 1) in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-normalize (limbs-sub '(0 0 2) '(0 0 1) 10))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-normalize (limbs-sub '(0 0 2) '(0 0 1) 10)) '(0 0 1)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-normalize", "integration"], "split": "train"}
{"id": "fast_multiply_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd '(2) and '(3) in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-add '(2) '(3) 10) '(5))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limbs-add '(2) '(3) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-add '(2) '(3) 10) '(5)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-add", "direct"], "split": "train"}
{"id": "fast_multiply_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: small integration task across module primitives.\n\nAdd '(9 9) and '(1 1) in base 10 (carry propagation).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limbs-add '(9 9) '(1 1) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-add '(9 9) '(1 1) 10) '(0 1 1)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-add", "carry"], "split": "train"}
{"id": "fast_multiply_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff addition is commutative for '(1 2 3) and '(4 5 6) in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (limbs-add '(1 2 3) '(4 5 6) 10) (limbs-add '(4 5 6) '(1 2 3) 10))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-add '(1 2 3) '(4 5 6) 10) (limbs-add '(4 5 6) '(1 2 3) 10)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-add", "property"], "split": "train"}
{"id": "fast_multiply_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-add", "prompt": "Task mode: compose existing APIs into one expression.\n\nAdd scaled limbs: (scale '(2 7) by 8) + '(4) in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-add (limb-scale '(2 7) 8 10) '(4) 10) '(0 8 5))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs-add (limb-scale '(2 7) 8 10) '(4) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-add (limb-scale '(2 7) 8 10) '(4) 10) '(0 8 5)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-add", "integration"], "split": "train"}
{"id": "fast_multiply_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: compose existing APIs into one expression.\n\nSubtract '(3) from '(5) in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-sub '(5) '(3) 10) '(2))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-sub '(5) '(3) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-sub '(5) '(3) 10) '(2)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-sub", "direct"], "split": "eval"}
{"id": "fast_multiply_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: small integration task across module primitives.\n\nSubtract '(1) from '(0 0 1) in base 10 (borrow case).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limbs-sub '(0 0 1) '(1) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-sub '(0 0 1) '(1) 10) '(9 9)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-sub", "borrow"], "split": "train"}
{"id": "fast_multiply_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute '(5 7 9) - '(4 5 6) in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limbs-sub '(5 7 9) '(4 5 6) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-sub '(5 7 9) '(4 5 6) 10) '(1 2 3)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-sub", "direct"], "split": "train"}
{"id": "fast_multiply_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-sub", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff (a+b)-b = a for a='(3 2 1), b='(5 4) in base 10.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (limbs-sub (limbs-add '(3 2 1) '(5 4) 10) '(5 4) 10) '(3 2 1))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-sub (limbs-add '(3 2 1) '(5 4) 10) '(5 4) 10) '(3 2 1)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-sub", "property"], "split": "train"}
{"id": "fast_multiply_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nShift '(1 2 3) left by 2 limbs.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limbs-shift '(1 2 3) 2)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-shift '(1 2 3) 2) '(0 0 1 2 3)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-shift", "direct"], "split": "train"}
{"id": "fast_multiply_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: small integration task across module primitives.\n\nShift '(0) left by 3 limbs and keep canonical zero.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-shift '(0) 3) '(0))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limbs-shift '(0) 3)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-shift '(0) 3) '(0)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-shift", "edge-case"], "split": "train"}
{"id": "fast_multiply_composition_023", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: small integration task across module primitives.\n\nShift '(5) by 0 limbs.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-shift '(5) 0)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-shift '(5) 0) '(5)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-shift", "direct"], "split": "train"}
{"id": "fast_multiply_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-shift", "prompt": "Task mode: small integration task across module primitives.\n\nConvert shifted limbs '(3 2 1) by 2 (base 10) to integer.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs->integer (limbs-shift '(3 2 1) 2) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer (limbs-shift '(3 2 1) 2) 10) 12300))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-shift", "integration"], "split": "eval"}
{"id": "fast_multiply_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nScale '(5) by scalar 2 in base 10.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limb-scale '(5) 2 10) '(0 1))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limb-scale '(5) 2 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limb-scale '(5) 2 10) '(0 1)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limb-scale", "direct"], "split": "train"}
{"id": "fast_multiply_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nScale '(2 7) by scalar 8 in base 10.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limb-scale '(2 7) 8 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limb-scale '(2 7) 8 10) '(6 7 5)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limb-scale", "direct"], "split": "train"}
{"id": "fast_multiply_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: small integration task across module primitives.\n\nScale any limbs by 0 and return canonical zero.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(limb-scale '(9 8 7) 0 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limb-scale '(9 8 7) 0 10) '(0)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limb-scale", "edge-case"], "split": "train"}
{"id": "fast_multiply_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limb-scale", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff limb-scale matches integer multiplication for '(2 7), scalar 8, base 10.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (= (limbs->integer (limb-scale '(2 7) 8 10) 10) (* (limbs->integer '(2 7) 10) 8)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (limbs->integer (limb-scale '(2 7) 8 10) 10) (* (limbs->integer '(2 7) 10) 8))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (= (limbs->integer (limb-scale '(2 7) 8 10) 10) (* (limbs->integer '(2 7) 10) 8)) #t))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limb-scale", "property"], "split": "train"}
{"id": "fast_multiply_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: compose existing APIs into one expression.\n\nMultiply 12 by 34 in base-10 limb form.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(limbs-multiply-schoolbook '(2 1) '(4 3) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-multiply-schoolbook '(2 1) '(4 3) 10) '(8 0 4)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-multiply-schoolbook", "direct"], "split": "train"}
{"id": "fast_multiply_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: compose existing APIs into one expression.\n\nMultiply by zero in limb form.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-multiply-schoolbook '(1 2 3) '(0) 10) '(0))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs-multiply-schoolbook '(1 2 3) '(0) 10)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-multiply-schoolbook '(1 2 3) '(0) 10) '(0)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-multiply-schoolbook", "edge-case"], "split": "train"}
{"id": "fast_multiply_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute integer product 12345*67890 via schoolbook limbs at base 1000.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000) (integer->limbs 67890 1000) 1000) 1000)", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs->integer (limbs-multiply-schoolbook (integer->limbs 12345 1000) (integer->limbs 67890 1000) 1000) 1000) (* 12345 67890)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-multiply-schoolbook", "integration"], "split": "train"}
{"id": "fast_multiply_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/number-theory/fast-multiply.ss", "source_test": "lattice/number-theory/test-fast-multiply.ss", "source_function": "limbs-multiply-schoolbook", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff schoolbook multiplication is commutative for (123,456) at base 10.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (limbs-multiply-schoolbook (integer->limbs 123 10) (integer->limbs 456 10) 10) (limbs-multiply-schoolbook (integer->limbs 456 10) (integer->limbs 123 10) 10))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (limbs-multiply-schoolbook (integer->limbs 123 10) (integer->limbs 456 10) 10) (limbs-multiply-schoolbook (integer->limbs 456 10) (integer->limbs 123 10) 10))", "verify_expr": "(let ()\n  (define (limbs->integer limbs base)\n  (let loop ([ls limbs] [multiplier 1] [result 0])\n    (if (null? ls)\n        result\n        (loop (cdr ls)\n              (* multiplier base)\n              (+ result (* (car ls) multiplier))))))\n  (define (integer->limbs n base)\n  (if (= n 0)\n      '(0)\n      (let loop ([n n] [limbs '()])\n        (if (= n 0)\n            (reverse limbs)\n            (loop (quotient n base)\n                  (cons (modulo n base) limbs))))))\n  (define (limbs-normalize limbs)\n  (let loop ([ls (reverse limbs)])\n    (cond\n      [(null? ls) '(0)]\n      [(and (= (car ls) 0) (not (null? (cdr ls))))\n       (loop (cdr ls))]\n      [else (reverse ls)])))\n  (define (limbs-add a b base)\n  (let loop ([a a] [b b] [carry 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize\n        (reverse (if (> carry 0) (cons carry result) result)))]\n      [(null? a)\n       (loop '() (cdr b)\n             (quotient (+ (car b) carry) base)\n             (cons (modulo (+ (car b) carry) base) result))]\n      [(null? b)\n       (loop (cdr a) '()\n             (quotient (+ (car a) carry) base)\n             (cons (modulo (+ (car a) carry) base) result))]\n      [else\n       (let ([sum (+ (car a) (car b) carry)])\n         (loop (cdr a) (cdr b)\n               (quotient sum base)\n               (cons (modulo sum base) result)))])))\n  (define (limbs-sub a b base)\n  (let loop ([a a] [b b] [borrow 0] [result '()])\n    (cond\n      [(and (null? a) (null? b))\n       (limbs-normalize (reverse result))]\n      [(null? b)\n       (let ([diff (- (car a) borrow)])\n         (if (< diff 0)\n             (loop (cdr a) '() 1 (cons (+ diff base) result))\n             (loop (cdr a) '() 0 (cons diff result))))]\n      [else\n       (let* ([av (if (null? a) 0 (car a))]\n              [bv (car b)]\n              [diff (- av bv borrow)])\n         (if (< diff 0)\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   1\n                   (cons (+ diff base) result))\n             (loop (if (null? a) '() (cdr a))\n                   (cdr b)\n                   0\n                   (cons diff result))))])))\n  (define (limbs-shift limbs k)\n  (if (and (= 1 (length limbs)) (= 0 (car limbs)))\n      limbs\n      (append (make-list k 0) limbs)))\n  (define (limb-scale limbs scalar base)\n  (let loop ([ls limbs] [carry 0] [result '()])\n    (if (null? ls)\n        (limbs-normalize\n         (reverse (if (> carry 0) (cons carry result) result)))\n        (let ([prod (+ (* (car ls) scalar) carry)])\n          (loop (cdr ls)\n                (quotient prod base)\n                (cons (modulo prod base) result))))))\n  (define (limbs-multiply-schoolbook a b base)\n  (let loop ([b b] [shift 0] [result '(0)])\n    (if (null? b)\n        (limbs-normalize result)\n        (let ([partial (limb-scale a (car b) base)])\n          (loop (cdr b)\n                (+ shift 1)\n                (limbs-add result (limbs-shift partial shift) base))))))\n  (equal? (limbs-multiply-schoolbook (integer->limbs 123 10) (integer->limbs 456 10) 10) (limbs-multiply-schoolbook (integer->limbs 456 10) (integer->limbs 123 10) 10)))", "tags": ["tier0", "number-theory", "fast-multiply", "composition", "limbs-multiply-schoolbook", "property"], "split": "eval"}
