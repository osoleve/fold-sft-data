{"id": "hamt_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-empty?`\nSpec: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\nWrite exactly one Scheme function definition for `hamt-empty?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-empty?`\nSpec: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\nWrite exactly one Scheme function definition for `hamt-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-empty?"], "split": "train"}
{"id": "hamt_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-empty?`\nBehavior contract: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\n```scheme\n(define (hamt-empty? x)\n  ;; TODO: detect the canonical empty HAMT marker\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-empty?`\nBehavior contract: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\n```scheme\n(define (hamt-empty? x)\n  ;; TODO: detect the canonical empty HAMT marker\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-empty?"], "split": "train"}
{"id": "hamt_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-lookup`\nSpec: Lookup key in HAMT and return its value, or #f when absent.\n\nWrite exactly one Scheme function definition for `hamt-lookup`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-lookup`\nSpec: Lookup key in HAMT and return its value, or #f when absent.\n\nWrite exactly one Scheme function definition for `hamt-lookup`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-lookup"], "split": "train"}
{"id": "hamt_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-lookup`\nBehavior contract: Lookup key in HAMT and return its value, or #f when absent.\n\n```scheme\n(define (hamt-lookup key hamt)\n  ;; TODO: hash key and delegate to recursive lookup\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-lookup`\nBehavior contract: Lookup key in HAMT and return its value, or #f when absent.\n\n```scheme\n(define (hamt-lookup key hamt)\n  ;; TODO: hash key and delegate to recursive lookup\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-lookup"], "split": "train"}
{"id": "hamt_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-lookup-or`\nSpec: Lookup key and return default when key is absent.\n\nWrite exactly one Scheme function definition for `hamt-lookup-or`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-lookup-or`\nSpec: Lookup key and return default when key is absent.\n\nWrite exactly one Scheme function definition for `hamt-lookup-or`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-lookup-or"], "split": "train"}
{"id": "hamt_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-lookup-or`\nBehavior contract: Lookup key and return default when key is absent.\n\n```scheme\n(define (hamt-lookup-or key hamt default)\n  ;; TODO: hash key and delegate to recursive lookup-or\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-lookup-or`\nBehavior contract: Lookup key and return default when key is absent.\n\n```scheme\n(define (hamt-lookup-or key hamt default)\n  ;; TODO: hash key and delegate to recursive lookup-or\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-lookup-or"], "split": "train"}
{"id": "hamt_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-has-key?`\nSpec: Return key existence even when value is #f (must not use lookup truthiness).\n\nWrite exactly one Scheme function definition for `hamt-has-key?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-has-key?`\nSpec: Return key existence even when value is #f (must not use lookup truthiness).\n\nWrite exactly one Scheme function definition for `hamt-has-key?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-has-key?"], "split": "train"}
{"id": "hamt_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-has-key?`\nBehavior contract: Return key existence even when value is #f (must not use lookup truthiness).\n\n```scheme\n(define (hamt-has-key? key hamt)\n  ;; TODO: distinguish missing key from key mapped to #f\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-has-key?`\nBehavior contract: Return key existence even when value is #f (must not use lookup truthiness).\n\n```scheme\n(define (hamt-has-key? key hamt)\n  ;; TODO: distinguish missing key from key mapped to #f\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-has-key?"], "split": "train"}
{"id": "hamt_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-dissoc`\nSpec: Remove key from HAMT and return updated HAMT without mutating input.\n\nWrite exactly one Scheme function definition for `hamt-dissoc`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-dissoc`\nSpec: Remove key from HAMT and return updated HAMT without mutating input.\n\nWrite exactly one Scheme function definition for `hamt-dissoc`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-dissoc"], "split": "train"}
{"id": "hamt_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-dissoc`\nBehavior contract: Remove key from HAMT and return updated HAMT without mutating input.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  ;; TODO: hash key and remove persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-dissoc`\nBehavior contract: Remove key from HAMT and return updated HAMT without mutating input.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  ;; TODO: hash key and remove persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-dissoc"], "split": "train"}
{"id": "hamt_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-fold`\nSpec: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\nWrite exactly one Scheme function definition for `hamt-fold`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-fold`\nSpec: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\nWrite exactly one Scheme function definition for `hamt-fold`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-fold"], "split": "train"}
{"id": "hamt_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-fold`\nBehavior contract: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\n```scheme\n(define (hamt-fold f init hamt)\n  ;; TODO: fold over leaves/collisions/nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-fold`\nBehavior contract: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\n```scheme\n(define (hamt-fold f init hamt)\n  ;; TODO: fold over leaves/collisions/nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-fold"], "split": "train"}
{"id": "hamt_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-size`\nSpec: Count the number of key-value pairs in HAMT.\n\nWrite exactly one Scheme function definition for `hamt-size`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-size`\nSpec: Count the number of key-value pairs in HAMT.\n\nWrite exactly one Scheme function definition for `hamt-size`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-size"], "split": "train"}
{"id": "hamt_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-size`\nBehavior contract: Count the number of key-value pairs in HAMT.\n\n```scheme\n(define (hamt-size hamt)\n  ;; TODO: fold through HAMT and count entries\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-size`\nBehavior contract: Count the number of key-value pairs in HAMT.\n\n```scheme\n(define (hamt-size hamt)\n  ;; TODO: fold through HAMT and count entries\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-size"], "split": "train"}
{"id": "hamt_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-keys`\nSpec: Collect all keys contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-keys`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-keys`\nSpec: Collect all keys contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-keys`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-keys"], "split": "train"}
{"id": "hamt_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-keys`\nBehavior contract: Collect all keys contained in the HAMT.\n\n```scheme\n(define (hamt-keys hamt)\n  ;; TODO: collect all keys with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-keys`\nBehavior contract: Collect all keys contained in the HAMT.\n\n```scheme\n(define (hamt-keys hamt)\n  ;; TODO: collect all keys with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-keys"], "split": "train"}
{"id": "hamt_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-values`\nSpec: Collect all values contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-values`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-values`\nSpec: Collect all values contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-values`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-values"], "split": "train"}
{"id": "hamt_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-values`\nBehavior contract: Collect all values contained in the HAMT.\n\n```scheme\n(define (hamt-values hamt)\n  ;; TODO: collect all values with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-values`\nBehavior contract: Collect all values contained in the HAMT.\n\n```scheme\n(define (hamt-values hamt)\n  ;; TODO: collect all values with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-values"], "split": "train"}
{"id": "hamt_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-entries`\nSpec: Collect key/value pairs as an association list.\n\nWrite exactly one Scheme function definition for `hamt-entries`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-entries`\nSpec: Collect key/value pairs as an association list.\n\nWrite exactly one Scheme function definition for `hamt-entries`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-entries"], "split": "train"}
{"id": "hamt_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-entries`\nBehavior contract: Collect key/value pairs as an association list.\n\n```scheme\n(define (hamt-entries hamt)\n  ;; TODO: collect key/value pairs with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-entries`\nBehavior contract: Collect key/value pairs as an association list.\n\n```scheme\n(define (hamt-entries hamt)\n  ;; TODO: collect key/value pairs with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-entries"], "split": "train"}
{"id": "hamt_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-map-values`\nSpec: Map a value transform over HAMT values while preserving keys/shape.\n\nWrite exactly one Scheme function definition for `hamt-map-values`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-map-values`\nSpec: Map a value transform over HAMT values while preserving keys/shape.\n\nWrite exactly one Scheme function definition for `hamt-map-values`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-map-values"], "split": "train"}
{"id": "hamt_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-map-values`\nBehavior contract: Map a value transform over HAMT values while preserving keys/shape.\n\n```scheme\n(define (hamt-map-values f hamt)\n  ;; TODO: recursively map value transformer across HAMT nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-map-values`\nBehavior contract: Map a value transform over HAMT values while preserving keys/shape.\n\n```scheme\n(define (hamt-map-values f hamt)\n  ;; TODO: recursively map value transformer across HAMT nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-map-values"], "split": "train"}
{"id": "hamt_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-filter`\nSpec: Keep only entries where predicate `(pred key value)` is true.\n\nWrite exactly one Scheme function definition for `hamt-filter`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-filter`\nSpec: Keep only entries where predicate `(pred key value)` is true.\n\nWrite exactly one Scheme function definition for `hamt-filter`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-filter"], "split": "train"}
{"id": "hamt_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-filter`\nBehavior contract: Keep only entries where predicate `(pred key value)` is true.\n\n```scheme\n(define (hamt-filter pred hamt)\n  ;; TODO: filter entries by predicate on key and value\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-filter`\nBehavior contract: Keep only entries where predicate `(pred key value)` is true.\n\n```scheme\n(define (hamt-filter pred hamt)\n  ;; TODO: filter entries by predicate on key and value\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-filter"], "split": "train"}
{"id": "hamt_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-merge`\nSpec: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\nWrite exactly one Scheme function definition for `hamt-merge`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-merge`\nSpec: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\nWrite exactly one Scheme function definition for `hamt-merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-merge"], "split": "train"}
{"id": "hamt_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-merge`\nBehavior contract: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\n```scheme\n(define (hamt-merge h1 h2)\n  ;; TODO: right-biased merge using hamt-fold and hamt-assoc\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-merge`\nBehavior contract: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\n```scheme\n(define (hamt-merge h1 h2)\n  ;; TODO: right-biased merge using hamt-fold and hamt-assoc\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-merge"], "split": "train"}
{"id": "hamt_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `dict->hamt`\nSpec: Convert an association-list dictionary into a HAMT.\n\nWrite exactly one Scheme function definition for `dict->hamt`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `dict->hamt`\nSpec: Convert an association-list dictionary into a HAMT.\n\nWrite exactly one Scheme function definition for `dict->hamt`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "dict->hamt"], "split": "train"}
{"id": "hamt_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `dict->hamt`\nBehavior contract: Convert an association-list dictionary into a HAMT.\n\n```scheme\n(define (dict->hamt dict)\n  ;; TODO: fold association pairs into a HAMT\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `dict->hamt`\nBehavior contract: Convert an association-list dictionary into a HAMT.\n\n```scheme\n(define (dict->hamt dict)\n  ;; TODO: fold association pairs into a HAMT\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "dict->hamt"], "split": "train"}
{"id": "hamt_spec_to_code_033", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `alist->hamt`\nSpec: Convert association list to HAMT; duplicate keys keep the last value.\n\nWrite exactly one Scheme function definition for `alist->hamt`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `alist->hamt`\nSpec: Convert association list to HAMT; duplicate keys keep the last value.\n\nWrite exactly one Scheme function definition for `alist->hamt`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "alist->hamt"], "split": "train"}
{"id": "hamt_spec_to_code_034", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `alist->hamt`\nBehavior contract: Convert association list to HAMT; duplicate keys keep the last value.\n\n```scheme\n(define (alist->hamt alist)\n  ;; TODO: build HAMT from association list\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `alist->hamt`\nBehavior contract: Convert association list to HAMT; duplicate keys keep the last value.\n\n```scheme\n(define (alist->hamt alist)\n  ;; TODO: build HAMT from association list\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "alist->hamt"], "split": "train"}
{"id": "hamt_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-empty?`\n\n```python\ndef hamt_empty_p(x):\n    return x == 'hamt-empty'\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-empty?`\n\n```python\ndef hamt_empty_p(x):\n    return x == 'hamt-empty'\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-empty?"], "split": "train"}
{"id": "hamt_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-empty?`\n\n```scheme\n(define (hamt-empty0? x)\n  (eq? x 'hamt-empty))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-empty?`\n\n```scheme\n(define (hamt-empty0? x)\n  (eq? x 'hamt-empty))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-empty?"], "split": "train"}
{"id": "hamt_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-lookup`\n\n```python\ndef hamt_lookup(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_lookup_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-lookup`\n\n```python\ndef hamt_lookup(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_lookup_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-lookup"], "split": "train"}
{"id": "hamt_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-lookup`\n\n```scheme\n(define (hamt-get key h)\n  (let ((hash (hamt-hash-key key)))\n    (hamt-lookup-hash hash key h 0)))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-lookup`\n\n```scheme\n(define (hamt-get key h)\n  (let ((hash (hamt-hash-key key)))\n    (hamt-lookup-hash hash key h 0)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-lookup"], "split": "train"}
{"id": "hamt_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-lookup-or`\n\n```python\ndef hamt_lookup_or_fn(key, hamt, default):\n    h = hamt_hash_key(key)\n    return hamt_lookup_or_hash(h, key, hamt, 0, default)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-lookup-or`\n\n```python\ndef hamt_lookup_or_fn(key, hamt, default):\n    h = hamt_hash_key(key)\n    return hamt_lookup_or_hash(h, key, hamt, 0, default)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-lookup-or"], "split": "train"}
{"id": "hamt_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-lookup-or`\n\n```scheme\n(define (hamt-get-or key h default)\n  (let ((hash (hamt-hash-key key)))\n    (hamt-lookup-or-hash hash key h 0 default)))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-lookup-or`\n\n```scheme\n(define (hamt-get-or key h default)\n  (let ((hash (hamt-hash-key key)))\n    (hamt-lookup-or-hash hash key h 0 default)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-lookup-or"], "split": "train"}
{"id": "hamt_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-has-key?`\n\n```python\ndef hamt_has_key(key, hamt):\n    sentinel = ['not-found']\n    return sentinel is not hamt_lookup_or(key, hamt, sentinel)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-has-key?`\n\n```python\ndef hamt_has_key(key, hamt):\n    sentinel = ['not-found']\n    return sentinel is not hamt_lookup_or(key, hamt, sentinel)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-has-key?"], "split": "train"}
{"id": "hamt_translation_008", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-has-key?`\n\n```scheme\n(define (hamt-has0? k h)\n  (let ((sentinel (list 'not-found)))\n    (not (eq? sentinel (hamt-lookup-or k h sentinel)))))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-has-key?`\n\n```scheme\n(define (hamt-has0? k h)\n  (let ((sentinel (list 'not-found)))\n    (not (eq? sentinel (hamt-lookup-or k h sentinel)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-has-key?"], "split": "train"}
{"id": "hamt_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-dissoc`\n\n```python\ndef hamt_dissoc(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_dissoc_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-dissoc`\n\n```python\ndef hamt_dissoc(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_dissoc_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-dissoc"], "split": "train"}
{"id": "hamt_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-dissoc`\n\n```scheme\n(define (hamt-del k h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-dissoc-hash hash k h 0)))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-dissoc`\n\n```scheme\n(define (hamt-del k h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-dissoc-hash hash k h 0)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-dissoc"], "split": "train"}
{"id": "hamt_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-fold`\n\n```python\ndef hamt_fold_fn(f, init, hamt):\n    if hamt_empty_p(hamt):\n        return init\n    if hamt_leaf_p(hamt):\n        return f(init, hamt_leaf_key(hamt), hamt_leaf_value(hamt))\n    if hamt_collision_p(hamt):\n        acc = init\n        for k, v in hamt_collision_entries(hamt):\n            acc = f(acc, k, v)\n        return acc\n    if hamt_node_p(hamt):\n        acc = init\n        for child in hamt_node_children(hamt):\n            acc = hamt_fold_fn(f, acc, child)\n        return acc\n    return init\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-fold`\n\n```python\ndef hamt_fold_fn(f, init, hamt):\n    if hamt_empty_p(hamt):\n        return init\n    if hamt_leaf_p(hamt):\n        return f(init, hamt_leaf_key(hamt), hamt_leaf_value(hamt))\n    if hamt_collision_p(hamt):\n        acc = init\n        for k, v in hamt_collision_entries(hamt):\n            acc = f(acc, k, v)\n        return acc\n    if hamt_node_p(hamt):\n        acc = init\n        for child in hamt_node_children(hamt):\n            acc = hamt_fold_fn(f, acc, child)\n        return acc\n    return init\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-fold"], "split": "train"}
{"id": "hamt_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-fold`\n\n```scheme\n(define (hamt-fold0 f init h)\n  (cond\n    ((hamt-empty? h) init)\n    ((hamt-leaf? h) (f init (hamt-leaf-key h) (hamt-leaf-value h)))\n    ((hamt-collision? h)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init\n                (hamt-collision-entries h)))\n    ((hamt-node? h)\n     (fold-left (lambda (acc child) (hamt-fold0 f acc child))\n                init\n                (hamt-node-children h)))\n    (else init)))\n```\n\nReturn only Fold code.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-fold`\n\n```scheme\n(define (hamt-fold0 f init h)\n  (cond\n    ((hamt-empty? h) init)\n    ((hamt-leaf? h) (f init (hamt-leaf-key h) (hamt-leaf-value h)))\n    ((hamt-collision? h)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init\n                (hamt-collision-entries h)))\n    ((hamt-node? h)\n     (fold-left (lambda (acc child) (hamt-fold0 f acc child))\n                init\n                (hamt-node-children h)))\n    (else init)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-fold"], "split": "train"}
{"id": "hamt_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-size`\n\n```python\ndef hamt_size(hamt):\n    return hamt_fold(lambda acc, k, v: acc + 1, 0, hamt)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-size`\n\n```python\ndef hamt_size(hamt):\n    return hamt_fold(lambda acc, k, v: acc + 1, 0, hamt)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-size"], "split": "train"}
{"id": "hamt_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-size`\n\n```scheme\n(define (hamt-count h)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-size`\n\n```scheme\n(define (hamt-count h)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-size"], "split": "train"}
{"id": "hamt_translation_017", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-keys`\n\n```python\ndef hamt_keys(hamt):\n    return hamt_fold(lambda acc, k, v: [k] + acc, [], hamt)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-keys`\n\n```python\ndef hamt_keys(hamt):\n    return hamt_fold(lambda acc, k, v: [k] + acc, [], hamt)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-keys"], "split": "train"}
{"id": "hamt_translation_018", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-keys`\n\n```scheme\n(define (hamt-keys0 h)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() h))\n```\n\nReturn only Fold code.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-keys`\n\n```scheme\n(define (hamt-keys0 h)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() h))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-keys"], "split": "train"}
{"id": "hamt_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-values`\n\n```python\ndef hamt_values(hamt):\n    return hamt_fold(lambda acc, k, v: [v] + acc, [], hamt)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-values`\n\n```python\ndef hamt_values(hamt):\n    return hamt_fold(lambda acc, k, v: [v] + acc, [], hamt)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-values"], "split": "train"}
{"id": "hamt_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-values`\n\n```scheme\n(define (hamt-values0 h)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() h))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-values`\n\n```scheme\n(define (hamt-values0 h)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() h))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-values"], "split": "train"}
{"id": "hamt_translation_021", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-entries`\n\n```python\ndef hamt_entries(hamt):\n    return hamt_fold(lambda acc, k, v: [(k, v)] + acc, [], hamt)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-entries`\n\n```python\ndef hamt_entries(hamt):\n    return hamt_fold(lambda acc, k, v: [(k, v)] + acc, [], hamt)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-entries"], "split": "train"}
{"id": "hamt_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-entries`\n\n```scheme\n(define (hamt-entries0 h)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() h))\n```\n\nReturn only Fold code.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-entries`\n\n```scheme\n(define (hamt-entries0 h)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() h))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-entries"], "split": "train"}
{"id": "hamt_translation_023", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-map-values`\n\n```python\ndef hamt_map_values(f, hamt):\n    if hamt_empty_p(hamt):\n        return hamt_empty\n    if hamt_leaf_p(hamt):\n        return make_hamt_leaf(hamt_leaf_hash(hamt), hamt_leaf_key(hamt), f(hamt_leaf_value(hamt)))\n    if hamt_collision_p(hamt):\n        return make_hamt_collision(hamt_collision_hash(hamt), [(k, f(v)) for (k, v) in hamt_collision_entries(hamt)])\n    if hamt_node_p(hamt):\n        return make_hamt_node(hamt_node_bitmap(hamt), [hamt_map_values(f, child) for child in hamt_node_children(hamt)])\n    return hamt\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-map-values`\n\n```python\ndef hamt_map_values(f, hamt):\n    if hamt_empty_p(hamt):\n        return hamt_empty\n    if hamt_leaf_p(hamt):\n        return make_hamt_leaf(hamt_leaf_hash(hamt), hamt_leaf_key(hamt), f(hamt_leaf_value(hamt)))\n    if hamt_collision_p(hamt):\n        return make_hamt_collision(hamt_collision_hash(hamt), [(k, f(v)) for (k, v) in hamt_collision_entries(hamt)])\n    if hamt_node_p(hamt):\n        return make_hamt_node(hamt_node_bitmap(hamt), [hamt_map_values(f, child) for child in hamt_node_children(hamt)])\n    return hamt\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-map-values"], "split": "train"}
{"id": "hamt_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-map-values`\n\n```scheme\n(define (hamt-map-values0 f h)\n  (cond\n    ((hamt-empty? h) hamt-empty)\n    ((hamt-leaf? h)\n     (make-hamt-leaf (hamt-leaf-hash h)\n                     (hamt-leaf-key h)\n                     (f (hamt-leaf-value h))))\n    ((hamt-collision? h)\n     (make-hamt-collision\n       (hamt-collision-hash h)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries h))))\n    ((hamt-node? h)\n     (make-hamt-node\n       (hamt-node-bitmap h)\n       (map (lambda (child) (hamt-map-values0 f child))\n            (hamt-node-children h))))\n    (else h)))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-map-values`\n\n```scheme\n(define (hamt-map-values0 f h)\n  (cond\n    ((hamt-empty? h) hamt-empty)\n    ((hamt-leaf? h)\n     (make-hamt-leaf (hamt-leaf-hash h)\n                     (hamt-leaf-key h)\n                     (f (hamt-leaf-value h))))\n    ((hamt-collision? h)\n     (make-hamt-collision\n       (hamt-collision-hash h)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries h))))\n    ((hamt-node? h)\n     (make-hamt-node\n       (hamt-node-bitmap h)\n       (map (lambda (child) (hamt-map-values0 f child))\n            (hamt-node-children h))))\n    (else h)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-map-values"], "split": "train"}
{"id": "hamt_translation_025", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-filter`\n\n```python\ndef hamt_filter(pred, hamt):\n    def step(acc, k, v):\n        return hamt_assoc(k, v, acc) if pred(k, v) else acc\n    return hamt_fold(step, hamt_empty, hamt)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-filter`\n\n```python\ndef hamt_filter(pred, hamt):\n    def step(acc, k, v):\n        return hamt_assoc(k, v, acc) if pred(k, v) else acc\n    return hamt_fold(step, hamt_empty, hamt)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-filter"], "split": "train"}
{"id": "hamt_translation_026", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-filter`\n\n```scheme\n(define (hamt-filter0 pred h)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v)\n                   (hamt-assoc k v acc)\n                   acc))\n             hamt-empty\n             h))\n```\n\nReturn only Fold code.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-filter`\n\n```scheme\n(define (hamt-filter0 pred h)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v)\n                   (hamt-assoc k v acc)\n                   acc))\n             hamt-empty\n             h))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-filter"], "split": "train"}
{"id": "hamt_translation_027", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-merge`\n\n```python\ndef hamt_merge(h1, h2):\n    return hamt_fold(lambda acc, k, v: hamt_assoc(k, v, acc), h1, h2)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-merge`\n\n```python\ndef hamt_merge(h1, h2):\n    return hamt_fold(lambda acc, k, v: hamt_assoc(k, v, acc), h1, h2)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-merge"], "split": "train"}
{"id": "hamt_translation_028", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-merge`\n\n```scheme\n(define (hamt-merge0 h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (hamt-assoc k v acc))\n             h1 h2))\n```\n\nReturn only Fold code.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-merge`\n\n```scheme\n(define (hamt-merge0 h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (hamt-assoc k v acc))\n             h1 h2))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-merge"], "split": "train"}
{"id": "hamt_translation_031", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `dict->hamt`\n\n```python\ndef dict_to_hamt(d):\n    acc = hamt_empty\n    for k, v in d:\n        acc = hamt_assoc(k, v, acc)\n    return acc\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `dict->hamt`\n\n```python\ndef dict_to_hamt(d):\n    acc = hamt_empty\n    for k, v in d:\n        acc = hamt_assoc(k, v, acc)\n    return acc\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "dict->hamt"], "split": "train"}
{"id": "hamt_translation_032", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `dict->hamt`\n\n```scheme\n(define (dict->hamt0 d)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty d))\n```\n\nReturn only Fold code.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `dict->hamt`\n\n```scheme\n(define (dict->hamt0 d)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty d))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "dict->hamt"], "split": "train"}
{"id": "hamt_translation_033", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `alist->hamt`\n\n```python\ndef alist_to_hamt(alist):\n    return dict_to_hamt(alist)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `alist->hamt`\n\n```python\ndef alist_to_hamt(alist):\n    return dict_to_hamt(alist)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "alist->hamt"], "split": "train"}
{"id": "hamt_translation_034", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist->hamt`\n\n```scheme\n(define (alist->hamt0 al)\n  (dict->hamt al))\n```\n\nReturn only Fold code.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist->hamt`\n\n```scheme\n(define (alist->hamt0 al)\n  (dict->hamt al))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "alist->hamt"], "split": "train"}
{"id": "hamt_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\n```scheme\n(define (hamt-empty? x)\n  (eq? x '()))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\n```scheme\n(define (hamt-empty? x)\n  (eq? x '()))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (hamt-empty? hamt-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-empty?"], "split": "train"}
{"id": "hamt_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Predicate polarity is reversed.\n\n```scheme\n(define (hamt-empty? x)\n  (not (eq? x 'hamt-empty)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Predicate polarity is reversed.\n\n```scheme\n(define (hamt-empty? x)\n  (not (eq? x 'hamt-empty)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Predicate polarity is reversed.\n\nExpected behavior after patch:\n```scheme\n(let () (hamt-empty? hamt-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-empty?"], "split": "train"}
{"id": "hamt_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup` in `lattice/data/hamt.ss`.\nKnown issue: Lookup hash must be derived from key, not from hamt object.\n\n```scheme\n(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key hamt)])\n    (hamt-lookup-hash hash key hamt 0)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup` in `lattice/data/hamt.ss`.\nKnown issue: Lookup hash must be derived from key, not from hamt object.\n\n```scheme\n(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key hamt)])\n    (hamt-lookup-hash hash key hamt 0)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-lookup"], "split": "train"}
{"id": "hamt_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup` in `lattice/data/hamt.ss`.\nKnown issue: Recursive lookup must start at shift 0.\n\n```scheme\n(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup` in `lattice/data/hamt.ss`.\nKnown issue: Recursive lookup must start at shift 0.\n\n```scheme\n(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-lookup"], "split": "train"}
{"id": "hamt_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup-or` in `lattice/data/hamt.ss`.\nKnown issue: Function must return the provided default on miss, not hardcoded #f.\n\n```scheme\n(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 #f)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup-or` in `lattice/data/hamt.ss`.\nKnown issue: Function must return the provided default on miss, not hardcoded #f.\n\n```scheme\n(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 #f)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-lookup-or"], "split": "train"}
{"id": "hamt_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-has-key?` in `lattice/data/hamt.ss`.\nKnown issue: Keys mapped to #f must still count as present.\n\n```scheme\n(define (hamt-has-key? key hamt)\n  (if (hamt-lookup key hamt) #t #f))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-has-key?` in `lattice/data/hamt.ss`.\nKnown issue: Keys mapped to #f must still count as present.\n\n```scheme\n(define (hamt-has-key? key hamt)\n  (if (hamt-lookup key hamt) #t #f))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-has-key?"], "split": "train"}
{"id": "hamt_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-has-key?` in `lattice/data/hamt.ss`.\nKnown issue: Using #f as sentinel breaks presence checks for keys with #f values.\n\n```scheme\n(define (hamt-has-key? key hamt)\n  (not (eq? #f (hamt-lookup-or key hamt #f))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-has-key?` in `lattice/data/hamt.ss`.\nKnown issue: Using #f as sentinel breaks presence checks for keys with #f values.\n\n```scheme\n(define (hamt-has-key? key hamt)\n  (not (eq? #f (hamt-lookup-or key hamt #f))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Using #f as sentinel breaks presence checks for keys with #f values.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-has-key?"], "split": "train"}
{"id": "hamt_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Function must actually remove key when present.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  hamt)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Function must actually remove key when present.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  hamt)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Function must actually remove key when present.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-dissoc"], "split": "train"}
{"id": "hamt_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Deletion recursion must start at shift 0.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Deletion recursion must start at shift 0.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-dissoc"], "split": "train"}
{"id": "hamt_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-fold` in `lattice/data/hamt.ss`.\nKnown issue: Leaf fold argument order must be (acc key value), and node/collision traversal cannot be omitted.\n\n```scheme\n(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-value hamt) (hamt-leaf-key hamt))]\n    [else init]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-fold` in `lattice/data/hamt.ss`.\nKnown issue: Leaf fold argument order must be (acc key value), and node/collision traversal cannot be omitted.\n\n```scheme\n(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-value hamt) (hamt-leaf-key hamt))]\n    [else init]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Leaf fold argument order must be (acc key value), and node/collision traversal cannot be omitted.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-fold"], "split": "train"}
{"id": "hamt_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-size` in `lattice/data/hamt.ss`.\nKnown issue: Size should count entries, not sum values.\n\n```scheme\n(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc v)) 0 hamt))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-size` in `lattice/data/hamt.ss`.\nKnown issue: Size should count entries, not sum values.\n\n```scheme\n(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc v)) 0 hamt))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Size should count entries, not sum values.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-size"], "split": "train"}
{"id": "hamt_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-size` in `lattice/data/hamt.ss`.\nKnown issue: Initial count must be 0.\n\n```scheme\n(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 1 hamt))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-size` in `lattice/data/hamt.ss`.\nKnown issue: Initial count must be 0.\n\n```scheme\n(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 1 hamt))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-size"], "split": "train"}
{"id": "hamt_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-keys` in `lattice/data/hamt.ss`.\nKnown issue: Key collection must accumulate keys, not values.\n\n```scheme\n(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-keys` in `lattice/data/hamt.ss`.\nKnown issue: Key collection must accumulate keys, not values.\n\n```scheme\n(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-keys"], "split": "train"}
{"id": "hamt_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-values` in `lattice/data/hamt.ss`.\nKnown issue: Value collection must accumulate values, not keys.\n\n```scheme\n(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-values` in `lattice/data/hamt.ss`.\nKnown issue: Value collection must accumulate values, not keys.\n\n```scheme\n(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-values"], "split": "train"}
{"id": "hamt_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-entries` in `lattice/data/hamt.ss`.\nKnown issue: Entry orientation must remain (key . value).\n\n```scheme\n(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons v k) acc)) '() hamt))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-entries` in `lattice/data/hamt.ss`.\nKnown issue: Entry orientation must remain (key . value).\n\n```scheme\n(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons v k) acc)) '() hamt))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Entry orientation must remain (key . value).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-entries"], "split": "train"}
{"id": "hamt_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-map-values` in `lattice/data/hamt.ss`.\nKnown issue: Mapping should apply the provided transformer and must not recurse infinitely.\n\n```scheme\n(define (hamt-map-values f hamt)\n  (hamt-map-values (lambda (x) x) hamt))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-map-values` in `lattice/data/hamt.ss`.\nKnown issue: Mapping should apply the provided transformer and must not recurse infinitely.\n\n```scheme\n(define (hamt-map-values f hamt)\n  (hamt-map-values (lambda (x) x) hamt))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-map-values"], "split": "train"}
{"id": "hamt_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-filter` in `lattice/data/hamt.ss`.\nKnown issue: Filter predicate handling is inverted; true should keep entries.\n\n```scheme\n(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) acc (hamt-assoc k v acc)))\n             hamt-empty hamt))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-filter` in `lattice/data/hamt.ss`.\nKnown issue: Filter predicate handling is inverted; true should keep entries.\n\n```scheme\n(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) acc (hamt-assoc k v acc)))\n             hamt-empty hamt))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Filter predicate handling is inverted; true should keep entries.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-filter"], "split": "train"}
{"id": "hamt_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge` in `lattice/data/hamt.ss`.\nKnown issue: Right-biased merge must overwrite collisions with values from h2.\n\n```scheme\n(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   acc\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge` in `lattice/data/hamt.ss`.\nKnown issue: Right-biased merge must overwrite collisions with values from h2.\n\n```scheme\n(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   acc\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Right-biased merge must overwrite collisions with values from h2.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-merge"], "split": "train"}
{"id": "hamt_bugfix_023", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Must convert all association-list entries into HAMT bindings.\n\n```scheme\n(define (alist->hamt alist)\n  hamt-empty)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Must convert all association-list entries into HAMT bindings.\n\n```scheme\n(define (alist->hamt alist)\n  hamt-empty)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must convert all association-list entries into HAMT bindings.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "alist->hamt"], "split": "train"}
{"id": "hamt_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Conversion should preserve key/value orientation.\n\n```scheme\n(define (alist->hamt alist)\n  (dict->hamt (map (lambda (pair) (cons (cdr pair) (car pair))) alist)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Conversion should preserve key/value orientation.\n\n```scheme\n(define (alist->hamt alist)\n  (dict->hamt (map (lambda (pair) (cons (cdr pair) (car pair))) alist)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "alist->hamt"], "split": "train"}
{"id": "hamt_bugfix_025", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Dictionary conversion must preserve `(car pair)` as key and `(cdr pair)` as value.\n\n```scheme\n(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (cdr pair) (car pair) acc))\n             hamt-empty dict))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Dictionary conversion must preserve `(car pair)` as key and `(cdr pair)` as value.\n\n```scheme\n(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (cdr pair) (car pair) acc))\n             hamt-empty dict))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Dictionary conversion must preserve `(car pair)` as key and `(cdr pair)` as value.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "dict->hamt"], "split": "train"}
{"id": "hamt_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Associate key 'a then check emptiness.", "prompt": "Task mode: small integration task across module primitives.\n\nAssociate key 'a then check emptiness.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-empty? (hamt-assoc 'a 1 hamt-empty))", "verify_expr": "(equal? (hamt-empty? (hamt-assoc 'a 1 hamt-empty)) #f)", "tags": ["tier0", "data", "hamt", "composition", "hamt-empty?", "edge-case"], "split": "train"}
{"id": "hamt_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Associate then dissoc same key and check emptiness.", "prompt": "Task mode: compose existing APIs into one expression.\n\nAssociate then dissoc same key and check emptiness.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty))) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-empty?", "integration"], "split": "train"}
{"id": "hamt_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Convert empty alist and check hamt-empty?.", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert empty alist and check hamt-empty?.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-empty? (alist->hamt '()))", "verify_expr": "(equal? (hamt-empty? (alist->hamt '())) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-empty?", "integration"], "split": "train"}
{"id": "hamt_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Lookup key 'b after inserting a and b.", "prompt": "Task mode: small integration task across module primitives.\n\nLookup key 'b after inserting a and b.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'b (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-lookup 'b (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty))) 2)", "tags": ["tier0", "data", "hamt", "composition", "hamt-lookup", "direct"], "split": "train"}
{"id": "hamt_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Lookup missing key and return #f.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nLookup missing key and return #f.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'missing (hamt-assoc 'a 1 hamt-empty))", "verify_expr": "(equal? (hamt-lookup 'missing (hamt-assoc 'a 1 hamt-empty)) #f)", "tags": ["tier0", "data", "hamt", "composition", "hamt-lookup", "edge-case"], "split": "train"}
{"id": "hamt_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Merge two HAMTs with + and lookup merged 'k.", "prompt": "Task mode: small integration task across module primitives.\n\nMerge two HAMTs with + and lookup merged 'k.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-lookup 'k (hamt-merge-with + (alist->hamt '((k . 2))) (alist->hamt '((k . 3)))))", "verify_expr": "(equal? (hamt-lookup 'k (hamt-merge-with + (alist->hamt '((k . 2))) (alist->hamt '((k . 3))))) 5)", "tags": ["tier0", "data", "hamt", "composition", "hamt-lookup", "integration"], "split": "train"}
{"id": "hamt_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Check that key 'a exists after insertion.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that key 'a exists after insertion.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-has-key? 'a (hamt-assoc 'a 7 hamt-empty))", "verify_expr": "(equal? (hamt-has-key? 'a (hamt-assoc 'a 7 hamt-empty)) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-has-key?", "direct"], "split": "train"}
{"id": "hamt_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Check missing key returns #f.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck missing key returns #f.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-has-key? 'x hamt-empty)", "verify_expr": "(equal? (hamt-has-key? 'x hamt-empty) #f)", "tags": ["tier0", "data", "hamt", "composition", "hamt-has-key?", "edge-case"], "split": "train"}
{"id": "hamt_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Key mapped to #f should still be reported present.", "prompt": "Task mode: compose existing APIs into one expression.\n\nKey mapped to #f should still be reported present.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-has-key? 'k (hamt-assoc 'k #f hamt-empty))", "verify_expr": "(equal? (hamt-has-key? 'k (hamt-assoc 'k #f hamt-empty)) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-has-key?", "property"], "split": "train"}
{"id": "hamt_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Associate key 'a -> 1 then lookup 'a.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAssociate key 'a -> 1 then lookup 'a.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'a (hamt-assoc 'a 1 hamt-empty))", "verify_expr": "(equal? (hamt-lookup 'a (hamt-assoc 'a 1 hamt-empty)) 1)", "tags": ["tier0", "data", "hamt", "composition", "hamt-assoc", "direct"], "split": "train"}
{"id": "hamt_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Update existing key and keep size at 1.", "prompt": "Task mode: compose existing APIs into one expression.\n\nUpdate existing key and keep size at 1.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (hamt-assoc 'a 9 (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-size (hamt-assoc 'a 9 (hamt-assoc 'a 1 hamt-empty))) 1)", "tags": ["tier0", "data", "hamt", "composition", "hamt-assoc", "property"], "split": "train"}
{"id": "hamt_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Insert three distinct keys and return size.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert three distinct keys and return size.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (hamt-assoc 'c 3 (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty))))", "verify_expr": "(equal? (hamt-size (hamt-assoc 'c 3 (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty)))) 3)", "tags": ["tier0", "data", "hamt", "composition", "hamt-assoc", "direct"], "split": "train"}
{"id": "hamt_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Associate key with #f then verify hamt-has-key? is true.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAssociate key with #f then verify hamt-has-key? is true.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-has-key? 'z (hamt-assoc 'z #f hamt-empty))", "verify_expr": "(equal? (hamt-has-key? 'z (hamt-assoc 'z #f hamt-empty)) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-assoc", "integration"], "split": "train"}
{"id": "hamt_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Remove key 'b from ((a . 1) (b . 2)) and lookup 'b.", "prompt": "Task mode: small integration task across module primitives.\n\nRemove key 'b from ((a . 1) (b . 2)) and lookup 'b.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'b (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2)))))", "verify_expr": "(equal? (hamt-lookup 'b (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2))))) #f)", "tags": ["tier0", "data", "hamt", "composition", "hamt-dissoc", "direct"], "split": "train"}
{"id": "hamt_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Dissoc from empty should stay empty.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDissoc from empty should stay empty.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-empty? (hamt-dissoc 'x hamt-empty))", "verify_expr": "(equal? (hamt-empty? (hamt-dissoc 'x hamt-empty)) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-dissoc", "edge-case"], "split": "train"}
{"id": "hamt_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Dissoc one key and ensure another key remains reachable.", "prompt": "Task mode: small integration task across module primitives.\n\nDissoc one key and ensure another key remains reachable.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'a (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2) (c . 3)))))", "verify_expr": "(equal? (hamt-lookup 'a (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2) (c . 3))))) 1)", "tags": ["tier0", "data", "hamt", "composition", "hamt-dissoc", "integration"], "split": "train"}
{"id": "hamt_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Return size of hamt-empty.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn size of hamt-empty.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-size hamt-empty)", "verify_expr": "(equal? (hamt-size hamt-empty) 0)", "tags": ["tier0", "data", "hamt", "composition", "hamt-size", "direct"], "split": "train"}
{"id": "hamt_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Return size of alist-converted HAMT with three keys.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn size of alist-converted HAMT with three keys.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (alist->hamt '((a . 1) (b . 2) (c . 3))))", "verify_expr": "(equal? (hamt-size (alist->hamt '((a . 1) (b . 2) (c . 3)))) 3)", "tags": ["tier0", "data", "hamt", "composition", "hamt-size", "direct"], "split": "train"}
{"id": "hamt_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Updating existing key should not increase size.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUpdating existing key should not increase size.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-size (hamt-assoc 'a 2 (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-size (hamt-assoc 'a 2 (hamt-assoc 'a 1 hamt-empty))) 1)", "tags": ["tier0", "data", "hamt", "composition", "hamt-size", "property"], "split": "train"}
{"id": "hamt_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Merge disjoint HAMTs and lookup new key 'c.", "prompt": "Task mode: small integration task across module primitives.\n\nMerge disjoint HAMTs and lookup new key 'c.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'c (hamt-merge-with + (alist->hamt '((a . 1))) (alist->hamt '((c . 3)))))", "verify_expr": "(equal? (hamt-lookup 'c (hamt-merge-with + (alist->hamt '((a . 1))) (alist->hamt '((c . 3))))) 3)", "tags": ["tier0", "data", "hamt", "composition", "hamt-merge-with", "direct"], "split": "train"}
{"id": "hamt_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Merge with conflict on 'b using +.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge with conflict on 'b using +.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-lookup 'b (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 5)))))", "verify_expr": "(equal? (hamt-lookup 'b (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 5))))) 7)", "tags": ["tier0", "data", "hamt", "composition", "hamt-merge-with", "direct"], "split": "train"}
{"id": "hamt_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Merge with resolver returning (old new) pair order for key 'k.", "prompt": "Task mode: small integration task across module primitives.\n\nMerge with resolver returning (old new) pair order for key 'k.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'k (hamt-merge-with (lambda (old new) (list old new)) (alist->hamt '((k . 1))) (alist->hamt '((k . 10)))))", "verify_expr": "(equal? (hamt-lookup 'k (hamt-merge-with (lambda (old new) (list old new)) (alist->hamt '((k . 1))) (alist->hamt '((k . 10))))) '(1 10))", "tags": ["tier0", "data", "hamt", "composition", "hamt-merge-with", "property"], "split": "train"}
{"id": "hamt_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Merge where old value is #f and resolver should still run.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge where old value is #f and resolver should still run.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'k (hamt-merge-with (lambda (old new) 'hit) (alist->hamt '((k . #f))) (alist->hamt '((k . 99)))))", "verify_expr": "(equal? (hamt-lookup 'k (hamt-merge-with (lambda (old new) 'hit) (alist->hamt '((k . #f))) (alist->hamt '((k . 99))))) 'hit)", "tags": ["tier0", "data", "hamt", "composition", "hamt-merge-with", "property"], "split": "train"}
{"id": "hamt_composition_038", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Convert alist ((a . 1) (b . 2)) and lookup 'a.", "prompt": "Task mode: small integration task across module primitives.\n\nConvert alist ((a . 1) (b . 2)) and lookup 'a.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'a (alist->hamt '((a . 1) (b . 2))))", "verify_expr": "(equal? (hamt-lookup 'a (alist->hamt '((a . 1) (b . 2)))) 1)", "tags": ["tier0", "data", "hamt", "composition", "alist->hamt", "direct"], "split": "train"}
{"id": "hamt_composition_039", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Duplicate key in alist should keep last value.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDuplicate key in alist should keep last value.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'a (alist->hamt '((a . 1) (a . 7))))", "verify_expr": "(equal? (hamt-lookup 'a (alist->hamt '((a . 1) (a . 7)))) 7)", "tags": ["tier0", "data", "hamt", "composition", "alist->hamt", "property"], "split": "train"}
{"id": "hamt_composition_040", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Empty alist conversion should be empty HAMT.", "prompt": "Task mode: compose existing APIs into one expression.\n\nEmpty alist conversion should be empty HAMT.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-empty? (alist->hamt '()))", "verify_expr": "(equal? (hamt-empty? (alist->hamt '())) #t)", "tags": ["tier0", "data", "hamt", "composition", "alist->hamt", "edge-case"], "split": "train"}
