{"id": "hamt_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-empty?`\nSpec: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\nWrite exactly one Scheme function definition for `hamt-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(hamt-empty? hamt-empty)\n(not (hamt-empty? (hamt-assoc 'a 1 hamt-empty)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["data", "hamt", "spec-to-code", "hamt-empty?"], "split": "train"}
{"id": "hamt_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-empty?`\nBehavior contract: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\n```scheme\n(define (hamt-empty? x)\n  ;; TODO: detect the canonical empty HAMT marker\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(hamt-empty? hamt-empty)\n(not (hamt-empty? (hamt-assoc 'a 1 hamt-empty)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "hamt-empty?"], "split": "train"}
{"id": "hamt_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-lookup`\nBehavior contract: Lookup key in HAMT and return its value, or #f when absent.\n\n```scheme\n(define (hamt-lookup key hamt)\n  ;; TODO: hash key and delegate to recursive lookup\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "hamt-lookup"], "split": "train"}
{"id": "hamt_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-has-key?`\nSpec: Return key existence even when value is #f (must not use lookup truthiness).\n\nWrite exactly one Scheme function definition for `hamt-has-key?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["data", "hamt", "spec-to-code", "hamt-has-key?"], "split": "train"}
{"id": "hamt_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-has-key?`\nBehavior contract: Return key existence even when value is #f (must not use lookup truthiness).\n\n```scheme\n(define (hamt-has-key? key hamt)\n  ;; TODO: distinguish missing key from key mapped to #f\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "hamt-has-key?"], "split": "train"}
{"id": "hamt_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-assoc`\nBehavior contract: Insert/update key -> value in persistent HAMT and return new structure.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  ;; TODO: hash key and insert/update persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "hamt-assoc"], "split": "train"}
{"id": "hamt_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-dissoc`\nSpec: Remove key from HAMT and return updated HAMT without mutating input.\n\nWrite exactly one Scheme function definition for `hamt-dissoc`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["data", "hamt", "spec-to-code", "hamt-dissoc"], "split": "train"}
{"id": "hamt_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-dissoc`\nBehavior contract: Remove key from HAMT and return updated HAMT without mutating input.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  ;; TODO: hash key and remove persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "hamt-dissoc"], "split": "train"}
{"id": "hamt_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-size`\nSpec: Count the number of key-value pairs in HAMT.\n\nWrite exactly one Scheme function definition for `hamt-size`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["data", "hamt", "spec-to-code", "hamt-size"], "split": "train"}
{"id": "hamt_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-size`\nBehavior contract: Count the number of key-value pairs in HAMT.\n\n```scheme\n(define (hamt-size hamt)\n  ;; TODO: fold through HAMT and count entries\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "hamt-size"], "split": "train"}
{"id": "hamt_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-merge-with`\nBehavior contract: Merge two HAMTs and resolve conflicts with function `(f old new)`.\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  ;; TODO: merge h2 into h1 using conflict resolver (old,new)\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "hamt-merge-with"], "split": "train"}
{"id": "hamt_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `alist->hamt`\nSpec: Convert association list to HAMT; duplicate keys keep the last value.\n\nWrite exactly one Scheme function definition for `alist->hamt`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["data", "hamt", "spec-to-code", "alist->hamt"], "split": "train"}
{"id": "hamt_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `alist->hamt`\nBehavior contract: Convert association list to HAMT; duplicate keys keep the last value.\n\n```scheme\n(define (alist->hamt alist)\n  ;; TODO: build HAMT from association list\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["data", "hamt", "spec-to-code", "skeleton", "alist->hamt"], "split": "train"}
{"id": "hamt_translation_002", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-empty?`\n\n```scheme\n(define (hamt-empty0? x)\n  (eq? x 'hamt-empty))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(hamt-empty? hamt-empty)\n(not (hamt-empty? (hamt-assoc 'a 1 hamt-empty)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["data", "hamt", "translation", "chez", "hamt-empty?"], "split": "train"}
{"id": "hamt_translation_003", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-lookup`\n\n```python\ndef hamt_lookup(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_lookup_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["data", "hamt", "translation", "python", "hamt-lookup"], "split": "train"}
{"id": "hamt_translation_004", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-lookup`\n\n```scheme\n(define (hamt-get key h)\n  (let ((hash (hamt-hash-key key)))\n    (hamt-lookup-hash hash key h 0)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["data", "hamt", "translation", "chez", "hamt-lookup"], "split": "train"}
{"id": "hamt_translation_005", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-has-key?`\n\n```python\ndef hamt_has_key(key, hamt):\n    sentinel = ['not-found']\n    return sentinel is not hamt_lookup_or(key, hamt, sentinel)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["data", "hamt", "translation", "python", "hamt-has-key?"], "split": "train"}
{"id": "hamt_translation_006", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-has-key?`\n\n```scheme\n(define (hamt-has0? k h)\n  (let ((sentinel (list 'not-found)))\n    (not (eq? sentinel (hamt-lookup-or k h sentinel)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["data", "hamt", "translation", "chez", "hamt-has-key?"], "split": "train"}
{"id": "hamt_translation_007", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-assoc`\n\n```python\ndef hamt_assoc(key, value, hamt):\n    h = hamt_hash_key(key)\n    return hamt_assoc_hash(h, key, value, hamt, 0)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["data", "hamt", "translation", "python", "hamt-assoc"], "split": "train"}
{"id": "hamt_translation_008", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-assoc`\n\n```scheme\n(define (hamt-put k v h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-assoc-hash hash k v h 0)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["data", "hamt", "translation", "chez", "hamt-assoc"], "split": "train"}
{"id": "hamt_translation_010", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-dissoc`\n\n```scheme\n(define (hamt-del k h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-dissoc-hash hash k h 0)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["data", "hamt", "translation", "chez", "hamt-dissoc"], "split": "train"}
{"id": "hamt_translation_011", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-size`\n\n```python\ndef hamt_size(hamt):\n    return hamt_fold(lambda acc, k, v: acc + 1, 0, hamt)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["data", "hamt", "translation", "python", "hamt-size"], "split": "train"}
{"id": "hamt_translation_012", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-size`\n\n```scheme\n(define (hamt-count h)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["data", "hamt", "translation", "chez", "hamt-size"], "split": "train"}
{"id": "hamt_translation_013", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-merge-with`\n\n```python\ndef hamt_merge_with(f, h1, h2):\n    def step(acc, k, v):\n        if hamt_has_key(k, acc):\n            return hamt_assoc(k, f(hamt_lookup(k, acc), v), acc)\n        return hamt_assoc(k, v, acc)\n    return hamt_fold(step, h1, h2)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["data", "hamt", "translation", "python", "hamt-merge-with"], "split": "train"}
{"id": "hamt_translation_014", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-merge-with`\n\n```scheme\n(define (hamt-merge0 f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["data", "hamt", "translation", "chez", "hamt-merge-with"], "split": "train"}
{"id": "hamt_translation_015", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `alist->hamt`\n\n```python\ndef alist_to_hamt(alist):\n    return dict_to_hamt(alist)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["data", "hamt", "translation", "python", "alist->hamt"], "split": "train"}
{"id": "hamt_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Predicate polarity is reversed.\n\n```scheme\n(define (hamt-empty? x)\n  (not (eq? x 'hamt-empty)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["data", "hamt", "bugfix", "hamt-empty?"], "split": "train"}
{"id": "hamt_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup` in `lattice/data/hamt.ss`.\nKnown issue: Lookup hash must be derived from key, not from hamt object.\n\n```scheme\n(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key hamt)])\n    (hamt-lookup-hash hash key hamt 0)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["data", "hamt", "bugfix", "hamt-lookup"], "split": "train"}
{"id": "hamt_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-lookup` in `lattice/data/hamt.ss`.\nKnown issue: Recursive lookup must start at shift 0.\n\n```scheme\n(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["data", "hamt", "bugfix", "hamt-lookup"], "split": "train"}
{"id": "hamt_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-has-key?` in `lattice/data/hamt.ss`.\nKnown issue: Keys mapped to #f must still count as present.\n\n```scheme\n(define (hamt-has-key? key hamt)\n  (if (hamt-lookup key hamt) #t #f))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["data", "hamt", "bugfix", "hamt-has-key?"], "split": "train"}
{"id": "hamt_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-has-key?` in `lattice/data/hamt.ss`.\nKnown issue: Using #f as sentinel breaks presence checks for keys with #f values.\n\n```scheme\n(define (hamt-has-key? key hamt)\n  (not (eq? #f (hamt-lookup-or key hamt #f))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (let ([h (hamt-assoc 'k #f hamt-empty)]) (and (hamt-has-key? 'k h) (not (hamt-has-key? 'x h)))))", "tags": ["data", "hamt", "bugfix", "hamt-has-key?"], "split": "train"}
{"id": "hamt_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-assoc` in `lattice/data/hamt.ss`.\nKnown issue: Assoc hash must be computed from key, not value.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key value)])\n    (hamt-assoc-hash hash key value hamt 0)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["data", "hamt", "bugfix", "hamt-assoc"], "split": "train"}
{"id": "hamt_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-assoc` in `lattice/data/hamt.ss`.\nKnown issue: Insertion recursion must start at shift 0.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["data", "hamt", "bugfix", "hamt-assoc"], "split": "train"}
{"id": "hamt_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Deletion recursion must start at shift 0.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["data", "hamt", "bugfix", "hamt-dissoc"], "split": "train"}
{"id": "hamt_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-size` in `lattice/data/hamt.ss`.\nKnown issue: Size should count entries, not sum values.\n\n```scheme\n(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc v)) 0 hamt))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["data", "hamt", "bugfix", "hamt-size"], "split": "train"}
{"id": "hamt_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-size` in `lattice/data/hamt.ss`.\nKnown issue: Initial count must be 0.\n\n```scheme\n(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 1 hamt))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-assoc 'b 9 h1)]) (and (= (hamt-size hamt-empty) 0) (= (hamt-size h1) 3) (= (hamt-size h2) 3))))", "tags": ["data", "hamt", "bugfix", "hamt-size"], "split": "train"}
{"id": "hamt_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge-with` in `lattice/data/hamt.ss`.\nKnown issue: Conflict resolver argument order must be (old-value, new-value).\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f v (hamt-lookup k acc)) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["data", "hamt", "bugfix", "hamt-merge-with"], "split": "train"}
{"id": "hamt_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge-with` in `lattice/data/hamt.ss`.\nKnown issue: Presence test must use hamt-has-key? so #f values are treated as existing keys.\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-lookup k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["data", "hamt", "bugfix", "hamt-merge-with"], "split": "train"}
{"id": "hamt_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Must convert all association-list entries into HAMT bindings.\n\n```scheme\n(define (alist->hamt alist)\n  hamt-empty)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["data", "hamt", "bugfix", "alist->hamt"], "split": "train"}
{"id": "hamt_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nAssociate key 'a then check emptiness.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-empty? (hamt-assoc 'a 1 hamt-empty))", "verify_expr": "(equal? (hamt-empty? (hamt-assoc 'a 1 hamt-empty)) #f)", "tags": ["data", "hamt", "composition", "hamt-empty?", "edge-case"], "split": "train"}
{"id": "hamt_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: compose existing APIs into one expression.\n\nAssociate then dissoc same key and check emptiness.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty))) #t)", "tags": ["data", "hamt", "composition", "hamt-empty?", "integration"], "split": "train"}
{"id": "hamt_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert empty alist and check hamt-empty?.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-empty? (alist->hamt '())) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-empty? (alist->hamt '()))", "verify_expr": "(equal? (hamt-empty? (alist->hamt '())) #t)", "tags": ["data", "hamt", "composition", "hamt-empty?", "integration"], "split": "train"}
{"id": "hamt_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: small integration task across module primitives.\n\nLookup key 'b after inserting a and b.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'b (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty))) 2)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'b (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-lookup 'b (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty))) 2)", "tags": ["data", "hamt", "composition", "hamt-lookup", "direct"], "split": "train"}
{"id": "hamt_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nLookup missing key and return #f.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'missing (hamt-assoc 'a 1 hamt-empty)) #f)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'missing (hamt-assoc 'a 1 hamt-empty))", "verify_expr": "(equal? (hamt-lookup 'missing (hamt-assoc 'a 1 hamt-empty)) #f)", "tags": ["data", "hamt", "composition", "hamt-lookup", "edge-case"], "split": "train"}
{"id": "hamt_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: compose existing APIs into one expression.\n\nLookup numeric key 1 and string key \"1\" in same HAMT.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (list (hamt-lookup 1 (alist->hamt '((1 . int) (\"1\" . str)))) (hamt-lookup \"1\" (alist->hamt '((1 . int) (\"1\" . str))))) '(int str))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (hamt-lookup 1 (alist->hamt '((1 . int) (\"1\" . str)))) (hamt-lookup \"1\" (alist->hamt '((1 . int) (\"1\" . str)))))", "verify_expr": "(equal? (list (hamt-lookup 1 (alist->hamt '((1 . int) (\"1\" . str)))) (hamt-lookup \"1\" (alist->hamt '((1 . int) (\"1\" . str))))) '(int str))", "tags": ["data", "hamt", "composition", "hamt-lookup", "property"], "split": "train"}
{"id": "hamt_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: small integration task across module primitives.\n\nMerge two HAMTs with + and lookup merged 'k.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'k (hamt-merge-with + (alist->hamt '((k . 2))) (alist->hamt '((k . 3))))) 5)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-lookup 'k (hamt-merge-with + (alist->hamt '((k . 2))) (alist->hamt '((k . 3)))))", "verify_expr": "(equal? (hamt-lookup 'k (hamt-merge-with + (alist->hamt '((k . 2))) (alist->hamt '((k . 3))))) 5)", "tags": ["data", "hamt", "composition", "hamt-lookup", "integration"], "split": "train"}
{"id": "hamt_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck missing key returns #f.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-has-key? 'x hamt-empty)", "verify_expr": "(equal? (hamt-has-key? 'x hamt-empty) #f)", "tags": ["data", "hamt", "composition", "hamt-has-key?", "edge-case"], "split": "train"}
{"id": "hamt_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: compose existing APIs into one expression.\n\nKey mapped to #f should still be reported present.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-has-key? 'k (hamt-assoc 'k #f hamt-empty))", "verify_expr": "(equal? (hamt-has-key? 'k (hamt-assoc 'k #f hamt-empty)) #t)", "tags": ["data", "hamt", "composition", "hamt-has-key?", "property"], "split": "train"}
{"id": "hamt_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert then dissoc key 'a and test presence.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-has-key? 'a (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty))) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-has-key? 'a (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-has-key? 'a (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty))) #f)", "tags": ["data", "hamt", "composition", "hamt-has-key?", "integration"], "split": "train"}
{"id": "hamt_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAssociate key 'a -> 1 then lookup 'a.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'a (hamt-assoc 'a 1 hamt-empty)) 1)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'a (hamt-assoc 'a 1 hamt-empty))", "verify_expr": "(equal? (hamt-lookup 'a (hamt-assoc 'a 1 hamt-empty)) 1)", "tags": ["data", "hamt", "composition", "hamt-assoc", "direct"], "split": "train"}
{"id": "hamt_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: compose existing APIs into one expression.\n\nUpdate existing key and keep size at 1.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (hamt-assoc 'a 9 (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-size (hamt-assoc 'a 9 (hamt-assoc 'a 1 hamt-empty))) 1)", "tags": ["data", "hamt", "composition", "hamt-assoc", "property"], "split": "train"}
{"id": "hamt_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert three distinct keys and return size.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (hamt-assoc 'c 3 (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty))))", "verify_expr": "(equal? (hamt-size (hamt-assoc 'c 3 (hamt-assoc 'b 2 (hamt-assoc 'a 1 hamt-empty)))) 3)", "tags": ["data", "hamt", "composition", "hamt-assoc", "direct"], "split": "train"}
{"id": "hamt_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAssociate key with #f then verify hamt-has-key? is true.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-has-key? 'z (hamt-assoc 'z #f hamt-empty)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-has-key? 'z (hamt-assoc 'z #f hamt-empty))", "verify_expr": "(equal? (hamt-has-key? 'z (hamt-assoc 'z #f hamt-empty)) #t)", "tags": ["data", "hamt", "composition", "hamt-assoc", "integration"], "split": "train"}
{"id": "hamt_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDissoc missing key should preserve size.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-size (hamt-dissoc 'x (alist->hamt '((a . 1) (b . 2))))) 2)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-size (hamt-dissoc 'x (alist->hamt '((a . 1) (b . 2)))))", "verify_expr": "(equal? (hamt-size (hamt-dissoc 'x (alist->hamt '((a . 1) (b . 2))))) 2)", "tags": ["data", "hamt", "composition", "hamt-dissoc", "edge-case"], "split": "train"}
{"id": "hamt_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDissoc from empty should stay empty.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-empty? (hamt-dissoc 'x hamt-empty))", "verify_expr": "(equal? (hamt-empty? (hamt-dissoc 'x hamt-empty)) #t)", "tags": ["data", "hamt", "composition", "hamt-dissoc", "edge-case"], "split": "train"}
{"id": "hamt_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: small integration task across module primitives.\n\nDissoc one key and ensure another key remains reachable.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'a (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2) (c . 3))))) 1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'a (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2) (c . 3)))))", "verify_expr": "(equal? (hamt-lookup 'a (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2) (c . 3))))) 1)", "tags": ["data", "hamt", "composition", "hamt-dissoc", "integration"], "split": "train"}
{"id": "hamt_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn size of hamt-empty.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-size hamt-empty)", "verify_expr": "(equal? (hamt-size hamt-empty) 0)", "tags": ["data", "hamt", "composition", "hamt-size", "direct"], "split": "train"}
{"id": "hamt_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn size of alist-converted HAMT with three keys.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-size (alist->hamt '((a . 1) (b . 2) (c . 3)))) 3)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (alist->hamt '((a . 1) (b . 2) (c . 3))))", "verify_expr": "(equal? (hamt-size (alist->hamt '((a . 1) (b . 2) (c . 3)))) 3)", "tags": ["data", "hamt", "composition", "hamt-size", "direct"], "split": "train"}
{"id": "hamt_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUpdating existing key should not increase size.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-size (hamt-assoc 'a 2 (hamt-assoc 'a 1 hamt-empty))) 1)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-size (hamt-assoc 'a 2 (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-size (hamt-assoc 'a 2 (hamt-assoc 'a 1 hamt-empty))) 1)", "tags": ["data", "hamt", "composition", "hamt-size", "property"], "split": "train"}
{"id": "hamt_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: small integration task across module primitives.\n\nMerge disjoint HAMTs and lookup new key 'c.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'c (hamt-merge-with + (alist->hamt '((a . 1))) (alist->hamt '((c . 3)))))", "verify_expr": "(equal? (hamt-lookup 'c (hamt-merge-with + (alist->hamt '((a . 1))) (alist->hamt '((c . 3))))) 3)", "tags": ["data", "hamt", "composition", "hamt-merge-with", "direct"], "split": "train"}
{"id": "hamt_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge with conflict on 'b using +.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'b (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 5))))) 7)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-lookup 'b (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 5)))))", "verify_expr": "(equal? (hamt-lookup 'b (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 5))))) 7)", "tags": ["data", "hamt", "composition", "hamt-merge-with", "direct"], "split": "train"}
{"id": "hamt_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: small integration task across module primitives.\n\nMerge with resolver returning (old new) pair order for key 'k.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'k (hamt-merge-with (lambda (old new) (list old new)) (alist->hamt '((k . 1))) (alist->hamt '((k . 10)))))", "verify_expr": "(equal? (hamt-lookup 'k (hamt-merge-with (lambda (old new) (list old new)) (alist->hamt '((k . 1))) (alist->hamt '((k . 10))))) '(1 10))", "tags": ["data", "hamt", "composition", "hamt-merge-with", "property"], "split": "train"}
{"id": "hamt_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge where old value is #f and resolver should still run.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'k (hamt-merge-with (lambda (old new) 'hit) (alist->hamt '((k . #f))) (alist->hamt '((k . 99)))))", "verify_expr": "(equal? (hamt-lookup 'k (hamt-merge-with (lambda (old new) 'hit) (alist->hamt '((k . #f))) (alist->hamt '((k . 99))))) 'hit)", "tags": ["data", "hamt", "composition", "hamt-merge-with", "property"], "split": "train"}
{"id": "hamt_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert alist ((a . 1) (b . 2)) and lookup 'a.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'a (alist->hamt '((a . 1) (b . 2)))) 1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'a (alist->hamt '((a . 1) (b . 2))))", "verify_expr": "(equal? (hamt-lookup 'a (alist->hamt '((a . 1) (b . 2)))) 1)", "tags": ["data", "hamt", "composition", "alist->hamt", "direct"], "split": "train"}
{"id": "hamt_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: small integration task across module primitives.\n\nDuplicate key in alist should keep last value.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-lookup 'a (alist->hamt '((a . 1) (a . 7)))) 7)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'a (alist->hamt '((a . 1) (a . 7))))", "verify_expr": "(equal? (hamt-lookup 'a (alist->hamt '((a . 1) (a . 7)))) 7)", "tags": ["data", "hamt", "composition", "alist->hamt", "property"], "split": "train"}
{"id": "hamt_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEmpty alist conversion should be empty HAMT.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (hamt-empty? (alist->hamt '())) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-empty? (alist->hamt '()))", "verify_expr": "(equal? (hamt-empty? (alist->hamt '())) #t)", "tags": ["data", "hamt", "composition", "alist->hamt", "edge-case"], "split": "train"}
