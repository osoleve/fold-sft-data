{"id": "hamt_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-empty?`\nSpec: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\nWrite exactly one Scheme function definition for `hamt-empty?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-empty?`\nSpec: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\nWrite exactly one Scheme function definition for `hamt-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-empty?"], "split": "eval"}
{"id": "hamt_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-empty?`\nBehavior contract: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\n```scheme\n(define (hamt-empty? x)\n  ;; TODO: detect the canonical empty HAMT marker\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-empty?`\nBehavior contract: Return #t only for the singleton empty HAMT marker `'hamt-empty`.\n\n```scheme\n(define (hamt-empty? x)\n  ;; TODO: detect the canonical empty HAMT marker\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-empty?"], "split": "eval"}
{"id": "hamt_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-lookup-or`\nSpec: Lookup key and return default when key is absent.\n\nWrite exactly one Scheme function definition for `hamt-lookup-or`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-lookup-or`\nSpec: Lookup key and return default when key is absent.\n\nWrite exactly one Scheme function definition for `hamt-lookup-or`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-lookup-or"], "split": "eval"}
{"id": "hamt_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-lookup-or`\nBehavior contract: Lookup key and return default when key is absent.\n\n```scheme\n(define (hamt-lookup-or key hamt default)\n  ;; TODO: hash key and delegate to recursive lookup-or\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-lookup-or`\nBehavior contract: Lookup key and return default when key is absent.\n\n```scheme\n(define (hamt-lookup-or key hamt default)\n  ;; TODO: hash key and delegate to recursive lookup-or\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (let ([h (hamt-assoc 'k #f (hamt-assoc 'a 1 hamt-empty))]) (and (equal? (hamt-lookup-or 'a h 'missing) 1) (equal? (hamt-lookup-or 'k h 'missing) #f) (equal? (hamt-lookup-or 'z h 'missing) 'missing))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-lookup-or"], "split": "eval"}
{"id": "hamt_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-dissoc`\nSpec: Remove key from HAMT and return updated HAMT without mutating input.\n\nWrite exactly one Scheme function definition for `hamt-dissoc`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-dissoc`\nSpec: Remove key from HAMT and return updated HAMT without mutating input.\n\nWrite exactly one Scheme function definition for `hamt-dissoc`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-dissoc`\nBehavior contract: Remove key from HAMT and return updated HAMT without mutating input.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  ;; TODO: hash key and remove persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-dissoc`\nBehavior contract: Remove key from HAMT and return updated HAMT without mutating input.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  ;; TODO: hash key and remove persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-fold`\nSpec: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\nWrite exactly one Scheme function definition for `hamt-fold`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-fold`\nSpec: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\nWrite exactly one Scheme function definition for `hamt-fold`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-fold"], "split": "eval"}
{"id": "hamt_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-fold`\nBehavior contract: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\n```scheme\n(define (hamt-fold f init hamt)\n  ;; TODO: fold over leaves/collisions/nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-fold`\nBehavior contract: Fold all key/value pairs with accumulator function `(f acc key value)`.\n\n```scheme\n(define (hamt-fold f init hamt)\n  ;; TODO: fold over leaves/collisions/nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [sum (hamt-fold (lambda (acc k v) (+ acc v)) 0 h)] [count (hamt-fold (lambda (acc k v) (+ acc 1)) 0 h)]) (and (= sum 6) (= count 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-fold"], "split": "eval"}
{"id": "hamt_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-keys`\nSpec: Collect all keys contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-keys`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-keys`\nSpec: Collect all keys contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-keys`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-keys"], "split": "eval"}
{"id": "hamt_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-keys`\nBehavior contract: Collect all keys contained in the HAMT.\n\n```scheme\n(define (hamt-keys hamt)\n  ;; TODO: collect all keys with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-keys`\nBehavior contract: Collect all keys contained in the HAMT.\n\n```scheme\n(define (hamt-keys hamt)\n  ;; TODO: collect all keys with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-keys hamt)\n  (hamt-fold (lambda (acc k v) (cons k acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [ks (hamt-keys h)]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-keys"], "split": "eval"}
{"id": "hamt_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-values`\nSpec: Collect all values contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-values`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-values`\nSpec: Collect all values contained in the HAMT.\n\nWrite exactly one Scheme function definition for `hamt-values`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-values"], "split": "eval"}
{"id": "hamt_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-values`\nBehavior contract: Collect all values contained in the HAMT.\n\n```scheme\n(define (hamt-values hamt)\n  ;; TODO: collect all values with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-values`\nBehavior contract: Collect all values contained in the HAMT.\n\n```scheme\n(define (hamt-values hamt)\n  ;; TODO: collect all values with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-values hamt)\n  (hamt-fold (lambda (acc k v) (cons v acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [vs (hamt-values h)]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-values"], "split": "eval"}
{"id": "hamt_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-entries`\nSpec: Collect key/value pairs as an association list.\n\nWrite exactly one Scheme function definition for `hamt-entries`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-entries`\nSpec: Collect key/value pairs as an association list.\n\nWrite exactly one Scheme function definition for `hamt-entries`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-entries"], "split": "eval"}
{"id": "hamt_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-entries`\nBehavior contract: Collect key/value pairs as an association list.\n\n```scheme\n(define (hamt-entries hamt)\n  ;; TODO: collect key/value pairs with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-entries`\nBehavior contract: Collect key/value pairs as an association list.\n\n```scheme\n(define (hamt-entries hamt)\n  ;; TODO: collect key/value pairs with hamt-fold\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-entries hamt)\n  (hamt-fold (lambda (acc k v) (cons (cons k v) acc)) '() hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [es (hamt-entries h)] [h2 (alist->hamt es)]) (and (= (hamt-size h2) 2) (= (hamt-lookup 'a h2) 1) (= (hamt-lookup 'b h2) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-entries"], "split": "eval"}
{"id": "hamt_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-map-values`\nSpec: Map a value transform over HAMT values while preserving keys/shape.\n\nWrite exactly one Scheme function definition for `hamt-map-values`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-map-values`\nSpec: Map a value transform over HAMT values while preserving keys/shape.\n\nWrite exactly one Scheme function definition for `hamt-map-values`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-map-values"], "split": "eval"}
{"id": "hamt_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-map-values`\nBehavior contract: Map a value transform over HAMT values while preserving keys/shape.\n\n```scheme\n(define (hamt-map-values f hamt)\n  ;; TODO: recursively map value transformer across HAMT nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-map-values`\nBehavior contract: Map a value transform over HAMT values while preserving keys/shape.\n\n```scheme\n(define (hamt-map-values f hamt)\n  ;; TODO: recursively map value transformer across HAMT nodes\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-map-values f hamt)\n  (cond\n    [(hamt-empty? hamt) hamt-empty]\n    [(hamt-leaf? hamt)\n     (make-hamt-leaf (hamt-leaf-hash hamt)\n                     (hamt-leaf-key hamt)\n                     (f (hamt-leaf-value hamt)))]\n    [(hamt-collision? hamt)\n     (make-hamt-collision\n       (hamt-collision-hash hamt)\n       (map (lambda (pair) (cons (car pair) (f (cdr pair))))\n            (hamt-collision-entries hamt)))]\n    [(hamt-node? hamt)\n     (make-hamt-node\n       (hamt-node-bitmap hamt)\n       (map (lambda (child) (hamt-map-values f child))\n            (hamt-node-children hamt)))]\n    [else hamt]))\n  (let* ([h (alist->hamt '((a . 1) (b . 2)))] [m (hamt-map-values (lambda (v) (+ v 10)) h)]) (and (= (hamt-lookup 'a m) 11) (= (hamt-lookup 'b m) 12) (= (hamt-size m) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-map-values"], "split": "eval"}
{"id": "hamt_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-filter`\nSpec: Keep only entries where predicate `(pred key value)` is true.\n\nWrite exactly one Scheme function definition for `hamt-filter`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-filter`\nSpec: Keep only entries where predicate `(pred key value)` is true.\n\nWrite exactly one Scheme function definition for `hamt-filter`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-filter"], "split": "eval"}
{"id": "hamt_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-filter`\nBehavior contract: Keep only entries where predicate `(pred key value)` is true.\n\n```scheme\n(define (hamt-filter pred hamt)\n  ;; TODO: filter entries by predicate on key and value\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-filter`\nBehavior contract: Keep only entries where predicate `(pred key value)` is true.\n\n```scheme\n(define (hamt-filter pred hamt)\n  ;; TODO: filter entries by predicate on key and value\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-filter pred hamt)\n  (hamt-fold (lambda (acc k v)\n               (if (pred k v) (hamt-assoc k v acc) acc))\n             hamt-empty hamt))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [f (hamt-filter (lambda (k v) (> v 1)) h)]) (and (= (hamt-size f) 2) (not (hamt-has-key? 'a f)) (= (hamt-lookup 'b f) 2) (= (hamt-lookup 'c f) 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-filter"], "split": "eval"}
{"id": "hamt_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-merge`\nSpec: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\nWrite exactly one Scheme function definition for `hamt-merge`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-merge`\nSpec: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\nWrite exactly one Scheme function definition for `hamt-merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-merge"], "split": "eval"}
{"id": "hamt_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-merge`\nBehavior contract: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\n```scheme\n(define (hamt-merge h1 h2)\n  ;; TODO: right-biased merge using hamt-fold and hamt-assoc\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-merge`\nBehavior contract: Merge two HAMTs with right-biased conflict resolution (h2 wins).\n\n```scheme\n(define (hamt-merge h1 h2)\n  ;; TODO: right-biased merge using hamt-fold and hamt-assoc\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge h1 h2)\n  (hamt-fold (lambda (acc k v) (hamt-assoc k v acc))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . 2)))] [h2 (alist->hamt '((b . 9) (c . 3)))] [m (hamt-merge h1 h2)]) (and (= (hamt-size m) 3) (= (hamt-lookup 'a m) 1) (= (hamt-lookup 'b m) 9) (= (hamt-lookup 'c m) 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-merge"], "split": "eval"}
{"id": "hamt_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `dict->hamt`\nSpec: Convert an association-list dictionary into a HAMT.\n\nWrite exactly one Scheme function definition for `dict->hamt`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `dict->hamt`\nSpec: Convert an association-list dictionary into a HAMT.\n\nWrite exactly one Scheme function definition for `dict->hamt`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "dict->hamt"], "split": "eval"}
{"id": "hamt_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `dict->hamt`\nBehavior contract: Convert an association-list dictionary into a HAMT.\n\n```scheme\n(define (dict->hamt dict)\n  ;; TODO: fold association pairs into a HAMT\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `dict->hamt`\nBehavior contract: Convert an association-list dictionary into a HAMT.\n\n```scheme\n(define (dict->hamt dict)\n  ;; TODO: fold association pairs into a HAMT\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (let ([h (dict->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "dict->hamt"], "split": "eval"}
{"id": "hamt_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-empty?`\n\n```python\ndef hamt_empty_p(x):\n    return x == 'hamt-empty'\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-empty?`\n\n```python\ndef hamt_empty_p(x):\n    return x == 'hamt-empty'\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-empty?"], "split": "eval"}
{"id": "hamt_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-empty?`\n\n```scheme\n(define (hamt-empty0? x)\n  (eq? x 'hamt-empty))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-empty?`\n\n```scheme\n(define (hamt-empty0? x)\n  (eq? x 'hamt-empty))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-empty?"], "split": "eval"}
{"id": "hamt_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-dissoc`\n\n```python\ndef hamt_dissoc(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_dissoc_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-dissoc`\n\n```python\ndef hamt_dissoc(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_dissoc_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-dissoc`\n\n```scheme\n(define (hamt-del k h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-dissoc-hash hash k h 0)))\n```\n\nReturn only Fold code.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-dissoc`\n\n```scheme\n(define (hamt-del k h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-dissoc-hash hash k h 0)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\n```scheme\n(define (hamt-empty? x)\n  (eq? x '()))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\n```scheme\n(define (hamt-empty? x)\n  (eq? x '()))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (hamt-empty? hamt-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-empty?"], "split": "eval"}
{"id": "hamt_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Predicate polarity is reversed.\n\n```scheme\n(define (hamt-empty? x)\n  (not (eq? x 'hamt-empty)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Predicate polarity is reversed.\n\n```scheme\n(define (hamt-empty? x)\n  (not (eq? x 'hamt-empty)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Predicate polarity is reversed.\n\nExpected behavior after patch:\n```scheme\n(let () (hamt-empty? hamt-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-empty?"], "split": "eval"}
{"id": "hamt_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Function must actually remove key when present.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  hamt)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Function must actually remove key when present.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  hamt)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Function must actually remove key when present.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Deletion recursion must start at shift 0.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Deletion recursion must start at shift 0.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Deletion recursion must start at shift 0.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Lookup numeric key 1 and string key \"1\" in same HAMT.", "prompt": "Task mode: compose existing APIs into one expression.\n\nLookup numeric key 1 and string key \"1\" in same HAMT.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (hamt-lookup 1 (alist->hamt '((1 . int) (\"1\" . str)))) (hamt-lookup \"1\" (alist->hamt '((1 . int) (\"1\" . str)))))", "verify_expr": "(equal? (list (hamt-lookup 1 (alist->hamt '((1 . int) (\"1\" . str)))) (hamt-lookup \"1\" (alist->hamt '((1 . int) (\"1\" . str))))) '(int str))", "tags": ["tier0", "data", "hamt", "composition", "hamt-lookup", "property"], "split": "eval"}
{"id": "hamt_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Insert then dissoc key 'a and test presence.", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert then dissoc key 'a and test presence.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-has-key? 'a (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-has-key? 'a (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty))) #f)", "tags": ["tier0", "data", "hamt", "composition", "hamt-has-key?", "integration"], "split": "eval"}
{"id": "hamt_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Associate key 'a -> 1 then lookup 'a.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAssociate key 'a -> 1 then lookup 'a.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup 'a (hamt-assoc 'a 1 hamt-empty))", "verify_expr": "(equal? (hamt-lookup 'a (hamt-assoc 'a 1 hamt-empty)) 1)", "tags": ["tier0", "data", "hamt", "composition", "hamt-assoc", "direct"], "split": "eval"}
{"id": "hamt_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Merge two HAMTs and return resulting size.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge two HAMTs and return resulting size.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 4) (c . 8)))))", "verify_expr": "(equal? (hamt-size (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 4) (c . 8))))) 3)", "tags": ["tier0", "data", "hamt", "composition", "hamt-size", "integration"], "split": "eval"}
{"id": "hamt_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Merge with conflict on 'b using +.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge with conflict on 'b using +.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-lookup 'b (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 5)))))", "verify_expr": "(equal? (hamt-lookup 'b (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 5))))) 7)", "tags": ["tier0", "data", "hamt", "composition", "hamt-merge-with", "direct"], "split": "eval"}
{"id": "hamt_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Convert mixed-key alist and return size.", "prompt": "Task mode: small integration task across module primitives.\n\nConvert mixed-key alist and return size.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-size (alist->hamt '((1 . one) (\"1\" . str) ((1 2) . pair))))", "verify_expr": "(equal? (hamt-size (alist->hamt '((1 . one) (\"1\" . str) ((1 2) . pair)))) 3)", "tags": ["tier0", "data", "hamt", "composition", "alist->hamt", "integration"], "split": "eval"}
