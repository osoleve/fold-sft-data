{"id": "hamt_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-lookup`\nSpec: Lookup key in HAMT and return its value, or #f when absent.\n\nWrite exactly one Scheme function definition for `hamt-lookup`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (let ([h (hamt-assoc 'a 1 (hamt-assoc 'b 2 hamt-empty))]) (and (= (hamt-lookup 'a h) 1) (= (hamt-lookup 'b h) 2) (equal? (hamt-lookup 'missing h) #f))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-lookup"], "split": "eval"}
{"id": "hamt_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-assoc`\nSpec: Insert/update key -> value in persistent HAMT and return new structure.\n\nWrite exactly one Scheme function definition for `hamt-assoc`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-assoc"], "split": "eval"}
{"id": "hamt_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-merge-with`\nSpec: Merge two HAMTs and resolve conflicts with function `(f old new)`.\n\nWrite exactly one Scheme function definition for `hamt-merge-with`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-merge-with"], "split": "eval"}
{"id": "hamt_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-empty?`\n\n```python\ndef hamt_empty_p(x):\n    return x == 'hamt-empty'\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-empty?"], "split": "eval"}
{"id": "hamt_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-dissoc`\n\n```python\ndef hamt_dissoc(key, hamt):\n    h = hamt_hash_key(key)\n    return hamt_dissoc_hash(h, key, hamt, 0)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `alist->hamt`\n\n```scheme\n(define (alist->hamt0 al)\n  (dict->hamt al))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "alist->hamt"], "split": "eval"}
{"id": "hamt_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-empty?` in `lattice/data/hamt.ss`.\nKnown issue: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\n```scheme\n(define (hamt-empty? x)\n  (eq? x '()))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty HAMT marker is `'hamt-empty`, not the empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (hamt-empty? hamt-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (hamt-empty? hamt-empty))\n(let () (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hamt-empty? x)\n  (eq? x 'hamt-empty))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (and (hamt-empty? hamt-empty) (not (hamt-empty? (hamt-assoc 'a 1 hamt-empty))) (hamt-empty? (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-empty?"], "split": "eval"}
{"id": "hamt_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-dissoc` in `lattice/data/hamt.ss`.\nKnown issue: Function must actually remove key when present.\n\n```scheme\n(define (hamt-dissoc key hamt)\n  hamt)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Function must actually remove key when present.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (collision-dissoc key entries)\n  (let loop ([es entries] [acc '()])\n    (cond\n      [(null? es) (reverse acc)]\n      [(equal? key (caar es)) (loop (cdr es) acc)]\n      [else (loop (cdr es) (cons (car es) acc))])))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-remove lst idx)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (append (reverse acc) (cdr l))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-dissoc-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) hamt-empty]\n\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         hamt-empty\n         node)]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (let ([new-entries (collision-dissoc key (hamt-collision-entries node))])\n           (cond\n             [(null? new-entries) hamt-empty]\n             [(null? (cdr new-entries))\n              (make-hamt-leaf hash (caar new-entries) (cdar new-entries))]\n             [else\n              (make-hamt-collision hash new-entries)]))\n         node)]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-dissoc-hash hash key child\n                                               (fx+ shift *hamt-bits*))])\n             (cond\n               [(hamt-empty? new-child)\n                (let ([new-bitmap (fxlogand bitmap (fxlognot bit))])\n                  (if (fxzero? new-bitmap)\n                      hamt-empty\n                      (let ([new-children (list-remove children idx)])\n                        (if (and (null? (cdr new-children))\n                                 (not (hamt-node? (car new-children))))\n                            (car new-children)\n                            (make-hamt-node new-bitmap new-children)))))]\n               [(and (not (hamt-node? new-child))\n                     (= 1 (length children)))\n                new-child]\n               [else\n                (make-hamt-node bitmap (list-set children idx new-child))]))\n           node))]\n\n    [else node]))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-dissoc key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-dissoc-hash hash key hamt 0)))\n  (let* ([h (alist->hamt '((a . 1) (b . 2) (c . 3)))] [h2 (hamt-dissoc 'b h)] [h3 (hamt-dissoc 'z h2)]) (and (= (hamt-size h2) 2) (not (hamt-has-key? 'b h2)) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 1))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-dissoc"], "split": "eval"}
{"id": "hamt_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->hamt` in `lattice/data/hamt.ss`.\nKnown issue: Conversion should preserve key/value orientation.\n\n```scheme\n(define (alist->hamt alist)\n  (dict->hamt (map (lambda (pair) (cons (cdr pair) (car pair))) alist)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (alist->hamt alist)\n  (dict->hamt alist))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (let ([h (alist->hamt '((x . 1) (y . 2) (x . 7)))]) (and (= (hamt-size h) 2) (= (hamt-lookup 'x h) 7) (= (hamt-lookup 'y h) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "alist->hamt"], "split": "eval"}
{"id": "hamt_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck whether canonical hamt-empty is empty.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-empty? hamt-empty)", "verify_expr": "(equal? (hamt-empty? hamt-empty) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-empty?", "direct"], "split": "eval"}
{"id": "hamt_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that key 'a exists after insertion.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-has-key? 'a (hamt-assoc 'a 7 hamt-empty))", "verify_expr": "(equal? (hamt-has-key? 'a (hamt-assoc 'a 7 hamt-empty)) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-has-key?", "direct"], "split": "eval"}
{"id": "hamt_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt": "Task mode: small integration task across module primitives.\n\nRemove key 'b from ((a . 1) (b . 2)) and lookup 'b.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'b (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2)))))", "verify_expr": "(equal? (hamt-lookup 'b (hamt-dissoc 'b (alist->hamt '((a . 1) (b . 2))))) #f)", "tags": ["tier0", "data", "hamt", "composition", "hamt-dissoc", "direct"], "split": "eval"}
{"id": "hamt_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge two HAMTs and return resulting size.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 4) (c . 8)))))", "verify_expr": "(equal? (hamt-size (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 4) (c . 8))))) 3)", "tags": ["tier0", "data", "hamt", "composition", "hamt-size", "integration"], "split": "eval"}
{"id": "hamt_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt": "Task mode: small integration task across module primitives.\n\nConvert mixed-key alist and return size.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(hamt-size (alist->hamt '((1 . one) (\"1\" . str) ((1 2) . pair))))", "verify_expr": "(equal? (hamt-size (alist->hamt '((1 . one) (\"1\" . str) ((1 2) . pair)))) 3)", "tags": ["tier0", "data", "hamt", "composition", "alist->hamt", "integration"], "split": "eval"}
