{"id": "hamt_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-assoc`\nSpec: Insert/update key -> value in persistent HAMT and return new structure.\n\nWrite exactly one Scheme function definition for `hamt-assoc`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-assoc`\nSpec: Insert/update key -> value in persistent HAMT and return new structure.\n\nWrite exactly one Scheme function definition for `hamt-assoc`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-assoc"], "split": "eval"}
{"id": "hamt_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-assoc`\nBehavior contract: Insert/update key -> value in persistent HAMT and return new structure.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  ;; TODO: hash key and insert/update persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-assoc`\nBehavior contract: Insert/update key -> value in persistent HAMT and return new structure.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  ;; TODO: hash key and insert/update persistently\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-assoc"], "split": "eval"}
{"id": "hamt_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-merge-with`\nSpec: Merge two HAMTs and resolve conflicts with function `(f old new)`.\n\nWrite exactly one Scheme function definition for `hamt-merge-with`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/data/hamt.ss\nFunction: `hamt-merge-with`\nSpec: Merge two HAMTs and resolve conflicts with function `(f old new)`.\n\nWrite exactly one Scheme function definition for `hamt-merge-with`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["tier0", "data", "hamt", "spec-to-code", "hamt-merge-with"], "split": "eval"}
{"id": "hamt_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Complete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-merge-with`\nBehavior contract: Merge two HAMTs and resolve conflicts with function `(f old new)`.\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  ;; TODO: merge h2 into h1 using conflict resolver (old,new)\n  <TODO>)\n```\n\nOutput only the completed function definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/data/hamt.ss\nFunction target: `hamt-merge-with`\nBehavior contract: Merge two HAMTs and resolve conflicts with function `(f old new)`.\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  ;; TODO: merge h2 into h1 using conflict resolver (old,new)\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["tier0", "data", "hamt", "skeleton-completion", "hamt-merge-with"], "split": "eval"}
{"id": "hamt_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-assoc`\n\n```python\ndef hamt_assoc(key, value, hamt):\n    h = hamt_hash_key(key)\n    return hamt_assoc_hash(h, key, value, hamt, 0)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-assoc`\n\n```python\ndef hamt_assoc(key, value, hamt):\n    h = hamt_hash_key(key)\n    return hamt_assoc_hash(h, key, value, hamt, 0)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-assoc"], "split": "eval"}
{"id": "hamt_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-assoc`\n\n```scheme\n(define (hamt-put k v h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-assoc-hash hash k v h 0)))\n```\n\nReturn only Fold code.", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-assoc`\n\n```scheme\n(define (hamt-put k v h)\n  (let ((hash (hamt-hash-key k)))\n    (hamt-assoc-hash hash k v h 0)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-assoc"], "split": "eval"}
{"id": "hamt_translation_029", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-merge-with`\n\n```python\ndef hamt_merge_with(f, h1, h2):\n    def step(acc, k, v):\n        if hamt_has_key(k, acc):\n            return hamt_assoc(k, f(hamt_lookup(k, acc), v), acc)\n        return hamt_assoc(k, v, acc)\n    return hamt_fold(step, h1, h2)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including key-absence semantics.\n\nTarget function name: `hamt-merge-with`\n\n```python\ndef hamt_merge_with(f, h1, h2):\n    def step(acc, k, v):\n        if hamt_has_key(k, acc):\n            return hamt_assoc(k, f(hamt_lookup(k, acc), v), acc)\n        return hamt_assoc(k, v, acc)\n    return hamt_fold(step, h1, h2)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["tier0", "data", "hamt", "python-to-scheme", "hamt-merge-with"], "split": "eval"}
{"id": "hamt_translation_030", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-merge-with`\n\n```scheme\n(define (hamt-merge0 f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only Fold code.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `hamt-merge-with`\n\n```scheme\n(define (hamt-merge0 f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["tier0", "data", "hamt", "chez-to-fold", "hamt-merge-with"], "split": "eval"}
{"id": "hamt_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-assoc` in `lattice/data/hamt.ss`.\nKnown issue: Assoc hash must be computed from key, not value.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key value)])\n    (hamt-assoc-hash hash key value hamt 0)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-assoc` in `lattice/data/hamt.ss`.\nKnown issue: Assoc hash must be computed from key, not value.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key value)])\n    (hamt-assoc-hash hash key value hamt 0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-assoc"], "split": "eval"}
{"id": "hamt_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-assoc", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-assoc` in `lattice/data/hamt.ss`.\nKnown issue: Insertion recursion must start at shift 0.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-assoc` in `lattice/data/hamt.ss`.\nKnown issue: Insertion recursion must start at shift 0.\n\n```scheme\n(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt *hamt-bits*)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Insertion recursion must start at shift 0.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (let* ([h0 hamt-empty] [h1 (hamt-assoc 'a 1 h0)] [h2 (hamt-assoc 'b 2 h1)] [h3 (hamt-assoc 'a 9 h2)]) (and (= (hamt-size h2) 2) (= (hamt-size h3) 2) (= (hamt-lookup 'a h3) 9) (= (hamt-lookup 'b h3) 2))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-assoc"], "split": "eval"}
{"id": "hamt_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge-with` in `lattice/data/hamt.ss`.\nKnown issue: Conflict resolver argument order must be (old-value, new-value).\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f v (hamt-lookup k acc)) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge-with` in `lattice/data/hamt.ss`.\nKnown issue: Conflict resolver argument order must be (old-value, new-value).\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f v (hamt-lookup k acc)) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Conflict resolver argument order must be (old-value, new-value).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-merge-with"], "split": "eval"}
{"id": "hamt_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge-with", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge-with` in `lattice/data/hamt.ss`.\nKnown issue: Presence test must use hamt-has-key? so #f values are treated as existing keys.\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-lookup k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hamt-merge-with` in `lattice/data/hamt.ss`.\nKnown issue: Presence test must use hamt-has-key? so #f values are treated as existing keys.\n\n```scheme\n(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-lookup k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Presence test must use hamt-has-key? so #f values are treated as existing keys.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))", "verify_expr": "(let ()\n  (define *hamt-bits* 5)\n  (define *hamt-mask* #b11111)\n  (define *hamt-hash-mask* #x7FFFFFFF)\n  (define hamt-empty 'hamt-empty)\n  (define (hamt-empty? x)\n  (eq? x 'hamt-empty))\n  (define (hamt-leaf? x)\n  (and (pair? x) (eq? (car x) 'hamt-leaf)))\n  (define (hamt-collision? x)\n  (and (pair? x) (eq? (car x) 'hamt-collision)))\n  (define (hamt-node? x)\n  (and (pair? x) (eq? (car x) 'hamt-node)))\n  (define (hamt-leaf-key n)\n  (caddr n))\n  (define (hamt-leaf-value n)\n  (cadddr n))\n  (define (hamt-collision-entries n)\n  (caddr n))\n  (define (hamt-node-children n)\n  (cddr n))\n  (define (hamt-fold f init hamt)\n  (cond\n    [(hamt-empty? hamt) init]\n    [(hamt-leaf? hamt)\n     (f init (hamt-leaf-key hamt) (hamt-leaf-value hamt))]\n    [(hamt-collision? hamt)\n     (fold-left (lambda (acc pair) (f acc (car pair) (cdr pair)))\n                init (hamt-collision-entries hamt))]\n    [(hamt-node? hamt)\n     (fold-left (lambda (acc child) (hamt-fold f acc child))\n                init (hamt-node-children hamt))]\n    [else init]))\n  (define (hamt-hash-key key)\n  (fxlogand (equal-hash key) *hamt-hash-mask*))\n  (define (hash-fragment shift hash)\n  (fxlogand (fxarithmetic-shift-right hash shift) *hamt-mask*))\n  (define (bit-pos fragment)\n  (fxarithmetic-shift-left 1 fragment))\n  (define (hamt-node-bitmap n)\n  (cadr n))\n  (define (bitmap-has? bitmap bit)\n  (not (fxzero? (fxlogand bitmap bit))))\n  (define (bitmap-index bitmap bit)\n  (fxbit-count (fxlogand bitmap (fx- bit 1))))\n  (define (hamt-lookup-or-hash hash key node shift default)\n  (cond\n    [(hamt-empty? node) default]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         default)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) default))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-or-hash hash key\n                                  (list-ref (hamt-node-children node) idx)\n                                  (fx+ shift *hamt-bits*) default))\n           default))]\n    [else default]))\n  (define (hamt-lookup-or key hamt default)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-or-hash hash key hamt 0 default)))\n  (define (hamt-has-key? key hamt)\n  (let ([sentinel (list 'not-found)])\n    (not (eq? sentinel (hamt-lookup-or key hamt sentinel)))))\n  (define (make-hamt-leaf hash key value)\n  (list 'hamt-leaf hash key value))\n  (define (hamt-leaf-hash n)\n  (cadr n))\n  (define (make-hamt-collision hash entries)\n  (list 'hamt-collision hash entries))\n  (define (make-hamt-node bitmap children)\n  (cons 'hamt-node (cons bitmap children)))\n  (define (create-branch hash1 node1 hash2 node2 shift)\n  (let* ([frag1 (hash-fragment shift hash1)]\n         [frag2 (hash-fragment shift hash2)]\n         [bit1 (bit-pos frag1)]\n         [bit2 (bit-pos frag2)])\n    (if (= frag1 frag2)\n        (let ([child (create-branch hash1 node1 hash2 node2\n                                    (fx+ shift *hamt-bits*))])\n          (make-hamt-node bit1 (list child)))\n        (if (< frag1 frag2)\n            (make-hamt-node (fxlogor bit1 bit2) (list node1 node2))\n            (make-hamt-node (fxlogor bit1 bit2) (list node2 node1))))))\n  (define (hamt-collision-hash n)\n  (cadr n))\n  (define (collision-assoc key value entries)\n  (let loop ([es entries] [acc '()] [found #f])\n    (cond\n      [(null? es)\n       (if found\n           (reverse acc)\n           (reverse (cons (cons key value) acc)))]\n      [(equal? key (caar es))\n       (loop (cdr es) (cons (cons key value) acc) #t)]\n      [else\n       (loop (cdr es) (cons (car es) acc) found)])))\n  (define (list-set lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(null? l) (reverse acc)]\n      [(= i idx) (loop (cdr l) (+ i 1) (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (list-insert lst idx val)\n  (let loop ([l lst] [i 0] [acc '()])\n    (cond\n      [(= i idx) (append (reverse (cons val acc)) l)]\n      [(null? l) (reverse (cons val acc))]\n      [else (loop (cdr l) (+ i 1) (cons (car l) acc))])))\n  (define (hamt-assoc-hash hash key value node shift)\n  (cond\n    [(hamt-empty? node)\n     (make-hamt-leaf hash key value)]\n\n    [(hamt-leaf? node)\n     (let ([existing-hash (hamt-leaf-hash node)]\n           [existing-key (hamt-leaf-key node)])\n       (cond\n         [(equal? key existing-key)\n          (make-hamt-leaf hash key value)]\n         [(= hash existing-hash)\n          (make-hamt-collision hash\n            (list (cons key value)\n                  (cons existing-key (hamt-leaf-value node))))]\n         [else\n          (create-branch existing-hash node hash\n                         (make-hamt-leaf hash key value)\n                         shift)]))]\n\n    [(hamt-collision? node)\n     (if (= hash (hamt-collision-hash node))\n         (make-hamt-collision hash\n           (collision-assoc key value (hamt-collision-entries node)))\n         (create-branch (hamt-collision-hash node) node\n                        hash (make-hamt-leaf hash key value)\n                        shift))]\n\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)]\n            [children (hamt-node-children node)])\n       (if (bitmap-has? bitmap bit)\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [child (list-ref children idx)]\n                  [new-child (hamt-assoc-hash hash key value child\n                                              (fx+ shift *hamt-bits*))])\n             (make-hamt-node bitmap (list-set children idx new-child)))\n           (let* ([idx (bitmap-index bitmap bit)]\n                  [new-bitmap (fxlogor bitmap bit)])\n             (make-hamt-node new-bitmap\n                             (list-insert children idx\n                                          (make-hamt-leaf hash key value))))))]\n\n    [else (make-hamt-leaf hash key value)]))\n  (define (hamt-assoc key value hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-assoc-hash hash key value hamt 0)))\n  (define (hamt-lookup-hash hash key node shift)\n  (cond\n    [(hamt-empty? node) #f]\n    [(hamt-leaf? node)\n     (if (equal? key (hamt-leaf-key node))\n         (hamt-leaf-value node)\n         #f)]\n    [(hamt-collision? node)\n     (let ([pair (assoc key (hamt-collision-entries node))])\n       (if pair (cdr pair) #f))]\n    [(hamt-node? node)\n     (let* ([frag (hash-fragment shift hash)]\n            [bit (bit-pos frag)]\n            [bitmap (hamt-node-bitmap node)])\n       (if (bitmap-has? bitmap bit)\n           (let ([idx (bitmap-index bitmap bit)])\n             (hamt-lookup-hash hash key\n                               (list-ref (hamt-node-children node) idx)\n                               (fx+ shift *hamt-bits*)))\n           #f))]\n    [else #f]))\n  (define (hamt-lookup key hamt)\n  (let ([hash (hamt-hash-key key)])\n    (hamt-lookup-hash hash key hamt 0)))\n  (define (hamt-size hamt)\n  (hamt-fold (lambda (acc k v) (+ acc 1)) 0 hamt))\n  (define (dict->hamt dict)\n  (fold-left (lambda (acc pair)\n               (hamt-assoc (car pair) (cdr pair) acc))\n             hamt-empty dict))\n  (define (alist->hamt alist)\n  (dict->hamt alist))\n  (define (hamt-merge-with f h1 h2)\n  (hamt-fold (lambda (acc k v)\n               (if (hamt-has-key? k acc)\n                   (hamt-assoc k (f (hamt-lookup k acc) v) acc)\n                   (hamt-assoc k v acc)))\n             h1 h2))\n  (let* ([h1 (alist->hamt '((a . 1) (b . #f)))] [h2 (alist->hamt '((b . 10) (c . 3)))] [m (hamt-merge-with (lambda (old new) (if (equal? old #f) 'had-false (+ old new))) h1 h2)]) (and (= (hamt-lookup 'a m) 1) (equal? (hamt-lookup 'b m) 'had-false) (= (hamt-lookup 'c m) 3) (= (hamt-size m) 3))))", "tags": ["tier0", "data", "hamt", "bugfix", "hamt-merge-with"], "split": "eval"}
{"id": "hamt_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-empty?", "prompt_body": "Check whether canonical hamt-empty is empty.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck whether canonical hamt-empty is empty.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-empty? hamt-empty)", "verify_expr": "(equal? (hamt-empty? hamt-empty) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-empty?", "direct"], "split": "eval"}
{"id": "hamt_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup", "prompt_body": "Lookup numeric key 1 and string key \"1\" in same HAMT.", "prompt": "Task mode: compose existing APIs into one expression.\n\nLookup numeric key 1 and string key \"1\" in same HAMT.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (hamt-lookup 1 (alist->hamt '((1 . int) (\"1\" . str)))) (hamt-lookup \"1\" (alist->hamt '((1 . int) (\"1\" . str)))))", "verify_expr": "(equal? (list (hamt-lookup 1 (alist->hamt '((1 . int) (\"1\" . str)))) (hamt-lookup \"1\" (alist->hamt '((1 . int) (\"1\" . str))))) '(int str))", "tags": ["tier0", "data", "hamt", "composition", "hamt-lookup", "property"], "split": "eval"}
{"id": "hamt_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-has-key?", "prompt_body": "Insert then dissoc key 'a and test presence.", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert then dissoc key 'a and test presence.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-has-key? 'a (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty)))", "verify_expr": "(equal? (hamt-has-key? 'a (hamt-dissoc 'a (hamt-assoc 'a 1 hamt-empty))) #f)", "tags": ["tier0", "data", "hamt", "composition", "hamt-has-key?", "integration"], "split": "eval"}
{"id": "hamt_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-dissoc", "prompt_body": "Dissoc missing key should preserve size.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nDissoc missing key should preserve size.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-size (hamt-dissoc 'x (alist->hamt '((a . 1) (b . 2)))))", "verify_expr": "(equal? (hamt-size (hamt-dissoc 'x (alist->hamt '((a . 1) (b . 2))))) 2)", "tags": ["tier0", "data", "hamt", "composition", "hamt-dissoc", "edge-case"], "split": "eval"}
{"id": "hamt_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-size", "prompt_body": "Merge two HAMTs and return resulting size.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge two HAMTs and return resulting size.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 4) (c . 8)))))", "verify_expr": "(equal? (hamt-size (hamt-merge-with + (alist->hamt '((a . 1) (b . 2))) (alist->hamt '((b . 4) (c . 8))))) 3)", "tags": ["tier0", "data", "hamt", "composition", "hamt-size", "integration"], "split": "eval"}
{"id": "hamt_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-lookup-or", "prompt_body": "Lookup missing key with explicit fallback value.", "prompt": "Task mode: compose existing APIs into one expression.\n\nLookup missing key with explicit fallback value.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-lookup-or 'missing (alist->hamt '((a . 1))) 'fallback)", "verify_expr": "(equal? (hamt-lookup-or 'missing (alist->hamt '((a . 1))) 'fallback) 'fallback)", "tags": ["tier0", "data", "hamt", "composition", "hamt-lookup-or", "direct"], "split": "eval"}
{"id": "hamt_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-fold", "prompt_body": "Fold values in HAMT and return their sum.", "prompt": "Task mode: small integration task across module primitives.\n\nFold values in HAMT and return their sum.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-fold (lambda (acc k v) (+ acc v)) 0 (alist->hamt '((a . 1) (b . 2) (c . 3))))", "verify_expr": "(equal? (hamt-fold (lambda (acc k v) (+ acc v)) 0 (alist->hamt '((a . 1) (b . 2) (c . 3)))) 6)", "tags": ["tier0", "data", "hamt", "composition", "hamt-fold", "direct"], "split": "eval"}
{"id": "hamt_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-keys", "prompt_body": "Return whether key collection includes a,b,c with length 3.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether key collection includes a,b,c with length 3.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([ks (hamt-keys (alist->hamt '((a . 1) (b . 2) (c . 3))))]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks)))))", "verify_expr": "(equal? (let ([ks (hamt-keys (alist->hamt '((a . 1) (b . 2) (c . 3))))]) (and (= (length ks) 3) (not (not (member 'a ks))) (not (not (member 'b ks))) (not (not (member 'c ks))))) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-keys", "property"], "split": "eval"}
{"id": "hamt_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-values", "prompt_body": "Return whether value collection includes 1,2,3 with length 3.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether value collection includes 1,2,3 with length 3.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([vs (hamt-values (alist->hamt '((a . 1) (b . 2) (c . 3))))]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs)))))", "verify_expr": "(equal? (let ([vs (hamt-values (alist->hamt '((a . 1) (b . 2) (c . 3))))]) (and (= (length vs) 3) (not (not (member 1 vs))) (not (not (member 2 vs))) (not (not (member 3 vs))))) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-values", "property"], "split": "eval"}
{"id": "hamt_composition_033", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-entries", "prompt_body": "Convert entries to HAMT again and read back values.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert entries to HAMT again and read back values.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([h (alist->hamt '((x . 10) (y . 20)))] [h2 (alist->hamt (hamt-entries h))]) (list (hamt-lookup 'x h2) (hamt-lookup 'y h2) (hamt-size h2)))", "verify_expr": "(equal? (let* ([h (alist->hamt '((x . 10) (y . 20)))] [h2 (alist->hamt (hamt-entries h))]) (list (hamt-lookup 'x h2) (hamt-lookup 'y h2) (hamt-size h2))) '(10 20 2))", "tags": ["tier0", "data", "hamt", "composition", "hamt-entries", "integration"], "split": "eval"}
{"id": "hamt_composition_034", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-map-values", "prompt_body": "Map (+ v 10) over values and lookup transformed keys.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap (+ v 10) over values and lookup transformed keys.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (hamt-map-values (lambda (v) (+ v 10)) (alist->hamt '((a . 1) (b . 2))))]) (list (hamt-lookup 'a m) (hamt-lookup 'b m)))", "verify_expr": "(equal? (let ([m (hamt-map-values (lambda (v) (+ v 10)) (alist->hamt '((a . 1) (b . 2))))]) (list (hamt-lookup 'a m) (hamt-lookup 'b m))) '(11 12))", "tags": ["tier0", "data", "hamt", "composition", "hamt-map-values", "direct"], "split": "eval"}
{"id": "hamt_composition_035", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-filter", "prompt_body": "Filter entries where value > 1 and check membership/size properties.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter entries where value > 1 and check membership/size properties.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([f (hamt-filter (lambda (k v) (> v 1)) (alist->hamt '((a . 1) (b . 2) (c . 3))))] [ks (hamt-keys f)]) (and (= (hamt-size f) 2) (not (not (member 'b ks))) (not (not (member 'c ks))) (not (member 'a ks))))", "verify_expr": "(equal? (let* ([f (hamt-filter (lambda (k v) (> v 1)) (alist->hamt '((a . 1) (b . 2) (c . 3))))] [ks (hamt-keys f)]) (and (= (hamt-size f) 2) (not (not (member 'b ks))) (not (not (member 'c ks))) (not (member 'a ks)))) #t)", "tags": ["tier0", "data", "hamt", "composition", "hamt-filter", "integration"], "split": "eval"}
{"id": "hamt_composition_036", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "hamt-merge", "prompt_body": "Merge with right-bias and read conflicting key.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge with right-bias and read conflicting key.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hamt-lookup 'k (hamt-merge (alist->hamt '((k . 1) (x . 2))) (alist->hamt '((k . 9) (y . 3)))) )", "verify_expr": "(equal? (hamt-lookup 'k (hamt-merge (alist->hamt '((k . 1) (x . 2))) (alist->hamt '((k . 9) (y . 3))))) 9)", "tags": ["tier0", "data", "hamt", "composition", "hamt-merge", "direct"], "split": "eval"}
{"id": "hamt_composition_037", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "dict->hamt", "prompt_body": "Convert dict with duplicate key and check rightmost value wins.", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert dict with duplicate key and check rightmost value wins.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([h (dict->hamt '((m . 1) (n . 2) (m . 7)))]) (list (hamt-lookup 'm h) (hamt-lookup 'n h) (hamt-size h)))", "verify_expr": "(equal? (let ([h (dict->hamt '((m . 1) (n . 2) (m . 7)))]) (list (hamt-lookup 'm h) (hamt-lookup 'n h) (hamt-size h))) '(7 2 2))", "tags": ["tier0", "data", "hamt", "composition", "dict->hamt", "direct"], "split": "eval"}
{"id": "hamt_composition_041", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/hamt.ss", "source_test": "lattice/data/test-hamt.ss", "source_function": "alist->hamt", "prompt_body": "Convert mixed-key alist and return size.", "prompt": "Task mode: compose existing APIs into one expression.\n\nConvert mixed-key alist and return size.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(hamt-size (alist->hamt '((1 . one) (\"1\" . str) ((1 2) . pair))))", "verify_expr": "(equal? (hamt-size (alist->hamt '((1 . one) (\"1\" . str) ((1 2) . pair)))) 3)", "tags": ["tier0", "data", "hamt", "composition", "alist->hamt", "integration"], "split": "eval"}
