{"id": "info_entropy_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `entropy-normalized`\nSpec: Normalize raw non-negative weights to probabilities (when total != 0), then compute Shannon entropy.\n\nWrite exactly one Scheme function definition for `entropy-normalized`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `entropy-normalized`\nSpec: Normalize raw non-negative weights to probabilities (when total != 0), then compute Shannon entropy.\n\nWrite exactly one Scheme function definition for `entropy-normalized`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001) (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001) (approx=? 0.0 (entropy-normalized '(0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "spec-to-code", "entropy-normalized"], "split": "eval"}
{"id": "info_entropy_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `mutual-information`\nSpec: Compute I(X;Y) = H(X) + H(Y) - H(X,Y) from joint distribution and marginals.\n\nWrite exactly one Scheme function definition for `mutual-information`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `mutual-information`\nSpec: Compute I(X;Y) = H(X) + H(Y) - H(X,Y) from joint distribution and marginals.\n\nWrite exactly one Scheme function definition for `mutual-information`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))", "tags": ["tier1", "info", "entropy", "spec-to-code", "mutual-information"], "split": "eval"}
{"id": "info_entropy_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `jensen-shannon-divergence`\nSpec: Compute JSD(P,Q) using midpoint distribution M=(P+Q)/2 and average KL divergence.\n\nWrite exactly one Scheme function definition for `jensen-shannon-divergence`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `jensen-shannon-divergence`\nSpec: Compute JSD(P,Q) using midpoint distribution M=(P+Q)/2 and average KL divergence.\n\nWrite exactly one Scheme function definition for `jensen-shannon-divergence`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))", "tags": ["tier1", "info", "entropy", "spec-to-code", "jensen-shannon-divergence"], "split": "eval"}
{"id": "info_entropy_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `entropy`.\nReturn only the Scheme definition.\n\n```python\ndef entropy(probs):\n    return -sum((0 if p <= 0 else p * log2(p)) for p in probs)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `entropy`.\nReturn only the Scheme definition.\n\n```python\ndef entropy(probs):\n    return -sum((0 if p <= 0 else p * log2(p)) for p in probs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001) (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001) (approx=? 0.0 (entropy '(1 0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "entropy"], "split": "eval"}
{"id": "info_entropy_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `cross-entropy`.\nReturn only the Scheme definition.\n\n```python\ndef cross_entropy(p, q):\n    if len(p) == 0:\n        return 0\n    if any((pi > 0 and qi <= 0) for pi, qi in zip(p, q)):\n        return float('inf')\n    return -sum((0 if pi <= 0 else pi * log2(qi)) for pi, qi in zip(p, q))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `cross-entropy`.\nReturn only the Scheme definition.\n\n```python\ndef cross_entropy(p, q):\n    if len(p) == 0:\n        return 0\n    if any((pi > 0 and qi <= 0) for pi, qi in zip(p, q)):\n        return float('inf')\n    return -sum((0 if pi <= 0 else pi * log2(qi)) for pi, qi in zip(p, q))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001) (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0) (approx=? 0.0 (cross-entropy '() '()) 0.000001)))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "cross-entropy"], "split": "eval"}
{"id": "info_entropy_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `renyi-entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (renyi-entropy0 alpha probs)\n  (cond\n    [(< alpha 0) +inf.0]\n    [(= alpha 1) (entropy probs)]\n    [(= alpha 0)\n     (let loop ([xs probs] [n 0])\n       (if (null? xs)\n           (log2 n)\n           (loop (cdr xs) (if (> (car xs) 0) (+ n 1) n))))]\n    [else\n      (let loop ([xs probs] [sum 0])\n        (if (null? xs)\n            (* (/ 1 (- 1 alpha)) (log2 sum))\n            (loop (cdr xs) (+ sum (expt (car xs) alpha)))))]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `renyi-entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (renyi-entropy0 alpha probs)\n  (cond\n    [(< alpha 0) +inf.0]\n    [(= alpha 1) (entropy probs)]\n    [(= alpha 0)\n     (let loop ([xs probs] [n 0])\n       (if (null? xs)\n           (log2 n)\n           (loop (cdr xs) (if (> (car xs) 0) (+ n 1) n))))]\n    [else\n      (let loop ([xs probs] [sum 0])\n        (if (null? xs)\n            (* (/ 1 (- 1 alpha)) (log2 sum))\n            (loop (cdr xs) (+ sum (expt (car xs) alpha)))))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "renyi-entropy"], "split": "eval"}
{"id": "info_entropy_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy` in `lattice/info/entropy.ss`.\nKnown issue: Entropy must negate the accumulated p*log2(p) sum.\n\n```scheme\n(define (entropy probs)\n  (fold-left + 0 (map plogp probs)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy` in `lattice/info/entropy.ss`.\nKnown issue: Entropy must negate the accumulated p*log2(p) sum.\n\n```scheme\n(define (entropy probs)\n  (fold-left + 0 (map plogp probs)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Entropy must negate the accumulated p*log2(p) sum.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001) (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001) (approx=? 0.0 (entropy '(1 0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "entropy"], "split": "eval"}
{"id": "info_entropy_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cross-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Support mismatch (pi>0 with qi<=0) must return +inf.0.\n\n```scheme\n(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (- (fold-left + 0\n                    (map (lambda (pi qi)\n                                 (if (<= pi 0)\n                                     0\n                                     (* pi (entropy-log2 qi))))\n                         p q)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cross-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Support mismatch (pi>0 with qi<=0) must return +inf.0.\n\n```scheme\n(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (- (fold-left + 0\n                    (map (lambda (pi qi)\n                                 (if (<= pi 0)\n                                     0\n                                     (* pi (entropy-log2 qi))))\n                         p q)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001))\n(let () (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001) (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0) (approx=? 0.0 (cross-entropy '() '()) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "cross-entropy"], "split": "eval"}
{"id": "info_entropy_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `renyi-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Hartley case (alpha=0) must count positive-support outcomes only.\n\n```scheme\n(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length probs))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `renyi-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Hartley case (alpha=0) must count positive-support outcomes only.\n\n```scheme\n(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length probs))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Hartley case (alpha=0) must count positive-support outcomes only.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))", "tags": ["tier1", "info", "entropy", "bugfix", "renyi-entropy"], "split": "eval"}
{"id": "info_entropy_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Compute entropy of a fair die distribution.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute entropy of a fair die distribution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(entropy '(1/6 1/6 1/6 1/6 1/6 1/6))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 2.584962 (entropy '(1/6 1/6 1/6 1/6 1/6 1/6)) 0.0001))", "tags": ["tier1", "info", "entropy", "composition", "entropy", "direct"], "split": "eval"}
{"id": "info_entropy_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Compute binary entropy at p=0.25.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute binary entropy at p=0.25.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(binary-entropy 0.25)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.811278 (binary-entropy 0.25) 0.001))", "tags": ["tier1", "info", "entropy", "composition", "binary-entropy", "direct"], "split": "eval"}
{"id": "info_entropy_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Compute cross-entropy of identical fair-coin distributions.", "prompt": "Task mode: small integration task across module primitives.\n\nCompute cross-entropy of identical fair-coin distributions.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(cross-entropy '(0.5 0.5) '(0.5 0.5))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "cross-entropy", "direct"], "split": "eval"}
{"id": "info_entropy_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Return whether cross-entropy equals entropy plus KL divergence for P='(0.8 0.2), Q='(0.5 0.5).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether cross-entropy equals entropy plus KL divergence for P='(0.8 0.2), Q='(0.5 0.5).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p '(0.8 0.2)] [q '(0.5 0.5)]) (approx=? (cross-entropy p q) (+ (entropy p) (kl-divergence p q)) 0.000001))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([p '(0.8 0.2)] [q '(0.5 0.5)]) (approx=? (cross-entropy p q) (+ (entropy p) (kl-divergence p q)) 0.000001)) #t))", "tags": ["tier1", "info", "entropy", "composition", "kl-divergence", "integration"], "split": "eval"}
{"id": "info_entropy_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Return whether H_2 <= H_1 for probabilities '(0.7 0.2 0.1).", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether H_2 <= H_1 for probabilities '(0.7 0.2 0.1).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(<= (renyi-entropy 2 '(0.7 0.2 0.1)) (renyi-entropy 1 '(0.7 0.2 0.1)))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n  (equal? (<= (renyi-entropy 2 '(0.7 0.2 0.1)) (renyi-entropy 1 '(0.7 0.2 0.1))) #t))", "tags": ["tier1", "info", "entropy", "composition", "renyi-entropy", "ordering"], "split": "eval"}
