{"id": "info_entropy_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `entropy`\nSpec: Compute Shannon entropy H(X) = -sum(p_i * log2(p_i)) with 0*log2(0) handled as 0.\n\nWrite exactly one Scheme function definition for `entropy`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `entropy`\nSpec: Compute Shannon entropy H(X) = -sum(p_i * log2(p_i)) with 0*log2(0) handled as 0.\n\nWrite exactly one Scheme function definition for `entropy`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001))\n(let () (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001) (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001) (approx=? 0.0 (entropy '(1 0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "spec-to-code", "entropy"], "split": "train"}
{"id": "info_entropy_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (entropy probs)\n  ;; TODO: Shannon entropy from probability list probs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `entropy`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (entropy probs)\n  ;; TODO: Shannon entropy from probability list probs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `entropy`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001))\n(let () (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001) (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001) (approx=? 0.0 (entropy '(1 0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "entropy"], "split": "train"}
{"id": "info_entropy_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (entropy-normalized weights)\n  ;; TODO: normalize weights when sum is non-zero, then call entropy\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `entropy-normalized`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (entropy-normalized weights)\n  ;; TODO: normalize weights when sum is non-zero, then call entropy\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `entropy-normalized`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001))\n(let () (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001) (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001) (approx=? 0.0 (entropy-normalized '(0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "entropy-normalized"], "split": "train"}
{"id": "info_entropy_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `binary-entropy`\nSpec: Compute binary entropy H(p) = -p*log2(p) - (1-p)*log2(1-p) with boundary values p<=0 or p>=1 returning 0.\n\nWrite exactly one Scheme function definition for `binary-entropy`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `binary-entropy`\nSpec: Compute binary entropy H(p) = -p*log2(p) - (1-p)*log2(1-p) with boundary values p<=0 or p>=1 returning 0.\n\nWrite exactly one Scheme function definition for `binary-entropy`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 1.0 (binary-entropy 0.5) 0.000001))\n(let () (approx=? 0.0 (binary-entropy 0.0) 0.000001))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (binary-entropy 0.5) 0.000001) (approx=? 0.0 (binary-entropy 0.0) 0.000001) (approx=? (binary-entropy 0.1) (binary-entropy 0.9) 0.000001)))", "tags": ["tier1", "info", "entropy", "spec-to-code", "binary-entropy"], "split": "train"}
{"id": "info_entropy_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (binary-entropy p)\n  ;; TODO: implement boundary-safe binary entropy\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `binary-entropy`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (binary-entropy p)\n  ;; TODO: implement boundary-safe binary entropy\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `binary-entropy`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 1.0 (binary-entropy 0.5) 0.000001))\n(let () (approx=? 0.0 (binary-entropy 0.0) 0.000001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (binary-entropy 0.5) 0.000001) (approx=? 0.0 (binary-entropy 0.0) 0.000001) (approx=? (binary-entropy 0.1) (binary-entropy 0.9) 0.000001)))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "binary-entropy"], "split": "train"}
{"id": "info_entropy_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (mutual-information joint-probs marginal-x marginal-y)\n  ;; TODO: combine H(X), H(Y), and H(X,Y)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mutual-information`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (mutual-information joint-probs marginal-x marginal-y)\n  ;; TODO: combine H(X), H(Y), and H(X,Y)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `mutual-information`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "mutual-information"], "split": "train"}
{"id": "info_entropy_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `cross-entropy`\nSpec: Compute cross entropy H(P,Q) with support-mismatch behavior returning +inf.0 when P has mass where Q is zero.\n\nWrite exactly one Scheme function definition for `cross-entropy`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `cross-entropy`\nSpec: Compute cross entropy H(P,Q) with support-mismatch behavior returning +inf.0 when P has mass where Q is zero.\n\nWrite exactly one Scheme function definition for `cross-entropy`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001) (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0) (approx=? 0.0 (cross-entropy '() '()) 0.000001)))", "tags": ["tier1", "info", "entropy", "spec-to-code", "cross-entropy"], "split": "train"}
{"id": "info_entropy_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (cross-entropy p q)\n  ;; TODO: return +inf.0 on support mismatch; otherwise compute -sum p_i*log2(q_i)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `cross-entropy`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (cross-entropy p q)\n  ;; TODO: return +inf.0 on support mismatch; otherwise compute -sum p_i*log2(q_i)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `cross-entropy`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001))\n(let () (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001) (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0) (approx=? 0.0 (cross-entropy '() '()) 0.000001)))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "cross-entropy"], "split": "train"}
{"id": "info_entropy_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `kl-divergence`\nSpec: Compute D_KL(P||Q) with 0-probability convention and +inf.0 when Q has zero where P is positive.\n\nWrite exactly one Scheme function definition for `kl-divergence`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `kl-divergence`\nSpec: Compute D_KL(P||Q) with 0-probability convention and +inf.0 when Q has zero where P is positive.\n\nWrite exactly one Scheme function definition for `kl-divergence`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001) (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0) (= (kl-divergence '(0.5 0.5) '(1.0 0.0)) +inf.0)))", "tags": ["tier1", "info", "entropy", "spec-to-code", "kl-divergence"], "split": "train"}
{"id": "info_entropy_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (kl-divergence p q)\n  ;; TODO: implement D_KL(P||Q) with qi<=0 inf handling\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `kl-divergence`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (kl-divergence p q)\n  ;; TODO: implement D_KL(P||Q) with qi<=0 inf handling\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `kl-divergence`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001))\n(let () (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001) (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0) (= (kl-divergence '(0.5 0.5) '(1.0 0.0)) +inf.0)))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "kl-divergence"], "split": "train"}
{"id": "info_entropy_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (jensen-shannon-divergence p q)\n  ;; TODO: compute midpoint distribution and average two KL terms\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `jensen-shannon-divergence`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (jensen-shannon-divergence p q)\n  ;; TODO: compute midpoint distribution and average two KL terms\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `jensen-shannon-divergence`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "jensen-shannon-divergence"], "split": "train"}
{"id": "info_entropy_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Implement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `renyi-entropy`\nSpec: Compute Renyi entropy H_alpha including alpha<0 => +inf.0, alpha=1 => Shannon entropy, alpha=0 => Hartley entropy.\n\nWrite exactly one Scheme function definition for `renyi-entropy`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this entropy utility in Fold-native Scheme.\n\nTarget module: lattice/info/entropy.ss\nFunction: `renyi-entropy`\nSpec: Compute Renyi entropy H_alpha including alpha<0 => +inf.0, alpha=1 => Shannon entropy, alpha=0 => Hartley entropy.\n\nWrite exactly one Scheme function definition for `renyi-entropy`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))", "tags": ["tier1", "info", "entropy", "spec-to-code", "renyi-entropy"], "split": "train"}
{"id": "info_entropy_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (renyi-entropy alpha probs)\n  ;; TODO: handle alpha special cases and generic Renyi formula\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `renyi-entropy`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (renyi-entropy alpha probs)\n  ;; TODO: handle alpha special cases and generic Renyi formula\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `renyi-entropy`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))", "tags": ["tier1", "info", "entropy", "skeleton-completion", "renyi-entropy"], "split": "train"}
{"id": "info_entropy_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (entropy0 probs)\n  (let loop ([xs probs] [acc 0])\n    (if (null? xs)\n        (- acc)\n        (loop (cdr xs) (+ acc (plogp (car xs)))))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (entropy0 probs)\n  (let loop ([xs probs] [acc 0])\n    (if (null? xs)\n        (- acc)\n        (loop (cdr xs) (+ acc (plogp (car xs)))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001))\n(let () (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001) (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001) (approx=? 0.0 (entropy '(1 0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "entropy"], "split": "train"}
{"id": "info_entropy_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `entropy-normalized`.\nReturn only the Scheme definition.\n\n```python\ndef entropy_normalized(weights):\n    total = sum(weights)\n    probs = weights if total == 0 else [w / total for w in weights]\n    return entropy(probs)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `entropy-normalized`.\nReturn only the Scheme definition.\n\n```python\ndef entropy_normalized(weights):\n    total = sum(weights)\n    probs = weights if total == 0 else [w / total for w in weights]\n    return entropy(probs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001))\n(let () (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001) (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001) (approx=? 0.0 (entropy-normalized '(0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "entropy-normalized"], "split": "train"}
{"id": "info_entropy_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `entropy-normalized`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (entropy-normalized0 weights)\n  (let ([total (fold-left + 0 weights)])\n    (if (= total 0)\n        (entropy weights)\n        (entropy (map (lambda (w) (/ w total)) weights)))))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `entropy-normalized`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (entropy-normalized0 weights)\n  (let ([total (fold-left + 0 weights)])\n    (if (= total 0)\n        (entropy weights)\n        (entropy (map (lambda (w) (/ w total)) weights)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001) (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001) (approx=? 0.0 (entropy-normalized '(0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "entropy-normalized"], "split": "train"}
{"id": "info_entropy_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `binary-entropy`.\nReturn only the Scheme definition.\n\n```python\ndef binary_entropy(p):\n    if p <= 0 or p >= 1:\n        return 0\n    return -(p * log2(p) + (1 - p) * log2(1 - p))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `binary-entropy`.\nReturn only the Scheme definition.\n\n```python\ndef binary_entropy(p):\n    if p <= 0 or p >= 1:\n        return 0\n    return -(p * log2(p) + (1 - p) * log2(1 - p))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (approx=? 1.0 (binary-entropy 0.5) 0.000001))\n(let () (approx=? 0.0 (binary-entropy 0.0) 0.000001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (binary-entropy 0.5) 0.000001) (approx=? 0.0 (binary-entropy 0.0) 0.000001) (approx=? (binary-entropy 0.1) (binary-entropy 0.9) 0.000001)))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "binary-entropy"], "split": "train"}
{"id": "info_entropy_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `binary-entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (binary-entropy0 p)\n  (if (or (<= p 0) (>= p 1))\n      0\n      (let ([q (- 1 p)])\n        (- (+ (plogp p) (plogp q))))))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `binary-entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (binary-entropy0 p)\n  (if (or (<= p 0) (>= p 1))\n      0\n      (let ([q (- 1 p)])\n        (- (+ (plogp p) (plogp q))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (approx=? 1.0 (binary-entropy 0.5) 0.000001))\n(let () (approx=? 0.0 (binary-entropy 0.0) 0.000001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (binary-entropy 0.5) 0.000001) (approx=? 0.0 (binary-entropy 0.0) 0.000001) (approx=? (binary-entropy 0.1) (binary-entropy 0.9) 0.000001)))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "binary-entropy"], "split": "train"}
{"id": "info_entropy_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `mutual-information`.\nReturn only the Scheme definition.\n\n```python\ndef mutual_information(joint_probs, marginal_x, marginal_y):\n    h_x = entropy(marginal_x)\n    h_y = entropy(marginal_y)\n    h_joint = entropy([v for row in joint_probs for v in row])\n    return h_x + h_y - h_joint\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `mutual-information`.\nReturn only the Scheme definition.\n\n```python\ndef mutual_information(joint_probs, marginal_x, marginal_y):\n    h_x = entropy(marginal_x)\n    h_y = entropy(marginal_y)\n    h_joint = entropy([v for row in joint_probs for v in row])\n    return h_x + h_y - h_joint\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "mutual-information"], "split": "train"}
{"id": "info_entropy_translation_008", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `mutual-information`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mutual-information0 joint-probs marginal-x marginal-y)\n  (let* ([h-x (entropy marginal-x)]\n         [h-y (entropy marginal-y)]\n         [flat (flatten joint-probs)]\n         [h-joint (entropy flat)])\n    (- (+ h-x h-y) h-joint)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `mutual-information`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mutual-information0 joint-probs marginal-x marginal-y)\n  (let* ([h-x (entropy marginal-x)]\n         [h-y (entropy marginal-y)]\n         [flat (flatten joint-probs)]\n         [h-joint (entropy flat)])\n    (- (+ h-x h-y) h-joint)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "mutual-information"], "split": "train"}
{"id": "info_entropy_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `cross-entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (cross-entropy0 p q)\n  (if (null? p)\n      0\n      (let loop ([ps p] [qs q] [acc 0])\n        (cond\n          [(null? ps) (- acc)]\n          [(and (> (car ps) 0) (<= (car qs) 0)) +inf.0]\n          [(<= (car ps) 0) (loop (cdr ps) (cdr qs) acc)]\n          [else\n           (loop (cdr ps)\n                 (cdr qs)\n                 (+ acc (* (car ps) (entropy-log2 (car qs)))))]))))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `cross-entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (cross-entropy0 p q)\n  (if (null? p)\n      0\n      (let loop ([ps p] [qs q] [acc 0])\n        (cond\n          [(null? ps) (- acc)]\n          [(and (> (car ps) 0) (<= (car qs) 0)) +inf.0]\n          [(<= (car ps) 0) (loop (cdr ps) (cdr qs) acc)]\n          [else\n           (loop (cdr ps)\n                 (cdr qs)\n                 (+ acc (* (car ps) (entropy-log2 (car qs)))))]))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001))\n(let () (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001) (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0) (approx=? 0.0 (cross-entropy '() '()) 0.000001)))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "cross-entropy"], "split": "train"}
{"id": "info_entropy_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `kl-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef kl_divergence(p, q):\n    if len(p) == 0:\n        return 0\n    out = 0.0\n    for pi, qi in zip(p, q):\n        if pi <= 0:\n            continue\n        if qi <= 0:\n            return float('inf')\n        out += pi * log2(pi / qi)\n    return out\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `kl-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef kl_divergence(p, q):\n    if len(p) == 0:\n        return 0\n    out = 0.0\n    for pi, qi in zip(p, q):\n        if pi <= 0:\n            continue\n        if qi <= 0:\n            return float('inf')\n        out += pi * log2(pi / qi)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001))\n(let () (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001) (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0) (= (kl-divergence '(0.5 0.5) '(1.0 0.0)) +inf.0)))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "kl-divergence"], "split": "train"}
{"id": "info_entropy_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `kl-divergence`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (kl-divergence0 p q)\n  (if (null? p)\n      0\n      (let loop ([ps p] [qs q] [acc 0])\n        (cond\n          [(null? ps) acc]\n          [(<= (car ps) 0) (loop (cdr ps) (cdr qs) acc)]\n          [(<= (car qs) 0) +inf.0]\n          [else\n           (loop (cdr ps)\n                 (cdr qs)\n                 (+ acc (* (car ps) (log2 (/ (car ps) (car qs))))))]))))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `kl-divergence`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (kl-divergence0 p q)\n  (if (null? p)\n      0\n      (let loop ([ps p] [qs q] [acc 0])\n        (cond\n          [(null? ps) acc]\n          [(<= (car ps) 0) (loop (cdr ps) (cdr qs) acc)]\n          [(<= (car qs) 0) +inf.0]\n          [else\n           (loop (cdr ps)\n                 (cdr qs)\n                 (+ acc (* (car ps) (log2 (/ (car ps) (car qs))))))]))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001))\n(let () (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001) (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0) (= (kl-divergence '(0.5 0.5) '(1.0 0.0)) +inf.0)))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "kl-divergence"], "split": "train"}
{"id": "info_entropy_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `jensen-shannon-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef jensen_shannon_divergence(p, q):\n    m = [(pi + qi) / 2 for pi, qi in zip(p, q)]\n    return (kl_divergence(p, m) + kl_divergence(q, m)) / 2\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `jensen-shannon-divergence`.\nReturn only the Scheme definition.\n\n```python\ndef jensen_shannon_divergence(p, q):\n    m = [(pi + qi) / 2 for pi, qi in zip(p, q)]\n    return (kl_divergence(p, m) + kl_divergence(q, m)) / 2\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "jensen-shannon-divergence"], "split": "train"}
{"id": "info_entropy_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `jensen-shannon-divergence`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (jensen-shannon0 p q)\n  (let* ([mid (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)]\n         [dp (kl-divergence p mid)]\n         [dq (kl-divergence q mid)])\n    (/ (+ dp dq) 2)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `jensen-shannon-divergence`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (jensen-shannon0 p q)\n  (let* ([mid (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)]\n         [dp (kl-divergence p mid)]\n         [dq (kl-divergence q mid)])\n    (/ (+ dp dq) 2)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))", "tags": ["tier1", "info", "entropy", "chez-to-fold", "jensen-shannon-divergence"], "split": "train"}
{"id": "info_entropy_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `renyi-entropy`.\nReturn only the Scheme definition.\n\n```python\ndef renyi_entropy(alpha, probs):\n    if alpha < 0:\n        return float('inf')\n    if alpha == 1:\n        return entropy(probs)\n    if alpha == 0:\n        return log2(sum(1 for p in probs if p > 0))\n    return (1 / (1 - alpha)) * log2(sum((p ** alpha) for p in probs))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `renyi-entropy`.\nReturn only the Scheme definition.\n\n```python\ndef renyi_entropy(alpha, probs):\n    if alpha < 0:\n        return float('inf')\n    if alpha == 1:\n        return entropy(probs)\n    if alpha == 0:\n        return log2(sum(1 for p in probs if p > 0))\n    return (1 / (1 - alpha)) * log2(sum((p ** alpha) for p in probs))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))", "tags": ["tier1", "info", "entropy", "python-to-scheme", "renyi-entropy"], "split": "train"}
{"id": "info_entropy_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy` in `lattice/info/entropy.ss`.\nKnown issue: Each term must be weighted by p_i, not just log2(p_i).\n\n```scheme\n(define (entropy probs)\n  (- (fold-left + 0 (map entropy-log2 probs))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy` in `lattice/info/entropy.ss`.\nKnown issue: Each term must be weighted by p_i, not just log2(p_i).\n\n```scheme\n(define (entropy probs)\n  (- (fold-left + 0 (map entropy-log2 probs))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001))\n(let () (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy '(0.5 0.5)) 0.000001) (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001) (approx=? 0.0 (entropy '(1 0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "entropy"], "split": "train"}
{"id": "info_entropy_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy-normalized` in `lattice/info/entropy.ss`.\nKnown issue: Normalization denominator must be sum(weights), not length(weights).\n\n```scheme\n(define (entropy-normalized weights)\n  (let* ([total (length weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy-normalized` in `lattice/info/entropy.ss`.\nKnown issue: Normalization denominator must be sum(weights), not length(weights).\n\n```scheme\n(define (entropy-normalized weights)\n  (let* ([total (length weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Normalization denominator must be sum(weights), not length(weights).\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001))\n(let () (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001) (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001) (approx=? 0.0 (entropy-normalized '(0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "entropy-normalized"], "split": "train"}
{"id": "info_entropy_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy-normalized` in `lattice/info/entropy.ss`.\nKnown issue: Function must normalize non-zero weights before calling entropy.\n\n```scheme\n(define (entropy-normalized weights)\n  (entropy weights))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `entropy-normalized` in `lattice/info/entropy.ss`.\nKnown issue: Function must normalize non-zero weights before calling entropy.\n\n```scheme\n(define (entropy-normalized weights)\n  (entropy weights))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001))\n(let () (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (entropy-normalized '(2 2)) 0.000001) (approx=? 0.811278 (entropy-normalized '(9 3)) 0.001) (approx=? 0.0 (entropy-normalized '(0 0 0)) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "entropy-normalized"], "split": "train"}
{"id": "info_entropy_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binary-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Binary entropy requires a leading negation of both plogp terms.\n\n```scheme\n(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (+ (plogp p) (plogp (- 1 p)))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binary-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Binary entropy requires a leading negation of both plogp terms.\n\n```scheme\n(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (+ (plogp p) (plogp (- 1 p)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (binary-entropy 0.5) 0.000001) (approx=? 0.0 (binary-entropy 0.0) 0.000001) (approx=? (binary-entropy 0.1) (binary-entropy 0.9) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "binary-entropy"], "split": "train"}
{"id": "info_entropy_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binary-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Second term must use (1-p), not p again.\n\n```scheme\n(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp p)))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binary-entropy` in `lattice/info/entropy.ss`.\nKnown issue: Second term must use (1-p), not p again.\n\n```scheme\n(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp p)))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Second term must use (1-p), not p again.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? 1.0 (binary-entropy 0.5) 0.000001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 1.0 (binary-entropy 0.5) 0.000001))\n(let () (approx=? 0.0 (binary-entropy 0.0) 0.000001))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (binary-entropy 0.5) 0.000001) (approx=? 0.0 (binary-entropy 0.0) 0.000001) (approx=? (binary-entropy 0.1) (binary-entropy 0.9) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "binary-entropy"], "split": "train"}
{"id": "info_entropy_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mutual-information` in `lattice/info/entropy.ss`.\nKnown issue: Mutual information subtracts joint entropy; it does not add it.\n\n```scheme\n(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x h-y h-joint)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mutual-information` in `lattice/info/entropy.ss`.\nKnown issue: Mutual information subtracts joint entropy; it does not add it.\n\n```scheme\n(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x h-y h-joint)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))", "tags": ["tier1", "info", "entropy", "bugfix", "mutual-information"], "split": "train"}
{"id": "info_entropy_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mutual-information` in `lattice/info/entropy.ss`.\nKnown issue: Formula must include both marginals: H(X)+H(Y)-H(X,Y).\n\n```scheme\n(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-joint (joint-entropy joint-probs)])\n       (- h-x h-joint)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `mutual-information` in `lattice/info/entropy.ss`.\nKnown issue: Formula must include both marginals: H(X)+H(Y)-H(X,Y).\n\n```scheme\n(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-joint (joint-entropy joint-probs)])\n       (- h-x h-joint)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([independent '((0.25 0.25) (0.25 0.25))] [correlated '((0.5 0) (0 0.5))] [m '(0.5 0.5)]) (and (approx=? 0.0 (mutual-information independent m m) 0.000001) (approx=? 1.0 (mutual-information correlated m m) 0.000001))))", "tags": ["tier1", "info", "entropy", "bugfix", "mutual-information"], "split": "train"}
{"id": "info_entropy_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cross-entropy` in `lattice/info/entropy.ss`.\nKnown issue: This computes KL-like terms; cross entropy must use -pi*log2(qi).\n\n```scheme\n(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (<= pi 0) (<= qi 0))\n                                  0\n                                  (* pi (log2 (/ pi qi)))))\n                      p q))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cross-entropy` in `lattice/info/entropy.ss`.\nKnown issue: This computes KL-like terms; cross entropy must use -pi*log2(qi).\n\n```scheme\n(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (if (or (<= pi 0) (<= qi 0))\n                                  0\n                                  (* pi (log2 (/ pi qi)))))\n                      p q))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 1.0 (cross-entropy '(0.5 0.5) '(0.5 0.5)) 0.000001) (= (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0) (approx=? 0.0 (cross-entropy '() '()) 0.000001)))", "tags": ["tier1", "info", "entropy", "bugfix", "cross-entropy"], "split": "train"}
{"id": "info_entropy_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kl-divergence` in `lattice/info/entropy.ss`.\nKnown issue: Ratio direction is reversed; must be log2(pi/qi).\n\n```scheme\n(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ qi pi)))]))\n                      p q))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kl-divergence` in `lattice/info/entropy.ss`.\nKnown issue: Ratio direction is reversed; must be log2(pi/qi).\n\n```scheme\n(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ qi pi)))]))\n                      p q))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Ratio direction is reversed; must be log2(pi/qi).\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001) (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0) (= (kl-divergence '(0.5 0.5) '(1.0 0.0)) +inf.0)))", "tags": ["tier1", "info", "entropy", "bugfix", "kl-divergence"], "split": "train"}
{"id": "info_entropy_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kl-divergence` in `lattice/info/entropy.ss`.\nKnown issue: When qi<=0 and pi>0, KL divergence must be +inf.0, not 0.\n\n```scheme\n(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) 0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `kl-divergence` in `lattice/info/entropy.ss`.\nKnown issue: When qi<=0 and pi>0, KL divergence must be +inf.0, not 0.\n\n```scheme\n(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) 0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001))\n(let () (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))", "verify_expr": "(let ()\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (and (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001) (>= (kl-divergence '(0.9 0.1) '(0.5 0.5)) 0) (= (kl-divergence '(0.5 0.5) '(1.0 0.0)) +inf.0)))", "tags": ["tier1", "info", "entropy", "bugfix", "kl-divergence"], "split": "train"}
{"id": "info_entropy_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `jensen-shannon-divergence` in `lattice/info/entropy.ss`.\nKnown issue: Midpoint distribution must average each coordinate: (pi+qi)/2.\n\n```scheme\n(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (+ pi qi)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `jensen-shannon-divergence` in `lattice/info/entropy.ss`.\nKnown issue: Midpoint distribution must average each coordinate: (pi+qi)/2.\n\n```scheme\n(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (+ pi qi)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Midpoint distribution must average each coordinate: (pi+qi)/2.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))", "tags": ["tier1", "info", "entropy", "bugfix", "jensen-shannon-divergence"], "split": "train"}
{"id": "info_entropy_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `jensen-shannon-divergence` in `lattice/info/entropy.ss`.\nKnown issue: JSD is the average of two KL terms, so divide by 2.\n\n```scheme\n(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (+ (kl-divergence p m) (kl-divergence q m))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `jensen-shannon-divergence` in `lattice/info/entropy.ss`.\nKnown issue: JSD is the average of two KL terms, so divide by 2.\n\n```scheme\n(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (+ (kl-divergence p m) (kl-divergence q m))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let* ([p '(0.9 0.1)] [q '(0.5 0.5)] [same (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))] [d1 (jensen-shannon-divergence p q)] [d2 (jensen-shannon-divergence q p)]) (and (approx=? 0.0 same 0.000001) (approx=? d1 d2 0.000001) (<= d1 1.0) (>= d1 0.0))))", "tags": ["tier1", "info", "entropy", "bugfix", "jensen-shannon-divergence"], "split": "train"}
{"id": "info_entropy_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `renyi-entropy` in `lattice/info/entropy.ss`.\nKnown issue: alpha=1 must dispatch to Shannon entropy to avoid division-by-zero behavior.\n\n```scheme\n(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `renyi-entropy` in `lattice/info/entropy.ss`.\nKnown issue: alpha=1 must dispatch to Shannon entropy to avoid division-by-zero behavior.\n\n```scheme\n(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (let ([p '(0.5 0.5)] [q '(0.7 0.2 0.1)]) (and (approx=? (entropy p) (renyi-entropy 1 p) 0.000001) (approx=? 1.0 (renyi-entropy 0 p) 0.000001) (approx=? 1.0 (renyi-entropy 2 p) 0.000001) (= (renyi-entropy -1 q) +inf.0))))", "tags": ["tier1", "info", "entropy", "bugfix", "renyi-entropy"], "split": "train"}
{"id": "info_entropy_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Compute entropy for a deterministic outcome '(1 0 0 0).", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute entropy for a deterministic outcome '(1 0 0 0).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(entropy '(1 0 0 0))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (entropy '(1 0 0 0)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "entropy", "edge-case"], "split": "train"}
{"id": "info_entropy_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Return whether entropy of a 4-way uniform distribution equals 2 bits.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether entropy of a 4-way uniform distribution equals 2 bits.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? 2.0 (entropy '(0.25 0.25 0.25 0.25)) 0.000001) #t))", "tags": ["tier1", "info", "entropy", "composition", "entropy", "property"], "split": "train"}
{"id": "info_entropy_composition_004", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy", "prompt_body": "Return whether Renyi entropy at alpha=1 matches entropy for '(0.6 0.4).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether Renyi entropy at alpha=1 matches entropy for '(0.6 0.4).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(approx=? (entropy '(0.6 0.4)) (renyi-entropy 1 '(0.6 0.4)) 0.000001)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? (entropy '(0.6 0.4)) (renyi-entropy 1 '(0.6 0.4)) 0.000001) #t))", "tags": ["tier1", "info", "entropy", "composition", "entropy", "integration"], "split": "train"}
{"id": "info_entropy_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Compute normalized entropy for weights '(2 2 2 2).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute normalized entropy for weights '(2 2 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(entropy-normalized '(2 2 2 2))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 2.0 (entropy-normalized '(2 2 2 2)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "entropy-normalized", "direct"], "split": "train"}
{"id": "info_entropy_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Return whether scaling all weights leaves entropy-normalized unchanged.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether scaling all weights leaves entropy-normalized unchanged.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(approx=? (entropy-normalized '(2 1 1)) (entropy-normalized '(20 10 10)) 0.000001)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? (entropy-normalized '(2 1 1)) (entropy-normalized '(20 10 10)) 0.000001) #t))", "tags": ["tier1", "info", "entropy", "composition", "entropy-normalized", "invariance"], "split": "train"}
{"id": "info_entropy_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Compute entropy-normalized for all-zero weights '(0 0 0).", "prompt": "Task mode: small integration task across module primitives.\n\nCompute entropy-normalized for all-zero weights '(0 0 0).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(entropy-normalized '(0 0 0))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (entropy-normalized '(0 0 0)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "entropy-normalized", "edge-case"], "split": "train"}
{"id": "info_entropy_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "entropy-normalized", "prompt_body": "Return whether entropy-normalized '(9 3) matches entropy of '(0.75 0.25).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether entropy-normalized '(9 3) matches entropy of '(0.75 0.25).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(approx=? (entropy-normalized '(9 3)) (entropy '(0.75 0.25)) 0.000001)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (entropy-normalized weights)\n  (let* ([total (fold-left + 0 weights)]\n         [probs (if (= total 0)\n                    weights\n                    (map (lambda (w) (/ w total)) weights))])\n        (entropy probs)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? (entropy-normalized '(9 3)) (entropy '(0.75 0.25)) 0.000001) #t))", "tags": ["tier1", "info", "entropy", "composition", "entropy-normalized", "integration"], "split": "train"}
{"id": "info_entropy_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Return whether binary entropy is symmetric around 0.5 for p=0.2.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether binary entropy is symmetric around 0.5 for p=0.2.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(approx=? (binary-entropy 0.2) (binary-entropy 0.8) 0.000001)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? (binary-entropy 0.2) (binary-entropy 0.8) 0.000001) #t))", "tags": ["tier1", "info", "entropy", "composition", "binary-entropy", "property"], "split": "train"}
{"id": "info_entropy_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Return whether H(0.5) is at least H(0.3).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether H(0.5) is at least H(0.3).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(>= (binary-entropy 0.5) (binary-entropy 0.3))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))\n  (equal? (>= (binary-entropy 0.5) (binary-entropy 0.3)) #t))", "tags": ["tier1", "info", "entropy", "composition", "binary-entropy", "ordering"], "split": "train"}
{"id": "info_entropy_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "binary-entropy", "prompt_body": "Return the pair (H(0) H(1)).", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn the pair (H(0) H(1)).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (binary-entropy 0) (binary-entropy 1))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (binary-entropy p)\n  (cond\n   [(<= p 0) 0]\n   [(>= p 1) 0]\n   [else (- (+ (plogp p) (plogp (- 1 p))))]))\n  (equal? (list (binary-entropy 0) (binary-entropy 1)) '(0 0)))", "tags": ["tier1", "info", "entropy", "composition", "binary-entropy", "edge-case"], "split": "train"}
{"id": "info_entropy_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Compute I(X;Y) for independent fair binary variables.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute I(X;Y) for independent fair binary variables.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mutual-information '((0.25 0.25) (0.25 0.25)) '(0.5 0.5) '(0.5 0.5))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (mutual-information '((0.25 0.25) (0.25 0.25)) '(0.5 0.5) '(0.5 0.5)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "mutual-information", "direct"], "split": "train"}
{"id": "info_entropy_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Compute I(X;Y) when X=Y for a fair binary source.", "prompt": "Task mode: small integration task across module primitives.\n\nCompute I(X;Y) when X=Y for a fair binary source.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(mutual-information '((0.5 0) (0 0.5)) '(0.5 0.5) '(0.5 0.5))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (mutual-information '((0.5 0) (0 0.5)) '(0.5 0.5) '(0.5 0.5)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "mutual-information", "direct"], "split": "train"}
{"id": "info_entropy_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Return whether mutual information is non-negative on a valid 2x2 joint distribution.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether mutual information is non-negative on a valid 2x2 joint distribution.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(>= (mutual-information '((0.4 0.1) (0.1 0.4)) '(0.5 0.5) '(0.5 0.5)) 0)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))\n  (equal? (>= (mutual-information '((0.4 0.1) (0.1 0.4)) '(0.5 0.5) '(0.5 0.5)) 0) #t))", "tags": ["tier1", "info", "entropy", "composition", "mutual-information", "property"], "split": "train"}
{"id": "info_entropy_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "mutual-information", "prompt_body": "Return whether I(X;Y) equals H(X) under perfect correlation for fair binary marginals.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether I(X;Y) equals H(X) under perfect correlation for fair binary marginals.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(approx=? (mutual-information '((0.5 0) (0 0.5)) '(0.5 0.5) '(0.5 0.5)) (entropy '(0.5 0.5)) 0.000001)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (joint-entropy joint-probs)\n  (let ([flat (flatten joint-probs)])\n       (entropy flat)))\n  (define (mutual-information joint-probs marginal-x marginal-y)\n  (let ([h-x (entropy marginal-x)]\n        [h-y (entropy marginal-y)]\n        [h-joint (joint-entropy joint-probs)])\n       (+ h-x (- h-y h-joint))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? (mutual-information '((0.5 0) (0 0.5)) '(0.5 0.5) '(0.5 0.5)) (entropy '(0.5 0.5)) 0.000001) #t))", "tags": ["tier1", "info", "entropy", "composition", "mutual-information", "integration"], "split": "train"}
{"id": "info_entropy_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Compute cross-entropy under support mismatch where Q has a zero-probability event with positive mass in P.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute cross-entropy under support mismatch where Q has a zero-probability event with positive mass in P.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(cross-entropy '(0.5 0.5) '(1.0 0.0))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))\n  (equal? (cross-entropy '(0.5 0.5) '(1.0 0.0)) +inf.0))", "tags": ["tier1", "info", "entropy", "composition", "cross-entropy", "edge-case"], "split": "train"}
{"id": "info_entropy_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Compute cross-entropy for empty distributions.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute cross-entropy for empty distributions.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(cross-entropy '() '())", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (cross-entropy '() '()) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "cross-entropy", "edge-case"], "split": "train"}
{"id": "info_entropy_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "cross-entropy", "prompt_body": "Return whether H(P,Q) is at least H(P) for P='(0.8 0.2) and Q='(0.5 0.5).", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether H(P,Q) is at least H(P) for P='(0.8 0.2) and Q='(0.5 0.5).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([p '(0.8 0.2)] [q '(0.5 0.5)]) (>= (cross-entropy p q) (entropy p)))", "verify_expr": "(let ()\n  (define (any2 pred xs ys)\n  (cond\n   [(null? xs) #f]\n   [(null? ys) #f]\n   [(pred (car xs) (car ys)) #t]\n   [else (any2 pred (cdr xs) (cdr ys))]))\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (cross-entropy p q)\n  (if (null? p)\n      0\n      (if (any2 (lambda (pi qi) (and (> pi 0) (<= qi 0))) p q)\n          +inf.0\n          (- (fold-left + 0\n                        (map (lambda (pi qi)\n                                     (if (<= pi 0)\n                                         0\n                                         (* pi (entropy-log2 qi))))\n                             p q))))))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (equal? (let ([p '(0.8 0.2)] [q '(0.5 0.5)]) (>= (cross-entropy p q) (entropy p))) #t))", "tags": ["tier1", "info", "entropy", "composition", "cross-entropy", "property"], "split": "train"}
{"id": "info_entropy_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Compute D_KL(P||P) for P='(0.5 0.5).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute D_KL(P||P) for P='(0.5 0.5).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kl-divergence '(0.5 0.5) '(0.5 0.5))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (kl-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "kl-divergence", "direct"], "split": "train"}
{"id": "info_entropy_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Return whether KL divergence is asymmetric for P='(0.9 0.1) and Q='(0.5 0.5).", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether KL divergence is asymmetric for P='(0.9 0.1) and Q='(0.5 0.5).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d1 (kl-divergence '(0.9 0.1) '(0.5 0.5))] [d2 (kl-divergence '(0.5 0.5) '(0.9 0.1))]) (not (approx=? d1 d2 0.000001)))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([d1 (kl-divergence '(0.9 0.1) '(0.5 0.5))] [d2 (kl-divergence '(0.5 0.5) '(0.9 0.1))]) (not (approx=? d1 d2 0.000001))) #t))", "tags": ["tier1", "info", "entropy", "composition", "kl-divergence", "property"], "split": "train"}
{"id": "info_entropy_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "kl-divergence", "prompt_body": "Compute KL divergence under support mismatch where Q has a zero-probability event used by P.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute KL divergence under support mismatch where Q has a zero-probability event used by P.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(kl-divergence '(0.5 0.5) '(1.0 0.0))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (equal? (kl-divergence '(0.5 0.5) '(1.0 0.0)) +inf.0))", "tags": ["tier1", "info", "entropy", "composition", "kl-divergence", "edge-case"], "split": "train"}
{"id": "info_entropy_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Compute JSD(P,P) for P='(0.5 0.5).", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute JSD(P,P) for P='(0.5 0.5).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 0.0 (jensen-shannon-divergence '(0.5 0.5) '(0.5 0.5)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "jensen-shannon-divergence", "direct"], "split": "train"}
{"id": "info_entropy_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Return whether Jensen-Shannon divergence is symmetric for P='(0.9 0.1), Q='(0.5 0.5).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether Jensen-Shannon divergence is symmetric for P='(0.9 0.1), Q='(0.5 0.5).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([d1 (jensen-shannon-divergence '(0.9 0.1) '(0.5 0.5))] [d2 (jensen-shannon-divergence '(0.5 0.5) '(0.9 0.1))]) (approx=? d1 d2 0.000001))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([d1 (jensen-shannon-divergence '(0.9 0.1) '(0.5 0.5))] [d2 (jensen-shannon-divergence '(0.5 0.5) '(0.9 0.1))]) (approx=? d1 d2 0.000001)) #t))", "tags": ["tier1", "info", "entropy", "composition", "jensen-shannon-divergence", "property"], "split": "train"}
{"id": "info_entropy_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Compute JSD between opposite deterministic binary distributions.", "prompt": "Task mode: small integration task across module primitives.\n\nCompute JSD between opposite deterministic binary distributions.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(jensen-shannon-divergence '(1 0) '(0 1))", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (jensen-shannon-divergence '(1 0) '(0 1)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "jensen-shannon-divergence", "boundary"], "split": "train"}
{"id": "info_entropy_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "jensen-shannon-divergence", "prompt_body": "Return whether JSD is non-negative for P='(0.7 0.3), Q='(0.4 0.6).", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether JSD is non-negative for P='(0.7 0.3), Q='(0.4 0.6).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(>= (jensen-shannon-divergence '(0.7 0.3) '(0.4 0.6)) 0)", "verify_expr": "(let ()\n  (define (kl-divergence p q)\n  (if (null? p)\n      0\n      (fold-left + 0\n                 (map (lambda (pi qi)\n                              (cond\n                               [(<= pi 0) 0]\n                               [(<= qi 0) +inf.0]\n                               [else (* pi (log2 (/ pi qi)))]))\n                      p q))))\n  (define (jensen-shannon-divergence p q)\n  (let ([m (map (lambda (pi qi) (/ (+ pi qi) 2)) p q)])\n       (/ (+ (kl-divergence p m) (kl-divergence q m)) 2)))\n  (equal? (>= (jensen-shannon-divergence '(0.7 0.3) '(0.4 0.6)) 0) #t))", "tags": ["tier1", "info", "entropy", "composition", "jensen-shannon-divergence", "property"], "split": "train"}
{"id": "info_entropy_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Compute Renyi entropy of order 0 for '(0.5 0.5).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute Renyi entropy of order 0 for '(0.5 0.5).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(renyi-entropy 0 '(0.5 0.5))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (renyi-entropy 0 '(0.5 0.5)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "renyi-entropy", "direct"], "split": "train"}
{"id": "info_entropy_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Return whether Renyi entropy at alpha=1 equals Shannon entropy for '(0.7 0.3).", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether Renyi entropy at alpha=1 equals Shannon entropy for '(0.7 0.3).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(approx=? (renyi-entropy 1 '(0.7 0.3)) (entropy '(0.7 0.3)) 0.000001)", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (approx=? (renyi-entropy 1 '(0.7 0.3)) (entropy '(0.7 0.3)) 0.000001) #t))", "tags": ["tier1", "info", "entropy", "composition", "renyi-entropy", "integration"], "split": "train"}
{"id": "info_entropy_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/entropy.ss", "source_test": "lattice/info/test-entropy.ss", "source_function": "renyi-entropy", "prompt_body": "Compute Renyi entropy of order 2 for '(0.5 0.5).", "prompt": "Task mode: small integration task across module primitives.\n\nCompute Renyi entropy of order 2 for '(0.5 0.5).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(renyi-entropy 2 '(0.5 0.5))", "verify_expr": "(let ()\n  (define (entropy-log2 x)\n  (if (<= x 0)\n      0\n      (log2 x)))\n  (define (plogp p)\n  (if (<= p 0)\n      0\n      (* p (entropy-log2 p))))\n  (define (entropy probs)\n  (- (fold-left + 0 (map plogp probs))))\n  (define (renyi-entropy alpha probs)\n  (cond\n   [(< alpha 0) +inf.0]\n   [(= alpha 1) (entropy probs)]\n   [(= alpha 0) (log2 (length (filter (lambda (p) (> p 0)) probs)))]\n   [else\n    (let ([sum-p-alpha (fold-left + 0 (map (lambda (p) (expt p alpha)) probs))])\n         (* (/ 1 (- 1 alpha)) (log2 sum-p-alpha)))]))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (renyi-entropy 2 '(0.5 0.5)) 0.000001))", "tags": ["tier1", "info", "entropy", "composition", "renyi-entropy", "direct"], "split": "train"}
