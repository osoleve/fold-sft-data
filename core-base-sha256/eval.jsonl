{"id": "core_sha256_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "sha256", "prompt_body": "You are implementing SHA-256 utilities in Fold-native Scheme.\n\nTarget module: core/base/sha256.ss\nFunction: `sha256`\nSpec: Compute 32-byte SHA-256 digest bytevector.\n\nWrite exactly one Scheme definition for `sha256`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing SHA-256 utilities in Fold-native Scheme.\n\nTarget module: core/base/sha256.ss\nFunction: `sha256`\nSpec: Compute 32-byte SHA-256 digest bytevector.\n\nWrite exactly one Scheme definition for `sha256`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sha256 msg)\n  (let* ([padded (pad-message msg)]\n         [num-blocks (quotient (bytevector-length padded) 64)]\n         [H (fxvector-copy H-init)])\n        (do ([i 0 (fx+ i 1)])\n            ((fx= i num-blocks))\n            (let ([W (make-schedule padded (fx* i 64))])\n                 (set! H (compress H W))))\n        (let ([result (make-bytevector 32)])\n             (do ([i 0 (fx+ i 1)])\n                 ((fx= i 8))\n                 (bytevector-u32-set! result (fx* i 4) (fxvector-ref H i) 'big))\n             result)))", "verify_expr": "(let ()\n  (define (pad-message msg)\n  (let* ([len (bytevector-length msg)]\n         [bit-len (* 8 len)]\n         [padded-len (let ([rem (modulo (+ len 9) 64)])\n                          (if (= rem 0)\n                              (+ len 9)\n                              (+ len 9 (- 64 rem))))]\n         [result (make-bytevector padded-len 0)])\n        (bytevector-copy! msg 0 result 0 len)\n        (bytevector-u8-set! result len #x80)\n        (bytevector-u64-set! result (- padded-len 8) bit-len 'big)\n        result))\n  (define-syntax u32+\n  (syntax-rules ()\n    [(_ . args) (fxand (fx+ . args) #xFFFFFFFF)]))\n  (define-syntax rotr32\n  (syntax-rules ()\n    [(_ x n)\n     (fxior (fxarithmetic-shift-right x n)\n            (fxarithmetic-shift-left (fxand x (fx- (fxarithmetic-shift-left 1 n) 1))\n                                     (fx- 32 n)))]))\n  (define-syntax shr\n  (syntax-rules ()\n    [(_ x n) (fxarithmetic-shift-right x n)]))\n  (define-syntax sigma0\n  (syntax-rules ()\n    [(_ x) (fxxor (rotr32 x 7)\n                  (fxxor (rotr32 x 18)\n                         (shr x 3)))]))\n  (define-syntax sigma1\n  (syntax-rules ()\n    [(_ x) (fxxor (rotr32 x 17)\n                  (fxxor (rotr32 x 19)\n                         (shr x 10)))]))\n  (define (make-schedule msg offset)\n  (let ([W (make-fxvector 64)])\n       (do ([i 0 (fx+ i 1)])\n           ((fx= i 16))\n           (fxvector-set! W i (bytevector-u32-ref msg (fx+ offset (fx* i 4)) 'big)))\n       (do ([i 16 (fx+ i 1)])\n           ((fx= i 64))\n           (fxvector-set! W i\n                        (u32+ (sigma1 (fxvector-ref W (fx- i 2)))\n                              (fxvector-ref W (fx- i 7))\n                              (sigma0 (fxvector-ref W (fx- i 15)))\n                              (fxvector-ref W (fx- i 16)))))\n       W))\n  (define-syntax Sigma1\n  (syntax-rules ()\n    [(_ x) (fxxor (rotr32 x 6)\n                  (fxxor (rotr32 x 11)\n                         (rotr32 x 25)))]))\n  (define-syntax Ch\n  (syntax-rules ()\n    [(_ x y z) (fxxor (fxand x y)\n                      (fxand (fxnot x) z))]))\n  (define-syntax Sigma0\n  (syntax-rules ()\n    [(_ x) (fxxor (rotr32 x 2)\n                  (fxxor (rotr32 x 13)\n                         (rotr32 x 22)))]))\n  (define-syntax Maj\n  (syntax-rules ()\n    [(_ x y z) (fxxor (fxand x y)\n                      (fxxor (fxand x z)\n                             (fxand y z)))]))\n  (define K\n  (fxvector #x428a2f98 #x71374491 #xb5c0fbcf #xe9b5dba5\n            #x3956c25b #x59f111f1 #x923f82a4 #xab1c5ed5\n            #xd807aa98 #x12835b01 #x243185be #x550c7dc3\n            #x72be5d74 #x80deb1fe #x9bdc06a7 #xc19bf174\n            #xe49b69c1 #xefbe4786 #x0fc19dc6 #x240ca1cc\n            #x2de92c6f #x4a7484aa #x5cb0a9dc #x76f988da\n            #x983e5152 #xa831c66d #xb00327c8 #xbf597fc7\n            #xc6e00bf3 #xd5a79147 #x06ca6351 #x14292967\n            #x27b70a85 #x2e1b2138 #x4d2c6dfc #x53380d13\n            #x650a7354 #x766a0abb #x81c2c92e #x92722c85\n            #xa2bfe8a1 #xa81a664b #xc24b8b70 #xc76c51a3\n            #xd192e819 #xd6990624 #xf40e3585 #x106aa070\n            #x19a4c116 #x1e376c08 #x2748774c #x34b0bcb5\n            #x391c0cb3 #x4ed8aa4a #x5b9cca4f #x682e6ff3\n            #x748f82ee #x78a5636f #x84c87814 #x8cc70208\n            #x90befffa #xa4506ceb #xbef9a3f7 #xc67178f2))\n  (define (compress H W)\n  (let ([a (fxvector-ref H 0)]\n        [b (fxvector-ref H 1)]\n        [c (fxvector-ref H 2)]\n        [d (fxvector-ref H 3)]\n        [e (fxvector-ref H 4)]\n        [f (fxvector-ref H 5)]\n        [g (fxvector-ref H 6)]\n        [h (fxvector-ref H 7)])\n       (do ([i 0 (fx+ i 1)])\n           ((fx= i 64))\n           (let* ([T1 (u32+ h (Sigma1 e) (Ch e f g)\n                            (fxvector-ref K i) (fxvector-ref W i))]\n                  [T2 (u32+ (Sigma0 a) (Maj a b c))])\n                 (set! h g)\n                 (set! g f)\n                 (set! f e)\n                 (set! e (u32+ d T1))\n                 (set! d c)\n                 (set! c b)\n                 (set! b a)\n                 (set! a (u32+ T1 T2))))\n       (fxvector (u32+ (fxvector-ref H 0) a)\n                 (u32+ (fxvector-ref H 1) b)\n                 (u32+ (fxvector-ref H 2) c)\n                 (u32+ (fxvector-ref H 3) d)\n                 (u32+ (fxvector-ref H 4) e)\n                 (u32+ (fxvector-ref H 5) f)\n                 (u32+ (fxvector-ref H 6) g)\n                 (u32+ (fxvector-ref H 7) h))))\n  (define H-init\n  (fxvector #x6a09e667 #xbb67ae85 #x3c6ef372 #xa54ff53a\n            #x510e527f #x9b05688c #x1f83d9ab #x5be0cd19))\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n       (if (= i n)\n           (reverse acc)\n           (loop (+ i 1) (cons i acc)))))\n  (define (hash->hex hash)\n  (let ([hex-chars \"0123456789abcdef\"])\n       (apply string-append\n              (map (lambda (i)\n                           (let ([b (bytevector-u8-ref hash i)])\n                                (string\n                                 (string-ref hex-chars (quotient b 16))\n                                 (string-ref hex-chars (modulo b 16)))))\n                   (iota (bytevector-length hash))))))\n  (define (sha256 msg)\n  (let* ([padded (pad-message msg)]\n         [num-blocks (quotient (bytevector-length padded) 64)]\n         [H (fxvector-copy H-init)])\n        (do ([i 0 (fx+ i 1)])\n            ((fx= i num-blocks))\n            (let ([W (make-schedule padded (fx* i 64))])\n                 (set! H (compress H W))))\n        (let ([result (make-bytevector 32)])\n             (do ([i 0 (fx+ i 1)])\n                 ((fx= i 8))\n                 (bytevector-u32-set! result (fx* i 4) (fxvector-ref H i) 'big))\n             result)))\n  (let* ([h1 (sha256 (string->utf8 \"abc\"))] [h2 (sha256 (string->utf8 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"))]) (and (= (bytevector-length h1) 32) (= (bytevector-u8-ref h1 0) #xba) (= (bytevector-u8-ref h1 31) #xad) (equal? (hash->hex h2) \"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\"))))", "tags": ["core", "base", "sha256", "spec-to-code", "sha256"], "split": "eval"}
{"id": "core_sha256_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "hash->hex", "prompt_body": "You are implementing SHA-256 utilities in Fold-native Scheme.\n\nTarget module: core/base/sha256.ss\nFunction: `hash->hex`\nSpec: Convert digest bytevector to lowercase hex string.\n\nWrite exactly one Scheme definition for `hash->hex`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing SHA-256 utilities in Fold-native Scheme.\n\nTarget module: core/base/sha256.ss\nFunction: `hash->hex`\nSpec: Convert digest bytevector to lowercase hex string.\n\nWrite exactly one Scheme definition for `hash->hex`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (hash->hex (bytevector #x00 #x01 #xfe #xff)) \"0001feff\"))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (hash->hex hash)\n  (let ([hex-chars \"0123456789abcdef\"])\n       (apply string-append\n              (map (lambda (i)\n                           (let ([b (bytevector-u8-ref hash i)])\n                                (string\n                                 (string-ref hex-chars (quotient b 16))\n                                 (string-ref hex-chars (modulo b 16)))))\n                   (iota (bytevector-length hash))))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n       (if (= i n)\n           (reverse acc)\n           (loop (+ i 1) (cons i acc)))))\n  (define (hash->hex hash)\n  (let ([hex-chars \"0123456789abcdef\"])\n       (apply string-append\n              (map (lambda (i)\n                           (let ([b (bytevector-u8-ref hash i)])\n                                (string\n                                 (string-ref hex-chars (quotient b 16))\n                                 (string-ref hex-chars (modulo b 16)))))\n                   (iota (bytevector-length hash))))))\n  (equal? (hash->hex (bytevector #x00 #x01 #xfe #xff)) \"0001feff\"))", "tags": ["core", "base", "sha256", "spec-to-code", "hash->hex"], "split": "eval"}
{"id": "core_sha256_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "hex->hash", "prompt_body": "You are implementing SHA-256 utilities in Fold-native Scheme.\n\nTarget module: core/base/sha256.ss\nFunction: `hex->hash`\nSpec: Convert even-length hex string to bytevector.\n\nWrite exactly one Scheme definition for `hex->hash`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing SHA-256 utilities in Fold-native Scheme.\n\nTarget module: core/base/sha256.ss\nFunction: `hex->hash`\nSpec: Convert even-length hex string to bytevector.\n\nWrite exactly one Scheme definition for `hex->hash`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (hex->hash hex)\n  (let* ([len (string-length hex)]\n         [result (make-bytevector (quotient len 2))])\n        (do ([i 0 (+ i 2)])\n            ((>= i len))\n            (bytevector-u8-set! result\n                                (quotient i 2)\n                                (+ (* 16 (hex-digit (string-ref hex i)))\n                                   (hex-digit (string-ref hex (+ i 1))))))\n        result))", "verify_expr": "(let ()\n  (define (hex-digit c)\n  (cond\n   [(char<=? #\\0 c #\\9) (- (char->integer c) (char->integer #\\0))]\n   [(char<=? #\\a c #\\f) (+ 10 (- (char->integer c) (char->integer #\\a)))]\n   [(char<=? #\\A c #\\F) (+ 10 (- (char->integer c) (char->integer #\\A)))]\n   [else 0]))\n  (define (hex->hash hex)\n  (let* ([len (string-length hex)]\n         [result (make-bytevector (quotient len 2))])\n        (do ([i 0 (+ i 2)])\n            ((>= i len))\n            (bytevector-u8-set! result\n                                (quotient i 2)\n                                (+ (* 16 (hex-digit (string-ref hex i)))\n                                   (hex-digit (string-ref hex (+ i 1))))))\n        result))\n  (let ([b (hex->hash \"0001feff\")]) (and (= (bytevector-length b) 4) (= (bytevector-u8-ref b 0) 0) (= (bytevector-u8-ref b 1) 1) (= (bytevector-u8-ref b 2) 254) (= (bytevector-u8-ref b 3) 255))))", "tags": ["core", "base", "sha256", "spec-to-code", "hex->hash"], "split": "eval"}
{"id": "core_sha256_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "pad-message", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `pad-message`.\nReturn only the Scheme definition.\n\n```python\ndef pad_message(msg: bytes) -> bytes:\n    bit_len = len(msg) * 8\n    padded = bytearray(msg)\n    padded.append(0x80)\n    while (len(padded) + 8) % 64 != 0:\n        padded.append(0)\n    padded.extend(bit_len.to_bytes(8, 'big'))\n    return bytes(padded)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `pad-message`.\nReturn only the Scheme definition.\n\n```python\ndef pad_message(msg: bytes) -> bytes:\n    bit_len = len(msg) * 8\n    padded = bytearray(msg)\n    padded.append(0x80)\n    while (len(padded) + 8) % 64 != 0:\n        padded.append(0)\n    padded.extend(bit_len.to_bytes(8, 'big'))\n    return bytes(padded)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (pad-message msg)\n  (let* ([len (bytevector-length msg)]\n         [bit-len (* 8 len)]\n         [padded-len (let ([rem (modulo (+ len 9) 64)])\n                          (if (= rem 0)\n                              (+ len 9)\n                              (+ len 9 (- 64 rem))))]\n         [result (make-bytevector padded-len 0)])\n        (bytevector-copy! msg 0 result 0 len)\n        (bytevector-u8-set! result len #x80)\n        (bytevector-u64-set! result (- padded-len 8) bit-len 'big)\n        result))", "verify_expr": "(let ()\n  (define (pad-message msg)\n  (let* ([len (bytevector-length msg)]\n         [bit-len (* 8 len)]\n         [padded-len (let ([rem (modulo (+ len 9) 64)])\n                          (if (= rem 0)\n                              (+ len 9)\n                              (+ len 9 (- 64 rem))))]\n         [result (make-bytevector padded-len 0)])\n        (bytevector-copy! msg 0 result 0 len)\n        (bytevector-u8-set! result len #x80)\n        (bytevector-u64-set! result (- padded-len 8) bit-len 'big)\n        result))\n  (let* ([m (string->utf8 \"abc\")] [p (pad-message m)]) (and (= (bytevector-length p) 64) (= (bytevector-u8-ref p 0) 97) (= (bytevector-u8-ref p 1) 98) (= (bytevector-u8-ref p 2) 99) (= (bytevector-u8-ref p 3) #x80) (= (bytevector-u64-ref p 56 'big) 24))))", "tags": ["core", "base", "sha256", "python-to-scheme", "pad-message"], "split": "eval"}
{"id": "core_sha256_translation_003", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "make-schedule", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `make-schedule`.\nReturn only the Scheme definition.\n\n```python\ndef make_schedule(msg: bytes, offset: int):\n    W = [0] * 64\n    for i in range(16):\n        W[i] = int.from_bytes(msg[offset + 4*i:offset + 4*i + 4], 'big')\n    for i in range(16, 64):\n        W[i] = (sigma1(W[i-2]) + W[i-7] + sigma0(W[i-15]) + W[i-16]) & 0xffffffff\n    return W\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `make-schedule`.\nReturn only the Scheme definition.\n\n```python\ndef make_schedule(msg: bytes, offset: int):\n    W = [0] * 64\n    for i in range(16):\n        W[i] = int.from_bytes(msg[offset + 4*i:offset + 4*i + 4], 'big')\n    for i in range(16, 64):\n        W[i] = (sigma1(W[i-2]) + W[i-7] + sigma0(W[i-15]) + W[i-16]) & 0xffffffff\n    return W\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p (pad-message (string->utf8 \"abc\"))] [w (make-schedule p 0)]) (and (= (fxvector-length w) 64) (= (fxvector-ref w 0) #x61626380) (= (fxvector-ref w 15) 24) (= (fxvector-ref w 16) #x61626380))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-schedule msg offset)\n  (let ([W (make-fxvector 64)])\n       (do ([i 0 (fx+ i 1)])\n           ((fx= i 16))\n           (fxvector-set! W i (bytevector-u32-ref msg (fx+ offset (fx* i 4)) 'big)))\n       (do ([i 16 (fx+ i 1)])\n           ((fx= i 64))\n           (fxvector-set! W i\n                        (u32+ (sigma1 (fxvector-ref W (fx- i 2)))\n                              (fxvector-ref W (fx- i 7))\n                              (sigma0 (fxvector-ref W (fx- i 15)))\n                              (fxvector-ref W (fx- i 16)))))\n       W))", "verify_expr": "(let ()\n  (define-syntax u32+\n  (syntax-rules ()\n    [(_ . args) (fxand (fx+ . args) #xFFFFFFFF)]))\n  (define-syntax rotr32\n  (syntax-rules ()\n    [(_ x n)\n     (fxior (fxarithmetic-shift-right x n)\n            (fxarithmetic-shift-left (fxand x (fx- (fxarithmetic-shift-left 1 n) 1))\n                                     (fx- 32 n)))]))\n  (define-syntax shr\n  (syntax-rules ()\n    [(_ x n) (fxarithmetic-shift-right x n)]))\n  (define-syntax sigma0\n  (syntax-rules ()\n    [(_ x) (fxxor (rotr32 x 7)\n                  (fxxor (rotr32 x 18)\n                         (shr x 3)))]))\n  (define-syntax sigma1\n  (syntax-rules ()\n    [(_ x) (fxxor (rotr32 x 17)\n                  (fxxor (rotr32 x 19)\n                         (shr x 10)))]))\n  (define (pad-message msg)\n  (let* ([len (bytevector-length msg)]\n         [bit-len (* 8 len)]\n         [padded-len (let ([rem (modulo (+ len 9) 64)])\n                          (if (= rem 0)\n                              (+ len 9)\n                              (+ len 9 (- 64 rem))))]\n         [result (make-bytevector padded-len 0)])\n        (bytevector-copy! msg 0 result 0 len)\n        (bytevector-u8-set! result len #x80)\n        (bytevector-u64-set! result (- padded-len 8) bit-len 'big)\n        result))\n  (define (make-schedule msg offset)\n  (let ([W (make-fxvector 64)])\n       (do ([i 0 (fx+ i 1)])\n           ((fx= i 16))\n           (fxvector-set! W i (bytevector-u32-ref msg (fx+ offset (fx* i 4)) 'big)))\n       (do ([i 16 (fx+ i 1)])\n           ((fx= i 64))\n           (fxvector-set! W i\n                        (u32+ (sigma1 (fxvector-ref W (fx- i 2)))\n                              (fxvector-ref W (fx- i 7))\n                              (sigma0 (fxvector-ref W (fx- i 15)))\n                              (fxvector-ref W (fx- i 16)))))\n       W))\n  (let* ([p (pad-message (string->utf8 \"abc\"))] [w (make-schedule p 0)]) (and (= (fxvector-length w) 64) (= (fxvector-ref w 0) #x61626380) (= (fxvector-ref w 15) 24) (= (fxvector-ref w 16) #x61626380))))", "tags": ["core", "base", "sha256", "python-to-scheme", "make-schedule"], "split": "eval"}
{"id": "core_sha256_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "iota", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iota` in `core/base/sha256.ss`.\nKnown issue: Sequence must start at 0 and end at n-1.\n\n```scheme\n(define (iota n)\n  (let loop ([i 1] [acc '()])\n       (if (> i n)\n           (reverse acc)\n           (loop (+ i 1) (cons i acc)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iota` in `core/base/sha256.ss`.\nKnown issue: Sequence must start at 0 and end at n-1.\n\n```scheme\n(define (iota n)\n  (let loop ([i 1] [acc '()])\n       (if (> i n)\n           (reverse acc)\n           (loop (+ i 1) (cons i acc)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Sequence must start at 0 and end at n-1.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (iota 0) '()))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (iota 0) '()))\n(let () (equal? (iota 5) '(0 1 2 3 4)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (iota n)\n  (let loop ([i 0] [acc '()])\n       (if (= i n)\n           (reverse acc)\n           (loop (+ i 1) (cons i acc)))))", "verify_expr": "(let ()\n  (define (iota n)\n  (let loop ([i 0] [acc '()])\n       (if (= i n)\n           (reverse acc)\n           (loop (+ i 1) (cons i acc)))))\n  (and (equal? (iota 0) '()) (equal? (iota 5) '(0 1 2 3 4))))", "tags": ["core", "base", "sha256", "bugfix", "iota"], "split": "eval"}
{"id": "core_sha256_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "hex-digit", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hex-digit` in `core/base/sha256.ss`.\nKnown issue: Must support both lowercase and uppercase A-F.\n\n```scheme\n(define (hex-digit c)\n  (if (char<=? #\\0 c #\\9) (- (char->integer c) (char->integer #\\0)) 0))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `hex-digit` in `core/base/sha256.ss`.\nKnown issue: Must support both lowercase and uppercase A-F.\n\n```scheme\n(define (hex-digit c)\n  (if (char<=? #\\0 c #\\9) (- (char->integer c) (char->integer #\\0)) 0))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (hex-digit #\\0) 0))\n(let () (= (hex-digit #\\9) 9))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (hex-digit c)\n  (cond\n   [(char<=? #\\0 c #\\9) (- (char->integer c) (char->integer #\\0))]\n   [(char<=? #\\a c #\\f) (+ 10 (- (char->integer c) (char->integer #\\a)))]\n   [(char<=? #\\A c #\\F) (+ 10 (- (char->integer c) (char->integer #\\A)))]\n   [else 0]))", "verify_expr": "(let ()\n  (define (hex-digit c)\n  (cond\n   [(char<=? #\\0 c #\\9) (- (char->integer c) (char->integer #\\0))]\n   [(char<=? #\\a c #\\f) (+ 10 (- (char->integer c) (char->integer #\\a)))]\n   [(char<=? #\\A c #\\F) (+ 10 (- (char->integer c) (char->integer #\\A)))]\n   [else 0]))\n  (and (= (hex-digit #\\0) 0) (= (hex-digit #\\9) 9) (= (hex-digit #\\a) 10) (= (hex-digit #\\f) 15) (= (hex-digit #\\A) 10) (= (hex-digit #\\F) 15) (= (hex-digit #\\x) 0)))", "tags": ["core", "base", "sha256", "bugfix", "hex-digit"], "split": "eval"}
{"id": "core_sha256_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "iota", "prompt_body": "Generate iota for 6.", "prompt": "Task mode: compose existing APIs into one expression.\n\nGenerate iota for 6.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(iota 6)", "verify_expr": "(equal? (iota 6) '(0 1 2 3 4 5))", "tags": ["core", "base", "sha256", "composition", "iota", "direct"], "split": "eval"}
{"id": "core_sha256_composition_007", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "compress", "prompt_body": "Compute first state word after compressing empty block.", "prompt": "Task mode: small integration task across module primitives.\n\nCompute first state word after compressing empty block.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(fxvector-ref (compress H-init (make-schedule (pad-message (string->utf8 \"\")) 0)) 0)", "verify_expr": "(equal? (fxvector-ref (compress H-init (make-schedule (pad-message (string->utf8 \"\")) 0)) 0) #xe3b0c442)", "tags": ["core", "base", "sha256", "composition", "compress", "direct"], "split": "eval"}
{"id": "core_sha256_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "sha256-hex", "prompt_body": "Hash the 448-bit NIST vector in hex.", "prompt": "Task mode: small integration task across module primitives.\n\nHash the 448-bit NIST vector in hex.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(sha256-hex (string->utf8 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"))", "verify_expr": "(equal? (sha256-hex (string->utf8 \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\")) \"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\")", "tags": ["core", "base", "sha256", "composition", "sha256-hex", "direct"], "split": "eval"}
{"id": "core_sha256_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/sha256.ss", "source_test": "core/base/test-sha256.ss", "source_function": "hex-digit", "prompt_body": "Decode invalid hex digit x as 0.", "prompt": "Task mode: small integration task across module primitives.\n\nDecode invalid hex digit x as 0.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(hex-digit #\\x)", "verify_expr": "(equal? (hex-digit #\\x) 0)", "tags": ["core", "base", "sha256", "composition", "hex-digit", "edge-case"], "split": "eval"}
