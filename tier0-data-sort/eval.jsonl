{"id": "sort_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `partition`\nSpec: Partition lst around pivot into (lt eq gt) buckets according to cmp.\n\nWrite exactly one Scheme function definition for `partition`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))", "tags": ["tier0", "data", "sort", "spec-to-code", "partition"], "split": "eval"}
{"id": "sort_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `insert-sorted`\nSpec: Insert x into a sorted list while preserving order.\n\nWrite exactly one Scheme function definition for `insert-sorted`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (and (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)) (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3))))", "tags": ["tier0", "data", "sort", "spec-to-code", "insert-sorted"], "split": "eval"}
{"id": "sort_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `insertion-sort-by`\nSpec: Sort lst by repeatedly inserting elements with comparator cmp.\n\nWrite exactly one Scheme function definition for `insertion-sort-by`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9))\n(equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))\n  (and (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "spec-to-code", "insertion-sort-by"], "split": "eval"}
{"id": "sort_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `merge`.\nReturn only the Scheme definition.\n\n```python\ndef merge(xs, ys, cmp):\n    if not xs:\n        return ys\n    if not ys:\n        return xs\n    if not cmp(ys[0], xs[0]):\n        return [xs[0]] + merge(xs[1:], ys, cmp)\n    return [ys[0]] + merge(xs, ys[1:], cmp)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))", "verify_expr": "(let ()\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "merge"], "split": "eval"}
{"id": "sort_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `split-at`.\nReturn only the Scheme definition.\n\n```python\ndef split_at(lst, n):\n    if n == 0 or not lst:\n        return ([], lst)\n    left, right = split_at(lst[1:], n - 1)\n    return ([lst[0]] + left, right)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (and (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))) (equal? (split-at '(1 2) 5) (cons '(1 2) '()))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "split-at"], "split": "eval"}
{"id": "sort_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `quicksort-by`.\nReturn only the Scheme definition.\n\n```python\ndef quicksort_by(cmp, lst):\n    if len(lst) <= 1:\n        return lst\n    pivot = lst[0]\n    lt, eq, gt = partition(cmp, pivot, lst[1:])\n    return quicksort_by(cmp, lt) + [pivot] + eq + quicksort_by(cmp, gt)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9))\n(equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n  (and (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)) (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "quicksort-by"], "split": "eval"}
{"id": "sort_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge` in `lattice/data/sort.ss`.\nKnown issue: Equal keys must prefer the left list to preserve stability.\n\n```scheme\n(define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(cmp (car xs) (car ys))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))", "verify_expr": "(let ()\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))", "tags": ["tier0", "data", "sort", "bugfix", "merge"], "split": "eval"}
{"id": "sort_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `quicksort-by` in `lattice/data/sort.ss`.\nKnown issue: Values equal to pivot must be preserved; this version drops duplicates.\n\n```scheme\n(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (list pivot)\n                (quicksort-by cmp gt)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9))\n(equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n  (and (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)) (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "bugfix", "quicksort-by"], "split": "eval"}
{"id": "sort_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `nth-smallest` in `lattice/data/sort.ss`.\nKnown issue: Must guard empty input before taking car/cdr.\n\n```scheme\n(define (nth-smallest n lst)\n  (let* ([pivot (car lst)]\n         [parts (partition < pivot (cdr lst))]\n         [lt (car parts)]\n         [eq (cadr parts)]\n         [gt (caddr parts)]\n         [lt-len (length lt)])\n    (cond\n      [(< n lt-len)\n       (nth-smallest n lt)]\n      [(< n (+ lt-len 1 (length eq)))\n       pivot]\n      [else\n       (nth-smallest (- n lt-len 1 (length eq)) gt)])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1)\n(= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n  (and (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1) (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5) (= (nth-smallest 2 '(3 1 2 1 3)) 2) (guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))))", "tags": ["tier0", "data", "sort", "bugfix", "nth-smallest"], "split": "eval"}
{"id": "sort_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge two ascending lists '(1 3 5) and '(2 4 6) using <.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (merge '(1 3 5) '(2 4 6) <) '(1 2 3 4 5 6))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(merge '(1 3 5) '(2 4 6) <)", "verify_expr": "(equal? (merge '(1 3 5) '(2 4 6) <) '(1 2 3 4 5 6))", "tags": ["tier0", "data", "sort", "composition", "merge", "direct"], "split": "eval"}
{"id": "sort_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nSort '(3 1 4 1 5 9) ascending with quicksort-by.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(quicksort-by < '(3 1 4 1 5 9))", "verify_expr": "(equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9))", "tags": ["tier0", "data", "sort", "composition", "quicksort-by", "direct"], "split": "eval"}
{"id": "sort_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff merge-sort-by is idempotent for '(4 1 3 2 3).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (merge-sort-by < (merge-sort-by < '(4 1 3 2 3))) (merge-sort-by < '(4 1 3 2 3)))", "verify_expr": "(equal? (merge-sort-by < (merge-sort-by < '(4 1 3 2 3))) (merge-sort-by < '(4 1 3 2 3)))", "tags": ["tier0", "data", "sort", "composition", "merge-sort-by", "property"], "split": "eval"}
{"id": "sort_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff nth-smallest 0 equals the head of merge-sort-by output.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(= (nth-smallest 0 '(9 2 5 1 7)) (car (merge-sort-by < '(9 2 5 1 7))))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (nth-smallest 0 '(9 2 5 1 7)) (car (merge-sort-by < '(9 2 5 1 7))))", "verify_expr": "(= (nth-smallest 0 '(9 2 5 1 7)) (car (merge-sort-by < '(9 2 5 1 7))))", "tags": ["tier0", "data", "sort", "composition", "nth-smallest", "property"], "split": "eval"}
{"id": "sort_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff nth-smallest agrees with merge-sort-by at index 2.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(= (nth-smallest 2 '(8 3 5 1 9)) (list-ref (merge-sort-by < '(8 3 5 1 9)) 2))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (nth-smallest 2 '(8 3 5 1 9)) (list-ref (merge-sort-by < '(8 3 5 1 9)) 2))", "verify_expr": "(= (nth-smallest 2 '(8 3 5 1 9)) (list-ref (merge-sort-by < '(8 3 5 1 9)) 2))", "tags": ["tier0", "data", "sort", "composition", "nth-smallest", "integration"], "split": "eval"}
