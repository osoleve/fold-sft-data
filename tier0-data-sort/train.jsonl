{"id": "sort_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `merge`\nSpec: Merge two already-sorted lists under comparator cmp, preserving stability when keys are equal.\n\nWrite exactly one Scheme function definition for `merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))", "verify_expr": "(let ()\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))", "tags": ["tier0", "data", "sort", "spec-to-code", "merge"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `merge`\nSpec: Merge two already-sorted lists under comparator cmp, preserving stability when keys are equal.\n\nWrite exactly one Scheme function definition for `merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "sort_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (merge xs ys cmp)\n  ;; TODO: merge two sorted lists, taking from xs when keys are equal\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `merge`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))", "verify_expr": "(let ()\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "merge"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (merge xs ys cmp)\n  ;; TODO: merge two sorted lists, taking from xs when keys are equal\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `merge`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sort_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `split-at`\nSpec: Split lst at index n and return (cons left right) where left has at most n elements.\n\nWrite exactly one Scheme function definition for `split-at`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (and (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))) (equal? (split-at '(1 2) 5) (cons '(1 2) '()))))", "tags": ["tier0", "data", "sort", "spec-to-code", "split-at"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `split-at`\nSpec: Split lst at index n and return (cons left right) where left has at most n elements.\n\nWrite exactly one Scheme function definition for `split-at`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sort_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (split-at lst n)\n  ;; TODO: return (cons left right) where left contains first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `split-at`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (and (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))) (equal? (split-at '(1 2) 5) (cons '(1 2) '()))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "split-at"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (split-at lst n)\n  ;; TODO: return (cons left right) where left contains first n elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `split-at`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "sort_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `merge-sort-by`\nSpec: Stable merge sort with custom comparator cmp.\n\nWrite exactly one Scheme function definition for `merge-sort-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n  (and (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c))))", "tags": ["tier0", "data", "sort", "spec-to-code", "merge-sort-by"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `merge-sort-by`\nSpec: Stable merge sort with custom comparator cmp.\n\nWrite exactly one Scheme function definition for `merge-sort-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sort_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (merge-sort-by cmp lst)\n  ;; TODO: stable merge sort using split-at and merge\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `merge-sort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n  (and (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "merge-sort-by"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (merge-sort-by cmp lst)\n  ;; TODO: stable merge sort using split-at and merge\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `merge-sort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "sort_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition cmp pivot lst)\n  ;; TODO: return (list lt eq gt)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "partition"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition cmp pivot lst)\n  ;; TODO: return (list lt eq gt)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sort_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `quicksort-by`\nSpec: Quicksort with custom comparator cmp using three-way partitioning.\n\nWrite exactly one Scheme function definition for `quicksort-by`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n(let () (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n  (and (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)) (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "spec-to-code", "quicksort-by"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `quicksort-by`\nSpec: Quicksort with custom comparator cmp using three-way partitioning.\n\nWrite exactly one Scheme function definition for `quicksort-by`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n(let () (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sort_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (quicksort-by cmp lst)\n  ;; TODO: sort using partition and recursive quicksort\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `quicksort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n  (and (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)) (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "quicksort-by"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (quicksort-by cmp lst)\n  ;; TODO: sort using partition and recursive quicksort\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `quicksort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "sort_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (insert-sorted cmp x sorted)\n  ;; TODO: insert x into sorted position\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `insert-sorted`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (and (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)) (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "insert-sorted"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (insert-sorted cmp x sorted)\n  ;; TODO: insert x into sorted position\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `insert-sorted`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "sort_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (insertion-sort-by cmp lst)\n  ;; TODO: fold through lst and insert each value into accumulator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `insertion-sort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))\n  (and (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "insertion-sort-by"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (insertion-sort-by cmp lst)\n  ;; TODO: fold through lst and insert each value into accumulator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `insertion-sort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sort_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `nth-smallest`\nSpec: Return the n-th smallest element (0-indexed); raise an error on empty input.\n\nWrite exactly one Scheme function definition for `nth-smallest`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n  (and (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1) (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5) (= (nth-smallest 2 '(3 1 2 1 3)) 2) (guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))))", "tags": ["tier0", "data", "sort", "spec-to-code", "nth-smallest"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 sorting code in Fold-native Scheme.\n\nTarget module: lattice/data/sort.ss\nFunction: `nth-smallest`\nSpec: Return the n-th smallest element (0-indexed); raise an error on empty input.\n\nWrite exactly one Scheme function definition for `nth-smallest`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "sort_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (nth-smallest n lst)\n  ;; TODO: quickselect-style n-th order statistic\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `nth-smallest`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1))\n(let () (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n  (and (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1) (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5) (= (nth-smallest 2 '(3 1 2 1 3)) 2) (guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))))", "tags": ["tier0", "data", "sort", "skeleton-completion", "nth-smallest"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (nth-smallest n lst)\n  ;; TODO: quickselect-style n-th order statistic\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `nth-smallest`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1))\n(let () (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "sort_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `merge`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge0 xs ys cmp)\n  (cond\n    ((null? xs) ys)\n    ((null? ys) xs)\n    ((not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge0 (cdr xs) ys cmp)))\n    (else\n     (cons (car ys) (merge0 xs (cdr ys) cmp)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))", "verify_expr": "(let ()\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "merge"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `merge`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge0 xs ys cmp)\n  (cond\n    ((null? xs) ys)\n    ((null? ys) xs)\n    ((not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge0 (cdr xs) ys cmp)))\n    (else\n     (cons (car ys) (merge0 xs (cdr ys) cmp)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sort_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `split-at`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (split0 xs n)\n  (if (or (= n 0) (null? xs))\n      (cons '() xs)\n      (let ((rest (split0 (cdr xs) (- n 1))))\n        (cons (cons (car xs) (car rest))\n              (cdr rest)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n(let () (equal? (split-at '(1 2) 5) (cons '(1 2) '())))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (and (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))) (equal? (split-at '(1 2) 5) (cons '(1 2) '()))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "split-at"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `split-at`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (split0 xs n)\n  (if (or (= n 0) (null? xs))\n      (cons '() xs)\n      (let ((rest (split0 (cdr xs) (- n 1))))\n        (cons (cons (car xs) (car rest))\n              (cdr rest)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n(let () (equal? (split-at '(1 2) 5) (cons '(1 2) '())))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sort_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `merge-sort-by`.\nReturn only the Scheme definition.\n\n```python\ndef merge_sort_by(cmp, lst):\n    if len(lst) <= 1:\n        return lst\n    mid = len(lst) // 2\n    left, right = split_at(lst, mid)\n    return merge(merge_sort_by(cmp, left), merge_sort_by(cmp, right), cmp)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n  (and (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "merge-sort-by"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `merge-sort-by`.\nReturn only the Scheme definition.\n\n```python\ndef merge_sort_by(cmp, lst):\n    if len(lst) <= 1:\n        return lst\n    mid = len(lst) // 2\n    left, right = split_at(lst, mid)\n    return merge(merge_sort_by(cmp, left), merge_sort_by(cmp, right), cmp)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sort_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `merge-sort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (msort cmp xs)\n  (if (<= (length xs) 1)\n      xs\n      (let* ((mid (quotient (length xs) 2))\n             (parts (split-at xs mid))\n             (left (car parts))\n             (right (cdr parts)))\n        (merge (msort cmp left)\n               (msort cmp right)\n               cmp))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n  (and (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "merge-sort-by"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `merge-sort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (msort cmp xs)\n  (if (<= (length xs) 1)\n      xs\n      (let* ((mid (quotient (length xs) 2))\n             (parts (split-at xs mid))\n             (left (car parts))\n             (right (cdr parts)))\n        (merge (msort cmp left)\n               (msort cmp right)\n               cmp))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sort_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `partition`.\nReturn only the Scheme definition.\n\n```python\ndef partition(cmp, pivot, lst):\n    lt, eq, gt = [], [], []\n    for x in lst:\n        if cmp(x, pivot):\n            lt.append(x)\n        elif cmp(pivot, x):\n            gt.append(x)\n        else:\n            eq.append(x)\n    return (lt, eq, gt)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "partition"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `partition`.\nReturn only the Scheme definition.\n\n```python\ndef partition(cmp, pivot, lst):\n    lt, eq, gt = [], [], []\n    for x in lst:\n        if cmp(x, pivot):\n            lt.append(x)\n        elif cmp(pivot, x):\n            gt.append(x)\n        else:\n            eq.append(x)\n    return (lt, eq, gt)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sort_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition0 cmp p xs)\n  (let loop ((rest xs) (lt '()) (eq '()) (gt '()))\n    (if (null? rest)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ((x (car rest)))\n          (cond\n            ((cmp x p) (loop (cdr rest) (cons x lt) eq gt))\n            ((cmp p x) (loop (cdr rest) lt eq (cons x gt)))\n            (else (loop (cdr rest) lt (cons x eq) gt)))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "partition"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition0 cmp p xs)\n  (let loop ((rest xs) (lt '()) (eq '()) (gt '()))\n    (if (null? rest)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ((x (car rest)))\n          (cond\n            ((cmp x p) (loop (cdr rest) (cons x lt) eq gt))\n            ((cmp p x) (loop (cdr rest) lt eq (cons x gt)))\n            (else (loop (cdr rest) lt (cons x eq) gt)))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sort_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `quicksort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (qsort cmp xs)\n  (if (or (null? xs) (null? (cdr xs)))\n      xs\n      (let* ((p (car xs))\n             (parts (partition cmp p (cdr xs)))\n             (lt (car parts))\n             (eq (cadr parts))\n             (gt (caddr parts)))\n        (append (qsort cmp lt)\n                (cons p eq)\n                (qsort cmp gt)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n(let () (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n  (and (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)) (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "quicksort-by"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `quicksort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (qsort cmp xs)\n  (if (or (null? xs) (null? (cdr xs)))\n      xs\n      (let* ((p (car xs))\n             (parts (partition cmp p (cdr xs)))\n             (lt (car parts))\n             (eq (cadr parts))\n             (gt (caddr parts)))\n        (append (qsort cmp lt)\n                (cons p eq)\n                (qsort cmp gt)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n(let () (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sort_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `insert-sorted`.\nReturn only the Scheme definition.\n\n```python\ndef insert_sorted(cmp, x, sorted_lst):\n    if not sorted_lst:\n        return [x]\n    if cmp(x, sorted_lst[0]):\n        return [x] + sorted_lst\n    return [sorted_lst[0]] + insert_sorted(cmp, x, sorted_lst[1:])\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (and (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)) (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "insert-sorted"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `insert-sorted`.\nReturn only the Scheme definition.\n\n```python\ndef insert_sorted(cmp, x, sorted_lst):\n    if not sorted_lst:\n        return [x]\n    if cmp(x, sorted_lst[0]):\n        return [x] + sorted_lst\n    return [sorted_lst[0]] + insert_sorted(cmp, x, sorted_lst[1:])\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "sort_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `insert-sorted`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (insert0 cmp x xs)\n  (cond\n    ((null? xs) (list x))\n    ((cmp x (car xs)) (cons x xs))\n    (else (cons (car xs) (insert0 cmp x (cdr xs))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (and (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)) (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "insert-sorted"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `insert-sorted`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (insert0 cmp x xs)\n  (cond\n    ((null? xs) (list x))\n    ((cmp x (car xs)) (cons x xs))\n    (else (cons (car xs) (insert0 cmp x (cdr xs))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sort_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `insertion-sort-by`.\nReturn only the Scheme definition.\n\n```python\ndef insertion_sort_by(cmp, lst):\n    out = []\n    for x in lst:\n        out = insert_sorted(cmp, x, out)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))\n  (and (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "insertion-sort-by"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `insertion-sort-by`.\nReturn only the Scheme definition.\n\n```python\ndef insertion_sort_by(cmp, lst):\n    out = []\n    for x in lst:\n        out = insert_sorted(cmp, x, out)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sort_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `insertion-sort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (isort cmp xs)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc))\n             '()\n             xs))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))\n  (and (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "insertion-sort-by"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `insertion-sort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (isort cmp xs)\n  (fold-left (lambda (acc x) (insert-sorted cmp x acc))\n             '()\n             xs))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "sort_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `nth-smallest`.\nReturn only the Scheme definition.\n\n```python\ndef nth_smallest(n, lst):\n    if not lst:\n        raise ValueError('List is empty')\n    pivot = lst[0]\n    lt, eq, gt = partition(lambda a, b: a < b, pivot, lst[1:])\n    if n < len(lt):\n        return nth_smallest(n, lt)\n    if n < len(lt) + 1 + len(eq):\n        return pivot\n    return nth_smallest(n - len(lt) - 1 - len(eq), gt)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1))\n(let () (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n  (and (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1) (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5) (= (nth-smallest 2 '(3 1 2 1 3)) 2) (guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))))", "tags": ["tier0", "data", "sort", "python-to-scheme", "nth-smallest"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `nth-smallest`.\nReturn only the Scheme definition.\n\n```python\ndef nth_smallest(n, lst):\n    if not lst:\n        raise ValueError('List is empty')\n    pivot = lst[0]\n    lt, eq, gt = partition(lambda a, b: a < b, pivot, lst[1:])\n    if n < len(lt):\n        return nth_smallest(n, lt)\n    if n < len(lt) + 1 + len(eq):\n        return pivot\n    return nth_smallest(n - len(lt) - 1 - len(eq), gt)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1))\n(let () (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sort_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `nth-smallest`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (nth0 n xs)\n  (if (null? xs)\n      (error 'nth-smallest \"List is empty\")\n      (let* ((p (car xs))\n             (parts (partition < p (cdr xs)))\n             (lt (car parts))\n             (eq (cadr parts))\n             (gt (caddr parts))\n             (m (length lt)))\n        (cond\n          ((< n m) (nth0 n lt))\n          ((< n (+ m 1 (length eq))) p)\n          (else (nth0 (- n m 1 (length eq)) gt))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1))\n(let () (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n  (and (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1) (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5) (= (nth-smallest 2 '(3 1 2 1 3)) 2) (guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))))", "tags": ["tier0", "data", "sort", "chez-to-fold", "nth-smallest"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `nth-smallest`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (nth0 n xs)\n  (if (null? xs)\n      (error 'nth-smallest \"List is empty\")\n      (let* ((p (car xs))\n             (parts (partition < p (cdr xs)))\n             (lt (car parts))\n             (eq (cadr parts))\n             (gt (caddr parts))\n             (m (length lt)))\n        (cond\n          ((< n m) (nth0 n lt))\n          ((< n (+ m 1 (length eq))) p)\n          (else (nth0 (- n m 1 (length eq)) gt))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1))\n(let () (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "sort_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge` in `lattice/data/sort.ss`.\nKnown issue: Merging must consume both inputs, not return xs unchanged when non-empty.\n\n```scheme\n(define (merge xs ys cmp)\n  (if (null? xs)\n      ys\n      xs))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))", "verify_expr": "(let ()\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (let* ([xs '((a . 1) (b . 2) (c . 2))] [ys '((d . 2) (e . 3))] [m (merge xs ys (lambda (u v) (< (cdr u) (cdr v))))]) (equal? (map car m) '(a b c d e))))", "tags": ["tier0", "data", "sort", "bugfix", "merge"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge` in `lattice/data/sort.ss`.\nKnown issue: Merging must consume both inputs, not return xs unchanged when non-empty.\n\n```scheme\n(define (merge xs ys cmp)\n  (if (null? xs)\n      ys\n      xs))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault."}
{"id": "sort_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `split-at` in `lattice/data/sort.ss`.\nKnown issue: Base case should trigger at n = 0, not n = 1.\n\n```scheme\n(define (split-at lst n)\n  (if (or (= n 1) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Base case should trigger at n = 0, not n = 1.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n(let () (equal? (split-at '(1 2) 5) (cons '(1 2) '())))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (and (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))) (equal? (split-at '(1 2) 5) (cons '(1 2) '()))))", "tags": ["tier0", "data", "sort", "bugfix", "split-at"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `split-at` in `lattice/data/sort.ss`.\nKnown issue: Base case should trigger at n = 0, not n = 1.\n\n```scheme\n(define (split-at lst n)\n  (if (or (= n 1) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Base case should trigger at n = 0, not n = 1.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n(let () (equal? (split-at '(1 2) 5) (cons '(1 2) '())))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "sort_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `split-at` in `lattice/data/sort.ss`.\nKnown issue: Return type must be a pair via cons, not a two-element list.\n\n```scheme\n(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (list '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (list (cons (car lst) (car rest))\n              (cdr rest)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Return type must be a pair via cons, not a two-element list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (and (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))) (equal? (split-at '(1 2) 5) (cons '(1 2) '()))))", "tags": ["tier0", "data", "sort", "bugfix", "split-at"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `split-at` in `lattice/data/sort.ss`.\nKnown issue: Return type must be a pair via cons, not a two-element list.\n\n```scheme\n(define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (list '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (list (cons (car lst) (car rest))\n              (cdr rest)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Return type must be a pair via cons, not a two-element list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (split-at '(1 2 3 4) 2) (cons '(1 2) '(3 4))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sort_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Both halves must be recursively sorted before merging.\n\n```scheme\n(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 right\n                 cmp)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n  (and (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c))))", "tags": ["tier0", "data", "sort", "bugfix", "merge-sort-by"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Both halves must be recursively sorted before merging.\n\n```scheme\n(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 right\n                 cmp)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sort_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Length-1 input must hit the base case to avoid non-terminating recursion.\n\n```scheme\n(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (< len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Length-1 input must hit the base case to avoid non-terminating recursion.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))", "verify_expr": "(let ()\n  (define (split-at lst n)\n  (if (or (= n 0) (null? lst))\n      (cons '() lst)\n      (let ([rest (split-at (cdr lst) (- n 1))])\n        (cons (cons (car lst) (car rest))\n              (cdr rest)))))\n  (define (merge xs ys cmp)\n  (cond\n    [(null? xs) ys]\n    [(null? ys) xs]\n    [(not (cmp (car ys) (car xs)))\n     (cons (car xs) (merge (cdr xs) ys cmp))]\n    [else\n     (cons (car ys) (merge xs (cdr ys) cmp))]))\n  (define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (<= len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n  (and (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c))))", "tags": ["tier0", "data", "sort", "bugfix", "merge-sort-by"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `merge-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Length-1 input must hit the base case to avoid non-terminating recursion.\n\n```scheme\n(define (merge-sort-by cmp lst)\n  (let ([len (length lst)])\n    (if (< len 1)\n        lst\n        (let* ([mid (quotient len 2)]\n               [split (split-at lst mid)]\n               [left (car split)]\n               [right (cdr split)])\n          (merge (merge-sort-by cmp left)\n                 (merge-sort-by cmp right)\n                 cmp)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Length-1 input must hit the base case to avoid non-terminating recursion.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (map car (merge-sort-by (lambda (x y) (< (cdr x) (cdr y))) '((a . 2) (b . 1) (c . 2)))) '(b a c)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sort_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `lattice/data/sort.ss`.\nKnown issue: Elements equal to pivot must go into the eq bucket, not gt.\n\n```scheme\n(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt eq (cons x gt))])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Elements equal to pivot must go into the eq bucket, not gt.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))", "tags": ["tier0", "data", "sort", "bugfix", "partition"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `lattice/data/sort.ss`.\nKnown issue: Elements equal to pivot must go into the eq bucket, not gt.\n\n```scheme\n(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt eq (cons x gt))])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Elements equal to pivot must go into the eq bucket, not gt.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sort_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `lattice/data/sort.ss`.\nKnown issue: Accumulator lists must be reversed before returning to preserve encounter order.\n\n```scheme\n(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list lt eq gt)\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Accumulator lists must be reversed before returning to preserve encounter order.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))", "tags": ["tier0", "data", "sort", "bugfix", "partition"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition` in `lattice/data/sort.ss`.\nKnown issue: Accumulator lists must be reversed before returning to preserve encounter order.\n\n```scheme\n(define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list lt eq gt)\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Accumulator lists must be reversed before returning to preserve encounter order.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([parts (partition < 3 '(1 3 2 4 3 5))]) (and (equal? (car parts) '(1 2)) (equal? (cadr parts) '(3 3)) (equal? (caddr parts) '(4 5)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sort_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `quicksort-by` in `lattice/data/sort.ss`.\nKnown issue: Partitioning must use cmp, not a hardcoded numeric comparator.\n\n```scheme\n(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Partitioning must use cmp, not a hardcoded numeric comparator.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n(let () (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition cmp pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n  (and (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)) (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "bugfix", "quicksort-by"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `quicksort-by` in `lattice/data/sort.ss`.\nKnown issue: Partitioning must use cmp, not a hardcoded numeric comparator.\n\n```scheme\n(define (quicksort-by cmp lst)\n  (if (or (null? lst) (null? (cdr lst)))\n      lst\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)])\n        (append (quicksort-by cmp lt)\n                (cons pivot eq)\n                (quicksort-by cmp gt)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Partitioning must use cmp, not a hardcoded numeric comparator.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (quicksort-by < '(3 1 4 1 5 9)) '(1 1 3 4 5 9)))\n(let () (equal? (quicksort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sort_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insert-sorted` in `lattice/data/sort.ss`.\nKnown issue: For equal keys, existing elements should stay before the inserted element.\n\n```scheme\n(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(not (cmp (car sorted) x)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: For equal keys, existing elements should stay before the inserted element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (and (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)) (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3))))", "tags": ["tier0", "data", "sort", "bugfix", "insert-sorted"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insert-sorted` in `lattice/data/sort.ss`.\nKnown issue: For equal keys, existing elements should stay before the inserted element.\n\n```scheme\n(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(not (cmp (car sorted) x)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: For equal keys, existing elements should stay before the inserted element.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sort_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insert-sorted` in `lattice/data/sort.ss`.\nKnown issue: Insertion must place x at its sorted position, not always append.\n\n```scheme\n(define (insert-sorted cmp x sorted)\n  (append sorted (list x)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (and (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)) (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3))))", "tags": ["tier0", "data", "sort", "bugfix", "insert-sorted"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insert-sorted` in `lattice/data/sort.ss`.\nKnown issue: Insertion must place x at its sorted position, not always append.\n\n```scheme\n(define (insert-sorted cmp x sorted)\n  (append sorted (list x)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5)))\n(let () (equal? (insert-sorted < 2 '(1 2 2 3)) '(1 2 2 2 3)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "sort_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insertion-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Accumulator should start empty; starting from lst duplicates data.\n\n```scheme\n(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             lst\n             lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))\n  (and (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "bugfix", "insertion-sort-by"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insertion-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Accumulator should start empty; starting from lst duplicates data.\n\n```scheme\n(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             lst\n             lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "sort_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insertion-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Function must actually sort the input list.\n\n```scheme\n(define (insertion-sort-by cmp lst)\n  lst)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Function must actually sort the input list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))", "verify_expr": "(let ()\n  (define (insert-sorted cmp x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(cmp x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted cmp x (cdr sorted)))]))\n  (define (insertion-sort-by cmp lst)\n  (fold-left (lambda (sorted x) (insert-sorted cmp x sorted))\n             '()\n             lst))\n  (and (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)) (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))))", "tags": ["tier0", "data", "sort", "bugfix", "insertion-sort-by"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insertion-sort-by` in `lattice/data/sort.ss`.\nKnown issue: Function must actually sort the input list.\n\n```scheme\n(define (insertion-sort-by cmp lst)\n  lst)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Function must actually sort the input list.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (insertion-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9)))\n(let () (equal? (insertion-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1)))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "sort_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `nth-smallest` in `lattice/data/sort.ss`.\nKnown issue: Pivot range must include the pivot itself (+ 1).\n\n```scheme\n(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))", "verify_expr": "(let ()\n  (define (partition cmp pivot lst)\n  (let loop ([xs lst] [lt '()] [eq '()] [gt '()])\n    (if (null? xs)\n        (list (reverse lt) (reverse eq) (reverse gt))\n        (let ([x (car xs)])\n          (cond\n            [(cmp x pivot)\n             (loop (cdr xs) (cons x lt) eq gt)]\n            [(cmp pivot x)\n             (loop (cdr xs) lt eq (cons x gt))]\n            [else\n             (loop (cdr xs) lt (cons x eq) gt)])))))\n  (define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len 1 (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n  (and (= (nth-smallest 0 '(5 2 8 1 9 3 7)) 1) (= (nth-smallest 3 '(5 2 8 1 9 3 7)) 5) (= (nth-smallest 2 '(3 1 2 1 3)) 2) (guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))))", "tags": ["tier0", "data", "sort", "bugfix", "nth-smallest"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `nth-smallest` in `lattice/data/sort.ss`.\nKnown issue: Pivot range must include the pivot itself (+ 1).\n\n```scheme\n(define (nth-smallest n lst)\n  (if (null? lst)\n      (error 'nth-smallest \"List is empty\")\n      (let* ([pivot (car lst)]\n             [parts (partition < pivot (cdr lst))]\n             [lt (car parts)]\n             [eq (cadr parts)]\n             [gt (caddr parts)]\n             [lt-len (length lt)])\n        (cond\n          [(< n lt-len)\n           (nth-smallest n lt)]\n          [(< n (+ lt-len (length eq)))\n           pivot]\n          [else\n           (nth-smallest (- n lt-len 1 (length eq)) gt)]))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault."}
{"id": "sort_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge pair lists by cdr and return the element labels in order.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (merge '((a . 2) (b . 2)) '((c . 2) (d . 3)) (lambda (x y) (< (cdr x) (cdr y)))))", "verify_expr": "(equal? (map car (merge '((a . 2) (b . 2)) '((c . 2) (d . 3)) (lambda (x y) (< (cdr x) (cdr y))))) '(a b c d))", "tags": ["tier0", "data", "sort", "composition", "merge", "direct", "stability"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nMerge pair lists by cdr and return the element labels in order.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: compose existing APIs into one expression.\n\nSplit '(1 2 3 4 5) at index 2 and return the resulting pair.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(split-at '(1 2 3 4 5) 2)", "verify_expr": "(equal? (split-at '(1 2 3 4 5) 2) (cons '(1 2) '(3 4 5)))", "tags": ["tier0", "data", "sort", "composition", "split-at", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSplit '(1 2 3 4 5) at index 2 and return the resulting pair.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: small integration task across module primitives.\n\nSplit '(1 2) at index 5; the right side should be empty.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(split-at '(1 2) 5)", "verify_expr": "(equal? (split-at '(1 2) 5) (cons '(1 2) '()))", "tags": ["tier0", "data", "sort", "composition", "split-at", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nSplit '(1 2) at index 5; the right side should be empty.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sort_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nSort '(5 2 8 1 9 3) ascending with merge-sort-by.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(merge-sort-by < '(5 2 8 1 9 3))", "verify_expr": "(equal? (merge-sort-by < '(5 2 8 1 9 3)) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "sort", "composition", "merge-sort-by", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSort '(5 2 8 1 9 3) ascending with merge-sort-by.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge-sort-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSort '(3 1 4 1 5) descending with comparator >.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(merge-sort-by > '(3 1 4 1 5))", "verify_expr": "(equal? (merge-sort-by > '(3 1 4 1 5)) '(5 4 3 1 1))", "tags": ["tier0", "data", "sort", "composition", "merge-sort-by", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nSort '(3 1 4 1 5) descending with comparator >.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPartition '(1 3 2 4 3 5) around pivot 3 using <.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition < 3 '(1 3 2 4 3 5))", "verify_expr": "(equal? (partition < 3 '(1 3 2 4 3 5)) '((1 2) (3 3) (4 5)))", "tags": ["tier0", "data", "sort", "composition", "partition", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nPartition '(1 3 2 4 3 5) around pivot 3 using <.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nPartition '(4 4 4) around pivot 4 and return the three buckets.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition < 4 '(4 4 4))", "verify_expr": "(equal? (partition < 4 '(4 4 4)) '(() (4 4 4) ()))", "tags": ["tier0", "data", "sort", "composition", "partition", "direct", "duplicates"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nPartition '(4 4 4) around pivot 4 and return the three buckets.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nSort strings '(\"cherry\" \"apple\" \"banana\") lexicographically.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(quicksort-by string<? '(\"cherry\" \"apple\" \"banana\"))", "verify_expr": "(equal? (quicksort-by string<? '(\"cherry\" \"apple\" \"banana\")) '(\"apple\" \"banana\" \"cherry\"))", "tags": ["tier0", "data", "sort", "composition", "quicksort-by", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSort strings '(\"cherry\" \"apple\" \"banana\") lexicographically.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sort_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: small integration task across module primitives.\n\nInsert 3 into sorted list '(1 2 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(insert-sorted < 3 '(1 2 4 5))", "verify_expr": "(equal? (insert-sorted < 3 '(1 2 4 5)) '(1 2 3 4 5))", "tags": ["tier0", "data", "sort", "composition", "insert-sorted", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nInsert 3 into sorted list '(1 2 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sort_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: compose existing APIs into one expression.\n\nSort '(4 1 3 2) ascending with insertion-sort-by.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(insertion-sort-by < '(4 1 3 2))", "verify_expr": "(equal? (insertion-sort-by < '(4 1 3 2)) '(1 2 3 4))", "tags": ["tier0", "data", "sort", "composition", "insertion-sort-by", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSort '(4 1 3 2) ascending with insertion-sort-by.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn the 3rd smallest element (index 2) of '(7 1 5 3 9).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(nth-smallest 2 '(7 1 5 3 9))", "verify_expr": "(equal? (nth-smallest 2 '(7 1 5 3 9)) 5)", "tags": ["tier0", "data", "sort", "composition", "nth-smallest", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn the 3rd smallest element (index 2) of '(7 1 5 3 9).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn the largest element via nth-smallest on '(7 1 5 3 9).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(nth-smallest 4 '(7 1 5 3 9))", "verify_expr": "(equal? (nth-smallest 4 '(7 1 5 3 9)) 9)", "tags": ["tier0", "data", "sort", "composition", "nth-smallest", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn the largest element via nth-smallest on '(7 1 5 3 9).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff merge output length equals sum of input lengths.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (length (merge '(1 4 7) '(2 3 9 10) <)) (+ (length '(1 4 7)) (length '(2 3 9 10))))", "verify_expr": "(= (length (merge '(1 4 7) '(2 3 9 10) <)) (+ (length '(1 4 7)) (length '(2 3 9 10))))", "tags": ["tier0", "data", "sort", "composition", "merge", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff merge output length equals sum of input lengths.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "split-at", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff split-at preserves total element count.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p (split-at '(a b c d e) 3)]) (= (+ (length (car p)) (length (cdr p))) 5))", "verify_expr": "(let ([p (split-at '(a b c d e) 3)]) (= (+ (length (car p)) (length (cdr p))) 5))", "tags": ["tier0", "data", "sort", "composition", "split-at", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn #t iff split-at preserves total element count.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff quicksort-by and merge-sort-by agree on numeric ascending sort.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (quicksort-by < '(5 2 8 1 9 3 7 4 6)) (merge-sort-by < '(5 2 8 1 9 3 7 4 6)))", "verify_expr": "(equal? (quicksort-by < '(5 2 8 1 9 3 7 4 6)) (merge-sort-by < '(5 2 8 1 9 3 7 4 6)))", "tags": ["tier0", "data", "sort", "composition", "quicksort-by", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff quicksort-by and merge-sort-by agree on numeric ascending sort.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sort_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff partition bucket sizes add up to original list size.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p (partition < 5 '(7 1 5 3 5 9 0))]) (= (+ (length (car p)) (length (cadr p)) (length (caddr p))) 7))", "verify_expr": "(let ([p (partition < 5 '(7 1 5 3 5 9 0))]) (= (+ (length (car p)) (length (cadr p)) (length (caddr p))) 7))", "tags": ["tier0", "data", "sort", "composition", "partition", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff partition bucket sizes add up to original list size.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff partition buckets respect pivot ordering constraints.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p (partition < 5 '(7 1 5 3 5 9 0))]) (and (null? (filter (lambda (x) (not (< x 5))) (car p))) (null? (filter (lambda (x) (not (equal? x 5))) (cadr p))) (null? (filter (lambda (x) (not (> x 5))) (caddr p)))))", "verify_expr": "(let ([p (partition < 5 '(7 1 5 3 5 9 0))]) (and (null? (filter (lambda (x) (not (< x 5))) (car p))) (null? (filter (lambda (x) (not (equal? x 5))) (cadr p))) (null? (filter (lambda (x) (not (> x 5))) (caddr p)))))", "tags": ["tier0", "data", "sort", "composition", "partition", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff partition buckets respect pivot ordering constraints.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff descending quicksort equals reverse of ascending quicksort.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (quicksort-by > '(5 1 4 2 3)) (reverse (quicksort-by < '(5 1 4 2 3))))", "verify_expr": "(equal? (quicksort-by > '(5 1 4 2 3)) (reverse (quicksort-by < '(5 1 4 2 3))))", "tags": ["tier0", "data", "sort", "composition", "quicksort-by", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn #t iff descending quicksort equals reverse of ascending quicksort.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff insert-sorted increases list length by one.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (length (insert-sorted < 6 '(1 3 5 7 9))) (+ 1 (length '(1 3 5 7 9))))", "verify_expr": "(= (length (insert-sorted < 6 '(1 3 5 7 9))) (+ 1 (length '(1 3 5 7 9))))", "tags": ["tier0", "data", "sort", "composition", "insert-sorted", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff insert-sorted increases list length by one.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sort_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff insertion-sort-by is idempotent for '(6 1 5 2 4 3).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (insertion-sort-by < (insertion-sort-by < '(6 1 5 2 4 3))) (insertion-sort-by < '(6 1 5 2 4 3)))", "verify_expr": "(equal? (insertion-sort-by < (insertion-sort-by < '(6 1 5 2 4 3))) (insertion-sort-by < '(6 1 5 2 4 3)))", "tags": ["tier0", "data", "sort", "composition", "insertion-sort-by", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn #t iff insertion-sort-by is idempotent for '(6 1 5 2 4 3).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff nth-smallest raises on empty input.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))", "verify_expr": "(guard (ex [else #t]) (begin (nth-smallest 0 '()) #f))", "tags": ["tier0", "data", "sort", "composition", "nth-smallest", "edge-case", "property"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff nth-smallest raises on empty input.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insert-sorted", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse fold-left with insert-sorted to build a sorted list from '(5 2 4 1 3).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(fold-left (lambda (acc x) (insert-sorted < x acc)) '() '(5 2 4 1 3))", "verify_expr": "(equal? (fold-left (lambda (acc x) (insert-sorted < x acc)) '() '(5 2 4 1 3)) '(1 2 3 4 5))", "tags": ["tier0", "data", "sort", "composition", "insert-sorted", "fold"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nUse fold-left with insert-sorted to build a sorted list from '(5 2 4 1 3).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "nth-smallest", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff nth-smallest matches list-ref of quicksort-by at the same index.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (nth-smallest 3 '(8 1 6 2 7 3 5 4)) (list-ref (quicksort-by < '(8 1 6 2 7 3 5 4)) 3))", "verify_expr": "(= (nth-smallest 3 '(8 1 6 2 7 3 5 4)) (list-ref (quicksort-by < '(8 1 6 2 7 3 5 4)) 3))", "tags": ["tier0", "data", "sort", "composition", "nth-smallest", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff nth-smallest matches list-ref of quicksort-by at the same index.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "insertion-sort-by", "prompt": "Task mode: small integration task across module primitives.\n\nSort pairs by descending cdr and return only labels.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map car (insertion-sort-by (lambda (x y) (> (cdr x) (cdr y))) '((a . 2) (b . 5) (c . 1))))", "verify_expr": "(equal? (map car (insertion-sort-by (lambda (x y) (> (cdr x) (cdr y))) '((a . 2) (b . 5) (c . 1)))) '(b a c))", "tags": ["tier0", "data", "sort", "composition", "insertion-sort-by", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nSort pairs by descending cdr and return only labels.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "sort_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "merge", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSplit a sorted list into two halves and merge them back.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([xs '(1 2 3 4 5 6)] [p (split-at xs 3)]) (merge (car p) (cdr p) <))", "verify_expr": "(equal? (let* ([xs '(1 2 3 4 5 6)] [p (split-at xs 3)]) (merge (car p) (cdr p) <)) '(1 2 3 4 5 6))", "tags": ["tier0", "data", "sort", "composition", "merge", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nSplit a sorted list into two halves and merge them back.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "sort_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "quicksort-by", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSort an empty list with quicksort-by.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(quicksort-by < '())", "verify_expr": "(equal? (quicksort-by < '()) '())", "tags": ["tier0", "data", "sort", "composition", "quicksort-by", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nSort an empty list with quicksort-by.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "sort_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/sort.ss", "source_test": "lattice/data/test-sort.ss", "source_function": "partition", "prompt": "Task mode: compose existing APIs into one expression.\n\nPartition '(1 2 3) around pivot 10 and verify all items are in lt.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition < 10 '(1 2 3))", "verify_expr": "(equal? (partition < 10 '(1 2 3)) '((1 2 3) () ()))", "tags": ["tier0", "data", "sort", "composition", "partition", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nPartition '(1 2 3) around pivot 10 and verify all items are in lt.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
