{"id": "optics_profunctor_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `profunctor?`\nSpec: Return #t iff value is a pair tagged with symbol 'profunctor in car position.\n\nWrite exactly one Scheme function definition for `profunctor?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]) (and (profunctor? p) (profunctor? (cons 'profunctor 'tail)) (not (profunctor? '(foo bar))) (not (profunctor? 'profunctor)) (not (profunctor? #f)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))])\n  (and (profunctor? p)\n       (profunctor? (cons 'profunctor 'tail))\n       (not (profunctor? '(foo bar)))\n       (not (profunctor? 'profunctor))\n       (not (profunctor? #f)))))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "profunctor?"], "split": "eval"}
{"id": "optics_profunctor_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `profunctor-lmap`\nSpec: Extract the lmap function from a profunctor dictionary.\n\nWrite exactly one Scheme function definition for `profunctor-lmap`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))]) (= (fn 3) 26)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (profunctor-lmap p)\n  (caddr p))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [lm (profunctor-lmap p)]\n       [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))])\n  (= (fn 3) 26)))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "profunctor-lmap"], "split": "eval"}
{"id": "optics_profunctor_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `lmap`\nSpec: Apply the profunctor's contravariant map on the input side.\n\nWrite exactly one Scheme function definition for `lmap`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]\n       [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))])\n  (and (= (fn 4) 9)\n       (= (fn 7) (cmp 7)))))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "lmap"], "split": "eval"}
{"id": "optics_profunctor_translation_001", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `make-profunctor`\n\n```python\ndef build_profunctor(dimap_fn):\n    return [\n        \"profunctor\",\n        dimap_fn,\n        lambda f, pa: dimap_fn(f, identity, pa),\n        lambda g, pa: dimap_fn(identity, g, pa),\n    ]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (cadr p)] [lm (caddr p)] [rm (cadddr p)] [h (lambda (n) (+ n 3))] [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)] [lm-fn (lm (lambda (n) (* n 2)) h)] [rm-fn (rm (lambda (n) (* n 10)) h)]) (and (= (d-fn 4) 10) (= (lm-fn 1) 5) (= (rm-fn 1) 40))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (cadr p)]\n       [lm (caddr p)]\n       [rm (cadddr p)]\n       [h (lambda (n) (+ n 3))]\n       [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)]\n       [lm-fn (lm (lambda (n) (* n 2)) h)]\n       [rm-fn (rm (lambda (n) (* n 10)) h)])\n  (and (= (d-fn 4) 10)\n       (= (lm-fn 1) 5)\n       (= (rm-fn 1) 40))))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "make-profunctor"], "split": "eval"}
{"id": "optics_profunctor_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `profunctor-rmap`\n\n```python\ndef get_rmap(p):\n    return p[3]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (= (fn 6) 14)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (profunctor-rmap p)\n  (cadddr p))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [rm (profunctor-rmap p)]\n       [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))])\n  (= (fn 6) 14)))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "profunctor-rmap"], "split": "eval"}
{"id": "optics_profunctor_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `rmap`\n\n```scheme\n(define (do-rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))] [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (and (= (fn 3) 106) (= (fn 8) (cmp 8)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]\n       [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))])\n  (and (= (fn 3) 106)\n       (= (fn 8) (cmp 8)))))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "rmap"], "split": "eval"}
{"id": "optics_profunctor_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-profunctor` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: Derived lmap must pre-map with f and keep identity on output; arguments are swapped.\n\n```scheme\n(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn identity f pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Derived lmap must pre-map with f and keep identity on output; arguments are swapped.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (cadr p)] [lm (caddr p)] [rm (cadddr p)] [h (lambda (n) (+ n 3))] [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)] [lm-fn (lm (lambda (n) (* n 2)) h)] [rm-fn (rm (lambda (n) (* n 10)) h)]) (and (= (d-fn 4) 10) (= (lm-fn 1) 5) (= (rm-fn 1) 40))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (cadr p)]\n       [lm (caddr p)]\n       [rm (cadddr p)]\n       [h (lambda (n) (+ n 3))]\n       [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)]\n       [lm-fn (lm (lambda (n) (* n 2)) h)]\n       [rm-fn (rm (lambda (n) (* n 10)) h)])\n  (and (= (d-fn 4) 10)\n       (= (lm-fn 1) 5)\n       (= (rm-fn 1) 40))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "make-profunctor"], "split": "eval"}
{"id": "optics_profunctor_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor-rmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: rmap accessor should return the fourth slot, not lmap.\n\n```scheme\n(define (profunctor-rmap p)\n  (caddr p))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: rmap accessor should return the fourth slot, not lmap.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (= (fn 6) 14)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (= (fn 6) 14)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (profunctor-rmap p)\n  (cadddr p))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [rm (profunctor-rmap p)]\n       [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))])\n  (= (fn 6) 14)))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor-rmap"], "split": "eval"}
{"id": "optics_profunctor_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: rmap argument order is (g pa); this version swaps them.\n\n```scheme\n(define (rmap prof g pa)\n  ((profunctor-rmap prof) pa g))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]\n       [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))])\n  (and (= (fn 3) 106)\n       (= (fn 8) (cmp 8)))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "rmap"], "split": "eval"}
{"id": "optics_profunctor_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConstruct a profunctor dictionary with standard dimap semantics and return its tag symbol.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(car (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x)))))))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (car (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))) 'profunctor))", "tags": ["tier1", "optics", "profunctor", "composition", "make-profunctor", "record"], "split": "eval"}
{"id": "optics_profunctor_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract dimap from a profunctor dictionary and apply it to evaluate at x=5.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]) (fn 5))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]) (fn 5)) 18))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-dimap", "execution"], "split": "eval"}
{"id": "optics_profunctor_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract rmap from a profunctor dictionary and evaluate the transformed function at input 6.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (fn 6))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (fn 6)) 14))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-rmap", "execution"], "split": "eval"}
{"id": "optics_profunctor_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild a dimap-transformed function and map it over '(0 1 2).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 1)) (lambda (y) (- y 1)) (lambda (z) (* z 2)))]) (map fn '(0 1 2)))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 1)) (lambda (y) (- y 1)) (lambda (z) (* z 2)))]) (map fn '(0 1 2))) '(1 3 5)))", "tags": ["tier1", "optics", "profunctor", "composition", "dimap", "map"], "split": "eval"}
{"id": "optics_profunctor_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse rmap to build a transformed function and map it over '(1 2 3).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 1)) (lambda (x) (* x 3)))]) (map fn '(1 2 3)))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 1)) (lambda (x) (* x 3)))]) (map fn '(1 2 3))) '(4 7 10)))", "tags": ["tier1", "optics", "profunctor", "composition", "rmap", "map"], "split": "eval"}
