{"id": "optics_profunctor_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `make-profunctor`\nSpec: Build a profunctor dictionary record with tag, dimap function, and derived lmap/rmap.\n\nWrite exactly one Scheme function definition for `make-profunctor`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (cadr p)]\n       [lm (caddr p)]\n       [rm (cadddr p)]\n       [h (lambda (n) (+ n 3))]\n       [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)]\n       [lm-fn (lm (lambda (n) (* n 2)) h)]\n       [rm-fn (rm (lambda (n) (* n 10)) h)])\n  (and (= (d-fn 4) 10)\n       (= (lm-fn 1) 5)\n       (= (rm-fn 1) 40))))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "make-profunctor"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `make-profunctor`\nBehavior contract: Build a profunctor dictionary record with tag, dimap function, and derived lmap/rmap.\n\n```scheme\n(define (make-profunctor dimap-fn)\n  ;; TODO: return tagged profunctor dictionary with dimap/lmap/rmap\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (cadr p)] [lm (caddr p)] [rm (cadddr p)] [h (lambda (n) (+ n 3))] [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)] [lm-fn (lm (lambda (n) (* n 2)) h)] [rm-fn (rm (lambda (n) (* n 10)) h)]) (and (= (d-fn 4) 10) (= (lm-fn 1) 5) (= (rm-fn 1) 40))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (cadr p)]\n       [lm (caddr p)]\n       [rm (cadddr p)]\n       [h (lambda (n) (+ n 3))]\n       [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)]\n       [lm-fn (lm (lambda (n) (* n 2)) h)]\n       [rm-fn (rm (lambda (n) (* n 10)) h)])\n  (and (= (d-fn 4) 10)\n       (= (lm-fn 1) 5)\n       (= (rm-fn 1) 40))))", "tags": ["tier1", "optics", "profunctor", "skeleton", "make-profunctor"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `profunctor?`\nBehavior contract: Return #t iff value is a pair tagged with symbol 'profunctor in car position.\n\n```scheme\n(define (profunctor? x)\n  ;; TODO: recognize profunctor tagged pairs\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))])\n  (and (profunctor? p)\n       (profunctor? (cons 'profunctor 'tail))\n       (not (profunctor? '(foo bar)))\n       (not (profunctor? 'profunctor))\n       (not (profunctor? #f)))))", "tags": ["tier1", "optics", "profunctor", "skeleton", "profunctor?"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `profunctor-dimap`\nSpec: Extract the dimap function from a profunctor dictionary.\n\nWrite exactly one Scheme function definition for `profunctor-dimap`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (= (fn 5) 6)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (profunctor-dimap p)\n  (cadr p))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (profunctor-dimap p)]\n       [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))])\n  (= (fn 5) 6)))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "profunctor-dimap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `profunctor-dimap`\nBehavior contract: Extract the dimap function from a profunctor dictionary.\n\n```scheme\n(define (profunctor-dimap p)\n  ;; TODO: select dimap slot from profunctor record\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (= (fn 5) 6)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (profunctor-dimap p)\n  (cadr p))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (profunctor-dimap p)]\n       [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))])\n  (= (fn 5) 6)))", "tags": ["tier1", "optics", "profunctor", "skeleton", "profunctor-dimap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `profunctor-lmap`\nBehavior contract: Extract the lmap function from a profunctor dictionary.\n\n```scheme\n(define (profunctor-lmap p)\n  ;; TODO: select lmap slot from profunctor record\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))]) (= (fn 3) 26)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (profunctor-lmap p)\n  (caddr p))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [lm (profunctor-lmap p)]\n       [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))])\n  (= (fn 3) 26)))", "tags": ["tier1", "optics", "profunctor", "skeleton", "profunctor-lmap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `profunctor-rmap`\nSpec: Extract the rmap function from a profunctor dictionary.\n\nWrite exactly one Scheme function definition for `profunctor-rmap`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (profunctor-rmap p)\n  (cadddr p))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [rm (profunctor-rmap p)]\n       [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))])\n  (= (fn 6) 14)))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "profunctor-rmap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `profunctor-rmap`\nBehavior contract: Extract the rmap function from a profunctor dictionary.\n\n```scheme\n(define (profunctor-rmap p)\n  ;; TODO: select rmap slot from profunctor record\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (= (fn 6) 14)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (profunctor-rmap p)\n  (cadddr p))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [rm (profunctor-rmap p)]\n       [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))])\n  (= (fn 6) 14)))", "tags": ["tier1", "optics", "profunctor", "skeleton", "profunctor-rmap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `dimap`\nSpec: Apply the profunctor's dimap implementation to pre-map f, post-map g, and payload pa.\n\nWrite exactly one Scheme function definition for `dimap`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]\n       [lhs (fn 5)]\n       [rhs ((rmap p (lambda (y) (* y 3))\n                  (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1))))\n             5)])\n  (and (= lhs 18) (= lhs rhs))))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "dimap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `dimap`\nBehavior contract: Apply the profunctor's dimap implementation to pre-map f, post-map g, and payload pa.\n\n```scheme\n(define (dimap prof f g pa)\n  ;; TODO: dispatch through profunctor-dimap\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))] [lhs (fn 5)] [rhs ((rmap p (lambda (y) (* y 3)) (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1)))) 5)]) (and (= lhs 18) (= lhs rhs))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]\n       [lhs (fn 5)]\n       [rhs ((rmap p (lambda (y) (* y 3))\n                  (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1))))\n             5)])\n  (and (= lhs 18) (= lhs rhs))))", "tags": ["tier1", "optics", "profunctor", "skeleton", "dimap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `lmap`\nBehavior contract: Apply the profunctor's contravariant map on the input side.\n\n```scheme\n(define (lmap prof f pa)\n  ;; TODO: dispatch through profunctor-lmap\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))] [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))]) (and (= (fn 4) 9) (= (fn 7) (cmp 7)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]\n       [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))])\n  (and (= (fn 4) 9)\n       (= (fn 7) (cmp 7)))))", "tags": ["tier1", "optics", "profunctor", "skeleton", "lmap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/optics/profunctor-optics.ss\nFunction: `rmap`\nSpec: Apply the profunctor's covariant map on the output side.\n\nWrite exactly one Scheme function definition for `rmap`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))] [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (and (= (fn 3) 106) (= (fn 8) (cmp 8)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]\n       [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))])\n  (and (= (fn 3) 106)\n       (= (fn 8) (cmp 8)))))", "tags": ["tier1", "optics", "profunctor", "spec-to-code", "rmap"], "split": "train"}
{"id": "optics_profunctor_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/optics/profunctor-optics.ss\nFunction target: `rmap`\nBehavior contract: Apply the profunctor's covariant map on the output side.\n\n```scheme\n(define (rmap prof g pa)\n  ;; TODO: dispatch through profunctor-rmap\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))] [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (and (= (fn 3) 106) (= (fn 8) (cmp 8)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]\n       [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))])\n  (and (= (fn 3) 106)\n       (= (fn 8) (cmp 8)))))", "tags": ["tier1", "optics", "profunctor", "skeleton", "rmap"], "split": "train"}
{"id": "optics_profunctor_translation_002", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `make-profunctor`\n\n```scheme\n(define (mk-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (cadr p)]\n       [lm (caddr p)]\n       [rm (cadddr p)]\n       [h (lambda (n) (+ n 3))]\n       [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)]\n       [lm-fn (lm (lambda (n) (* n 2)) h)]\n       [rm-fn (rm (lambda (n) (* n 10)) h)])\n  (and (= (d-fn 4) 10)\n       (= (lm-fn 1) 5)\n       (= (rm-fn 1) 40))))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "make-profunctor"], "split": "train"}
{"id": "optics_profunctor_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `profunctor?`\n\n```python\ndef is_profunctor(x):\n    return isinstance(x, (list, tuple)) and len(x) > 0 and x[0] == 'profunctor'\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]) (and (profunctor? p) (profunctor? (cons 'profunctor 'tail)) (not (profunctor? '(foo bar))) (not (profunctor? 'profunctor)) (not (profunctor? #f)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))])\n  (and (profunctor? p)\n       (profunctor? (cons 'profunctor 'tail))\n       (not (profunctor? '(foo bar)))\n       (not (profunctor? 'profunctor))\n       (not (profunctor? #f)))))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "profunctor?"], "split": "train"}
{"id": "optics_profunctor_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `profunctor?`\n\n```scheme\n(define (profunctor-tagged? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]) (and (profunctor? p) (profunctor? (cons 'profunctor 'tail)) (not (profunctor? '(foo bar))) (not (profunctor? 'profunctor)) (not (profunctor? #f)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))])\n  (and (profunctor? p)\n       (profunctor? (cons 'profunctor 'tail))\n       (not (profunctor? '(foo bar)))\n       (not (profunctor? 'profunctor))\n       (not (profunctor? #f)))))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "profunctor?"], "split": "train"}
{"id": "optics_profunctor_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `profunctor-dimap`\n\n```python\ndef get_dimap(p):\n    return p[1]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (= (fn 5) 6)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (profunctor-dimap p)\n  (cadr p))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (profunctor-dimap p)]\n       [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))])\n  (= (fn 5) 6)))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "profunctor-dimap"], "split": "train"}
{"id": "optics_profunctor_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `profunctor-dimap`\n\n```scheme\n(define (dimap-slot p)\n  (cadr p))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (= (fn 5) 6)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (profunctor-dimap p)\n  (cadr p))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (profunctor-dimap p)]\n       [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))])\n  (= (fn 5) 6)))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "profunctor-dimap"], "split": "train"}
{"id": "optics_profunctor_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `profunctor-lmap`\n\n```python\ndef get_lmap(p):\n    return p[2]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (profunctor-lmap p)\n  (caddr p))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [lm (profunctor-lmap p)]\n       [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))])\n  (= (fn 3) 26)))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "profunctor-lmap"], "split": "train"}
{"id": "optics_profunctor_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `profunctor-lmap`\n\n```scheme\n(define (lmap-slot p)\n  (caddr p))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (profunctor-lmap p)\n  (caddr p))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [lm (profunctor-lmap p)]\n       [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))])\n  (= (fn 3) 26)))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "profunctor-lmap"], "split": "train"}
{"id": "optics_profunctor_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `profunctor-rmap`\n\n```scheme\n(define (rmap-slot p)\n  (cadddr p))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (= (fn 6) 14)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (profunctor-rmap p)\n  (cadddr p))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [rm (profunctor-rmap p)]\n       [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))])\n  (= (fn 6) 14)))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "profunctor-rmap"], "split": "train"}
{"id": "optics_profunctor_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `dimap`\n\n```python\ndef apply_dimap(prof, f, g, pa):\n    return get_dimap(prof)(f, g, pa)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))] [lhs (fn 5)] [rhs ((rmap p (lambda (y) (* y 3)) (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1)))) 5)]) (and (= lhs 18) (= lhs rhs))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]\n       [lhs (fn 5)]\n       [rhs ((rmap p (lambda (y) (* y 3))\n                  (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1))))\n             5)])\n  (and (= lhs 18) (= lhs rhs))))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "dimap"], "split": "train"}
{"id": "optics_profunctor_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `dimap`\n\n```scheme\n(define (do-dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]\n       [lhs (fn 5)]\n       [rhs ((rmap p (lambda (y) (* y 3))\n                  (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1))))\n             5)])\n  (and (= lhs 18) (= lhs rhs))))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "dimap"], "split": "train"}
{"id": "optics_profunctor_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `lmap`\n\n```python\ndef apply_lmap(prof, f, pa):\n    return get_lmap(prof)(f, pa)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))] [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))]) (and (= (fn 4) 9) (= (fn 7) (cmp 7)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]\n       [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))])\n  (and (= (fn 4) 9)\n       (= (fn 7) (cmp 7)))))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "lmap"], "split": "train"}
{"id": "optics_profunctor_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `lmap`\n\n```scheme\n(define (do-lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))] [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))]) (and (= (fn 4) 9) (= (fn 7) (cmp 7)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]\n       [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))])\n  (and (= (fn 4) 9)\n       (= (fn 7) (cmp 7)))))", "tags": ["tier1", "optics", "profunctor", "translation", "chez", "lmap"], "split": "train"}
{"id": "optics_profunctor_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `rmap`\n\n```python\ndef apply_rmap(prof, g, pa):\n    return get_rmap(prof)(g, pa)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))] [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (and (= (fn 3) 106) (= (fn 8) (cmp 8)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]\n       [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))])\n  (and (= (fn 3) 106)\n       (= (fn 8) (cmp 8)))))", "tags": ["tier1", "optics", "profunctor", "translation", "python", "rmap"], "split": "train"}
{"id": "optics_profunctor_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-profunctor` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: Derived rmap must post-map with g and keep identity on input, not the reverse.\n\n```scheme\n(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn g identity pa))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Derived rmap must post-map with g and keep identity on input, not the reverse.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (cadr p)] [lm (caddr p)] [rm (cadddr p)] [h (lambda (n) (+ n 3))] [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)] [lm-fn (lm (lambda (n) (* n 2)) h)] [rm-fn (rm (lambda (n) (* n 10)) h)]) (and (= (d-fn 4) 10) (= (lm-fn 1) 5) (= (rm-fn 1) 40))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (cadr p)] [lm (caddr p)] [rm (cadddr p)] [h (lambda (n) (+ n 3))] [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)] [lm-fn (lm (lambda (n) (* n 2)) h)] [rm-fn (rm (lambda (n) (* n 10)) h)]) (and (= (d-fn 4) 10) (= (lm-fn 1) 5) (= (rm-fn 1) 40))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (cadr p)]\n       [lm (caddr p)]\n       [rm (cadddr p)]\n       [h (lambda (n) (+ n 3))]\n       [d-fn (d (lambda (n) (* n 2)) (lambda (n) (- n 1)) h)]\n       [lm-fn (lm (lambda (n) (* n 2)) h)]\n       [rm-fn (rm (lambda (n) (* n 10)) h)])\n  (and (= (d-fn 4) 10)\n       (= (lm-fn 1) 5)\n       (= (rm-fn 1) 40))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "make-profunctor"], "split": "train"}
{"id": "optics_profunctor_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor?` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: Tag symbol is misspelled; it must match 'profunctor exactly.\n\n```scheme\n(define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunct)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]) (and (profunctor? p) (profunctor? (cons 'profunctor 'tail)) (not (profunctor? '(foo bar))) (not (profunctor? 'profunctor)) (not (profunctor? #f)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))])\n  (and (profunctor? p)\n       (profunctor? (cons 'profunctor 'tail))\n       (not (profunctor? '(foo bar)))\n       (not (profunctor? 'profunctor))\n       (not (profunctor? #f)))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor?"], "split": "train"}
{"id": "optics_profunctor_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor?` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: Recognizer must accept any tagged pair, including improper pairs created with cons.\n\n```scheme\n(define (profunctor? x)\n  (and (list? x) (eq? (car x) 'profunctor)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]) (and (profunctor? p) (profunctor? (cons 'profunctor 'tail)) (not (profunctor? '(foo bar))) (not (profunctor? 'profunctor)) (not (profunctor? #f)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))])\n  (and (profunctor? p)\n       (profunctor? (cons 'profunctor 'tail))\n       (not (profunctor? '(foo bar)))\n       (not (profunctor? 'profunctor))\n       (not (profunctor? #f)))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor?"], "split": "train"}
{"id": "optics_profunctor_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor-dimap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: dimap slot is the second element, not the third.\n\n```scheme\n(define (profunctor-dimap p)\n  (caddr p))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (= (fn 5) 6)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (profunctor-dimap p)\n  (cadr p))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (profunctor-dimap p)]\n       [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))])\n  (= (fn 5) 6)))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor-dimap"], "split": "train"}
{"id": "optics_profunctor_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor-dimap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: dimap accessor is reading the rmap slot instead of dimap.\n\n```scheme\n(define (profunctor-dimap p)\n  (cadddr p))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (= (fn 5) 6)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (profunctor-dimap p)\n  (cadr p))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [d (profunctor-dimap p)]\n       [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))])\n  (= (fn 5) 6)))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor-dimap"], "split": "train"}
{"id": "optics_profunctor_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor-lmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: lmap accessor should return the third slot, not dimap.\n\n```scheme\n(define (profunctor-lmap p)\n  (cadr p))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))]) (= (fn 3) 26)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (profunctor-lmap p)\n  (caddr p))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [lm (profunctor-lmap p)]\n       [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))])\n  (= (fn 3) 26)))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor-lmap"], "split": "train"}
{"id": "optics_profunctor_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor-lmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: lmap accessor is pointing at rmap; use caddr.\n\n```scheme\n(define (profunctor-lmap p)\n  (cadddr p))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (profunctor-lmap p)\n  (caddr p))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [lm (profunctor-lmap p)]\n       [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))])\n  (= (fn 3) 26)))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor-lmap"], "split": "train"}
{"id": "optics_profunctor_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `profunctor-rmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: rmap accessor is reading dimap; use cadddr.\n\n```scheme\n(define (profunctor-rmap p)\n  (cadr p))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (= (fn 6) 14)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (profunctor-rmap p)\n  (cadddr p))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [rm (profunctor-rmap p)]\n       [fn (rm (lambda (y) (- y 4)) (lambda (z) (* z 3)))])\n  (= (fn 6) 14)))", "tags": ["tier1", "optics", "profunctor", "bugfix", "profunctor-rmap"], "split": "train"}
{"id": "optics_profunctor_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dimap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: dimap must apply both input and output mappings through profunctor-dimap.\n\n```scheme\n(define (dimap prof f g pa)\n  ((profunctor-lmap prof) f pa))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))] [lhs (fn 5)] [rhs ((rmap p (lambda (y) (* y 3)) (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1)))) 5)]) (and (= lhs 18) (= lhs rhs))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]\n       [lhs (fn 5)]\n       [rhs ((rmap p (lambda (y) (* y 3))\n                  (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1))))\n             5)])\n  (and (= lhs 18) (= lhs rhs))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "dimap"], "split": "train"}
{"id": "optics_profunctor_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dimap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: Input and output maps are reversed; keep order (f g pa).\n\n```scheme\n(define (dimap prof f g pa)\n  ((profunctor-dimap prof) g f pa))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Input and output maps are reversed; keep order (f g pa).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))] [lhs (fn 5)] [rhs ((rmap p (lambda (y) (* y 3)) (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1)))) 5)]) (and (= lhs 18) (= lhs rhs))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))] [lhs (fn 5)] [rhs ((rmap p (lambda (y) (* y 3)) (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1)))) 5)]) (and (= lhs 18) (= lhs rhs))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]\n       [lhs (fn 5)]\n       [rhs ((rmap p (lambda (y) (* y 3))\n                  (lmap p (lambda (x) (+ x 2)) (lambda (z) (- z 1))))\n             5)])\n  (and (= lhs 18) (= lhs rhs))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "dimap"], "split": "train"}
{"id": "optics_profunctor_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: lmap must dispatch to profunctor-lmap, not profunctor-rmap.\n\n```scheme\n(define (lmap prof f pa)\n  ((profunctor-rmap prof) f pa))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))] [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))]) (and (= (fn 4) 9) (= (fn 7) (cmp 7)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]\n       [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))])\n  (and (= (fn 4) 9)\n       (= (fn 7) (cmp 7)))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "lmap"], "split": "train"}
{"id": "optics_profunctor_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: lmap argument order is (f pa); this version passes them reversed.\n\n```scheme\n(define (lmap prof f pa)\n  ((profunctor-lmap prof) pa f))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]\n       [cmp (dimap p (lambda (x) (* x 2)) identity (lambda (z) (+ z 1)))])\n  (and (= (fn 4) 9)\n       (= (fn 7) (cmp 7)))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "lmap"], "split": "train"}
{"id": "optics_profunctor_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rmap` in `lattice/optics/profunctor-optics.ss`.\nKnown issue: rmap must dispatch to profunctor-rmap, not profunctor-lmap.\n\n```scheme\n(define (rmap prof g pa)\n  ((profunctor-lmap prof) g pa))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: rmap must dispatch to profunctor-rmap, not profunctor-lmap.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))] [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (and (= (fn 3) 106) (= (fn 8) (cmp 8)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))] [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (and (= (fn 3) 106) (= (fn 8) (cmp 8)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))]\n       [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]\n       [cmp (dimap p identity (lambda (y) (+ y 100)) (lambda (z) (* z 2)))])\n  (and (= (fn 3) 106)\n       (= (fn 8) (cmp 8)))))", "tags": ["tier1", "optics", "profunctor", "bugfix", "rmap"], "split": "train"}
{"id": "optics_profunctor_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild a profunctor with canonical dimap behavior, extract dimap, and evaluate the transformed function at 5.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (fn 5))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d (lambda (x) (+ x 1)) (lambda (y) (* y 2)) (lambda (z) (- z 3)))]) (fn 5)) 6))", "tags": ["tier1", "optics", "profunctor", "composition", "make-profunctor", "execution"], "split": "train"}
{"id": "optics_profunctor_composition_003", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: small integration task across module primitives.\n\nUsing a profunctor built by make-profunctor, verify derived lmap matches dimap with identity output mapping.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 4))] [lhs ((profunctor-lmap p) (lambda (x) (* x 2)) h)] [rhs ((profunctor-dimap p) (lambda (x) (* x 2)) identity h)]) (= (lhs 3) (rhs 3)))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 4))] [lhs ((profunctor-lmap p) (lambda (x) (* x 2)) h)] [rhs ((profunctor-dimap p) (lambda (x) (* x 2)) identity h)]) (= (lhs 3) (rhs 3))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "make-profunctor", "law"], "split": "train"}
{"id": "optics_profunctor_composition_004", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "make-profunctor", "prompt": "Task mode: compose existing APIs into one expression.\n\nUsing a profunctor built by make-profunctor, verify derived rmap matches dimap with identity input mapping.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (* x 5))] [lhs ((profunctor-rmap p) (lambda (y) (- y 2)) h)] [rhs ((profunctor-dimap p) identity (lambda (y) (- y 2)) h)]) (= (lhs 6) (rhs 6)))", "verify_expr": "(let ()\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (* x 5))] [lhs ((profunctor-rmap p) (lambda (y) (- y 2)) h)] [rhs ((profunctor-dimap p) identity (lambda (y) (- y 2)) h)]) (= (lhs 6) (rhs 6))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "make-profunctor", "law"], "split": "train"}
{"id": "optics_profunctor_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: compose existing APIs into one expression.\n\nClassify a valid profunctor dictionary and a plain list using profunctor?.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(list (profunctor? (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))) (profunctor? '(foo bar)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (list (profunctor? (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))) (profunctor? '(foo bar))) '(#t #f)))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor?", "classification"], "split": "train"}
{"id": "optics_profunctor_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCount how many entries in a mixed list are recognized by profunctor?.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(length (filter profunctor? (list (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x)))))) '(profunctor) (cons 'profunctor 'tail) 7 '())))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (length (filter profunctor? (list (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x)))))) '(profunctor) (cons 'profunctor 'tail) 7 '()))) 3))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor?", "filter"], "split": "train"}
{"id": "optics_profunctor_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: small integration task across module primitives.\n\nCheck whether an improper pair tagged with 'profunctor is accepted by profunctor?.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(profunctor? (cons 'profunctor 'tail))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (equal? (profunctor? (cons 'profunctor 'tail)) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor?", "pair-shape"], "split": "train"}
{"id": "optics_profunctor_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether profunctor? rejects three non-pair inputs.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and (not (profunctor? 'profunctor)) (not (profunctor? #f)) (not (profunctor? 0)))", "verify_expr": "(let ()\n  (define (profunctor? x)\n  (and (pair? x) (eq? (car x) 'profunctor)))\n  (equal? (and (not (profunctor? 'profunctor)) (not (profunctor? #f)) (not (profunctor? 0))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor?", "negative-cases"], "split": "train"}
{"id": "optics_profunctor_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: small integration task across module primitives.\n\nVerify profunctor-dimap extraction agrees with the top-level dimap wrapper on the same inputs.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 7))] [a ((profunctor-dimap p) (lambda (x) (* x 2)) (lambda (y) (- y 5)) h)] [b (dimap p (lambda (x) (* x 2)) (lambda (y) (- y 5)) h)]) (= (a 4) (b 4)))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 7))] [a ((profunctor-dimap p) (lambda (x) (* x 2)) (lambda (y) (- y 5)) h)] [b (dimap p (lambda (x) (* x 2)) (lambda (y) (- y 5)) h)]) (= (a 4) (b 4))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-dimap", "agreement"], "split": "train"}
{"id": "optics_profunctor_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse extracted dimap to build a transformed function and map it over '(1 2 3).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d identity (lambda (y) (+ y 1)) (lambda (z) (* z 2)))]) (map fn '(1 2 3)))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [d (profunctor-dimap p)] [fn (d identity (lambda (y) (+ y 1)) (lambda (z) (* z 2)))]) (map fn '(1 2 3))) '(3 5 7)))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-dimap", "map"], "split": "train"}
{"id": "optics_profunctor_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-dimap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply profunctor-dimap with both nontrivial pre-map and post-map and return the numeric result at input 2.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn ((profunctor-dimap p) (lambda (x) (+ x 10)) (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (fn 2))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn ((profunctor-dimap p) (lambda (x) (+ x 10)) (lambda (y) (- y 4)) (lambda (z) (* z 3)))]) (fn 2)) 32))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-dimap", "pre-post"], "split": "train"}
{"id": "optics_profunctor_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: small integration task across module primitives.\n\nExtract lmap from a profunctor dictionary and evaluate the transformed function at input 3.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))]) (fn 3))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (+ x 10)) (lambda (z) (* z 2)))]) (fn 3)) 26))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-lmap", "execution"], "split": "train"}
{"id": "optics_profunctor_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nShow profunctor-lmap is equivalent to dimap with identity post-map for one input.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 1))] [a ((profunctor-lmap p) (lambda (x) (* x 3)) h)] [b ((profunctor-dimap p) (lambda (x) (* x 3)) identity h)]) (= (a 6) (b 6)))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 1))] [a ((profunctor-lmap p) (lambda (x) (* x 3)) h)] [b ((profunctor-dimap p) (lambda (x) (* x 3)) identity h)]) (= (a 6) (b 6))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-lmap", "law"], "split": "train"}
{"id": "optics_profunctor_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract lmap, build a transformed function, and map it over '(1 2 3).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (* x 3)) (lambda (z) (- z 1)))]) (map fn '(1 2 3)))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (* x 3)) (lambda (z) (- z 1)))]) (map fn '(1 2 3))) '(2 5 8)))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-lmap", "map"], "split": "train"}
{"id": "optics_profunctor_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-lmap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse profunctor-lmap with a pair-producing base function and return the transformed pair at input 3.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (* x 2)) (lambda (x) (cons x (+ x 1))))]) (fn 3))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [lm (profunctor-lmap p)] [fn (lm (lambda (x) (* x 2)) (lambda (x) (cons x (+ x 1))))]) (fn 3)) '(6 . 7)))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-lmap", "shape-change"], "split": "train"}
{"id": "optics_profunctor_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: small integration task across module primitives.\n\nShow profunctor-rmap is equivalent to dimap with identity input map for one input.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 2))] [a ((profunctor-rmap p) (lambda (y) (* y 5)) h)] [b ((profunctor-dimap p) identity (lambda (y) (* y 5)) h)]) (= (a 3) (b 3)))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 2))] [a ((profunctor-rmap p) (lambda (y) (* y 5)) h)] [b ((profunctor-dimap p) identity (lambda (y) (* y 5)) h)]) (= (a 3) (b 3))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-rmap", "law"], "split": "train"}
{"id": "optics_profunctor_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract rmap, build an output-transformed function, and map it over '(1 2 3).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (* y y)) (lambda (x) (+ x 1)))]) (map fn '(1 2 3)))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (* y y)) (lambda (x) (+ x 1)))]) (map fn '(1 2 3))) '(4 9 16)))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-rmap", "map"], "split": "train"}
{"id": "optics_profunctor_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "profunctor-rmap", "prompt": "Task mode: small integration task across module primitives.\n\nUse profunctor-rmap to post-process a numeric result into a tagged pair.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (cons 'out y)) (lambda (x) (* x 4)))]) (fn 3))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [rm (profunctor-rmap p)] [fn (rm (lambda (y) (cons 'out y)) (lambda (x) (* x 4)))]) (fn 3)) '(out . 12)))", "tags": ["tier1", "optics", "profunctor", "composition", "profunctor-rmap", "shape-change"], "split": "train"}
{"id": "optics_profunctor_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply dimap through a function profunctor and evaluate at input 5.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]) (fn 5))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (dimap p (lambda (x) (+ x 2)) (lambda (y) (* y 3)) (lambda (z) (- z 1)))]) (fn 5)) 18))", "tags": ["tier1", "optics", "profunctor", "composition", "dimap", "execution"], "split": "train"}
{"id": "optics_profunctor_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that dimap with identity/identity leaves behavior unchanged for a sample function.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (- x 2))] [a ((dimap p identity identity h) 9)] [b (h 9)]) (= a b))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (- x 2))] [a ((dimap p identity identity h) 9)] [b (h 9)]) (= a b)) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "dimap", "identity-law"], "split": "train"}
{"id": "optics_profunctor_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "dimap", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify dimap equals rmap-after-lmap for the same pre and post maps.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [f (lambda (x) (* x 2))] [g (lambda (y) (+ y 1))] [h (lambda (x) (- x 3))] [a (dimap p f g h)] [b (rmap p g (lmap p f h))]) (= (a 10) (b 10)))", "verify_expr": "(let ()\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [f (lambda (x) (* x 2))] [g (lambda (y) (+ y 1))] [h (lambda (x) (- x 3))] [a (dimap p f g h)] [b (rmap p g (lmap p f h))]) (= (a 10) (b 10))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "dimap", "factorization"], "split": "train"}
{"id": "optics_profunctor_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: small integration task across module primitives.\n\nApply lmap through a function profunctor and evaluate at input 4.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]) (fn 4))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (* x 2)) (lambda (z) (+ z 1)))]) (fn 4)) 9))", "tags": ["tier1", "optics", "profunctor", "composition", "lmap", "execution"], "split": "train"}
{"id": "optics_profunctor_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that lmap equals dimap with identity output mapping on a shared example.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [f (lambda (x) (+ x 5))] [h (lambda (x) (* x 2))] [a (lmap p f h)] [b (dimap p f identity h)]) (= (a 3) (b 3)))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [f (lambda (x) (+ x 5))] [h (lambda (x) (* x 2))] [a (lmap p f h)] [b (dimap p f identity h)]) (= (a 3) (b 3))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "lmap", "agreement"], "split": "train"}
{"id": "optics_profunctor_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify sequential lmap applications match one combined pre-map.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 1))] [f1 (lmap p (lambda (x) (+ x 2)) h)] [f2 (lmap p (lambda (x) (* x 3)) f1)] [f3 (lmap p (lambda (x) (+ (* 3 x) 2)) h)]) (= (f2 4) (f3 4)))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (+ x 1))] [f1 (lmap p (lambda (x) (+ x 2)) h)] [f2 (lmap p (lambda (x) (* x 3)) f1)] [f3 (lmap p (lambda (x) (+ (* 3 x) 2)) h)]) (= (f2 4) (f3 4))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "lmap", "composition-law"], "split": "train"}
{"id": "optics_profunctor_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "lmap", "prompt": "Task mode: compose existing APIs into one expression.\n\nUse lmap to build a transformed function and map it over '(2 4 6).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (/ x 2)) (lambda (z) (+ z 7)))]) (map fn '(2 4 6)))", "verify_expr": "(let ()\n  (define (profunctor-lmap p)\n  (caddr p))\n  (define (lmap prof f pa)\n  ((profunctor-lmap prof) f pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (lmap p (lambda (x) (/ x 2)) (lambda (z) (+ z 7)))]) (map fn '(2 4 6))) '(8 9 10)))", "tags": ["tier1", "optics", "profunctor", "composition", "lmap", "map"], "split": "train"}
{"id": "optics_profunctor_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply rmap through a function profunctor and evaluate at input 3.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (fn 3))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [fn (rmap p (lambda (y) (+ y 100)) (lambda (z) (* z 2)))]) (fn 3)) 106))", "tags": ["tier1", "optics", "profunctor", "composition", "rmap", "execution"], "split": "train"}
{"id": "optics_profunctor_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that rmap equals dimap with identity input mapping on a shared example.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [g (lambda (y) (* y 4))] [h (lambda (x) (+ x 1))] [a (rmap p g h)] [b (dimap p identity g h)]) (= (a 5) (b 5)))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (define (profunctor-dimap p)\n  (cadr p))\n  (define (dimap prof f g pa)\n  ((profunctor-dimap prof) f g pa))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [g (lambda (y) (* y 4))] [h (lambda (x) (+ x 1))] [a (rmap p g h)] [b (dimap p identity g h)]) (= (a 5) (b 5))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "rmap", "agreement"], "split": "train"}
{"id": "optics_profunctor_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/profunctor-optics.ss", "source_test": "lattice/optics/test-profunctor-optics.ss", "source_function": "rmap", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nVerify sequential rmap applications match one combined post-map.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (* x 2))] [r1 (rmap p (lambda (y) (+ y 3)) h)] [r2 (rmap p (lambda (y) (* y 5)) r1)] [r3 (rmap p (lambda (y) (* (+ y 3) 5)) h)]) (= (r2 4) (r3 4)))", "verify_expr": "(let ()\n  (define (profunctor-rmap p)\n  (cadddr p))\n  (define (rmap prof g pa)\n  ((profunctor-rmap prof) g pa))\n  (define (identity x)\n  x)\n  (define (make-profunctor dimap-fn)\n  (list 'profunctor\n        dimap-fn\n        (lambda (f pa) (dimap-fn f identity pa))\n        (lambda (g pa) (dimap-fn identity g pa))))\n  (equal? (let* ([p (make-profunctor (lambda (f g h) (lambda (x) (g (h (f x))))))] [h (lambda (x) (* x 2))] [r1 (rmap p (lambda (y) (+ y 3)) h)] [r2 (rmap p (lambda (y) (* y 5)) r1)] [r3 (rmap p (lambda (y) (* (+ y 3) 5)) h)]) (= (r2 4) (r3 4))) #t))", "tags": ["tier1", "optics", "profunctor", "composition", "rmap", "composition-law"], "split": "train"}
