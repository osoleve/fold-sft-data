{"id": "matrix_decomp_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-set!`\nSpec: Mutate matrix element at row i, column j to val using row-major indexing.\n\nWrite exactly one `define` for `matrix-set!`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (and (= (matrix-ref m 1 0) 7) (= (matrix-ref m 0 1) 0)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))", "verify_expr": "(let ()\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (let ([m (make-matrix 2 2 0)])\n  (matrix-set! m 1 0 7)\n  (and (= (matrix-ref m 1 0) 7)\n       (= (matrix-ref m 0 1) 0))))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-set!"], "split": "eval"}
{"id": "matrix_decomp_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-lu`\nSpec: Compute LU decomposition with partial pivoting, returning `(list L U P)` or `(error ...)`.\n\nWrite exactly one `define` for `matrix-lu`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (let* ([a (matrix-from-lists '((4 3) (6 3)))]\n       [res (matrix-lu a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let ([l (car res)]\n             [u (cadr res)]\n             [p (caddr res)])\n         (and (= (vector-length p) 2)\n              (= (matrix-ref l 0 0) 1)\n              (= (matrix-ref l 1 1) 1)\n              (approx=? (matrix-ref u 1 0) 0 1e-10))))))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-lu"], "split": "eval"}
{"id": "matrix_decomp_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `permutation-sign`\nSpec: Return +1 for even permutations and -1 for odd permutations.\n\nWrite exactly one `define` for `permutation-sign`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (permutation-sign '#(0 1 2 3)) 1)\n(= (permutation-sign '#(1 0 2 3)) -1)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))", "verify_expr": "(let ()\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (and (= (permutation-sign '#(0 1 2 3)) 1)\n     (= (permutation-sign '#(1 0 2 3)) -1)\n     (= (permutation-sign '#(1 2 0 3)) 1)))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "permutation-sign"], "split": "eval"}
{"id": "matrix_decomp_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-copy`.\n\n```python\ndef matrix_copy(m):\n    rows, cols, data = m.rows, m.cols, m.data\n    out = [0] * (rows * cols)\n    for i in range(rows * cols):\n        out[i] = data[i]\n    return Matrix(rows, cols, out)\n```\n\nReturn only the Fold definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-set! c 0 0 99) (and (= (matrix-ref m 0 0) 1) (= (matrix-ref c 0 0) 99) (= (matrix-ref c 1 1) 4)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-copy"], "split": "eval"}
{"id": "matrix_decomp_translation_009", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-lu-solve`.\n\n```python\ndef matrix_lu_solve(lu_result, b):\n    L, U, p = lu_result\n    n = len(b)\n    pb = [b[p[i]] for i in range(n)]\n\n    y = [0] * n\n    for i in range(n):\n        s = 0\n        for j in range(i):\n            s += L.ref(i, j) * y[j]\n        y[i] = pb[i] - s\n\n    x = [0] * n\n    for i in range(n - 1, -1, -1):\n        s = 0\n        for j in range(i + 1, n):\n            s += U.ref(i, j) * x[j]\n        x[i] = (y[i] - s) / U.ref(i, i)\n    return x\n```\n\nReturn only the Fold definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [lu (matrix-lu a)] [x (matrix-lu-solve lu b)] [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1)))] [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0)) (* (matrix-ref a 1 1) (vector-ref x 1)))]) (and (approx=? ax0 5 1e-8) (approx=? ax1 6 1e-8)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-lu-solve"], "split": "eval"}
{"id": "matrix_decomp_translation_016", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-det`\n\n```scheme\n(define (matrix-det0 a)\n  (let ((res (matrix-lu a)))\n    (if (and (pair? res) (eq? (car res) 'error))\n        (if (eq? (cadr res) 'singular-matrix)\n            0\n            res)\n        (let ((u (cadr res))\n              (p (caddr res)))\n          (let ((n (matrix-rows u)))\n            (let loop ((i 0) (prod 1))\n              (if (= i n)\n                  (* prod (permutation-sign p))\n                  (loop (+ i 1) (* prod (matrix-ref u i i))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n(= (matrix-det (matrix-identity 3)) 1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-det"], "split": "eval"}
{"id": "matrix_decomp_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-copy` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Returns original matrix instead of deep copy; mutations to copy alias original.\n\n```scheme\n(define (matrix-copy m)\n  m)\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-copy"], "split": "eval"}
{"id": "matrix_decomp_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-lu-solve` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Fails to apply permutation vector to RHS before substitution.\n\n```scheme\n(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b i)))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [lu (matrix-lu a)] [x (matrix-lu-solve lu b)] [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1)))] [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0)) (* (matrix-ref a 1 1) (vector-ref x 1)))]) (and (approx=? ax0 5 1e-8) (approx=? ax1 6 1e-8)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-lu-solve"], "split": "eval"}
{"id": "matrix_decomp_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-det` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Drops permutation sign correction term.\n\n```scheme\n(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              prod\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n```\n\nReturn only the corrected function definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n(= (matrix-det (matrix-identity 3)) 1)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-det"], "split": "eval"}
{"id": "matrix_decomp_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: compose existing APIs into one expression.\n\nCopy a 2x2 matrix and return the copied bottom-right value.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-ref c 1 1)) 4)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-ref c 1 1))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-ref c 1 1)) 4))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-copy", "direct"], "split": "eval"}
{"id": "matrix_decomp_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn column 1 of a 3x3 matrix.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1) '#(2 5 8))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1) '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-column", "direct"], "split": "eval"}
{"id": "matrix_decomp_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: compose existing APIs into one expression.\n\nSolve a 2x2 linear system and return x[0].\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(let ([x0 (let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 0))]) (< (abs (- x0 1.8)) 1e-8))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (let ([x0 (let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 0))]) (< (abs (- x0 1.8)) 1e-8)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu-solve", "direct"], "split": "eval"}
{"id": "matrix_decomp_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute reconstructed entry (1,0) from L*L^T for a 2x2 PD matrix.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(let ([v (let* ([a (matrix-from-lists '((4 12) (12 37)))] [l (car (matrix-cholesky a))] [llt (matrix-mul l (matrix-transpose l))]) (matrix-ref llt 1 0))]) (< (abs (- v 12)) 1e-6))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (matrix-from-lists '((4 12) (12 37)))] [l (car (matrix-cholesky a))] [llt (matrix-mul l (matrix-transpose l))]) (matrix-ref llt 1 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (let ([v (let* ([a (matrix-from-lists '((4 12) (12 37)))] [l (car (matrix-cholesky a))] [llt (matrix-mul l (matrix-transpose l))]) (matrix-ref llt 1 0))]) (< (abs (- v 12)) 1e-6)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-cholesky", "integration"], "split": "eval"}
{"id": "matrix_decomp_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn determinant of upper-triangular 3x3 matrix.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L) × det(U) × sign(P) = 1 × (product of U diagonal) × sign(P). Complexity: O(n³) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-det", "property"], "split": "eval"}
