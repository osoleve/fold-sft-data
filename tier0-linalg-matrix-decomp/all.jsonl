{"id": "matrix_decomp_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-copy`\nSpec: Deep copy a matrix into a new matrix structure with independent backing storage.\n\nWrite exactly one `define` for `matrix-copy`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-copy"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `matrix-copy`\nBehavior contract: Deep copy a matrix into a new matrix structure with independent backing storage.\n\n```scheme\n(define (matrix-copy m)\n  ;; TODO: allocate new data vector and copy all entries\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "matrix-copy"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `matrix-set!`\nBehavior contract: Mutate matrix element at row i, column j to val using row-major indexing.\n\n```scheme\n(define (matrix-set! m i j val)\n  ;; TODO: mutate underlying row-major data vector at (i,j)\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (and (= (matrix-ref m 1 0) 7) (= (matrix-ref m 0 1) 0)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))", "verify_expr": "(let ()\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (let ([m (make-matrix 2 2 0)])\n  (matrix-set! m 1 0 7)\n  (and (= (matrix-ref m 1 0) 7)\n       (= (matrix-ref m 0 1) 0))))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "matrix-set!"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-column`\nSpec: Extract column j as a dense vector of length matrix-rows.\n\nWrite exactly one `define` for `matrix-column`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)\n        '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-column"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `matrix-column`\nBehavior contract: Extract column j as a dense vector of length matrix-rows.\n\n```scheme\n(define (matrix-column m j)\n  ;; TODO: extract column j into a vector of length (matrix-rows m)\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1) '#(2 5 8))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)\n        '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "matrix-column"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `matrix-lu`\nBehavior contract: Compute LU decomposition with partial pivoting, returning `(list L U P)` or `(error ...)`.\n\n```scheme\n(define (matrix-lu a)\n  ;; TODO: LU decomposition with partial pivoting\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (matrix-from-lists '((4 3) (6 3)))] [res (matrix-lu a)]) (and (pair? res) (not (eq? (car res) 'error)) (let ([l (car res)] [u (cadr res)] [p (caddr res)]) (and (= (vector-length p) 2) (= (matrix-ref l 0 0) 1) (= (matrix-ref l 1 1) 1) (approx=? (matrix-ref u 1 0) 0 1e-10)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (let* ([a (matrix-from-lists '((4 3) (6 3)))]\n       [res (matrix-lu a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let ([l (car res)]\n             [u (cadr res)]\n             [p (caddr res)])\n         (and (= (vector-length p) 2)\n              (= (matrix-ref l 0 0) 1)\n              (= (matrix-ref l 1 1) 1)\n              (approx=? (matrix-ref u 1 0) 0 1e-10))))))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "matrix-lu"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-lu-solve`\nSpec: Solve `Ax=b` given LU decomposition result `(L U P)` using permutation + forward/back substitution.\n\nWrite exactly one `define` for `matrix-lu-solve`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [lu (matrix-lu a)] [x (matrix-lu-solve lu b)] [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1)))] [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0)) (* (matrix-ref a 1 1) (vector-ref x 1)))]) (and (approx=? ax0 5 1e-8) (approx=? ax1 6 1e-8)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-lu-solve"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `matrix-lu-solve`\nBehavior contract: Solve `Ax=b` given LU decomposition result `(L U P)` using permutation + forward/back substitution.\n\n```scheme\n(define (matrix-lu-solve lu-result b)\n  ;; TODO: apply permutation, then forward/back substitute\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "matrix-lu-solve"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-cholesky`\nSpec: Compute Cholesky factor L for positive-definite square matrix A such that A = L*L^T.\n\nWrite exactly one `define` for `matrix-cholesky`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (matrix-from-lists '((4 12) (12 37)))] [res (matrix-cholesky a)]) (and (pair? res) (not (eq? (car res) 'error)) (let* ([l (car res)] [lt (matrix-transpose l)] [llt (matrix-mul l lt)]) (and (approx=? (matrix-ref llt 0 0) 4 1e-6) (approx=? (matrix-ref llt 0 1) 12 1e-6) (approx=? (matrix-ref llt 1 1) 37 1e-6)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (let* ([a (matrix-from-lists '((4 12) (12 37)))]\n       [res (matrix-cholesky a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let* ([l (car res)]\n              [lt (matrix-transpose l)]\n              [llt (matrix-mul l lt)])\n         (and (approx=? (matrix-ref llt 0 0) 4 1e-6)\n              (approx=? (matrix-ref llt 0 1) 12 1e-6)\n              (approx=? (matrix-ref llt 1 1) 37 1e-6))))))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-cholesky"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `matrix-cholesky`\nBehavior contract: Compute Cholesky factor L for positive-definite square matrix A such that A = L*L^T.\n\n```scheme\n(define (matrix-cholesky a)\n  ;; TODO: lower-triangular Cholesky decomposition with PD checks\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (matrix-from-lists '((4 12) (12 37)))] [res (matrix-cholesky a)]) (and (pair? res) (not (eq? (car res) 'error)) (let* ([l (car res)] [lt (matrix-transpose l)] [llt (matrix-mul l lt)]) (and (approx=? (matrix-ref llt 0 0) 4 1e-6) (approx=? (matrix-ref llt 0 1) 12 1e-6) (approx=? (matrix-ref llt 1 1) 37 1e-6)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (let* ([a (matrix-from-lists '((4 12) (12 37)))]\n       [res (matrix-cholesky a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let* ([l (car res)]\n              [lt (matrix-transpose l)]\n              [llt (matrix-mul l lt)])\n         (and (approx=? (matrix-ref llt 0 0) 4 1e-6)\n              (approx=? (matrix-ref llt 0 1) 12 1e-6)\n              (approx=? (matrix-ref llt 1 1) 37 1e-6))))))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "matrix-cholesky"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `permutation-sign`\nBehavior contract: Return +1 for even permutations and -1 for odd permutations.\n\n```scheme\n(define (permutation-sign p)\n  ;; TODO: count inversions and return +/-1\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (permutation-sign '#(0 1 2 3)) 1)\n(= (permutation-sign '#(1 0 2 3)) -1)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))", "verify_expr": "(let ()\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (and (= (permutation-sign '#(0 1 2 3)) 1)\n     (= (permutation-sign '#(1 0 2 3)) -1)\n     (= (permutation-sign '#(1 2 0 3)) 1)))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "permutation-sign"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-det`\nSpec: Compute determinant via LU decomposition, including permutation sign correction.\n\nWrite exactly one `define` for `matrix-det`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-det"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix-decomp.ss\nTarget function: `matrix-det`\nBehavior contract: Compute determinant via LU decomposition, including permutation sign correction.\n\n```scheme\n(define (matrix-det a)\n  ;; TODO: determinant via LU + permutation sign\n  <TODO>)\n```\n\nReturn only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n(= (matrix-det (matrix-identity 3)) 1)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "skeleton", "matrix-det"], "split": "train"}
{"id": "matrix_decomp_translation_002", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-copy`\n\n```scheme\n(define (matrix-copy0 m)\n  (let* ((rows (matrix-rows m))\n         (cols (matrix-cols m))\n         (data (matrix-data m))\n         (out (make-vector (* rows cols) 0)))\n    (do ((i 0 (+ i 1)))\n        ((= i (* rows cols)) (list 'matrix rows cols out))\n      (vector-set! out i (vector-ref data i)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-set! c 0 0 99) (and (= (matrix-ref m 0 0) 1) (= (matrix-ref c 0 0) 99) (= (matrix-ref c 1 1) 4)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-copy"], "split": "train"}
{"id": "matrix_decomp_translation_003", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-set!`.\n\n```python\ndef matrix_set(m, i, j, val):\n    idx = i * m.cols + j\n    m.data[idx] = val\n```\n\nReturn only the Fold definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (and (= (matrix-ref m 1 0) 7) (= (matrix-ref m 0 1) 0)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))", "verify_expr": "(let ()\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (let ([m (make-matrix 2 2 0)])\n  (matrix-set! m 1 0 7)\n  (and (= (matrix-ref m 1 0) 7)\n       (= (matrix-ref m 0 1) 0))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-set!"], "split": "train"}
{"id": "matrix_decomp_translation_004", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-set!`\n\n```scheme\n(define (matrix-set!0 m i j v)\n  (let ((cols (matrix-cols m))\n        (data (matrix-data m)))\n    (vector-set! data (+ (* i cols) j) v)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))", "verify_expr": "(let ()\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (let ([m (make-matrix 2 2 0)])\n  (matrix-set! m 1 0 7)\n  (and (= (matrix-ref m 1 0) 7)\n       (= (matrix-ref m 0 1) 0))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-set!"], "split": "train"}
{"id": "matrix_decomp_translation_005", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-column`.\n\n```python\ndef matrix_column(m, j):\n    out = [0] * m.rows\n    for i in range(m.rows):\n        out[i] = m.ref(i, j)\n    return out\n```\n\nReturn only the Fold definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1) '#(2 5 8))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)\n        '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-column"], "split": "train"}
{"id": "matrix_decomp_translation_006", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-column`\n\n```scheme\n(define (matrix-column0 m j)\n  (let* ((rows (matrix-rows m))\n         (out (make-vector rows 0)))\n    (do ((i 0 (+ i 1)))\n        ((= i rows) out)\n      (vector-set! out i (matrix-ref m i j)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)\n        '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-column"], "split": "train"}
{"id": "matrix_decomp_translation_007", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-lu`.\n\n```python\ndef matrix_lu(a):\n    m, n = a.rows, a.cols\n    if m != n:\n        return (\"error\", \"not-square\", m, n)\n    lu = matrix_copy(a)\n    p = list(range(n))\n\n    for k in range(n):\n        max_row = k\n        max_val = abs(lu.ref(k, k))\n        for i in range(k + 1, n):\n            v = abs(lu.ref(i, k))\n            if v > max_val:\n                max_val = v\n                max_row = i\n        if max_val < MATRIX_TOLERANCE:\n            return (\"error\", \"singular-matrix\", k)\n\n        if max_row != k:\n            for col in range(n):\n                lu.swap(k, col, max_row, col)\n            p[k], p[max_row] = p[max_row], p[k]\n\n        for i in range(k + 1, n):\n            factor = lu.ref(i, k) / lu.ref(k, k)\n            lu.set(i, k, factor)\n            for j in range(k + 1, n):\n                lu.set(i, j, lu.ref(i, j) - factor * lu.ref(k, j))\n\n    L = make_matrix(n, n, 0)\n    U = make_matrix(n, n, 0)\n    for i in range(n):\n        L.set(i, i, 1)\n        for j in range(i):\n            L.set(i, j, lu.ref(i, j))\n        for j in range(i, n):\n            U.set(i, j, lu.ref(i, j))\n    return (L, U, p)\n```\n\nReturn only the Fold definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (matrix-from-lists '((4 3) (6 3)))] [res (matrix-lu a)]) (and (pair? res) (not (eq? (car res) 'error)) (let ([l (car res)] [u (cadr res)] [p (caddr res)]) (and (= (vector-length p) 2) (= (matrix-ref l 0 0) 1) (= (matrix-ref l 1 1) 1) (approx=? (matrix-ref u 1 0) 0 1e-10)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (let* ([a (matrix-from-lists '((4 3) (6 3)))]\n       [res (matrix-lu a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let ([l (car res)]\n             [u (cadr res)]\n             [p (caddr res)])\n         (and (= (vector-length p) 2)\n              (= (matrix-ref l 0 0) 1)\n              (= (matrix-ref l 1 1) 1)\n              (approx=? (matrix-ref u 1 0) 0 1e-10))))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-lu"], "split": "train"}
{"id": "matrix_decomp_translation_008", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-lu`\n\n```scheme\n(define (matrix-lu0 a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (let* ([a (matrix-from-lists '((4 3) (6 3)))]\n       [res (matrix-lu a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let ([l (car res)]\n             [u (cadr res)]\n             [p (caddr res)])\n         (and (= (vector-length p) 2)\n              (= (matrix-ref l 0 0) 1)\n              (= (matrix-ref l 1 1) 1)\n              (approx=? (matrix-ref u 1 0) 0 1e-10))))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-lu"], "split": "train"}
{"id": "matrix_decomp_translation_010", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-lu-solve`\n\n```scheme\n(define (matrix-lu-solve0 lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [lu (matrix-lu a)] [x (matrix-lu-solve lu b)] [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1)))] [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0)) (* (matrix-ref a 1 1) (vector-ref x 1)))]) (and (approx=? ax0 5 1e-8) (approx=? ax1 6 1e-8)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-lu-solve"], "split": "train"}
{"id": "matrix_decomp_translation_011", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-cholesky`.\n\n```python\ndef matrix_cholesky(a):\n    n = a.rows\n    if n != a.cols:\n        return (\"error\", \"not-square\", a.rows, a.cols)\n    L = make_matrix(n, n, 0)\n\n    for i in range(n):\n        for j in range(i + 1):\n            s = 0\n            for k in range(j):\n                s += L.ref(i, k) * L.ref(j, k)\n            if i == j:\n                val = a.ref(i, i) - s\n                if val <= 0:\n                    return (\"error\", \"not-positive-definite\", i, val)\n                L.set(i, i, sqrt(val))\n            else:\n                L.set(i, j, (a.ref(i, j) - s) / L.ref(j, j))\n    return (L,)\n```\n\nReturn only the Fold definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (matrix-from-lists '((4 12) (12 37)))] [res (matrix-cholesky a)]) (and (pair? res) (not (eq? (car res) 'error)) (let* ([l (car res)] [lt (matrix-transpose l)] [llt (matrix-mul l lt)]) (and (approx=? (matrix-ref llt 0 0) 4 1e-6) (approx=? (matrix-ref llt 0 1) 12 1e-6) (approx=? (matrix-ref llt 1 1) 37 1e-6)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (let* ([a (matrix-from-lists '((4 12) (12 37)))]\n       [res (matrix-cholesky a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let* ([l (car res)]\n              [lt (matrix-transpose l)]\n              [llt (matrix-mul l lt)])\n         (and (approx=? (matrix-ref llt 0 0) 4 1e-6)\n              (approx=? (matrix-ref llt 0 1) 12 1e-6)\n              (approx=? (matrix-ref llt 1 1) 37 1e-6))))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-cholesky"], "split": "train"}
{"id": "matrix_decomp_translation_012", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-cholesky`\n\n```scheme\n(define (matrix-cholesky0 a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (matrix-from-lists '((4 12) (12 37)))] [res (matrix-cholesky a)]) (and (pair? res) (not (eq? (car res) 'error)) (let* ([l (car res)] [lt (matrix-transpose l)] [llt (matrix-mul l lt)]) (and (approx=? (matrix-ref llt 0 0) 4 1e-6) (approx=? (matrix-ref llt 0 1) 12 1e-6) (approx=? (matrix-ref llt 1 1) 37 1e-6)))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (let* ([a (matrix-from-lists '((4 12) (12 37)))]\n       [res (matrix-cholesky a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let* ([l (car res)]\n              [lt (matrix-transpose l)]\n              [llt (matrix-mul l lt)])\n         (and (approx=? (matrix-ref llt 0 0) 4 1e-6)\n              (approx=? (matrix-ref llt 0 1) 12 1e-6)\n              (approx=? (matrix-ref llt 1 1) 37 1e-6))))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-cholesky"], "split": "train"}
{"id": "matrix_decomp_translation_013", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `permutation-sign`.\n\n```python\ndef permutation_sign(p):\n    inv = 0\n    n = len(p)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                inv += 1\n    return 1 if (inv % 2 == 0) else -1\n```\n\nReturn only the Fold definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))", "verify_expr": "(let ()\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (and (= (permutation-sign '#(0 1 2 3)) 1)\n     (= (permutation-sign '#(1 0 2 3)) -1)\n     (= (permutation-sign '#(1 2 0 3)) 1)))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "permutation-sign"], "split": "train"}
{"id": "matrix_decomp_translation_014", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `permutation-sign`\n\n```scheme\n(define (perm-sign0 p)\n  (let ((n (vector-length p)))\n    (let outer ((i 0) (swaps 0))\n      (if (= i n)\n          (if (even? swaps) 1 -1)\n          (let inner ((j (+ i 1)) (s swaps))\n            (if (= j n)\n                (outer (+ i 1) s)\n                (inner (+ j 1)\n                       (if (> (vector-ref p i) (vector-ref p j))\n                           (+ s 1)\n                           s))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (permutation-sign '#(0 1 2 3)) 1)\n(= (permutation-sign '#(1 0 2 3)) -1)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))", "verify_expr": "(let ()\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (and (= (permutation-sign '#(0 1 2 3)) 1)\n     (= (permutation-sign '#(1 0 2 3)) -1)\n     (= (permutation-sign '#(1 2 0 3)) 1)))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "permutation-sign"], "split": "train"}
{"id": "matrix_decomp_translation_015", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-det`.\n\n```python\ndef matrix_det(a):\n    res = matrix_lu(a)\n    if isinstance(res, tuple) and len(res) >= 2 and res[0] == \"error\":\n        if res[1] == \"singular-matrix\":\n            return 0\n        return res\n    L, U, p = res\n    prod = 1\n    for i in range(U.rows):\n        prod *= U.ref(i, i)\n    return prod * permutation_sign(p)\n```\n\nReturn only the Fold definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-det"], "split": "train"}
{"id": "matrix_decomp_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-copy` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Copy loop stops after only `rows` entries instead of `rows*cols`.\n\n```scheme\n(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n```\n\nReturn only the corrected function definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-set! c 0 0 99) (and (= (matrix-ref m 0 0) 1) (= (matrix-ref c 0 0) 99) (= (matrix-ref c 1 1) 4)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-copy"], "split": "train"}
{"id": "matrix_decomp_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-set!` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Row/column indexing is transposed, writing to wrong location.\n\n```scheme\n(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* j cols) i) val)))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))", "verify_expr": "(let ()\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (let ([m (make-matrix 2 2 0)])\n  (matrix-set! m 1 0 7)\n  (and (= (matrix-ref m 1 0) 7)\n       (= (matrix-ref m 0 1) 0))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-set!"], "split": "train"}
{"id": "matrix_decomp_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-set!` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Writes into a temporary vector, leaving matrix data unchanged.\n\n```scheme\n(define (matrix-set! m i j val)\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! (make-vector (vector-length data) 0)\n                    (+ (* i cols) j)\n                    val)))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (and (= (matrix-ref m 1 0) 7) (= (matrix-ref m 0 1) 0)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))", "verify_expr": "(let ()\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (let ([m (make-matrix 2 2 0)])\n  (matrix-set! m 1 0 7)\n  (and (= (matrix-ref m 1 0) 7)\n       (= (matrix-ref m 0 1) 0))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-set!"], "split": "train"}
{"id": "matrix_decomp_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-column` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Uses column count for output length instead of row count.\n\n```scheme\n(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-cols m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)\n        '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-column"], "split": "train"}
{"id": "matrix_decomp_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-column` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Ignores requested column index and always extracts column 0.\n\n```scheme\n(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i 0)))))\n```\n\nReturn only the corrected function definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1) '#(2 5 8))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)\n        '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-column"], "split": "train"}
{"id": "matrix_decomp_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-lu` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Square-matrix guard is inverted.\n\n```scheme\n(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (= m n)\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (matrix-from-lists '((4 3) (6 3)))] [res (matrix-lu a)]) (and (pair? res) (not (eq? (car res) 'error)) (let ([l (car res)] [u (cadr res)] [p (caddr res)]) (and (= (vector-length p) 2) (= (matrix-ref l 0 0) 1) (= (matrix-ref l 1 1) 1) (approx=? (matrix-ref u 1 0) 0 1e-10)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (let* ([a (matrix-from-lists '((4 3) (6 3)))]\n       [res (matrix-lu a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let ([l (car res)]\n             [u (cadr res)]\n             [p (caddr res)])\n         (and (= (vector-length p) 2)\n              (= (matrix-ref l 0 0) 1)\n              (= (matrix-ref l 1 1) 1)\n              (approx=? (matrix-ref u 1 0) 0 1e-10))))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-lu"], "split": "train"}
{"id": "matrix_decomp_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-lu` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Pivot selection chooses smaller pivots, breaking numerical stability.\n\n```scheme\n(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (< val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (matrix-from-lists '((4 3) (6 3)))] [res (matrix-lu a)]) (and (pair? res) (not (eq? (car res) 'error)) (let ([l (car res)] [u (cadr res)] [p (caddr res)]) (and (= (vector-length p) 2) (= (matrix-ref l 0 0) 1) (= (matrix-ref l 1 1) 1) (approx=? (matrix-ref u 1 0) 0 1e-10)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (let* ([a (matrix-from-lists '((4 3) (6 3)))]\n       [res (matrix-lu a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let ([l (car res)]\n             [u (cadr res)]\n             [p (caddr res)])\n         (and (= (vector-length p) 2)\n              (= (matrix-ref l 0 0) 1)\n              (= (matrix-ref l 1 1) 1)\n              (approx=? (matrix-ref u 1 0) 0 1e-10))))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-lu"], "split": "train"}
{"id": "matrix_decomp_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-lu-solve` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Back-substitution divides by L diagonal instead of U diagonal.\n\n```scheme\n(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref l i i)))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-lu-solve"], "split": "train"}
{"id": "matrix_decomp_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-cholesky` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Square-matrix precondition check is inverted.\n\n```scheme\n(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (= n (matrix-cols a))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n```\n\nReturn only the corrected function definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (matrix-from-lists '((4 12) (12 37)))] [res (matrix-cholesky a)]) (and (pair? res) (not (eq? (car res) 'error)) (let* ([l (car res)] [lt (matrix-transpose l)] [llt (matrix-mul l lt)]) (and (approx=? (matrix-ref llt 0 0) 4 1e-6) (approx=? (matrix-ref llt 0 1) 12 1e-6) (approx=? (matrix-ref llt 1 1) 37 1e-6)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (let* ([a (matrix-from-lists '((4 12) (12 37)))]\n       [res (matrix-cholesky a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let* ([l (car res)]\n              [lt (matrix-transpose l)]\n              [llt (matrix-mul l lt)])\n         (and (approx=? (matrix-ref llt 0 0) 4 1e-6)\n              (approx=? (matrix-ref llt 0 1) 12 1e-6)\n              (approx=? (matrix-ref llt 1 1) 37 1e-6))))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-cholesky"], "split": "train"}
{"id": "matrix_decomp_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-cholesky` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Allows zero pivots, incorrectly accepting non-positive-definite matrices.\n\n```scheme\n(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (< val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (let* ([a (matrix-from-lists '((4 12) (12 37)))]\n       [res (matrix-cholesky a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let* ([l (car res)]\n              [lt (matrix-transpose l)]\n              [llt (matrix-mul l lt)])\n         (and (approx=? (matrix-ref llt 0 0) 4 1e-6)\n              (approx=? (matrix-ref llt 0 1) 12 1e-6)\n              (approx=? (matrix-ref llt 1 1) 37 1e-6))))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-cholesky"], "split": "train"}
{"id": "matrix_decomp_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `permutation-sign` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Counts non-inversions rather than inversions.\n\n```scheme\n(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (< (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (permutation-sign '#(0 1 2 3)) 1)\n(= (permutation-sign '#(1 0 2 3)) -1)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))", "verify_expr": "(let ()\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (and (= (permutation-sign '#(0 1 2 3)) 1)\n     (= (permutation-sign '#(1 0 2 3)) -1)\n     (= (permutation-sign '#(1 2 0 3)) 1)))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "permutation-sign"], "split": "train"}
{"id": "matrix_decomp_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `permutation-sign` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Initial inversion count is off by one, flipping parity.\n\n```scheme\n(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 1])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))", "verify_expr": "(let ()\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (and (= (permutation-sign '#(0 1 2 3)) 1)\n     (= (permutation-sign '#(1 0 2 3)) -1)\n     (= (permutation-sign '#(1 2 0 3)) 1)))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "permutation-sign"], "split": "train"}
{"id": "matrix_decomp_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-det` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Uses L diagonal product instead of U diagonal product.\n\n```scheme\n(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref l i i))))))))))\n```\n\nReturn only the corrected function definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n(= (matrix-det (matrix-identity 3)) 1)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-det"], "split": "train"}
{"id": "matrix_decomp_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: compose existing APIs into one expression.\n\nMutate a copied matrix and return original (0,0) value.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-set! c 0 0 99) (matrix-ref m 0 0)) 1)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-set! c 0 0 99) (matrix-ref m 0 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-set! c 0 0 99) (matrix-ref m 0 0)) 1))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-copy", "property"], "split": "train"}
{"id": "matrix_decomp_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn determinant of a copied 2x2 matrix.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (matrix-from-lists '((1 2) (3 4)))]) (matrix-det (matrix-copy m))) -2)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (matrix-from-lists '((1 2) (3 4)))]) (matrix-det (matrix-copy m)))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([m (matrix-from-lists '((1 2) (3 4)))]) (matrix-det (matrix-copy m))) -2))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-copy", "integration"], "split": "train"}
{"id": "matrix_decomp_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: small integration task across module primitives.\n\nCopy a 0x0 matrix and return `(rows cols)`.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([m (make-matrix 0 0 0)] [c (matrix-copy m)]) (list (matrix-rows c) (matrix-cols c))) '(0 0))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (make-matrix 0 0 0)] [c (matrix-copy m)]) (list (matrix-rows c) (matrix-cols c)))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let* ([m (make-matrix 0 0 0)] [c (matrix-copy m)]) (list (matrix-rows c) (matrix-cols c))) '(0 0)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-copy", "edge-case"], "split": "train"}
{"id": "matrix_decomp_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSet value 7 at (1,0) in a fresh 2x2 matrix and read it back.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (matrix-ref m 1 0)) 7)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (matrix-ref m 1 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (matrix-ref m 1 0)) 7))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-set!", "direct"], "split": "train"}
{"id": "matrix_decomp_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: small integration task across module primitives.\n\nSet diagonal values in a 2x2 matrix and return determinant.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (make-matrix 2 2 0)]) (matrix-set! m 0 0 3) (matrix-set! m 1 1 5) (matrix-det m)) 15)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (make-matrix 2 2 0)]) (matrix-set! m 0 0 3) (matrix-set! m 1 1 5) (matrix-det m))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([m (make-matrix 2 2 0)]) (matrix-set! m 0 0 3) (matrix-set! m 1 1 5) (matrix-det m)) 15))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-set!", "integration"], "split": "train"}
{"id": "matrix_decomp_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nWrite one off-diagonal entry and return `(changed untouched)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (make-matrix 2 2 0)]) (matrix-set! m 0 1 9) (list (matrix-ref m 0 1) (matrix-ref m 1 0))) '(9 0))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (make-matrix 2 2 0)]) (matrix-set! m 0 1 9) (list (matrix-ref m 0 1) (matrix-ref m 1 0)))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([m (make-matrix 2 2 0)]) (matrix-set! m 0 1 9) (list (matrix-ref m 0 1) (matrix-ref m 1 0))) '(9 0)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-set!", "property"], "split": "train"}
{"id": "matrix_decomp_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: small integration task across module primitives.\n\nSet only element of 1x1 matrix and return determinant.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (make-matrix 1 1 0)]) (matrix-set! m 0 0 11) (matrix-det m)) 11)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (make-matrix 1 1 0)]) (matrix-set! m 0 0 11) (matrix-det m))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([m (make-matrix 1 1 0)]) (matrix-set! m 0 0 11) (matrix-det m)) 11))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-set!", "edge-case"], "split": "train"}
{"id": "matrix_decomp_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract column 0 from a 3x1 matrix.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-column (matrix-from-lists '((10) (20) (30))) 0)", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-column (matrix-from-lists '((10) (20) (30))) 0) '#(10 20 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-column", "edge-case"], "split": "train"}
{"id": "matrix_decomp_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn sum of entries in column 2 of a 3x3 matrix.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([c (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 2)]) (+ (vector-ref c 0) (vector-ref c 1) (vector-ref c 2))) 18)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([c (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 2)]) (+ (vector-ref c 0) (vector-ref c 1) (vector-ref c 2)))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([c (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 2)]) (+ (vector-ref c 0) (vector-ref c 1) (vector-ref c 2))) 18))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-column", "property"], "split": "train"}
{"id": "matrix_decomp_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSet `(0,1)=9` then return column 1.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (matrix-from-lists '((1 2) (3 4)))]) (matrix-set! m 0 1 9) (matrix-column m 1)) '#(9 4))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (matrix-from-lists '((1 2) (3 4)))]) (matrix-set! m 0 1 9) (matrix-column m 1))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([m (matrix-from-lists '((1 2) (3 4)))]) (matrix-set! m 0 1 9) (matrix-column m 1)) '#(9 4)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-column", "integration"], "split": "train"}
{"id": "matrix_decomp_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff LU decomposition of a 2x2 matrix succeeds.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([r (matrix-lu (matrix-from-lists '((4 3) (6 3))))]) (and (pair? r) (not (eq? (car r) 'error)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r (matrix-lu (matrix-from-lists '((4 3) (6 3))))]) (and (pair? r) (not (eq? (car r) 'error))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let ([r (matrix-lu (matrix-from-lists '((4 3) (6 3))))]) (and (pair? r) (not (eq? (car r) 'error)))) #t))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu", "direct"], "split": "train"}
{"id": "matrix_decomp_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn error code from LU on non-square matrix.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (cadr (matrix-lu (matrix-from-lists '((1 2 3) (4 5 6))))) 'not-square)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(cadr (matrix-lu (matrix-from-lists '((1 2 3) (4 5 6)))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (cadr (matrix-lu (matrix-from-lists '((1 2 3) (4 5 6))))) 'not-square))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu", "edge-case"], "split": "train"}
{"id": "matrix_decomp_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn error code from LU on singular matrix.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(cadr (matrix-lu (matrix-from-lists '((1 2) (2 4)))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (cadr (matrix-lu (matrix-from-lists '((1 2) (2 4))))) 'singular-matrix))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu", "edge-case"], "split": "train"}
{"id": "matrix_decomp_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn permutation vector length from LU of a 3x3 matrix.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([r (matrix-lu (matrix-from-lists '((2 1 1) (4 -6 0) (-2 7 2))))] [p (caddr r)]) (vector-length p)) 3)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([r (matrix-lu (matrix-from-lists '((2 1 1) (4 -6 0) (-2 7 2))))] [p (caddr r)]) (vector-length p))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let* ([r (matrix-lu (matrix-from-lists '((2 1 1) (4 -6 0) (-2 7 2))))] [p (caddr r)]) (vector-length p)) 3))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu", "property"], "split": "train"}
{"id": "matrix_decomp_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: small integration task across module primitives.\n\nSolve identity system and return x as vector.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (matrix-identity 3)] [b '#(7 8 9)] [x (matrix-lu-solve (matrix-lu a) b)]) x)", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let* ([a (matrix-identity 3)] [b '#(7 8 9)] [x (matrix-lu-solve (matrix-lu a) b)]) x) '#(7 8 9)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu-solve", "property"], "split": "train"}
{"id": "matrix_decomp_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: compose existing APIs into one expression.\n\nSolve system and return first reconstructed Ax component.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(let ([ax0 (let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1))))]) (< (abs (- ax0 5)) 1e-8))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (let ([ax0 (let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1))))]) (< (abs (- ax0 5)) 1e-8)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu-solve", "integration"], "split": "train"}
{"id": "matrix_decomp_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: compose existing APIs into one expression.\n\nSolve a 3x3 system with known solution and return x[2].\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(let ([x2 (let* ([a (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))] [b '#(14 32 53)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 2))]) (< (abs (- x2 3.0)) 1e-8))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))] [b '#(14 32 53)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 2))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (let ([x2 (let* ([a (matrix-from-lists '((1 2 3) (4 5 6) (7 8 10)))] [b '#(14 32 53)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 2))]) (< (abs (- x2 3.0)) 1e-8)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu-solve", "integration"], "split": "train"}
{"id": "matrix_decomp_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn error code for Cholesky on non-square matrix.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (cadr (matrix-cholesky (matrix-from-lists '((1 2 3) (4 5 6))))) 'not-square)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(cadr (matrix-cholesky (matrix-from-lists '((1 2 3) (4 5 6)))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (cadr (matrix-cholesky (matrix-from-lists '((1 2 3) (4 5 6))))) 'not-square))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-cholesky", "edge-case"], "split": "train"}
{"id": "matrix_decomp_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: small integration task across module primitives.\n\nReturn error code for Cholesky on non-positive-definite matrix.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (cadr (matrix-cholesky (matrix-from-lists '((1 2) (2 1))))) 'not-positive-definite)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(cadr (matrix-cholesky (matrix-from-lists '((1 2) (2 1)))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (cadr (matrix-cholesky (matrix-from-lists '((1 2) (2 1))))) 'not-positive-definite))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-cholesky", "edge-case"], "split": "train"}
{"id": "matrix_decomp_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun Cholesky on identity and return L(1,1).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([res (matrix-cholesky (matrix-identity 3))] [l (car res)]) (matrix-ref l 1 1)) 1)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([res (matrix-cholesky (matrix-identity 3))] [l (car res)]) (matrix-ref l 1 1))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let* ([res (matrix-cholesky (matrix-identity 3))] [l (car res)]) (matrix-ref l 1 1)) 1))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-cholesky", "direct"], "split": "train"}
{"id": "matrix_decomp_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn sign of identity permutation #(0 1 2 3).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (permutation-sign '#(0 1 2 3)) 1)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(permutation-sign '#(0 1 2 3))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (permutation-sign '#(0 1 2 3)) 1))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "permutation-sign", "direct"], "split": "train"}
{"id": "matrix_decomp_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn sign of single transposition permutation #(1 0 2 3).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (permutation-sign '#(1 0 2 3)) -1)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(permutation-sign '#(1 0 2 3))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (permutation-sign '#(1 0 2 3)) -1))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "permutation-sign", "direct"], "split": "train"}
{"id": "matrix_decomp_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn sign of 3-cycle permutation #(1 2 0).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(permutation-sign '#(1 2 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (permutation-sign '#(1 2 0)) 1))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "permutation-sign", "property"], "split": "train"}
{"id": "matrix_decomp_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn sign of permutation #(2 1 0).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (permutation-sign '#(2 1 0)) -1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(permutation-sign '#(2 1 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (permutation-sign '#(2 1 0)) -1))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "permutation-sign", "property"], "split": "train"}
{"id": "matrix_decomp_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: small integration task across module primitives.\n\nReturn determinant of 2x2 matrix ((1 2) (3 4)).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix-det (matrix-from-lists '((1 2) (3 4))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-det", "direct"], "split": "train"}
{"id": "matrix_decomp_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn determinant of identity 3x3 matrix.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-det (matrix-identity 3)) 1)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-det (matrix-identity 3))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-det (matrix-identity 3)) 1))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-det", "property"], "split": "train"}
{"id": "matrix_decomp_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn determinant of singular matrix ((1 2) (2 4)).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix-det (matrix-from-lists '((1 2) (2 4))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-det (matrix-from-lists '((1 2) (2 4)))) 0))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-det", "edge-case"], "split": "train"}
{"id": "matrix_decomp_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-set!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-set!`\nSpec: Mutate matrix element at row i, column j to val using row-major indexing.\n\nWrite exactly one `define` for `matrix-set!`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([m (make-matrix 2 2 0)]) (matrix-set! m 1 0 7) (and (= (matrix-ref m 1 0) 7) (= (matrix-ref m 0 1) 0)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))", "verify_expr": "(let ()\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (let ([m (make-matrix 2 2 0)])\n  (matrix-set! m 1 0 7)\n  (and (= (matrix-ref m 1 0) 7)\n       (= (matrix-ref m 0 1) 0))))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-set!"], "split": "eval"}
{"id": "matrix_decomp_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `matrix-lu`\nSpec: Compute LU decomposition with partial pivoting, returning `(list L U P)` or `(error ...)`.\n\nWrite exactly one `define` for `matrix-lu`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (let* ([a (matrix-from-lists '((4 3) (6 3)))]\n       [res (matrix-lu a)])\n  (and (pair? res)\n       (not (eq? (car res) 'error))\n       (let ([l (car res)]\n             [u (cadr res)]\n             [p (caddr res)])\n         (and (= (vector-length p) 2)\n              (= (matrix-ref l 0 0) 1)\n              (= (matrix-ref l 1 1) 1)\n              (approx=? (matrix-ref u 1 0) 0 1e-10))))))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "matrix-lu"], "split": "eval"}
{"id": "matrix_decomp_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "permutation-sign", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this Fold Scheme function.\n\nTarget module: lattice/linalg/matrix-decomp.ss\nFunction: `permutation-sign`\nSpec: Return +1 for even permutations and -1 for odd permutations.\n\nWrite exactly one `define` for `permutation-sign`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (permutation-sign '#(0 1 2 3)) 1)\n(= (permutation-sign '#(1 0 2 3)) -1)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))", "verify_expr": "(let ()\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (and (= (permutation-sign '#(0 1 2 3)) 1)\n     (= (permutation-sign '#(1 0 2 3)) -1)\n     (= (permutation-sign '#(1 2 0 3)) 1)))", "tags": ["tier0", "linalg", "matrix-decomp", "spec-to-code", "permutation-sign"], "split": "eval"}
{"id": "matrix_decomp_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-copy`.\n\n```python\ndef matrix_copy(m):\n    rows, cols, data = m.rows, m.cols, m.data\n    out = [0] * (rows * cols)\n    for i in range(rows * cols):\n        out[i] = data[i]\n    return Matrix(rows, cols, out)\n```\n\nReturn only the Fold definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-set! c 0 0 99) (and (= (matrix-ref m 0 0) 1) (= (matrix-ref c 0 0) 99) (= (matrix-ref c 1 1) 4)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-copy"], "split": "eval"}
{"id": "matrix_decomp_translation_009", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior exactly and name the function `matrix-lu-solve`.\n\n```python\ndef matrix_lu_solve(lu_result, b):\n    L, U, p = lu_result\n    n = len(b)\n    pb = [b[p[i]] for i in range(n)]\n\n    y = [0] * n\n    for i in range(n):\n        s = 0\n        for j in range(i):\n            s += L.ref(i, j) * y[j]\n        y[i] = pb[i] - s\n\n    x = [0] * n\n    for i in range(n - 1, -1, -1):\n        s = 0\n        for j in range(i + 1, n):\n            s += U.ref(i, j) * x[j]\n        x[i] = (y[i] - s) / U.ref(i, i)\n    return x\n```\n\nReturn only the Fold definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [lu (matrix-lu a)] [x (matrix-lu-solve lu b)] [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1)))] [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0)) (* (matrix-ref a 1 1) (vector-ref x 1)))]) (and (approx=? ax0 5 1e-8) (approx=? ax1 6 1e-8)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "python", "matrix-lu-solve"], "split": "eval"}
{"id": "matrix_decomp_translation_016", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style definition to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-det`\n\n```scheme\n(define (matrix-det0 a)\n  (let ((res (matrix-lu a)))\n    (if (and (pair? res) (eq? (car res) 'error))\n        (if (eq? (cadr res) 'singular-matrix)\n            0\n            res)\n        (let ((u (cadr res))\n              (p (caddr res)))\n          (let ((n (matrix-rows u)))\n            (let loop ((i 0) (prod 1))\n              (if (= i n)\n                  (* prod (permutation-sign p))\n                  (loop (+ i 1) (* prod (matrix-ref u i i))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n(= (matrix-det (matrix-identity 3)) 1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "translation", "chez", "matrix-det"], "split": "eval"}
{"id": "matrix_decomp_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-copy` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Returns original matrix instead of deep copy; mutations to copy alias original.\n\n```scheme\n(define (matrix-copy m)\n  m)\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (let* ([m (matrix-from-lists '((1 2) (3 4)))]\n       [c (matrix-copy m)])\n  (matrix-set! c 0 0 99)\n  (and (= (matrix-ref m 0 0) 1)\n       (= (matrix-ref c 0 0) 99)\n       (= (matrix-ref c 1 1) 4))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-copy"], "split": "eval"}
{"id": "matrix_decomp_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-lu-solve` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Fails to apply permutation vector to RHS before substitution.\n\n```scheme\n(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b i)))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n```\n\nReturn only the corrected function definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [lu (matrix-lu a)] [x (matrix-lu-solve lu b)] [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0)) (* (matrix-ref a 0 1) (vector-ref x 1)))] [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0)) (* (matrix-ref a 1 1) (vector-ref x 1)))]) (and (approx=? ax0 5 1e-8) (approx=? ax1 6 1e-8)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (let* ([a (matrix-from-lists '((2 1) (1 3)))]\n       [b '#(5 6)]\n       [lu (matrix-lu a)]\n       [x (matrix-lu-solve lu b)]\n       [ax0 (+ (* (matrix-ref a 0 0) (vector-ref x 0))\n               (* (matrix-ref a 0 1) (vector-ref x 1)))]\n       [ax1 (+ (* (matrix-ref a 1 0) (vector-ref x 0))\n               (* (matrix-ref a 1 1) (vector-ref x 1)))])\n  (and (approx=? ax0 5 1e-8)\n       (approx=? ax1 6 1e-8))))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-lu-solve"], "split": "eval"}
{"id": "matrix_decomp_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal changes.\nTarget: `matrix-det` in `lattice/linalg/matrix-decomp.ss`.\nKnown issue: Drops permutation sign correction term.\n\n```scheme\n(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              prod\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n```\n\nReturn only the corrected function definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n(= (matrix-det (matrix-identity 3)) 1)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (and (= (matrix-det (matrix-from-lists '((1 2) (3 4)))) -2)\n     (= (matrix-det (matrix-identity 3)) 1)\n     (= (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)))", "tags": ["tier0", "linalg", "matrix-decomp", "bugfix", "matrix-det"], "split": "eval"}
{"id": "matrix_decomp_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-copy", "prompt": "Task mode: compose existing APIs into one expression.\n\nCopy a 2x2 matrix and return the copied bottom-right value.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-ref c 1 1)) 4)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-ref c 1 1))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (let* ([m (matrix-from-lists '((1 2) (3 4)))] [c (matrix-copy m)]) (matrix-ref c 1 1)) 4))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-copy", "direct"], "split": "eval"}
{"id": "matrix_decomp_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-column", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn column 1 of a 3x3 matrix.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1) '#(2 5 8))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1)", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-column (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1) '#(2 5 8)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-column", "direct"], "split": "eval"}
{"id": "matrix_decomp_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-lu-solve", "prompt": "Task mode: compose existing APIs into one expression.\n\nSolve a 2x2 linear system and return x[0].\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(let ([x0 (let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 0))]) (< (abs (- x0 1.8)) 1e-8))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (let ([x0 (let* ([a (matrix-from-lists '((2 1) (1 3)))] [b '#(5 6)] [x (matrix-lu-solve (matrix-lu a) b)]) (vector-ref x 0))]) (< (abs (- x0 1.8)) 1e-8)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-lu-solve", "direct"], "split": "eval"}
{"id": "matrix_decomp_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-cholesky", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute reconstructed entry (1,0) from L*L^T for a 2x2 PD matrix.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(let ([v (let* ([a (matrix-from-lists '((4 12) (12 37)))] [l (car (matrix-cholesky a))] [llt (matrix-mul l (matrix-transpose l))]) (matrix-ref llt 1 0))]) (< (abs (- v 12)) 1e-6))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (matrix-from-lists '((4 12) (12 37)))] [l (car (matrix-cholesky a))] [llt (matrix-mul l (matrix-transpose l))]) (matrix-ref llt 1 0))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (let ([v (let* ([a (matrix-from-lists '((4 12) (12 37)))] [l (car (matrix-cholesky a))] [llt (matrix-mul l (matrix-transpose l))]) (matrix-ref llt 1 0))]) (< (abs (- v 12)) 1e-6)))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-cholesky", "integration"], "split": "eval"}
{"id": "matrix_decomp_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix-decomp.ss", "source_test": "lattice/linalg/test-matrix-decomp.ss", "source_function": "matrix-det", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn determinant of upper-triangular 3x3 matrix.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5))))", "verify_expr": "(let ()\n  (define *matrix-tolerance* 1e-10)\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (make-matrix rows cols init)\n  (list 'matrix rows cols (make-vector (* rows cols) init)))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            ;; Validate that all rows have the same length\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   ;; All rows valid, construct matrix\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   ;; Row has wrong length - return error\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   ;; Check next row\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 ;; i-k-j order: inner loop over j for sequential M2/C access\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              ;; Inner loop: sequential access to row k of B and row i of C\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (matrix-copy m)\n  (doc 'description \"Copy a matrix to a new data structure.\")\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [new-data (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i (* rows cols)) (list 'matrix rows cols new-data)]\n            (vector-set! new-data i (vector-ref data i)))))\n  (define (matrix-set! m i j val)\n  (doc 'description \"Set matrix element at (i, j) to val (mutation).\")\n  (let ([cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (vector-set! data (+ (* i cols) j) val)))\n  (define (matrix-column m j)\n  (doc 'description \"Extract column j as a vector.\")\n  (let* ([rows (matrix-rows m)]\n         [result (make-vector rows 0)])\n        (do ([i 0 (+ i 1)])\n            [(= i rows) result]\n            (vector-set! result i (matrix-ref m i j)))))\n  (define (matrix-lu a)\n  (doc 'description \"LU decomposition with partial pivoting. Returns (L U P) where A = PLU, or error if matrix is singular.\")\n  (let* ([m (matrix-rows a)]\n         [n (matrix-cols a)])\n        (if (not (= m n))\n            `(error not-square ,m ,n)\n            (let* ([lu (matrix-copy a)]\n                   [p (make-vector n 0)])\n                  ;; Initialize permutation\n                  (do ([i 0 (+ i 1)])\n                      [(= i n)]\n                      (vector-set! p i i))\n                  ;; Gaussian elimination with partial pivoting\n                  (let main-loop ([k 0])\n                       (if (= k n)\n                           ;; Split into L and U\n                           (let ([l (make-matrix n n 0)]\n                                 [u (make-matrix n n 0)])\n                                (do ([i 0 (+ i 1)])\n                                    [(= i n)]\n                                    (matrix-set! l i i 1)\n                                    (do ([j 0 (+ j 1)])\n                                        [(>= j i)]\n                                        (when (not (= i j))\n                                              (matrix-set! l i j (matrix-ref lu i j))))\n                                    (do ([j i (+ j 1)])\n                                        [(= j n)]\n                                        (matrix-set! u i j (matrix-ref lu i j))))\n                                (list l u p))\n                           ;; Find pivot row\n                           (let find-pivot ([i (+ k 1)] [max-row k] [max-val (abs (matrix-ref lu k k))])\n                                (if (= i n)\n                                    ;; Check for singularity and continue\n                                    (if (< max-val *matrix-tolerance*)\n                                        `(error singular-matrix ,k)\n                                        (begin\n                                         ;; Swap rows if needed\n                                         (when (not (= max-row k))\n                                               (let ([cols (matrix-cols lu)]\n                                                     [data (matrix-data lu)])\n                                                    (do ([col 0 (+ col 1)])\n                                                        [(= col cols)]\n                                                        (let ([idx-k (+ (* k cols) col)]\n                                                              [idx-max (+ (* max-row cols) col)])\n                                                             (let ([temp (vector-ref data idx-k)])\n                                                                  (vector-set! data idx-k (vector-ref data idx-max))\n                                                                  (vector-set! data idx-max temp)))))\n                                               (let ([temp (vector-ref p k)])\n                                                    (vector-set! p k (vector-ref p max-row))\n                                                    (vector-set! p max-row temp)))\n                                         ;; Eliminate below pivot\n                                         (do ([i (+ k 1) (+ i 1)])\n                                             [(= i n)]\n                                             (let ([factor (/ (matrix-ref lu i k) (matrix-ref lu k k))])\n                                                  (matrix-set! lu i k factor)\n                                                  (do ([j (+ k 1) (+ j 1)])\n                                                      [(= j n)]\n                                                      (matrix-set! lu i j\n                                                                   (- (matrix-ref lu i j)\n                                                                      (* factor (matrix-ref lu k j)))))))\n                                         (main-loop (+ k 1))))\n                                    ;; Continue finding pivot\n                                    (let ([val (abs (matrix-ref lu i k))])\n                                         (if (> val max-val)\n                                             (find-pivot (+ i 1) i val)\n                                             (find-pivot (+ i 1) max-row max-val)))))))))))\n  (define (matrix-lu-solve lu-result b)\n  (doc 'description \"Solve Ax = b given LU decomposition with permutation. Algorithm: 1) Apply P to b, 2) Forward substitute Ly = Pb, 3) Back substitute Ux = y\")\n  (let* ([l (car lu-result)]\n         [u (cadr lu-result)]\n         [p (caddr lu-result)]\n         [n (vector-length b)]\n         ;; Step 1: Apply permutation to b\n         [pb (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (vector-set! pb i (vector-ref b (vector-ref p i))))]\n         ;; Step 2: Forward substitution (Ly = Pb)\n         [y (make-vector n 0)]\n         [_ (do ([i 0 (+ i 1)])\n                [(= i n)]\n                (let ([sum (let loop ([j 0] [s 0])\n                                (if (= j i)\n                                    s\n                                    (loop (+ j 1)\n                                          (+ s (* (matrix-ref l i j)\n                                                  (vector-ref y j))))))])\n                     (vector-set! y i (- (vector-ref pb i) sum))))]\n         ;; Step 3: Back substitution (Ux = y)\n         [x (make-vector n 0)])\n        (do ([i (- n 1) (- i 1)])\n            [(< i 0) x]\n            (let ([sum (let loop ([j (+ i 1)] [s 0])\n                            (if (= j n)\n                                s\n                                (loop (+ j 1)\n                                      (+ s (* (matrix-ref u i j)\n                                              (vector-ref x j))))))])\n                 (vector-set! x i (/ (- (vector-ref y i) sum)\n                                     (matrix-ref u i i)))))))\n  (define (matrix-cholesky a)\n  (doc 'description \"Cholesky decomposition. Returns (list L) where A = L x L^T for positive-definite A.\")\n  (let ([n (matrix-rows a)])\n       (if (not (= n (matrix-cols a)))\n           `(error not-square ,(matrix-rows a) ,(matrix-cols a))\n           (let ([l (make-matrix n n 0)])\n                (let row-loop ([i 0])\n                     (if (= i n)\n                         (list l)\n                         (let col-loop ([j 0])\n                              (if (> j i)\n                                  (row-loop (+ i 1))\n                                  (let ([sum (let k-loop ([k 0] [s 0])\n                                                  (if (= k j)\n                                                      s\n                                                      (k-loop (+ k 1)\n                                                              (+ s (* (matrix-ref l i k)\n                                                                      (matrix-ref l j k))))))])\n                                       (cond\n                                        [(= i j)\n                                         (let ([val (- (matrix-ref a i i) sum)])\n                                              (if (<= val 0)\n                                                  `(error not-positive-definite ,i ,val)\n                                                  (begin\n                                                   (matrix-set! l i i (sqrt val))\n                                                   (col-loop (+ j 1)))))]\n                                        [else\n                                         (matrix-set! l i j (/ (- (matrix-ref a i j) sum)\n                                                               (matrix-ref l j j)))\n                                         (col-loop (+ j 1))]))))))))))\n  (define (permutation-sign p)\n  (doc 'description \"Compute the sign of a permutation: (-1)^(number of inversions). An inversion is a pair (i, j) where i < j but P[i] > P[j].\")\n  (let ([n (vector-length p)])\n       (let outer ([i 0] [swaps 0])\n            (if (= i n)\n                (if (even? swaps) 1 -1)\n                (let inner ([j (+ i 1)] [s swaps])\n                     (if (= j n)\n                         (outer (+ i 1) s)\n                         (inner (+ j 1)\n                                (if (> (vector-ref p i) (vector-ref p j))\n                                    (+ s 1)\n                                    s))))))))\n  (define (matrix-det a)\n  (doc 'description \"Compute the determinant of a square matrix using LU decomposition. det(A) = det(L)  det(U)  sign(P) = 1  (product of U diagonal)  sign(P). Complexity: O(n) via LU decomposition.\")\n  (let ([result (matrix-lu a)])\n       (if (and (pair? result) (eq? (car result) 'error))\n           ;; Singular matrix has determinant 0\n           (if (eq? (cadr result) 'singular-matrix)\n               0\n               result)\n           (let ([l (car result)]\n                 [u (cadr result)]\n                 [p (caddr result)])\n                ;; det(U) = product of diagonal elements\n                (let ([n (matrix-rows u)])\n                     (let loop ([i 0] [prod 1])\n                          (if (= i n)\n                              (* prod (permutation-sign p))\n                              (loop (+ i 1)\n                                    (* prod (matrix-ref u i i))))))))))\n  (equal? (matrix-det (matrix-from-lists '((2 1 0) (0 3 4) (0 0 5)))) 30))", "tags": ["tier0", "linalg", "matrix-decomp", "composition", "matrix-det", "property"], "split": "eval"}
