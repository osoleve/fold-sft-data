{"id": "fp_parsing_regex_parser_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-class-range`\nSpec: Parse and expand a character range like a-z into an inclusive character list; reject reversed ranges.\n\nWrite exactly one Scheme function definition for `parse-class-range`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2)) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "parse-class-range"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-class-range`\nSpec: Parse and expand a character range like a-z into an inclusive character list; reject reversed ranges.\n\nWrite exactly one Scheme function definition for `parse-class-range`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-class-range)\n  ;; TODO: parse start-end class range and expand inclusive chars\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-class-range`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "parse-class-range"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-class-range)\n  ;; TODO: parse start-end class range and expand inclusive chars\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-class-range`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-class-range` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse and expand a character range like a-z into an inclusive character list; reject reversed ranges.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-class-range`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2)))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "parse-class-range"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-class-range` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse and expand a character range like a-z into an inclusive character list; reject reversed ranges.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-class-range`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-interval`\nSpec: Parse interval quantifiers {n}, {n,m}, {n,}, {,m}; reject empty {} and invalid min>max.\n\nWrite exactly one Scheme function definition for `parse-interval`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3)) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f)))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "parse-interval"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-interval`\nSpec: Parse interval quantifiers {n}, {n,m}, {n,}, {,m}; reject empty {} and invalid min>max.\n\nWrite exactly one Scheme function definition for `parse-interval`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-interval)\n  ;; TODO: parse {n}, {n,m}, {n,}, {,m} with validation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-interval`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t)\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f)) (equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "parse-interval"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-interval)\n  ;; TODO: parse {n}, {n,m}, {n,}, {,m} with validation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-interval`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-interval` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse interval quantifiers {n}, {n,m}, {n,}, {,m}; reject empty {} and invalid min>max.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-interval`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t)\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4)) (equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "parse-interval"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-interval` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse interval quantifiers {n}, {n,m}, {n,}, {,m}; reject empty {} and invalid min>max.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-interval`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `apply-postfix-op`\nSpec: Apply regex postfix operator (*,+,?,interval-pair) to an AST node.\n\nWrite exactly one Scheme function definition for `apply-postfix-op`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t) (equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `apply-postfix-op`\nSpec: Apply regex postfix operator (*,+,?,interval-pair) to an AST node.\n\nWrite exactly one Scheme function definition for `apply-postfix-op`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-postfix-op expr op)\n  ;; TODO: map char operators and interval pairs to regex AST wrappers\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-postfix-op`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t) (equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (apply-postfix-op expr op)\n  ;; TODO: map char operators and interval pairs to regex AST wrappers\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `apply-postfix-op`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `apply-postfix-op` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Apply regex postfix operator (*,+,?,interval-pair) to an AST node.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `apply-postfix-op`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t) (equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `apply-postfix-op` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Apply regex postfix operator (*,+,?,interval-pair) to an AST node.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `apply-postfix-op`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-seq`\nSpec: Parse concatenation of postfix terms; return regex-empty for none, single node for one, regex-seq for many.\n\nWrite exactly one Scheme function definition for `parse-seq`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "parse-seq"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-seq`\nSpec: Parse concatenation of postfix terms; return regex-empty for none, single node for one, regex-seq for many.\n\nWrite exactly one Scheme function definition for `parse-seq`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-seq)\n  ;; TODO: parse zero-or-more postfix items and normalize empty/singleton/many\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-seq`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "parse-seq"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-seq)\n  ;; TODO: parse zero-or-more postfix items and normalize empty/singleton/many\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-seq`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `parse-seq` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse concatenation of postfix terms; return regex-empty for none, single node for one, regex-seq for many.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-seq`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t) (= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "parse-seq"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement `parse-seq` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse concatenation of postfix terms; return regex-empty for none, single node for one, regex-seq for many.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-seq`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-alt`\nSpec: Parse alternations separated by | with left term plus zero-or-more right terms.\n\nWrite exactly one Scheme function definition for `parse-alt`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "parse-alt"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `parse-alt`\nSpec: Parse alternations separated by | with left term plus zero-or-more right terms.\n\nWrite exactly one Scheme function definition for `parse-alt`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-alt)\n  ;; TODO: parse seq and trailing |seq clauses, building regex-alt when needed\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-alt`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "parse-alt"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-alt)\n  ;; TODO: parse seq and trailing |seq clauses, building regex-alt when needed\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-alt`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-alt` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse alternations separated by | with left term plus zero-or-more right terms.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-alt`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "parse-alt"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `parse-alt` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Parse alternations separated by | with left term plus zero-or-more right terms.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `parse-alt`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-repeat`\nSpec: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nWrite exactly one Scheme function definition for `compile-repeat`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-repeat`\nSpec: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nWrite exactly one Scheme function definition for `compile-repeat`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  ;; TODO: compile repeat bounds into equivalent FSM composition\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-repeat`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  ;; TODO: compile repeat bounds into equivalent FSM composition\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-repeat`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-repeat` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-repeat`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-repeat` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-repeat`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-anchor`\nSpec: Compile ^/$ anchor into assertion FSM with zero-width transition metadata.\n\nWrite exactly one Scheme function definition for `compile-anchor`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t) (equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "compile-anchor"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-anchor`\nSpec: Compile ^/$ anchor into assertion FSM with zero-width transition metadata.\n\nWrite exactly one Scheme function definition for `compile-anchor`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-anchor type)\n  ;; TODO: emit assertion FSM for anchor type\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-anchor`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t) (equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "compile-anchor"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-anchor type)\n  ;; TODO: emit assertion FSM for anchor type\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-anchor`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-anchor` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile ^/$ anchor into assertion FSM with zero-width transition metadata.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-anchor`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "compile-anchor"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-anchor` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile ^/$ anchor into assertion FSM with zero-width transition metadata.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-anchor`.\n3. Return one production-ready definition only.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-lookahead`\nSpec: Compile positive/negative lookahead into assertion FSM preserving inner compiled pattern and polarity.\n\nWrite exactly one Scheme function definition for `compile-lookahead`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-lookahead`\nSpec: Compile positive/negative lookahead into assertion FSM preserving inner compiled pattern and polarity.\n\nWrite exactly one Scheme function definition for `compile-lookahead`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-lookahead expr positive? universe)\n  ;; TODO: emit assertion FSM for lookahead polarity and inner pattern\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-lookahead`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-lookahead expr positive? universe)\n  ;; TODO: emit assertion FSM for lookahead polarity and inner pattern\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-lookahead`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `compile-lookahead` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile positive/negative lookahead into assertion FSM preserving inner compiled pattern and polarity.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-lookahead`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement `compile-lookahead` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile positive/negative lookahead into assertion FSM preserving inner compiled pattern and polarity.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-lookahead`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-class-range`.\nReturn only the Scheme definition.\n\n```python\ndef parse_class_range():\n    start = parse_class_char()\n    expect('-')\n    end = parse_class_char()\n    if start <= end:\n        return [chr(ord(start) + i) for i in range(ord(end) - ord(start) + 1)]\n    raise ParseError('invalid range: start > end')\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2)) (equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "parse-class-range"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-class-range`.\nReturn only the Scheme definition.\n\n```python\ndef parse_class_range():\n    start = parse_class_char()\n    expect('-')\n    end = parse_class_char()\n    if start <= end:\n        return [chr(ord(start) + i) for i in range(ord(end) - ord(start) + 1)]\n    raise ParseError('invalid range: start > end')\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-class-range`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (class-range)\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([si (char->integer start)]\n                      [n (+ 1 (- (char->integer end) si))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i si)))\n                                   (iota n))))\n               (parser-fail \"invalid range: start > end\")))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2)))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "parse-class-range"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-class-range`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (class-range)\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([si (char->integer start)]\n                      [n (+ 1 (- (char->integer end) si))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i si)))\n                                   (iota n))))\n               (parser-fail \"invalid range: start > end\")))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))\n```"}
{"id": "fp_parsing_regex_parser_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-class-range`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-class-range`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_class_range():\n    start = parse_class_char()\n    expect('-')\n    end = parse_class_char()\n    if start <= end:\n        return [chr(ord(start) + i) for i in range(ord(end) - ord(start) + 1)]\n    raise ParseError('invalid range: start > end')\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t) (= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "parse-class-range"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-class-range`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-class-range`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_class_range():\n    start = parse_class_char()\n    expect('-')\n    end = parse_class_char()\n    if start <= end:\n        return [chr(ord(start) + i) for i in range(ord(end) - ord(start) + 1)]\n    raise ParseError('invalid range: start > end')\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)\n```"}
{"id": "fp_parsing_regex_parser_translation_004", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-interval`.\nReturn only the Scheme definition.\n\n```python\ndef parse_interval():\n    expect('{')\n    min_v = maybe_parse_nat()\n    if peek() == '}':\n        expect('}')\n        if min_v is None:\n            raise ParseError('empty interval {} is invalid')\n        return (min_v, min_v)\n    expect(',')\n    max_v = maybe_parse_nat()\n    expect('}')\n    min_out = 0 if min_v is None else min_v\n    max_out = max_v\n    if max_out is not None and min_out > max_out:\n        raise ParseError('interval min > max')\n    return (min_out, max_out)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t)\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3)) (equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "parse-interval"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-interval`.\nReturn only the Scheme definition.\n\n```python\ndef parse_interval():\n    expect('{')\n    min_v = maybe_parse_nat()\n    if peek() == '}':\n        expect('}')\n        if min_v is None:\n            raise ParseError('empty interval {} is invalid')\n        return (min_v, min_v)\n    expect(',')\n    max_v = maybe_parse_nat()\n    expect('}')\n    min_out = 0 if min_v is None else min_v\n    max_out = max_v\n    if max_out is not None and min_out > max_out:\n        raise ParseError('interval min > max')\n    return (min_out, max_out)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3))\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-interval`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (interval-parser)\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (mn)\n        (parser-or\n         (parser-bind (parser-char #\\})\n                      (lambda (_)\n                        (if (nothing? mn)\n                            (parser-fail \"empty interval {} is invalid\")\n                            (let ([n (from-just mn)])\n                              (parser-pure (cons n n))))))\n         (parser-bind (parser-char #\\,)\n                      (lambda (_)\n                        (parser-bind\n                         (parser-option-maybe parser-natural)\n                         (lambda (mx)\n                           (parser-bind\n                            (parser-char #\\})\n                            (lambda (_)\n                              (let ([min (if (nothing? mn) 0 (from-just mn))]\n                                    [max (if (nothing? mx) #f (from-just mx))])\n                                (if (and max (> min max))\n                                    (parser-fail \"interval min > max\")\n                                    (parser-pure (cons min max))))))))))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f)) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4)))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "parse-interval"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-interval`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (interval-parser)\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (mn)\n        (parser-or\n         (parser-bind (parser-char #\\})\n                      (lambda (_)\n                        (if (nothing? mn)\n                            (parser-fail \"empty interval {} is invalid\")\n                            (let ([n (from-just mn)])\n                              (parser-pure (cons n n))))))\n         (parser-bind (parser-char #\\,)\n                      (lambda (_)\n                        (parser-bind\n                         (parser-option-maybe parser-natural)\n                         (lambda (mx)\n                           (parser-bind\n                            (parser-char #\\})\n                            (lambda (_)\n                              (let ([min (if (nothing? mn) 0 (from-just mn))]\n                                    [max (if (nothing? mx) #f (from-just mx))])\n                                (if (and max (> min max))\n                                    (parser-fail \"interval min > max\")\n                                    (parser-pure (cons min max))))))))))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```"}
{"id": "fp_parsing_regex_parser_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-interval`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-interval`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_interval():\n    expect('{')\n    min_v = maybe_parse_nat()\n    if peek() == '}':\n        expect('}')\n        if min_v is None:\n            raise ParseError('empty interval {} is invalid')\n        return (min_v, min_v)\n    expect(',')\n    max_v = maybe_parse_nat()\n    expect('}')\n    min_out = 0 if min_v is None else min_v\n    max_out = max_v\n    if max_out is not None and min_out > max_out:\n        raise ParseError('interval min > max')\n    return (min_out, max_out)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4)) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f)))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "parse-interval"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-interval`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-interval`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_interval():\n    expect('{')\n    min_v = maybe_parse_nat()\n    if peek() == '}':\n        expect('}')\n        if min_v is None:\n            raise ParseError('empty interval {} is invalid')\n        return (min_v, min_v)\n    expect(',')\n    max_v = maybe_parse_nat()\n    expect('}')\n    min_out = 0 if min_v is None else min_v\n    max_out = max_v\n    if max_out is not None and min_out > max_out:\n        raise ParseError('interval min > max')\n    return (min_out, max_out)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (right? e1))\n(let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (equal? (from-right e1) (cons 3 3)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```"}
{"id": "fp_parsing_regex_parser_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `apply-postfix-op`.\nReturn only the Scheme definition.\n\n```python\ndef apply_postfix_op(expr, op):\n    if isinstance(op, str):\n        if op == '*':\n            return regex_star(expr)\n        if op == '+':\n            return regex_plus(expr)\n        if op == '?':\n            return regex_opt(expr)\n    if isinstance(op, tuple):\n        mn, mx = op\n        return regex_repeat(expr, mn, mx)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t) (equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `apply-postfix-op`.\nReturn only the Scheme definition.\n\n```python\ndef apply_postfix_op(expr, op):\n    if isinstance(op, str):\n        if op == '*':\n            return regex_star(expr)\n        if op == '+':\n            return regex_plus(expr)\n        if op == '?':\n            return regex_opt(expr)\n    if isinstance(op, tuple):\n        mn, mx = op\n        return regex_repeat(expr, mn, mx)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `apply-postfix-op`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (postfix->ast expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t) (equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `apply-postfix-op`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (postfix->ast expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `apply-postfix-op`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `apply-postfix-op`.\nReturn only the final Scheme definition.\n\n```python\ndef apply_postfix_op(expr, op):\n    if isinstance(op, str):\n        if op == '*':\n            return regex_star(expr)\n        if op == '+':\n            return regex_plus(expr)\n        if op == '?':\n            return regex_opt(expr)\n    if isinstance(op, tuple):\n        mn, mx = op\n        return regex_repeat(expr, mn, mx)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r))) '(2 4))\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t) (equal? (let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r))) '(2 4)))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `apply-postfix-op`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `apply-postfix-op`.\nReturn only the final Scheme definition.\n\n```python\ndef apply_postfix_op(expr, op):\n    if isinstance(op, str):\n        if op == '*':\n            return regex_star(expr)\n        if op == '+':\n            return regex_plus(expr)\n        if op == '?':\n            return regex_opt(expr)\n    if isinstance(op, tuple):\n        mn, mx = op\n        return regex_repeat(expr, mn, mx)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r))) '(2 4))\n```"}
{"id": "fp_parsing_regex_parser_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-seq`.\nReturn only the Scheme definition.\n\n```python\ndef parse_seq():\n    exprs = many(parse_postfix)\n    if not exprs:\n        return regex_empty()\n    if len(exprs) == 1:\n        return exprs[0]\n    return regex_seq(exprs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "parse-seq"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-seq`.\nReturn only the Scheme definition.\n\n```python\ndef parse_seq():\n    exprs = many(parse_postfix)\n    if not exprs:\n        return regex_empty()\n    if len(exprs) == 1:\n        return exprs[0]\n    return regex_seq(exprs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-seq`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (seq-parser)\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t) (= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "parse-seq"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-seq`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (seq-parser)\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```"}
{"id": "fp_parsing_regex_parser_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-seq`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-seq`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_seq():\n    exprs = many(parse_postfix)\n    if not exprs:\n        return regex_empty()\n    if len(exprs) == 1:\n        return exprs[0]\n    return regex_seq(exprs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "parse-seq"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-seq`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-seq`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_seq():\n    exprs = many(parse_postfix)\n    if not exprs:\n        return regex_empty()\n    if len(exprs) == 1:\n        return exprs[0]\n    return regex_seq(exprs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-alt`.\nReturn only the Scheme definition.\n\n```python\ndef parse_alt():\n    first = parse_seq()\n    rest = many(lambda: then(char('|'), parse_seq()))\n    if not rest:\n        return first\n    return regex_alt([first] + rest)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "parse-alt"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `parse-alt`.\nReturn only the Scheme definition.\n\n```python\ndef parse_alt():\n    first = parse_seq()\n    rest = many(lambda: then(char('|'), parse_seq()))\n    if not rest:\n        return first\n    return regex_alt([first] + rest)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-alt`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (alt-parser)\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "parse-alt"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `parse-alt`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (alt-parser)\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-alt`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-alt`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_alt():\n    first = parse_seq()\n    rest = many(lambda: then(char('|'), parse_seq()))\n    if not rest:\n        return first\n    return regex_alt([first] + rest)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "parse-alt"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this reference implementation into canonical Fold Scheme for `parse-alt`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `parse-alt`.\nReturn only the final Scheme definition.\n\n```python\ndef parse_alt():\n    first = parse_seq()\n    rest = many(lambda: then(char('|'), parse_seq()))\n    if not rest:\n        return first\n    return regex_alt([first] + rest)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-repeat`.\nReturn only the Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-repeat`.\nReturn only the Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_017", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-repeat`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-repeat* expr mn mx universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= mn 0) (eqv? mx 0)) (fsm-epsilon-lang)]\n     [(and (= mn 0) (not mx)) (fsm-star base)]\n     [(= mn 0)\n      (fold-left (lambda (acc _) (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota mx))]\n     [(eqv? mn mx)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- mn 1))))]\n     [(not mx)\n      (let ([req (fold-left fsm-concat base\n                            (map (lambda (_) (regex-compile expr universe))\n                                 (iota (- mn 1))))])\n        (fsm-concat req (fsm-star base)))]\n     [else\n      (let* ([req (fold-left fsm-concat base\n                             (map (lambda (_) (regex-compile expr universe))\n                                  (iota (- mn 1))))]\n             [opt (fold-left (lambda (acc _)\n                               (fsm-concat (fsm-optional base) acc))\n                             (fsm-epsilon-lang)\n                             (iota (- mx mn)))])\n        (fsm-concat req opt))])))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-repeat`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-repeat* expr mn mx universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= mn 0) (eqv? mx 0)) (fsm-epsilon-lang)]\n     [(and (= mn 0) (not mx)) (fsm-star base)]\n     [(= mn 0)\n      (fold-left (lambda (acc _) (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota mx))]\n     [(eqv? mn mx)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- mn 1))))]\n     [(not mx)\n      (let ([req (fold-left fsm-concat base\n                            (map (lambda (_) (regex-compile expr universe))\n                                 (iota (- mn 1))))])\n        (fsm-concat req (fsm-star base)))]\n     [else\n      (let* ([req (fold-left fsm-concat base\n                             (map (lambda (_) (regex-compile expr universe))\n                                  (iota (- mn 1))))]\n             [opt (fold-left (lambda (acc _)\n                               (fsm-concat (fsm-optional base) acc))\n                             (fsm-epsilon-lang)\n                             (iota (- mx mn)))])\n        (fsm-concat req opt))])))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-repeat`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-repeat`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-repeat`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-repeat`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-anchor`.\nReturn only the Scheme definition.\n\n```python\ndef compile_anchor(anchor_type):\n    s0 = fsm_fresh_state('anc')\n    s1 = fsm_fresh_state('anc')\n    assertions = [(s0, 'anchor', anchor_type, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "compile-anchor"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-anchor`.\nReturn only the Scheme definition.\n\n```python\ndef compile_anchor(anchor_type):\n    s0 = fsm_fresh_state('anc')\n    s1 = fsm_fresh_state('anc')\n    assertions = [(s0, 'anchor', anchor_type, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-anchor`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (anchor-fsm type)\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "compile-anchor"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-anchor`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (anchor-fsm type)\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-anchor`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-anchor`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_anchor(anchor_type):\n    s0 = fsm_fresh_state('anc')\n    s1 = fsm_fresh_state('anc')\n    assertions = [(s0, 'anchor', anchor_type, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "compile-anchor"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-anchor`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-anchor`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_anchor(anchor_type):\n    s0 = fsm_fresh_state('anc')\n    s1 = fsm_fresh_state('anc')\n    assertions = [(s0, 'anchor', anchor_type, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_022", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-lookahead`.\nReturn only the Scheme definition.\n\n```python\ndef compile_lookahead(expr, positive, universe):\n    inner = regex_compile(expr, universe)\n    s0 = fsm_fresh_state('la')\n    s1 = fsm_fresh_state('la')\n    assertions = [(s0, 'lookahead', inner, positive, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-lookahead`.\nReturn only the Scheme definition.\n\n```python\ndef compile_lookahead(expr, positive, universe):\n    inner = regex_compile(expr, universe)\n    s0 = fsm_fresh_state('la')\n    s1 = fsm_fresh_state('la')\n    assertions = [(s0, 'lookahead', inner, positive, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_023", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-lookahead`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (lookahead-fsm expr positive? universe)\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-lookahead`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (lookahead-fsm expr positive? universe)\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-lookahead`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-lookahead`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_lookahead(expr, positive, universe):\n    inner = regex_compile(expr, universe)\n    s0 = fsm_fresh_state('la')\n    s1 = fsm_fresh_state('la')\n    assertions = [(s0, 'lookahead', inner, positive, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-lookahead`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-lookahead`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_lookahead(expr, positive, universe):\n    inner = regex_compile(expr, universe)\n    s0 = fsm_fresh_state('la')\n    s1 = fsm_fresh_state('la')\n    assertions = [(s0, 'lookahead', inner, positive, s1)]\n    return make_fsm_with_assertions([s0, s1], [], [], s0, [s1], [], assertions)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-class-range` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Range expansion must be inclusive; dropping +1 omits the upper bound character.\n\n```scheme\n(define (parse-class-range)\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (- (char->integer end) start-int)])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t) (= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-class-range"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-class-range` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Range expansion must be inclusive; dropping +1 omits the upper bound character.\n\n```scheme\n(define (parse-class-range)\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (- (char->integer end) start-int)])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (right? ok))\n(let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (= (length (from-right ok)) 26))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-class-range` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Character ranges must expand inclusively; returning literal start-dash-end loses range semantics.\n\n```scheme\n(define (parse-class-range)\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (parser-pure (list start #\\- end)))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```", "ground_truth": "(define (parse-class-range)\n  (doc 'type '(Parser (List Char)))\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (if (char<=? start end)\n               (let* ([start-int (char->integer start)]\n                      [count (+ 1 (- (char->integer end) start-int))])\n                 (parser-pure (map (lambda (i) (integer->char (+ i start-int)))\n                                   (iota count))))\n               (parser-fail \"invalid range: start > end\")))))))))", "verify_expr": "(and (let ([ok (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")] [bad (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")]) (and (right? ok) (= (length (from-right ok)) 26) (equal? (car (from-right ok)) #\\a) (equal? (car (reverse (from-right ok))) #\\z) (left? bad))) (= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26) (equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-class-range"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-class-range` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Character ranges must expand inclusively; returning literal start-dash-end loses range semantics.\n\n```scheme\n(define (parse-class-range)\n  (parser-bind\n   (parse-class-char)\n   (lambda (start)\n     (parser-bind\n      (parser-char #\\-)\n      (lambda (_)\n        (parser-bind\n         (parse-class-char)\n         (lambda (end)\n           (parser-pure (list start #\\- end)))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)\n```\n\nCheck 2:\n```scheme\n(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-interval` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Exact intervals {n} must yield (n . n), not an unbounded upper bound.\n\n```scheme\n(define (parse-interval)\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n #f))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f)) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4)))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-interval"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-interval` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Exact intervals {n} must yield (n . n), not an unbounded upper bound.\n\n```scheme\n(define (parse-interval)\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n #f))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```"}
{"id": "fp_parsing_regex_parser_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-interval` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Open lower bound {,m} must default min to 0 and still enforce min<=max validation.\n\n```scheme\n(define (parse-interval)\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 1 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (parser-pure (cons min max)))))))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3))\n```", "ground_truth": "(define (parse-interval)\n  (doc 'type '(Parser (Pair Nat (Option Nat))))\n  (doc 'description \"Parse interval quantifier, returns (min . max) where max=#f means unbounded\")\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 0 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (if (and max (> min max))\n                        (parser-fail \"interval min > max\")\n                        (parser-pure (cons min max))))))))))))))))", "verify_expr": "(and (let ([e1 (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")] [e2 (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")] [e3 (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")] [bad1 (parser-parse (parser-left (parse-interval) parser-eof) \"{}\")] [bad2 (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")]) (and (right? e1) (equal? (from-right e1) (cons 3 3)) (right? e2) (equal? (from-right e2) (cons 2 #f)) (right? e3) (equal? (from-right e3) (cons 0 4)) (left? bad1) (left? bad2))) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4)) (equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3)))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-interval"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-interval` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Open lower bound {,m} must default min to 0 and still enforce min<=max validation.\n\n```scheme\n(define (parse-interval)\n  (parser-bind\n   (parser-char #\\{)\n   (lambda (_)\n     (parser-bind\n      (parser-option-maybe parser-natural)\n      (lambda (min-maybe)\n        (parser-or\n         (parser-bind\n          (parser-char #\\})\n          (lambda (_)\n            (if (nothing? min-maybe)\n                (parser-fail \"empty interval {} is invalid\")\n                (let ([n (from-just min-maybe)])\n                  (parser-pure (cons n n))))))\n         (parser-bind\n          (parser-char #\\,)\n          (lambda (_)\n            (parser-bind\n             (parser-option-maybe parser-natural)\n             (lambda (max-maybe)\n               (parser-bind\n                (parser-char #\\})\n                (lambda (_)\n                  (let ([min (if (nothing? min-maybe) 1 (from-just min-maybe))]\n                        [max (if (nothing? max-maybe) #f (from-just max-maybe))])\n                    (parser-pure (cons min max)))))))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3))\n```"}
{"id": "fp_parsing_regex_parser_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-postfix-op` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Star and plus semantics are swapped; postfix mapping must preserve operator meaning.\n\n```scheme\n(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-plus expr)]\n     [(char=? op #\\+) (regex-star expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t) (equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-postfix-op` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Star and plus semantics are swapped; postfix mapping must preserve operator meaning.\n\n```scheme\n(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-plus expr)]\n     [(char=? op #\\+) (regex-star expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-postfix-op` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Interval pairs are (min . max); swapping bounds corrupts repeat semantics.\n\n```scheme\n(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (cdr op) (car op))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r))) '(2 4))\n```", "ground_truth": "(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (car op) (cdr op))]))", "verify_expr": "(and (let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (and (regex-star? s) (regex-plus? p) (regex-opt? o) (regex-repeat? r) (= (regex-repeat-min r) 2) (= (regex-repeat-max r) 4))) (equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t) (equal? (let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r))) '(2 4)))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "apply-postfix-op"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `apply-postfix-op` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Interval pairs are (min . max); swapping bounds corrupts repeat semantics.\n\n```scheme\n(define (apply-postfix-op expr op)\n  (cond\n   [(char? op)\n    (cond\n     [(char=? op #\\*) (regex-star expr)]\n     [(char=? op #\\+) (regex-plus expr)]\n     [(char=? op #\\?) (regex-opt expr)])]\n   [(pair? op)\n    (regex-repeat expr (cdr op) (car op))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-star? s))\n(let* ([lit (regex-lit #\\a)] [s (apply-postfix-op lit #\\*)] [p (apply-postfix-op lit #\\+)] [o (apply-postfix-op lit #\\?)] [r (apply-postfix-op lit (cons 2 4))]) (regex-plus? p))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r))) '(2 4))\n```"}
{"id": "fp_parsing_regex_parser_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-seq` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Empty and singleton sequences must normalize to regex-empty/single-node, not always regex-seq.\n\n```scheme\n(define (parse-seq)\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure (regex-seq exprs)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-seq"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-seq` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Empty and singleton sequences must normalize to regex-empty/single-node, not always regex-seq.\n\n```scheme\n(define (parse-seq)\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure (regex-seq exprs)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-seq` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Sequence parser must allow zero terms so empty pattern parses as regex-empty.\n\n```scheme\n(define (parse-seq)\n  (parser-bind\n   (parser-some (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (if (null? (cdr exprs))\n          (car exprs)\n          (regex-seq exprs))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t)\n```", "ground_truth": "(define (parse-seq)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parser-many (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (cond\n       [(null? exprs) (regex-empty)]\n       [(null? (cdr exprs)) (car exprs)]\n       [else (regex-seq exprs)])))))", "verify_expr": "(and (let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (and (right? e0) (regex-empty? (from-right e0)) (right? e1) (regex-lit? (from-right e1)) (right? e2) (regex-seq? (from-right e2)) (= (length (regex-seq-exprs (from-right e2))) 2))) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t) (equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-seq"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-seq` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Sequence parser must allow zero terms so empty pattern parses as regex-empty.\n\n```scheme\n(define (parse-seq)\n  (parser-bind\n   (parser-some (parse-postfix))\n   (lambda (exprs)\n     (parser-pure\n      (if (null? (cdr exprs))\n          (car exprs)\n          (regex-seq exprs))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (right? e0))\n(let ([e0 (parser-parse (parser-left (parse-seq) parser-eof) \"\")] [e1 (parser-parse (parser-left (parse-seq) parser-eof) \"a\")] [e2 (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (regex-empty? (from-right e0)))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-alt` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Alternation must support repeated | branches, not just a single optional branch.\n\n```scheme\n(define (parse-alt)\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-option-maybe (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest-maybe)\n        (if (nothing? rest-maybe)\n            (parser-pure first)\n            (parser-pure (regex-alt (list first (from-just rest-maybe))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t) (= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-alt"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-alt` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Alternation must support repeated | branches, not just a single optional branch.\n\n```scheme\n(define (parse-alt)\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-option-maybe (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest-maybe)\n        (if (nothing? rest-maybe)\n            (parser-pure first)\n            (parser-pure (regex-alt (list first (from-just rest-maybe))))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-alt` in `lattice/fp/parsing/regex.ss`.\nKnown issue: When no | appears, parser must return the sequence directly instead of wrapping singleton alt.\n\n```scheme\n(define (parse-alt)\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure (regex-alt (cons first rest))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: When no | appears, parser must return the sequence directly instead of wrapping singleton alt.\n\nExpected behavior after patch:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```", "ground_truth": "(define (parse-alt)\n  (doc 'type '(Parser RegexAST))\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure\n         (if (null? rest)\n             first\n             (regex-alt (cons first rest)))))))))", "verify_expr": "(and (let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? a) (regex-alt? (from-right a)) (= (length (regex-alt-exprs (from-right a))) 3) (right? b) (regex-seq? (from-right b)) (right? c) (regex-alt? (from-right c)) (let ([alts (regex-alt-exprs (from-right c))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) (equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t) (= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "parse-alt"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-alt` in `lattice/fp/parsing/regex.ss`.\nKnown issue: When no | appears, parser must return the sequence directly instead of wrapping singleton alt.\n\n```scheme\n(define (parse-alt)\n  (parser-bind\n   (parse-seq)\n   (lambda (first)\n     (parser-bind\n      (parser-many (parser-then (parser-char #\\|) (parse-seq)))\n      (lambda (rest)\n        (parser-pure (regex-alt (cons first rest))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: When no | appears, parser must return the sequence directly instead of wrapping singleton alt.\n\nExpected behavior after patch:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (right? a))\n(let* ([a (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")] [b (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")] [c (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (regex-alt? (from-right a)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)\n```\n\nCheck 2:\n```scheme\n(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: {0,0} must match empty string, not empty language.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (make-fsm '(dead) '() '() 'dead '())]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: {0,0} must match empty string, not empty language.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (make-fsm '(dead) '() '() 'dead '())]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\nExpected behavior after patch:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\nExpected behavior after patch:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-anchor` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Anchors are assertion transitions, not epsilon edges on a plain FSM.\n\n```scheme\n(define (compile-anchor type)\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm (list s0 s1) '() '() s0 (list s1) (list (list s0 s1)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-anchor"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-anchor` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Anchors are assertion transitions, not epsilon edges on a plain FSM.\n\n```scheme\n(define (compile-anchor type)\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm (list s0 s1) '() '() s0 (list s1) (list (list s0 s1)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-anchor` in `lattice/fp/parsing/regex.ss`.\nKnown issue: compile-anchor must preserve caller-supplied anchor type instead of hardcoding start.\n\n```scheme\n(define (compile-anchor type)\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor 'start s1)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: compile-anchor must preserve caller-supplied anchor type instead of hardcoding start.\n\nExpected behavior after patch:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t)\n```", "ground_truth": "(define (compile-anchor type)\n  (doc 'type '(-> Symbol FSM))\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor type s1)))))", "verify_expr": "(and (let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (and (pair? sas) (pair? eas) (fsm-accepts? s \"\") (fsm-accepts? e \"\") (not (fsm-accepts? s \"x\")) (not (fsm-accepts? e \"x\")) (equal? (cadr (car sas)) 'anchor) (equal? (caddr (car sas)) 'start) (equal? (caddr (car eas)) 'end))) (equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-anchor"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-anchor` in `lattice/fp/parsing/regex.ss`.\nKnown issue: compile-anchor must preserve caller-supplied anchor type instead of hardcoding start.\n\n```scheme\n(define (compile-anchor type)\n  (let ([s0 (fsm-fresh-state \"anc\")]\n        [s1 (fsm-fresh-state \"anc\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor 'start s1)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: compile-anchor must preserve caller-supplied anchor type instead of hardcoding start.\n\nExpected behavior after patch:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? sas))\n(let* ([s (compile-anchor 'start)] [e (compile-anchor 'end)] [sas (fsm-assertions s)] [eas (fsm-assertions e)]) (pair? eas))\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-lookahead` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Lookahead polarity must follow the positive? argument; forcing #t breaks negative lookahead.\n\n```scheme\n(define (compile-lookahead expr positive? universe)\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner #t s1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Lookahead polarity must follow the positive? argument; forcing #t breaks negative lookahead.\n\nExpected behavior after patch:\n```scheme\n(let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (fsm-accepts? pos \"a\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-lookahead` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Lookahead polarity must follow the positive? argument; forcing #t breaks negative lookahead.\n\n```scheme\n(define (compile-lookahead expr positive? universe)\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner #t s1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Lookahead polarity must follow the positive? argument; forcing #t breaks negative lookahead.\n\nExpected behavior after patch:\n```scheme\n(let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (fsm-accepts? pos \"a\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-lookahead` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Lookahead compilation must emit lookahead assertions carrying the inner regex machine.\n\n```scheme\n(define (compile-lookahead expr positive? universe)\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor 'start s1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (fsm-accepts? pos \"a\"))\n(let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (not (fsm-accepts? pos \"b\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```", "ground_truth": "(define (compile-lookahead expr positive? universe)\n  (doc 'type '(-> RegexAST Boolean (List Char) FSM))\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'lookahead inner positive? s1)))))", "verify_expr": "(and (let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (and (fsm-accepts? pos \"a\") (not (fsm-accepts? pos \"b\")) (fsm-accepts? neg \"a\") (not (fsm-accepts? neg \"b\")) (equal? (cadr pa) 'lookahead) (equal? (cadddr pa) #t) (equal? (cadddr na) #f))) (equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t) (equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-lookahead"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-lookahead` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Lookahead compilation must emit lookahead assertions carrying the inner regex machine.\n\n```scheme\n(define (compile-lookahead expr positive? universe)\n  (let ([inner (regex-compile expr universe)]\n        [s0 (fsm-fresh-state \"la\")]\n        [s1 (fsm-fresh-state \"la\")])\n    (make-fsm-with-assertions\n     (list s0 s1) '() '() s0 (list s1) '()\n     (list (list s0 'anchor 'start s1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (fsm-accepts? pos \"a\"))\n(let* ([u '(#\\a #\\b #\\c)] [pos (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))] [neg (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))] [pa (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t u)))] [na (car (fsm-assertions (compile-lookahead (regex-lit #\\b) #f u)))]) (not (fsm-accepts? pos \"b\")))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)\n```"}
{"id": "fp_parsing_regex_parser_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: compose existing APIs into one expression.\n\nParse class range `a-z` and return expanded character count.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1))", "verify_expr": "(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-class-range", "range-size"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nParse class range `a-z` and return expanded character count.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: compose existing APIs into one expression.\n\nParse class range `0-2` and return the expanded character list.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '()))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"0-2\")]) (if (right? r) (from-right r) '())) '(#\\0 #\\1 #\\2))", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-class-range", "digits"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nParse class range `0-2` and return the expanded character list.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether parsing reversed class range `z-a` fails.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\"))", "verify_expr": "(equal? (left? (parser-parse (parser-left (parse-class-range) parser-eof) \"z-a\")) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-class-range", "invalid-range"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether parsing reversed class range `z-a` fails.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse class range `m-m` and return whether it expands to a singleton list.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"m-m\")]) (and (right? r) (equal? (from-right r) '(#\\m)))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-class-range", "singleton"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nParse class range `m-m` and return whether it expands to a singleton list.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: small integration task across module primitives.\n\nParse interval token `{3}` and return the parsed min/max pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad)))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{3}\")]) (if (right? r) (from-right r) '(bad))) (cons 3 3))", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-interval", "exact"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse interval token `{3}` and return the parsed min/max pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: small integration task across module primitives.\n\nParse interval token `{2,}` and return parsed pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad)))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{2,}\")]) (if (right? r) (from-right r) '(bad))) (cons 2 #f))", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-interval", "unbounded"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse interval token `{2,}` and return parsed pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: small integration task across module primitives.\n\nParse interval token `{,4}` and return parsed pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-interval`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `from-right`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad)))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-interval", "lower-default"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse interval token `{,4}` and return parsed pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-interval`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `from-right`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether invalid interval `{4,2}` fails to parse.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\"))", "verify_expr": "(equal? (left? (parser-parse (parser-left (parse-interval) parser-eof) \"{4,2}\")) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-interval", "validation"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether invalid interval `{4,2}` fails to parse.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply `*` postfix to literal `a` and return whether result is regex-star.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-star?`\n- `regex-lit`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(regex-star? (apply-postfix-op (regex-lit #\\a) #\\*))", "verify_expr": "(equal? (regex-star? (apply-postfix-op (regex-lit #\\a) #\\*)) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "apply-postfix-op", "star"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nApply `*` postfix to literal `a` and return whether result is regex-star.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-star?`\n- `regex-lit`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply `+` postfix to literal `a` and return whether result is regex-plus.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+))", "verify_expr": "(equal? (regex-plus? (apply-postfix-op (regex-lit #\\a) #\\+)) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "apply-postfix-op", "plus"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nApply `+` postfix to literal `a` and return whether result is regex-plus.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply interval postfix (2 . 4) to literal `a` and return parsed bounds from regex-repeat.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-lit`\n- `cons`\n- `list`\n- `regex-repeat-min`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r)))", "verify_expr": "(equal? (let ([r (apply-postfix-op (regex-lit #\\a) (cons 2 4))]) (list (regex-repeat-min r) (regex-repeat-max r))) '(2 4))", "tags": ["tier1", "fp", "parsing", "regex", "composition", "apply-postfix-op", "interval"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nApply interval postfix (2 . 4) to literal `a` and return parsed bounds from regex-repeat.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-lit`\n- `cons`\n- `list`\n- `regex-repeat-min`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile optional postfix on literal `a` and return whether resulting FSM accepts empty and `a` but rejects `aa`.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-compile`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\"))))", "verify_expr": "(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "apply-postfix-op", "optional"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile optional postfix on literal `a` and return whether resulting FSM accepts empty and `a` but rejects `aa`.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-compile`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: small integration task across module primitives.\n\nParse empty input with parse-seq and return whether AST is regex-empty.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-seq", "empty"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse empty input with parse-seq and return whether AST is regex-empty.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse `ab` with parse-seq and return concatenation arity.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-seq`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-seq?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1))", "verify_expr": "(= (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"ab\")]) (if (and (right? r) (regex-seq? (from-right r))) (length (regex-seq-exprs (from-right r))) -1)) 2)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-seq", "concat"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nParse `ab` with parse-seq and return concatenation arity.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-seq`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-seq?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse `a*` with parse-seq and return whether singleton result is regex-star.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a*\")]) (and (right? r) (regex-star? (from-right r)))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-seq", "singleton"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nParse `a*` with parse-seq and return whether singleton result is regex-star.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: compose existing APIs into one expression.\n\nParse `a(?=b)` with parse-seq and return whether it becomes a 2-term sequence.\n\nEnsure `parse-seq` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `parse-seq`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-seq?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2)))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"a(?=b)\")]) (and (right? r) (regex-seq? (from-right r)) (= (length (regex-seq-exprs (from-right r))) 2))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-seq", "lookahead-seq"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nParse `a(?=b)` with parse-seq and return whether it becomes a 2-term sequence.\n\nEnsure `parse-seq` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `parse-seq`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-seq?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: compose existing APIs into one expression.\n\nParse `a|b|c` and return alternation branch count.\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-alt`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-alt?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1))", "verify_expr": "(= (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b|c\")]) (if (and (right? r) (regex-alt? (from-right r))) (length (regex-alt-exprs (from-right r))) -1)) 3)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-alt", "nary-alt"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nParse `a|b|c` and return alternation branch count.\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-alt`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-alt?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: small integration task across module primitives.\n\nParse `ab` with parse-alt and return whether AST remains sequence (not alternation).\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-alt`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-seq?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"ab\")]) (and (right? r) (regex-seq? (from-right r)))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-alt", "no-alt"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse `ab` with parse-alt and return whether AST remains sequence (not alternation).\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-alt`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-seq?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nParse `a|bc` and return whether second alternation branch is a sequence.\n\nEnsure `parse-alt` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `parse-alt`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-alt?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts))))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|bc\")]) (and (right? r) (regex-alt? (from-right r)) (let ([alts (regex-alt-exprs (from-right r))]) (and (= (length alts) 2) (regex-seq? (cadr alts)))))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-alt", "mixed-branches"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nParse `a|bc` and return whether second alternation branch is a sequence.\n\nEnsure `parse-alt` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `parse-alt`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `regex-alt?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: small integration task across module primitives.\n\nParse `a|b` and return whether first branch is literal `a`.\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a)))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-alt", "branch-shape"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse `a|b` and return whether first branch is literal `a`.\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: small integration task across module primitives.\n\nCompile repeat bounds {0,0} for literal `a` and return whether FSM accepts only empty string.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-repeat`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\"))))", "verify_expr": "(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-repeat", "zero-zero"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompile repeat bounds {0,0} for literal `a` and return whether FSM accepts only empty string.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-repeat`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile repeat bounds {2,4} for literal `a` and return acceptance for aa/aaaa with rejection for a/aaaaa.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-repeat`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\"))))", "verify_expr": "(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-repeat", "bounded"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile repeat bounds {2,4} for literal `a` and return acceptance for aa/aaaa with rejection for a/aaaaa.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-repeat`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile repeat bounds {2,} for literal `a` and return acceptance for aa/aaaaa with rejection for a.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-repeat`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\"))))", "verify_expr": "(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-repeat", "unbounded"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile repeat bounds {2,} for literal `a` and return acceptance for aa/aaaaa with rejection for a.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-repeat`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile repeat bounds {0,2} for literal `a` and return whether empty/a/aa pass but aaa fails.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\"))))", "verify_expr": "(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-repeat", "zero-upper"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile repeat bounds {0,2} for literal `a` and return whether empty/a/aa pass but aaa fails.\n\nEnsure `compile-repeat` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile start anchor and return whether assertion metadata encodes anchor/start.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start)))", "verify_expr": "(equal? (let ([a (car (fsm-assertions (compile-anchor 'start)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'start))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-anchor", "metadata"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile start anchor and return whether assertion metadata encodes anchor/start.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile end anchor and return whether assertion metadata encodes anchor/end.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-anchor`\n- `car`\n- `fsm-assertions`\n- `equal?`\n- `cadr`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end)))", "verify_expr": "(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-anchor", "metadata"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile end anchor and return whether assertion metadata encodes anchor/end.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-anchor`\n- `car`\n- `fsm-assertions`\n- `equal?`\n- `cadr`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose start anchor with literal `a` and return whether it accepts `a` but rejects `ba`.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\"))))", "verify_expr": "(equal? (let ([m (fsm-concat (compile-anchor 'start) (fsm-literal \"a\"))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"ba\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-anchor", "anchored-prefix"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompose start anchor with literal `a` and return whether it accepts `a` but rejects `ba`.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConcatenate start and end anchors and return whether result matches only empty string.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\"))))", "verify_expr": "(equal? (let ([m (fsm-concat (compile-anchor 'start) (compile-anchor 'end))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-anchor", "empty-only"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nConcatenate start and end anchors and return whether result matches only empty string.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose positive lookahead for `a` with literal `a` and return acceptance for `a` with rejection for `b`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\"))))", "verify_expr": "(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\a) #t u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-lookahead", "positive"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompose positive lookahead for `a` with literal `a` and return acceptance for `a` with rejection for `b`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose negative lookahead for `b` with literal `a` and return acceptance for `a` with rejection for `b`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `regex-lit`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\"))))", "verify_expr": "(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-lookahead", "negative"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompose negative lookahead for `b` with literal `a` and return acceptance for `a` with rejection for `b`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `regex-lit`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile positive lookahead and return whether assertion metadata stores lookahead with #t polarity.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `car`\n- `fsm-assertions`\n- `regex-lit`\n- `equal?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t)))", "verify_expr": "(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-lookahead", "metadata"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile positive lookahead and return whether assertion metadata stores lookahead with #t polarity.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `car`\n- `fsm-assertions`\n- `regex-lit`\n- `equal?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild `a(?=b)b` from primitives and return whether it matches `ab` but rejects `ac`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `fsm-char`\n- `regex-lit`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\"))))", "verify_expr": "(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-lookahead", "sequence-integration"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild `a(?=b)b` from primitives and return whether it matches `ab` but rejects `ac`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `fsm-char`\n- `regex-lit`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
