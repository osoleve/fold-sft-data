{"id": "fp_parsing_regex_parser_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-repeat`\nSpec: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nWrite exactly one Scheme function definition for `compile-repeat`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "spec-to-code", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this regex parsing/compilation utility in Fold-native Scheme.\n\nTarget module: lattice/fp/parsing/regex.ss\nFunction: `compile-repeat`\nSpec: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nWrite exactly one Scheme function definition for `compile-repeat`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  ;; TODO: compile repeat bounds into equivalent FSM composition\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-repeat`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "skeleton-completion", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  ;; TODO: compile repeat bounds into equivalent FSM composition\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compile-repeat`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-repeat` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-repeat`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "contract-implementation", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement `compile-repeat` from this regex parser contract.\n\nModule: `lattice/fp/parsing/regex.ss`\nContract focus: Compile bounded/unbounded repetition to an FSM matching regex quantifier semantics.\n\nRequirements:\n1. Preserve regex/parse semantics and edge cases.\n2. Keep the exact function name/signature for `compile-repeat`.\n3. Return one production-ready definition only.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-repeat`.\nReturn only the Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "python-to-scheme", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compile-repeat`.\nReturn only the Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_017", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-repeat`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-repeat* expr mn mx universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= mn 0) (eqv? mx 0)) (fsm-epsilon-lang)]\n     [(and (= mn 0) (not mx)) (fsm-star base)]\n     [(= mn 0)\n      (fold-left (lambda (acc _) (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota mx))]\n     [(eqv? mn mx)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- mn 1))))]\n     [(not mx)\n      (let ([req (fold-left fsm-concat base\n                            (map (lambda (_) (regex-compile expr universe))\n                                 (iota (- mn 1))))])\n        (fsm-concat req (fsm-star base)))]\n     [else\n      (let* ([req (fold-left fsm-concat base\n                             (map (lambda (_) (regex-compile expr universe))\n                                  (iota (- mn 1))))]\n             [opt (fold-left (lambda (acc _)\n                               (fsm-concat (fsm-optional base) acc))\n                             (fsm-epsilon-lang)\n                             (iota (- mx mn)))])\n        (fsm-concat req opt))])))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "chez-to-fold", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compile-repeat`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compile-repeat* expr mn mx universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= mn 0) (eqv? mx 0)) (fsm-epsilon-lang)]\n     [(and (= mn 0) (not mx)) (fsm-star base)]\n     [(= mn 0)\n      (fold-left (lambda (acc _) (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota mx))]\n     [(eqv? mn mx)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- mn 1))))]\n     [(not mx)\n      (let ([req (fold-left fsm-concat base\n                            (map (lambda (_) (regex-compile expr universe))\n                                 (iota (- mn 1))))])\n        (fsm-concat req (fsm-star base)))]\n     [else\n      (let* ([req (fold-left fsm-concat base\n                             (map (lambda (_) (regex-compile expr universe))\n                                  (iota (- mn 1))))]\n             [opt (fold-left (lambda (acc _)\n                               (fsm-concat (fsm-optional base) acc))\n                             (fsm-epsilon-lang)\n                             (iota (- mx mn)))])\n        (fsm-concat req opt))])))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 2 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (fsm-accepts? m \"aa\") (not (fsm-accepts? m \"aaa\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-repeat`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-repeat`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "reference-translation", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compile-repeat`.\n\nPreserve observable behavior exactly (including failure cases).\nKeep the target function name/signature as `compile-repeat`.\nReturn only the final Scheme definition.\n\n```python\ndef compile_repeat(expr, mn, mx, universe):\n    base = regex_compile(expr, universe)\n    if mn == 0 and mx == 0:\n        return fsm_epsilon_lang()\n    if mn == 0 and mx is None:\n        return fsm_star(base)\n    if mn == 0:\n        acc = fsm_epsilon_lang()\n        for _ in range(mx):\n            acc = fsm_optional(fsm_concat(base, acc))\n        return acc\n    if mx == mn:\n        return concat_n(base, mn)\n    if mx is None:\n        return fsm_concat(concat_n(base, mn), fsm_star(base))\n    return fsm_concat(concat_n(base, mn), concat_optional(base, mx - mn))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: {0,0} must match empty string, not empty language.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (make-fsm '(dead) '() '() 'dead '())]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: {0,0} must match empty string, not empty language.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (make-fsm '(dead) '() '() 'dead '())]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (not (fsm-accepts? z \"a\")))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 0 0 '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (not (fsm-accepts? m \"a\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-repeat", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\nExpected behavior after patch:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```", "ground_truth": "(define (compile-repeat expr min max universe)\n  (doc 'type '(-> RegexAST Nat (Option Nat) (List Char) FSM))\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (let ([required (fold-left fsm-concat base\n                                 (map (lambda (_) (regex-compile expr universe))\n                                      (iota (- min 1))))])\n        (fsm-concat required (fsm-star base)))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))", "verify_expr": "(and (let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (and (fsm-accepts? z \"\") (not (fsm-accepts? z \"a\")) (fsm-accepts? r24 \"aa\") (fsm-accepts? r24 \"aaaa\") (not (fsm-accepts? r24 \"a\")) (not (fsm-accepts? r24 \"aaaaa\")) (fsm-accepts? r2p \"aa\") (fsm-accepts? r2p \"aaaaa\") (not (fsm-accepts? r2p \"a\")) (fsm-accepts? r02 \"\") (fsm-accepts? r02 \"aa\") (not (fsm-accepts? r02 \"aaa\")))) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t) (equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t))", "tags": ["tier1", "fp", "parsing", "regex", "bugfix", "compile-repeat"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compile-repeat` in `lattice/fp/parsing/regex.ss`.\nKnown issue: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\n```scheme\n(define (compile-repeat expr min max universe)\n  (let ([base (regex-compile expr universe)])\n    (cond\n     [(and (= min 0) (eqv? max 0))\n      (fsm-epsilon-lang)]\n     [(and (= min 0) (not max))\n      (fsm-star base)]\n     [(= min 0)\n      (fold-left (lambda (acc _)\n                   (fsm-optional (fsm-concat base acc)))\n                 (fsm-epsilon-lang)\n                 (iota max))]\n     [(eqv? min max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [(not max)\n      (fold-left fsm-concat base\n                 (map (lambda (_) (regex-compile expr universe))\n                      (iota (- min 1))))]\n     [else\n      (let* ([required (fold-left fsm-concat base\n                                  (map (lambda (_) (regex-compile expr universe))\n                                       (iota (- min 1))))]\n             [optional (fold-left (lambda (acc _)\n                                    (fsm-concat (fsm-optional base) acc))\n                                  (fsm-epsilon-lang)\n                                  (iota (- max min)))])\n        (fsm-concat required optional))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Unbounded upper ranges {n,} require concatenating a trailing star for extra repetitions.\n\nExpected behavior after patch:\n```scheme\n(let* ([u '(#\\a #\\b)] [z (compile-repeat (regex-lit #\\a) 0 0 u)] [r24 (compile-repeat (regex-lit #\\a) 2 4 u)] [r2p (compile-repeat (regex-lit #\\a) 2 #f u)] [r02 (compile-repeat (regex-lit #\\a) 0 2 u)]) (fsm-accepts? z \"\"))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 4 '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaa\") (not (fsm-accepts? m \"a\")) (not (fsm-accepts? m \"aaaaa\")))) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let ([m (compile-repeat (regex-lit #\\a) 2 #f '(#\\a #\\b))]) (and (fsm-accepts? m \"aa\") (fsm-accepts? m \"aaaaa\") (not (fsm-accepts? m \"a\")))) #t)\n```"}
{"id": "fp_parsing_regex_parser_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-class-range", "prompt": "Task mode: compose existing APIs into one expression.\n\nParse class range `a-z` and return expanded character count.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1))", "verify_expr": "(= (let ([r (parser-parse (parser-left (parse-class-range) parser-eof) \"a-z\")]) (if (right? r) (length (from-right r)) -1)) 26)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-class-range", "range-size"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nParse class range `a-z` and return expanded character count.\n\nEnsure `parse-class-range` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-interval", "prompt": "Task mode: small integration task across module primitives.\n\nParse interval token `{,4}` and return parsed pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-interval`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `from-right`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad)))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-interval) parser-eof) \"{,4}\")]) (if (right? r) (from-right r) '(bad))) (cons 0 4))", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-interval", "lower-default"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse interval token `{,4}` and return parsed pair.\n\nEnsure `parse-interval` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `parse-interval`\n- `parser-parse`\n- `parser-left`\n- `right?`\n- `from-right`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "apply-postfix-op", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile optional postfix on literal `a` and return whether resulting FSM accepts empty and `a` but rejects `aa`.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-compile`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\"))))", "verify_expr": "(equal? (let ([m (regex-compile (apply-postfix-op (regex-lit #\\a) #\\?) '(#\\a #\\b))]) (and (fsm-accepts? m \"\") (fsm-accepts? m \"a\") (not (fsm-accepts? m \"aa\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "apply-postfix-op", "optional"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile optional postfix on literal `a` and return whether resulting FSM accepts empty and `a` but rejects `aa`.\n\nEnsure `apply-postfix-op` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `apply-postfix-op`\n- `regex-compile`\n- `regex-lit`\n- `fsm-accepts?`\n- `not`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "fp_parsing_regex_parser_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-seq", "prompt": "Task mode: small integration task across module primitives.\n\nParse empty input with parse-seq and return whether AST is regex-empty.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-seq) parser-eof) \"\")]) (and (right? r) (regex-empty? (from-right r)))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-seq", "empty"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse empty input with parse-seq and return whether AST is regex-empty.\n\nEnsure `parse-seq` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "parse-alt", "prompt": "Task mode: small integration task across module primitives.\n\nParse `a|b` and return whether first branch is literal `a`.\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a)))))", "verify_expr": "(equal? (let ([r (parser-parse (parser-left (parse-alt) parser-eof) \"a|b\")]) (and (right? r) (regex-alt? (from-right r)) (let ([a1 (car (regex-alt-exprs (from-right r)))]) (and (regex-lit? a1) (equal? (regex-lit-char a1) #\\a))))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "parse-alt", "branch-shape"], "split": "eval", "prompt_body": "Task mode: small integration task across module primitives.\n\nParse `a|b` and return whether first branch is literal `a`.\n\nEnsure `parse-alt` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-anchor", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompile end anchor and return whether assertion metadata encodes anchor/end.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-anchor`\n- `car`\n- `fsm-assertions`\n- `equal?`\n- `cadr`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end)))", "verify_expr": "(equal? (let ([a (car (fsm-assertions (compile-anchor 'end)))]) (and (equal? (cadr a) 'anchor) (equal? (caddr a) 'end))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-anchor", "metadata"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompile end anchor and return whether assertion metadata encodes anchor/end.\n\nEnsure `compile-anchor` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-anchor`\n- `car`\n- `fsm-assertions`\n- `equal?`\n- `cadr`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose negative lookahead for `b` with literal `a` and return acceptance for `a` with rejection for `b`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `regex-lit`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\"))))", "verify_expr": "(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (compile-lookahead (regex-lit #\\b) #f u) (fsm-char #\\a))]) (and (fsm-accepts? m \"a\") (not (fsm-accepts? m \"b\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-lookahead", "negative"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompose negative lookahead for `b` with literal `a` and return acceptance for `a` with rejection for `b`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `regex-lit`\n- `fsm-char`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "fp_parsing_regex_parser_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompile positive lookahead and return whether assertion metadata stores lookahead with #t polarity.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `car`\n- `fsm-assertions`\n- `regex-lit`\n- `equal?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t)))", "verify_expr": "(equal? (let ([a (car (fsm-assertions (compile-lookahead (regex-lit #\\a) #t '(#\\a #\\b #\\c))))]) (and (equal? (cadr a) 'lookahead) (equal? (cadddr a) #t))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-lookahead", "metadata"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompile positive lookahead and return whether assertion metadata stores lookahead with #t polarity.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `car`\n- `fsm-assertions`\n- `regex-lit`\n- `equal?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "fp_parsing_regex_parser_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/fp/parsing/regex.ss", "source_test": "lattice/fp/parsing/test-regex.ss", "source_function": "compile-lookahead", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild `a(?=b)b` from primitives and return whether it matches `ab` but rejects `ac`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `fsm-char`\n- `regex-lit`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\"))))", "verify_expr": "(equal? (let* ([u '(#\\a #\\b #\\c)] [m (fsm-concat (fsm-char #\\a) (fsm-concat (compile-lookahead (regex-lit #\\b) #t u) (fsm-char #\\b)))]) (and (fsm-accepts? m \"ab\") (not (fsm-accepts? m \"ac\")))) #t)", "tags": ["tier1", "fp", "parsing", "regex", "composition", "compile-lookahead", "sequence-integration"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nBuild `a(?=b)b` from primitives and return whether it matches `ab` but rejects `ac`.\n\nEnsure `compile-lookahead` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `compile-lookahead`\n- `fsm-concat`\n- `fsm-char`\n- `regex-lit`\n- `fsm-accepts?`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
