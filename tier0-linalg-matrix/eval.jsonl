{"id": "matrix_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-ref`\nSpec: Return element at (i,j) when in bounds, else `(error out-of-bounds (i j) (rows cols))`.\n\nWrite exactly one Scheme function definition for `matrix-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (and (= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6) (equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-ref"], "split": "eval"}
{"id": "matrix_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-map2`\nSpec: Apply binary function elementwise on two same-shape matrices, else dimension-mismatch error.\n\nWrite exactly one Scheme function definition for `matrix-map2`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))\n  (and (equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44))) (equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-map2"], "split": "eval"}
{"id": "matrix_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-identity`\nSpec: Construct n x n identity matrix with ones on diagonal and zeros elsewhere.\n\nWrite exactly one Scheme function definition for `matrix-identity`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1)))\n(equal? (matrix->lists (matrix-identity 0)) '())\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1))) (equal? (matrix->lists (matrix-identity 0)) '())))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-identity"], "split": "eval"}
{"id": "matrix_translation_001", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-from-lists`\n\n```python\ndef matrix_from_lists(rows):\n    if not rows:\n        return ['matrix', 0, 0, []]\n    m = len(rows)\n    n = len(rows[0])\n    i = 0\n    for r in rows:\n        if len(r) != n:\n            return ['error', 'ragged-input', 'row', i, 'expected-length', n, 'actual-length', len(r)]\n        i += 1\n    data = [0] * (m * n)\n    for i in range(m):\n        for j in range(n):\n            data[i * n + j] = rows[i][j]\n    return ['matrix', m, n, list_to_vector(data)]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-from-lists"], "split": "eval"}
{"id": "matrix_translation_009", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-mul`\n\n```python\ndef matrix_mul(m1, m2):\n    r1, c1 = matrix_rows(m1), matrix_cols(m1)\n    r2, c2 = matrix_rows(m2), matrix_cols(m2)\n    if c1 != r2:\n        return ['error', 'dimension-mismatch', [r1, c1], [r2, c2]]\n    d1, d2 = matrix_data(m1), matrix_data(m2)\n    out = [0] * (r1 * c2)\n    for i in range(r1):\n        for k in range(c1):\n            a_ik = d1[i * c1 + k]\n            b_row_k = k * c2\n            c_row_i = i * c2\n            for j in range(c2):\n                idx = c_row_i + j\n                out[idx] = out[idx] + a_ik * d2[b_row_k + j]\n    return ['matrix', r1, c2, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))\n(equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-mul"], "split": "eval"}
{"id": "matrix_translation_016", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-submatrix`\n\n```scheme\n(define (mat-sub m r1 c1 r2 c2)\n  (let ((rows (matrix-rows m))\n        (cols (matrix-cols m))\n        (data (matrix-data m)))\n    (cond ((or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1)))\n          ((or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2)))\n          ((or (> r1 r2) (> c1 c2)) `(error invalid-range))\n          (else\n           (let* ((nr (- r2 r1)) (nc (- c2 c1)) (out (make-vector (* nr nc) 0)))\n             (do ((i 0 (+ i 1)))\n                 ((= i nr) (list 'matrix nr nc out))\n               (do ((j 0 (+ j 1)))\n                   ((= j nc))\n                 (vector-set! out (+ (* i nc) j)\n                              (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11)))\n(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-submatrix"], "split": "eval"}
{"id": "matrix_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-from-lists` in `lattice/linalg/matrix.ss`.\nKnown issue: Must validate ragged rows and return ragged-input error.\n\n```scheme\n(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)] [n (length (car rows))] [data (make-vector (* m n) 0)])\n        (do ([i 0 (+ i 1)] [rs rows (cdr rs)])\n            ((= i m) (list 'matrix m n data))\n          (do ([j 0 (+ j 1)] [cs (car rs) (cdr cs)])\n              ((= j n))\n            (vector-set! data (+ (* i n) j) (car cs)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6)))\n(equal? (matrix->lists (matrix-from-lists '())) '())\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "bugfix", "matrix-from-lists"], "split": "eval"}
{"id": "matrix_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-mul` in `lattice/linalg/matrix.ss`.\nKnown issue: Compatibility check must be `c1 = r2`.\n\n```scheme\n(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)] [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n    (if (not (= r1 c2))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let* ([data1 (matrix-data m1)] [data2 (matrix-data m2)] [result (make-vector (* r1 c2) 0)])\n          (do ([i 0 (+ i 1)])\n              ((= i r1))\n            (do ([k 0 (+ k 1)])\n                ((= k c1))\n              (let ([a-ik (vector-ref data1 (+ (* i c1) k))] [b-row-k (* k c2)] [c-row-i (* i c2)])\n                (do ([j 0 (+ j 1)])\n                    ((= j c2))\n                  (let ([idx (+ c-row-i j)])\n                    (vector-set! result idx (+ (vector-ref result idx) (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n          (list 'matrix r1 c2 result)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-mul"], "split": "eval"}
{"id": "matrix_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-submatrix` in `lattice/linalg/matrix.ss`.\nKnown issue: Upper bounds should allow r2=rows and c2=cols for full-edge slices.\n\n```scheme\n(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)])\n    (cond\n      [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n      [(or (>= r2 rows) (>= c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n      [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n      [else\n       (let* ([new-rows (- r2 r1)] [new-cols (- c2 c1)] [result (make-vector (* new-rows new-cols) 0)])\n         (do ([i 0 (+ i 1)])\n             ((= i new-rows) (list 'matrix new-rows new-cols result))\n           (do ([j 0 (+ j 1)])\n               ((= j new-cols))\n             (vector-set! result (+ (* i new-cols) j)\n                          (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-submatrix"], "split": "eval"}
{"id": "matrix_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: small integration task across module primitives.\n\nBuild matrix from '((1 2) (3 4)) and return as lists.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-from-lists '((1 2) (3 4)))) '((1 2) (3 4)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-from-lists '((1 2) (3 4))))", "verify_expr": "(equal? (matrix->lists (matrix-from-lists '((1 2) (3 4)))) '((1 2) (3 4)))", "tags": ["linalg", "matrix", "composition", "matrix-from-lists", "direct"], "split": "eval"}
{"id": "matrix_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: compose existing APIs into one expression.\n\nTranspose ((1 2 3) (4 5 6)).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))))", "verify_expr": "(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))", "tags": ["linalg", "matrix", "composition", "matrix-transpose", "direct"], "split": "eval"}
{"id": "matrix_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMultiply ((1 2)(3 4)) by ((5 6)(7 8)).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))))", "verify_expr": "(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))", "tags": ["linalg", "matrix", "composition", "matrix-mul", "direct"], "split": "eval"}
{"id": "matrix_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMultiply transpose(((1 2 3)(4 5 6))) by #(1 1) and return vector.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-vec-mul (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) (vector 1 1)) (vector 5 7 9))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-vec-mul (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) (vector 1 1))", "verify_expr": "(equal? (matrix-vec-mul (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) (vector 1 1)) (vector 5 7 9))", "tags": ["linalg", "matrix", "composition", "matrix-vec-mul", "integration"], "split": "eval"}
{"id": "matrix_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: compose existing APIs into one expression.\n\nTake full-range submatrix and compare to original lists.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((2 3) (4 5))) 0 0 2 2)) '((2 3) (4 5)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix->lists (matrix-submatrix (matrix-from-lists '((2 3) (4 5))) 0 0 2 2))", "verify_expr": "(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((2 3) (4 5))) 0 0 2 2)) '((2 3) (4 5)))", "tags": ["linalg", "matrix", "composition", "matrix-submatrix", "property"], "split": "eval"}
