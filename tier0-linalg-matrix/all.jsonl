{"id": "matrix_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-from-lists`\nSpec: Build a row-major matrix from rectangular row lists; return ragged-input error on mismatched row lengths.\n\nWrite exactly one Scheme function definition for `matrix-from-lists`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-from-lists"], "split": "train"}
{"id": "matrix_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-from-lists`\nBehavior contract: Build a row-major matrix from rectangular row lists; return ragged-input error on mismatched row lengths.\n\n```scheme\n(define (matrix-from-lists rows)\n  ;; TODO: validate rectangular rows and pack row-major vector\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6)))\n(equal? (matrix->lists (matrix-from-lists '())) '())\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-from-lists"], "split": "train"}
{"id": "matrix_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-ref`\nBehavior contract: Return element at (i,j) when in bounds, else `(error out-of-bounds (i j) (rows cols))`.\n\n```scheme\n(define (matrix-ref m i j)\n  ;; TODO: bounds check then index row-major data\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (and (= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6) (equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-ref"], "split": "train"}
{"id": "matrix_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-transpose`\nSpec: Return a new matrix with rows/cols swapped and data transposed.\n\nWrite exactly one Scheme function definition for `matrix-transpose`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (and (equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6))) (equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-transpose"], "split": "train"}
{"id": "matrix_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-transpose`\nBehavior contract: Return a new matrix with rows/cols swapped and data transposed.\n\n```scheme\n(define (matrix-transpose m)\n  ;; TODO: swap dimensions and transpose entries\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (and (equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6))) (equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-transpose"], "split": "train"}
{"id": "matrix_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-map2`\nBehavior contract: Apply binary function elementwise on two same-shape matrices, else dimension-mismatch error.\n\n```scheme\n(define (matrix-map2 f m1 m2)\n  ;; TODO: enforce same shape and map f pairwise\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))\n  (and (equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44))) (equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-map2"], "split": "train"}
{"id": "matrix_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-mul`\nSpec: Matrix multiplication A(r1 x c1) * B(r2 x c2), with dimension check `c1 = r2`.\n\nWrite exactly one Scheme function definition for `matrix-mul`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-mul"], "split": "train"}
{"id": "matrix_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-mul`\nBehavior contract: Matrix multiplication A(r1 x c1) * B(r2 x c2), with dimension check `c1 = r2`.\n\n```scheme\n(define (matrix-mul m1 m2)\n  ;; TODO: implement matrix multiply with dimension check\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))\n(equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-mul"], "split": "train"}
{"id": "matrix_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-vec-mul`\nSpec: Multiply matrix by vector with column/length check; return result vector or dimension-mismatch error.\n\nWrite exactly one Scheme function definition for `matrix-vec-mul`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))\n  (and (equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32)) (equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-vec-mul"], "split": "train"}
{"id": "matrix_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-vec-mul`\nBehavior contract: Multiply matrix by vector with column/length check; return result vector or dimension-mismatch error.\n\n```scheme\n(define (matrix-vec-mul m v)\n  ;; TODO: matrix-vector multiply with dimension check\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))\n  (and (equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32)) (equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-vec-mul"], "split": "train"}
{"id": "matrix_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-identity`\nBehavior contract: Construct n x n identity matrix with ones on diagonal and zeros elsewhere.\n\n```scheme\n(define (matrix-identity n)\n  ;; TODO: allocate n*n and set diagonal to 1\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1)))\n(equal? (matrix->lists (matrix-identity 0)) '())\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1))) (equal? (matrix->lists (matrix-identity 0)) '())))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-identity"], "split": "train"}
{"id": "matrix_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-submatrix`\nSpec: Extract half-open slice [r1,r2) x [c1,c2); validate bounds and range.\n\nWrite exactly one Scheme function definition for `matrix-submatrix`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11)))\n(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-submatrix"], "split": "train"}
{"id": "matrix_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/matrix.ss\nFunction target: `matrix-submatrix`\nBehavior contract: Extract half-open slice [r1,r2) x [c1,c2); validate bounds and range.\n\n```scheme\n(define (matrix-submatrix m r1 c1 r2 c2)\n  ;; TODO: validate range and copy sub-block\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "spec-to-code", "skeleton", "matrix-submatrix"], "split": "train"}
{"id": "matrix_translation_002", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-from-lists`\n\n```scheme\n(define (mat-from-rows rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ((m (length rows))\n             (n (length (car rows))))\n        (let check ((rs rows) (i 0))\n          (cond ((null? rs)\n                 (let ((data (make-vector (* m n) 0)))\n                   (do ((i 0 (+ i 1)) (rs rows (cdr rs)))\n                       ((= i m))\n                     (do ((j 0 (+ j 1)) (cs (car rs) (cdr cs)))\n                         ((= j n))\n                       (vector-set! data (+ (* i n) j) (car cs))))\n                   (list 'matrix m n data)))\n                ((not (= (length (car rs)) n))\n                 `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs))))\n                (else (check (cdr rs) (+ i 1))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6)))\n(equal? (matrix->lists (matrix-from-lists '())) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-from-lists"], "split": "train"}
{"id": "matrix_translation_003", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-ref`\n\n```python\ndef matrix_ref(m, i, j):\n    rows = matrix_rows(m)\n    cols = matrix_cols(m)\n    data = matrix_data(m)\n    if 0 <= i < rows and 0 <= j < cols:\n        return data[i * cols + j]\n    return ['error', 'out-of-bounds', [i, j], [rows, cols]]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (and (= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6) (equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-ref"], "split": "train"}
{"id": "matrix_translation_004", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-ref`\n\n```scheme\n(define (mat-ref m i j)\n  (let ((r (matrix-rows m)) (c (matrix-cols m)) (d (matrix-data m)))\n    (if (and (>= i 0) (< i r) (>= j 0) (< j c))\n        (vector-ref d (+ (* i c) j))\n        `(error out-of-bounds (,i ,j) (,r ,c)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6)\n(equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (and (= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6) (equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-ref"], "split": "train"}
{"id": "matrix_translation_005", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-transpose`\n\n```python\ndef matrix_transpose(m):\n    rows = matrix_rows(m)\n    cols = matrix_cols(m)\n    data = matrix_data(m)\n    out = [0] * (rows * cols)\n    for i in range(rows):\n        for j in range(cols):\n            out[j * rows + i] = data[i * cols + j]\n    return ['matrix', cols, rows, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (and (equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6))) (equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())))", "tags": ["linalg", "matrix", "translation", "python", "matrix-transpose"], "split": "train"}
{"id": "matrix_translation_006", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-transpose`\n\n```scheme\n(define (mat-transpose m)\n  (let* ((r (matrix-rows m))\n         (c (matrix-cols m))\n         (d (matrix-data m))\n         (out (make-vector (* r c) 0)))\n    (do ((i 0 (+ i 1)))\n        ((= i r))\n      (do ((j 0 (+ j 1)))\n          ((= j c))\n        (vector-set! out (+ (* j r) i)\n                     (vector-ref d (+ (* i c) j)))))\n    (list 'matrix c r out)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (and (equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6))) (equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-transpose"], "split": "train"}
{"id": "matrix_translation_007", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-map2`\n\n```python\ndef matrix_map2(f, m1, m2):\n    r1, c1 = matrix_rows(m1), matrix_cols(m1)\n    r2, c2 = matrix_rows(m2), matrix_cols(m2)\n    if not (r1 == r2 and c1 == c2):\n        return ['error', 'dimension-mismatch', [r1, c1], [r2, c2]]\n    d1, d2 = matrix_data(m1), matrix_data(m2)\n    out = [0] * (r1 * c1)\n    for i in range(r1 * c1):\n        out[i] = f(d1[i], d2[i])\n    return ['matrix', r1, c1, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))\n  (and (equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44))) (equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-map2"], "split": "train"}
{"id": "matrix_translation_008", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-map2`\n\n```scheme\n(define (mat-map2 f a b)\n  (let ((r1 (matrix-rows a)) (c1 (matrix-cols a))\n        (r2 (matrix-rows b)) (c2 (matrix-cols b)))\n    (if (not (and (= r1 r2) (= c1 c2)))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let* ((d1 (matrix-data a)) (d2 (matrix-data b)) (n (* r1 c1)))\n          (list 'matrix r1 c1\n                (vec-tabulate n i (f (vector-ref d1 i) (vector-ref d2 i))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))\n  (and (equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44))) (equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-map2"], "split": "train"}
{"id": "matrix_translation_010", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-mul`\n\n```scheme\n(define (mat-mul a b)\n  (let ((r1 (matrix-rows a)) (c1 (matrix-cols a))\n        (r2 (matrix-rows b)) (c2 (matrix-cols b)))\n    (if (not (= c1 r2))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let* ((d1 (matrix-data a)) (d2 (matrix-data b)) (out (make-vector (* r1 c2) 0)))\n          (do ((i 0 (+ i 1)))\n              ((= i r1))\n            (do ((k 0 (+ k 1)))\n                ((= k c1))\n              (let ((aik (vector-ref d1 (+ (* i c1) k)))\n                    (bk (* k c2))\n                    (ci (* i c2)))\n                (do ((j 0 (+ j 1)))\n                    ((= j c2))\n                  (let ((idx (+ ci j)))\n                    (vector-set! out idx (+ (vector-ref out idx) (* aik (vector-ref d2 (+ bk j))))))))))\n          (list 'matrix r1 c2 out))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))\n(equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-mul"], "split": "train"}
{"id": "matrix_translation_011", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-vec-mul`\n\n```python\ndef matrix_vec_mul(m, v):\n    rows = matrix_rows(m)\n    cols = matrix_cols(m)\n    if cols != len(v):\n        return ['error', 'dimension-mismatch', cols, len(v)]\n    data = matrix_data(m)\n    out = [0] * rows\n    for i in range(rows):\n        s = 0\n        for j in range(cols):\n            s += data[i * cols + j] * v[j]\n        out[i] = s\n    return list_to_vector(out)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))\n  (and (equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32)) (equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-vec-mul"], "split": "train"}
{"id": "matrix_translation_012", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-vec-mul`\n\n```scheme\n(define (mat-vec-mul m v)\n  (let ((r (matrix-rows m)) (c (matrix-cols m)) (n (vector-length v)))\n    (if (not (= c n))\n        `(error dimension-mismatch ,c ,n)\n        (let ((d (matrix-data m)) (out (make-vector r 0)))\n          (do ((i 0 (+ i 1)))\n              ((= i r) out)\n            (do ((j 0 (+ j 1))\n                 (sum 0 (+ sum (* (vector-ref d (+ (* i c) j)) (vector-ref v j)))))\n                ((= j c) (vector-set! out i sum))))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32))\n(equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))\n  (and (equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32)) (equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-vec-mul"], "split": "train"}
{"id": "matrix_translation_013", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-identity`\n\n```python\ndef matrix_identity(n):\n    data = [0] * (n * n)\n    for i in range(n):\n        data[i * n + i] = 1\n    return ['matrix', n, n, list_to_vector(data)]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1)))\n(equal? (matrix->lists (matrix-identity 0)) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1))) (equal? (matrix->lists (matrix-identity 0)) '())))", "tags": ["linalg", "matrix", "translation", "python", "matrix-identity"], "split": "train"}
{"id": "matrix_translation_014", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-identity`\n\n```scheme\n(define (eye n)\n  (let ((data (make-vector (* n n) 0)))\n    (do ((i 0 (+ i 1)))\n        ((= i n) (list 'matrix n n data))\n      (vector-set! data (+ (* i n) i) 1))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1))) (equal? (matrix->lists (matrix-identity 0)) '())))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-identity"], "split": "train"}
{"id": "matrix_translation_015", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-submatrix`\n\n```python\ndef matrix_submatrix(m, r1, c1, r2, c2):\n    rows, cols = matrix_rows(m), matrix_cols(m)\n    data = matrix_data(m)\n    if r1 < 0 or c1 < 0:\n        return ['error', 'out-of-bounds', [r1, c1]]\n    if r2 > rows or c2 > cols:\n        return ['error', 'out-of-bounds', [r2, c2]]\n    if r1 > r2 or c1 > c2:\n        return ['error', 'invalid-range']\n    nr, nc = r2 - r1, c2 - c1\n    out = [0] * (nr * nc)\n    for i in range(nr):\n        for j in range(nc):\n            out[i * nc + j] = data[(r1 + i) * cols + (c1 + j)]\n    return ['matrix', nr, nc, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11)))\n(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-submatrix"], "split": "train"}
{"id": "matrix_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-from-lists` in `lattice/linalg/matrix.ss`.\nKnown issue: Empty input should produce a 0x0 matrix, not an error.\n\n```scheme\n(define (matrix-from-lists rows)\n  (if (null? rows)\n      '(error empty-matrix)\n      (let* ([m (length rows)] [n (length (car rows))] [data (make-vector (* m n) 0)])\n        (do ([i 0 (+ i 1)] [rs rows (cdr rs)])\n            ((= i m) (list 'matrix m n data))\n          (do ([j 0 (+ j 1)] [cs (car rs) (cdr cs)])\n              ((= j n))\n            (vector-set! data (+ (* i n) j) (car cs)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "bugfix", "matrix-from-lists"], "split": "train"}
{"id": "matrix_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-ref` in `lattice/linalg/matrix.ss`.\nKnown issue: Row-major indexing must multiply by column count, not row count.\n\n```scheme\n(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)])\n    (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n        (vector-ref data (+ (* i rows) j))\n        `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6)\n(equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (and (= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6) (equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-ref"], "split": "train"}
{"id": "matrix_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-ref` in `lattice/linalg/matrix.ss`.\nKnown issue: Must check bounds and return structured out-of-bounds error.\n\n```scheme\n(define (matrix-ref m i j)\n  (vector-ref (matrix-data m) (+ (* i (matrix-cols m)) j)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6)\n(equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (and (= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6) (equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-ref"], "split": "train"}
{"id": "matrix_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-transpose` in `lattice/linalg/matrix.ss`.\nKnown issue: Transpose must swap dimensions and move elements across diagonal.\n\n```scheme\n(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)] [result (make-vector (* rows cols) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (do ([j 0 (+ j 1)])\n          ((= j cols))\n        (vector-set! result (+ (* i cols) j) (vector-ref data (+ (* i cols) j)))))\n    (list 'matrix rows cols result)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (and (equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6))) (equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())))", "tags": ["linalg", "matrix", "bugfix", "matrix-transpose"], "split": "train"}
{"id": "matrix_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-transpose` in `lattice/linalg/matrix.ss`.\nKnown issue: Read index must be original (i,j), not swapped source coordinates.\n\n```scheme\n(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)] [result (make-vector (* rows cols) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i rows))\n      (do ([j 0 (+ j 1)])\n          ((= j cols))\n        (vector-set! result (+ (* j rows) i) (vector-ref data (+ (* j cols) i)))))\n    (list 'matrix cols rows result)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-transpose m)\n  (let* ([rows (matrix-rows m)]\n         [cols (matrix-cols m)]\n         [data (matrix-data m)]\n         [result (make-vector (* rows cols) 0)])\n        (do ([i 0 (+ i 1)])\n            ((= i rows))\n            (do ([j 0 (+ j 1)])\n                ((= j cols))\n                (vector-set! result (+ (* j rows) i)\n                             (vector-ref data (+ (* i cols) j)))))\n        (list 'matrix cols rows result)))\n  (and (equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6))) (equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())))", "tags": ["linalg", "matrix", "bugfix", "matrix-transpose"], "split": "train"}
{"id": "matrix_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-map2` in `lattice/linalg/matrix.ss`.\nKnown issue: Dimension guard is inverted.\n\n```scheme\n(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)] [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n    (if (and (= r1 r2) (= c1 c2))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let* ([data1 (matrix-data m1)] [data2 (matrix-data m2)] [n (* r1 c1)])\n          (list 'matrix r1 c1 (vec-tabulate n i (f (vector-ref data1 i) (vector-ref data2 i))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))\n  (and (equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44))) (equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-map2"], "split": "train"}
{"id": "matrix_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-map2` in `lattice/linalg/matrix.ss`.\nKnown issue: Elementwise combine must use one value from each matrix.\n\n```scheme\n(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)] [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n    (if (not (and (= r1 r2) (= c1 c2)))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let* ([data1 (matrix-data m1)] [data2 (matrix-data m2)] [n (* r1 c1)])\n          (list 'matrix r1 c1 (vec-tabulate n i (f (vector-ref data1 i) (vector-ref data1 i))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))\n  (and (equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44))) (equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-map2"], "split": "train"}
{"id": "matrix_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-mul` in `lattice/linalg/matrix.ss`.\nKnown issue: Inner multiply must use matching column index j without shifting.\n\n```scheme\n(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)] [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n    (if (not (= c1 r2))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let* ([data1 (matrix-data m1)] [data2 (matrix-data m2)] [result (make-vector (* r1 c2) 0)])\n          (do ([i 0 (+ i 1)])\n              ((= i r1))\n            (do ([k 0 (+ k 1)])\n                ((= k c1))\n              (let ([a-ik (vector-ref data1 (+ (* i c1) k))] [b-row-k (* k c2)] [c-row-i (* i c2)])\n                (do ([j 0 (+ j 1)])\n                    ((= j c2))\n                  (let ([idx (+ c-row-i j)])\n                    (vector-set! result idx (+ (vector-ref result idx) (* a-ik (vector-ref data2 (+ j b-row-k 1))))))))))\n          (list 'matrix r1 c2 result)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))\n(equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-mul"], "split": "train"}
{"id": "matrix_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-vec-mul` in `lattice/linalg/matrix.ss`.\nKnown issue: Vector length should match matrix column count.\n\n```scheme\n(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)] [cols (matrix-cols m)] [n (vector-length v)])\n    (if (not (= rows n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ([data (matrix-data m)] [result (make-vector rows 0)])\n          (do ([i 0 (+ i 1)])\n              ((= i rows) result)\n            (do ([j 0 (+ j 1)] [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j)) (vector-ref v j)))])\n                ((= j cols) (vector-set! result i sum))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32))\n(equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))\n  (and (equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32)) (equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))))", "tags": ["linalg", "matrix", "bugfix", "matrix-vec-mul"], "split": "train"}
{"id": "matrix_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-vec-mul` in `lattice/linalg/matrix.ss`.\nKnown issue: Accumulation index into matrix data must stay row-major at (i,j).\n\n```scheme\n(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)] [cols (matrix-cols m)] [n (vector-length v)])\n    (if (not (= cols n))\n        `(error dimension-mismatch ,cols ,n)\n        (let ([data (matrix-data m)] [result (make-vector rows 0)])\n          (do ([i 0 (+ i 1)])\n              ((= i rows) result)\n            (do ([j 0 (+ j 1)] [sum 0 (+ sum (* (vector-ref data (+ (* j cols) i)) (vector-ref v j)))])\n                ((= j cols) (vector-set! result i sum))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-vec-mul m v)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [n (vector-length v)])\n       (if (not (= cols n))\n           `(error dimension-mismatch ,cols ,n)\n           (let ([data (matrix-data m)]\n                 [result (make-vector rows 0)])\n                (do ([i 0 (+ i 1)])\n                    ((= i rows) result)\n                    (do ([j 0 (+ j 1)]\n                         [sum 0 (+ sum (* (vector-ref data (+ (* i cols) j))\n                                          (vector-ref v j)))])\n                        ((= j cols)\n                         (vector-set! result i sum))))))))\n  (and (equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32)) (equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))))", "tags": ["linalg", "matrix", "bugfix", "matrix-vec-mul"], "split": "train"}
{"id": "matrix_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-identity` in `lattice/linalg/matrix.ss`.\nKnown issue: Diagonal index should be i*n+i, not superdiagonal.\n\n```scheme\n(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n    (do ([i 0 (+ i 1)])\n        ((= i n) (list 'matrix n n data))\n      (vector-set! data (+ (* i n) (+ i 1)) 1))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1)))\n(equal? (matrix->lists (matrix-identity 0)) '())\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1))) (equal? (matrix->lists (matrix-identity 0)) '())))", "tags": ["linalg", "matrix", "bugfix", "matrix-identity"], "split": "train"}
{"id": "matrix_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-identity` in `lattice/linalg/matrix.ss`.\nKnown issue: Identity matrix must contain zeros off the diagonal.\n\n```scheme\n(define (matrix-identity n)\n  (list 'matrix n n (make-vector (* n n) 1)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1))) (equal? (matrix->lists (matrix-identity 0)) '())))", "tags": ["linalg", "matrix", "bugfix", "matrix-identity"], "split": "train"}
{"id": "matrix_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-submatrix` in `lattice/linalg/matrix.ss`.\nKnown issue: Submatrix bounds are half-open; dimensions are (r2-r1) x (c2-c1).\n\n```scheme\n(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)])\n    (cond\n      [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n      [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n      [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n      [else\n       (let* ([new-rows (+ 1 (- r2 r1))] [new-cols (+ 1 (- c2 c1))] [result (make-vector (* new-rows new-cols) 0)])\n         (do ([i 0 (+ i 1)])\n             ((= i new-rows) (list 'matrix new-rows new-cols result))\n           (do ([j 0 (+ j 1)])\n               ((= j new-cols))\n             (vector-set! result (+ (* i new-cols) j)\n                          (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-submatrix"], "split": "train"}
{"id": "matrix_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: small integration task across module primitives.\n\nReturn ragged-input error for '((1 2 3) (4 5)).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-from-lists '((1 2 3) (4 5)))", "verify_expr": "(equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))", "tags": ["linalg", "matrix", "composition", "matrix-from-lists", "edge-case"], "split": "train"}
{"id": "matrix_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: small integration task across module primitives.\n\nBuild from empty list and return shape pair.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (cons (matrix-rows (matrix-from-lists '())) (matrix-cols (matrix-from-lists '()))) '(0 . 0))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(cons (matrix-rows (matrix-from-lists '())) (matrix-cols (matrix-from-lists '())))", "verify_expr": "(equal? (cons (matrix-rows (matrix-from-lists '())) (matrix-cols (matrix-from-lists '()))) '(0 . 0))", "tags": ["linalg", "matrix", "composition", "matrix-from-lists", "edge-case"], "split": "train"}
{"id": "matrix_composition_004", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild two matrices then matrix-mul them and return lists.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))))", "verify_expr": "(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))", "tags": ["linalg", "matrix", "composition", "matrix-from-lists", "integration"], "split": "train"}
{"id": "matrix_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: small integration task across module primitives.\n\nRead element (1,2) from matrix ((1 2 3) (4 5 6)).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2)", "verify_expr": "(equal? (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6)", "tags": ["linalg", "matrix", "composition", "matrix-ref", "direct"], "split": "train"}
{"id": "matrix_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: small integration task across module primitives.\n\nAccess out-of-bounds row and return error.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-ref (matrix-from-lists '((1 2) (3 4))) 3 0)", "verify_expr": "(equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 3 0) '(error out-of-bounds (3 0) (2 2)))", "tags": ["linalg", "matrix", "composition", "matrix-ref", "edge-case"], "split": "train"}
{"id": "matrix_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: small integration task across module primitives.\n\nTake submatrix then read its (0,1) entry.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-ref (matrix-submatrix (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 0 3 2) 0 1)", "verify_expr": "(equal? (matrix-ref (matrix-submatrix (matrix-from-lists '((1 2 3) (4 5 6) (7 8 9))) 1 0 3 2) 0 1) 5)", "tags": ["linalg", "matrix", "composition", "matrix-ref", "integration"], "split": "train"}
{"id": "matrix_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: small integration task across module primitives.\n\nTranspose matrix then read element (2,0).\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-ref (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) 2 0)", "verify_expr": "(equal? (matrix-ref (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) 2 0) 3)", "tags": ["linalg", "matrix", "composition", "matrix-ref", "integration"], "split": "train"}
{"id": "matrix_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: small integration task across module primitives.\n\nDouble transpose should recover original matrix lists.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix->lists (matrix-transpose (matrix-transpose (matrix-from-lists '((9 8) (7 6))))))", "verify_expr": "(equal? (matrix->lists (matrix-transpose (matrix-transpose (matrix-from-lists '((9 8) (7 6)))))) '((9 8) (7 6)))", "tags": ["linalg", "matrix", "composition", "matrix-transpose", "property"], "split": "train"}
{"id": "matrix_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nTranspose empty matrix and return lists.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-transpose (matrix-from-lists '())))", "verify_expr": "(equal? (matrix->lists (matrix-transpose (matrix-from-lists '()))) '())", "tags": ["linalg", "matrix", "composition", "matrix-transpose", "edge-case"], "split": "train"}
{"id": "matrix_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: small integration task across module primitives.\n\nMultiply A by transpose(B) where A=((1 2)(3 4)) and B=((5 6)(7 8)).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-transpose (matrix-from-lists '((5 6) (7 8))))))", "verify_expr": "(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-transpose (matrix-from-lists '((5 6) (7 8)))))) '((17 23) (39 53)))", "tags": ["linalg", "matrix", "composition", "matrix-transpose", "integration"], "split": "train"}
{"id": "matrix_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: small integration task across module primitives.\n\nAdd two 2x2 matrices with matrix-map2.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40)))))", "verify_expr": "(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))", "tags": ["linalg", "matrix", "composition", "matrix-map2", "direct"], "split": "train"}
{"id": "matrix_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn dimension mismatch when shapes differ.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((3) (4))))", "verify_expr": "(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((3) (4)))) '(error dimension-mismatch (1 2) (2 1)))", "tags": ["linalg", "matrix", "composition", "matrix-map2", "edge-case"], "split": "train"}
{"id": "matrix_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: compose existing APIs into one expression.\n\nSubtract two matrices with matrix-map2 and return lists.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-map2 - (matrix-from-lists '((7 8) (9 10))) (matrix-from-lists '((1 2) (3 4))))) '((6 6) (6 6)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-map2 - (matrix-from-lists '((7 8) (9 10))) (matrix-from-lists '((1 2) (3 4)))))", "verify_expr": "(equal? (matrix->lists (matrix-map2 - (matrix-from-lists '((7 8) (9 10))) (matrix-from-lists '((1 2) (3 4))))) '((6 6) (6 6)))", "tags": ["linalg", "matrix", "composition", "matrix-map2", "direct"], "split": "train"}
{"id": "matrix_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse matrix-map2(*) then sum first row via matrix-ref.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(+ (matrix-ref (matrix-map2 * (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))) 0 0) (matrix-ref (matrix-map2 * (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))) 0 1))", "verify_expr": "(equal? (+ (matrix-ref (matrix-map2 * (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))) 0 0) (matrix-ref (matrix-map2 * (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))) 0 1)) 17)", "tags": ["linalg", "matrix", "composition", "matrix-map2", "integration"], "split": "train"}
{"id": "matrix_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn dimension mismatch for (1x3)*(2x2).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4))))", "verify_expr": "(equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))", "tags": ["linalg", "matrix", "composition", "matrix-mul", "edge-case"], "split": "train"}
{"id": "matrix_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: small integration task across module primitives.\n\nMultiply by identity matrix and return unchanged lists.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((2 3) (4 5))) (matrix-identity 2))) '((2 3) (4 5)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-mul (matrix-from-lists '((2 3) (4 5))) (matrix-identity 2)))", "verify_expr": "(equal? (matrix->lists (matrix-mul (matrix-from-lists '((2 3) (4 5))) (matrix-identity 2))) '((2 3) (4 5)))", "tags": ["linalg", "matrix", "composition", "matrix-mul", "property"], "split": "train"}
{"id": "matrix_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute (A*B)(1,1) for A=((1 2)(3 4)), B=((5 6)(7 8)).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-ref (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))) 1 1) 50)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-ref (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))) 1 1)", "verify_expr": "(equal? (matrix-ref (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))) 1 1) 50)", "tags": ["linalg", "matrix", "composition", "matrix-mul", "integration"], "split": "train"}
{"id": "matrix_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: small integration task across module primitives.\n\nMultiply ((1 2 3)(4 5 6)) by vector #(1 2 3).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3))", "verify_expr": "(equal? (matrix-vec-mul (matrix-from-lists '((1 2 3) (4 5 6))) (vector 1 2 3)) (vector 14 32))", "tags": ["linalg", "matrix", "composition", "matrix-vec-mul", "direct"], "split": "train"}
{"id": "matrix_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn dimension mismatch for 2x2 matrix and length-3 vector.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3))", "verify_expr": "(equal? (matrix-vec-mul (matrix-from-lists '((1 2) (3 4))) (vector 1 2 3)) '(error dimension-mismatch 2 3))", "tags": ["linalg", "matrix", "composition", "matrix-vec-mul", "edge-case"], "split": "train"}
{"id": "matrix_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: small integration task across module primitives.\n\nMultiply identity 3x3 by vector #(7 8 9).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-vec-mul (matrix-identity 3) (vector 7 8 9)) (vector 7 8 9))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-vec-mul (matrix-identity 3) (vector 7 8 9))", "verify_expr": "(equal? (matrix-vec-mul (matrix-identity 3) (vector 7 8 9)) (vector 7 8 9))", "tags": ["linalg", "matrix", "composition", "matrix-vec-mul", "property"], "split": "train"}
{"id": "matrix_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn 3x3 identity as lists.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-identity 3))", "verify_expr": "(equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1)))", "tags": ["linalg", "matrix", "composition", "matrix-identity", "direct"], "split": "train"}
{"id": "matrix_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn 0x0 identity as empty list of rows.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-identity 0))", "verify_expr": "(equal? (matrix->lists (matrix-identity 0)) '())", "tags": ["linalg", "matrix", "composition", "matrix-identity", "edge-case"], "split": "train"}
{"id": "matrix_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that identity(4) has ones on all diagonal entries.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(and (= (matrix-ref (matrix-identity 4) 0 0) 1) (= (matrix-ref (matrix-identity 4) 1 1) 1) (= (matrix-ref (matrix-identity 4) 2 2) 1) (= (matrix-ref (matrix-identity 4) 3 3) 1))", "verify_expr": "(equal? (and (= (matrix-ref (matrix-identity 4) 0 0) 1) (= (matrix-ref (matrix-identity 4) 1 1) 1) (= (matrix-ref (matrix-identity 4) 2 2) 1) (= (matrix-ref (matrix-identity 4) 3 3) 1)) #t)", "tags": ["linalg", "matrix", "composition", "matrix-identity", "property"], "split": "train"}
{"id": "matrix_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: small integration task across module primitives.\n\nMultiply identity(2) by ((9 8)(7 6)).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-identity 2) (matrix-from-lists '((9 8) (7 6))))) '((9 8) (7 6)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-mul (matrix-identity 2) (matrix-from-lists '((9 8) (7 6)))))", "verify_expr": "(equal? (matrix->lists (matrix-mul (matrix-identity 2) (matrix-from-lists '((9 8) (7 6))))) '((9 8) (7 6)))", "tags": ["linalg", "matrix", "composition", "matrix-identity", "integration"], "split": "train"}
{"id": "matrix_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract rows [1,3), cols [1,3) from 3x4 matrix and return lists.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3))", "verify_expr": "(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11)))", "tags": ["linalg", "matrix", "composition", "matrix-submatrix", "direct"], "split": "train"}
{"id": "matrix_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn invalid-range when start row exceeds end row.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1)", "verify_expr": "(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range))", "tags": ["linalg", "matrix", "composition", "matrix-submatrix", "edge-case"], "split": "train"}
{"id": "matrix_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn out-of-bounds error for negative start index.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1)", "verify_expr": "(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))", "tags": ["linalg", "matrix", "composition", "matrix-submatrix", "edge-case"], "split": "train"}
{"id": "matrix_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-ref", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-ref`\nSpec: Return element at (i,j) when in bounds, else `(error out-of-bounds (i j) (rows cols))`.\n\nWrite exactly one Scheme function definition for `matrix-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix-ref m i j)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (if (and (>= i 0) (< i rows) (>= j 0) (< j cols))\n           (vector-ref data (+ (* i cols) j))\n           `(error out-of-bounds (,i ,j) (,rows ,cols)))))\n  (and (= (matrix-ref (matrix-from-lists '((1 2 3) (4 5 6))) 1 2) 6) (equal? (matrix-ref (matrix-from-lists '((1 2) (3 4))) 2 0) '(error out-of-bounds (2 0) (2 2)))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-ref"], "split": "eval"}
{"id": "matrix_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-map2", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-map2`\nSpec: Apply binary function elementwise on two same-shape matrices, else dimension-mismatch error.\n\nWrite exactly one Scheme function definition for `matrix-map2`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44)))\n(equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-map2 f m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (and (= r1 r2) (= c1 c2)))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [n (* r1 c1)])\n                 (list 'matrix r1 c1\n                       (vec-tabulate n i\n                         (f (vector-ref data1 i)\n                            (vector-ref data2 i))))))))\n  (and (equal? (matrix->lists (matrix-map2 + (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((10 20) (30 40))))) '((11 22) (33 44))) (equal? (matrix-map2 + (matrix-from-lists '((1 2))) (matrix-from-lists '((1) (2))) ) '(error dimension-mismatch (1 2) (2 1)))))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-map2"], "split": "eval"}
{"id": "matrix_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-identity", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/matrix.ss\nFunction: `matrix-identity`\nSpec: Construct n x n identity matrix with ones on diagonal and zeros elsewhere.\n\nWrite exactly one Scheme function definition for `matrix-identity`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1)))\n(equal? (matrix->lists (matrix-identity 0)) '())\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-identity n)\n  (let ([data (make-vector (* n n) 0)])\n       (do ([i 0 (+ i 1)])\n           ((= i n) (list 'matrix n n data))\n           (vector-set! data (+ (* i n) i) 1))))\n  (and (equal? (matrix->lists (matrix-identity 3)) '((1 0 0) (0 1 0) (0 0 1))) (equal? (matrix->lists (matrix-identity 0)) '())))", "tags": ["linalg", "matrix", "spec-to-code", "matrix-identity"], "split": "eval"}
{"id": "matrix_translation_001", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-from-lists`\n\n```python\ndef matrix_from_lists(rows):\n    if not rows:\n        return ['matrix', 0, 0, []]\n    m = len(rows)\n    n = len(rows[0])\n    i = 0\n    for r in rows:\n        if len(r) != n:\n            return ['error', 'ragged-input', 'row', i, 'expected-length', n, 'actual-length', len(r)]\n        i += 1\n    data = [0] * (m * n)\n    for i in range(m):\n        for j in range(n):\n            data[i * n + j] = rows[i][j]\n    return ['matrix', m, n, list_to_vector(data)]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-from-lists"], "split": "eval"}
{"id": "matrix_translation_009", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `matrix-mul`\n\n```python\ndef matrix_mul(m1, m2):\n    r1, c1 = matrix_rows(m1), matrix_cols(m1)\n    r2, c2 = matrix_rows(m2), matrix_cols(m2)\n    if c1 != r2:\n        return ['error', 'dimension-mismatch', [r1, c1], [r2, c2]]\n    d1, d2 = matrix_data(m1), matrix_data(m2)\n    out = [0] * (r1 * c2)\n    for i in range(r1):\n        for k in range(c1):\n            a_ik = d1[i * c1 + k]\n            b_row_k = k * c2\n            c_row_i = i * c2\n            for j in range(c2):\n                idx = c_row_i + j\n                out[idx] = out[idx] + a_ik * d2[b_row_k + j]\n    return ['matrix', r1, c2, list_to_vector(out)]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))\n(equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "translation", "python", "matrix-mul"], "split": "eval"}
{"id": "matrix_translation_016", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `matrix-submatrix`\n\n```scheme\n(define (mat-sub m r1 c1 r2 c2)\n  (let ((rows (matrix-rows m))\n        (cols (matrix-cols m))\n        (data (matrix-data m)))\n    (cond ((or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1)))\n          ((or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2)))\n          ((or (> r1 r2) (> c1 c2)) `(error invalid-range))\n          (else\n           (let* ((nr (- r2 r1)) (nc (- c2 c1)) (out (make-vector (* nr nc) 0)))\n             (do ((i 0 (+ i 1)))\n                 ((= i nr) (list 'matrix nr nc out))\n               (do ((j 0 (+ j 1)))\n                   ((= j nc))\n                 (vector-set! out (+ (* i nc) j)\n                              (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j))))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11)))\n(equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "translation", "chez", "matrix-submatrix"], "split": "eval"}
{"id": "matrix_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-from-lists` in `lattice/linalg/matrix.ss`.\nKnown issue: Must validate ragged rows and return ragged-input error.\n\n```scheme\n(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)] [n (length (car rows))] [data (make-vector (* m n) 0)])\n        (do ([i 0 (+ i 1)] [rs rows (cdr rs)])\n            ((= i m) (list 'matrix m n data))\n          (do ([j 0 (+ j 1)] [cs (car rs) (cdr cs)])\n              ((= j n))\n            (vector-set! data (+ (* i n) j) (car cs)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6)))\n(equal? (matrix->lists (matrix-from-lists '())) '())\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (and (equal? (matrix->lists (matrix-from-lists '((1 2 3) (4 5 6)))) '((1 2 3) (4 5 6))) (equal? (matrix->lists (matrix-from-lists '())) '()) (equal? (matrix-from-lists '((1 2 3) (4 5))) '(error ragged-input row 1 expected-length 3 actual-length 2))))", "tags": ["linalg", "matrix", "bugfix", "matrix-from-lists"], "split": "eval"}
{"id": "matrix_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-mul` in `lattice/linalg/matrix.ss`.\nKnown issue: Compatibility check must be `c1 = r2`.\n\n```scheme\n(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)] [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n    (if (not (= r1 c2))\n        `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n        (let* ([data1 (matrix-data m1)] [data2 (matrix-data m2)] [result (make-vector (* r1 c2) 0)])\n          (do ([i 0 (+ i 1)])\n              ((= i r1))\n            (do ([k 0 (+ k 1)])\n                ((= k c1))\n              (let ([a-ik (vector-ref data1 (+ (* i c1) k))] [b-row-k (* k c2)] [c-row-i (* i c2)])\n                (do ([j 0 (+ j 1)])\n                    ((= j c2))\n                  (let ([idx (+ c-row-i j)])\n                    (vector-set! result idx (+ (vector-ref result idx) (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n          (list 'matrix r1 c2 result)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-mul m1 m2)\n  (let ([r1 (matrix-rows m1)] [c1 (matrix-cols m1)]\n        [r2 (matrix-rows m2)] [c2 (matrix-cols m2)])\n       (if (not (= c1 r2))\n           `(error dimension-mismatch (,r1 ,c1) (,r2 ,c2))\n           (let* ([data1 (matrix-data m1)]\n                  [data2 (matrix-data m2)]\n                  [result (make-vector (* r1 c2) 0)])\n                 (do ([i 0 (+ i 1)])\n                     ((= i r1))\n                     (do ([k 0 (+ k 1)])\n                         ((= k c1))\n                         (let ([a-ik (vector-ref data1 (+ (* i c1) k))]\n                               [b-row-k (* k c2)]\n                               [c-row-i (* i c2)])\n                              (do ([j 0 (+ j 1)])\n                                  ((= j c2))\n                                  (let ([idx (+ c-row-i j)])\n                                       (vector-set! result idx\n                                                    (+ (vector-ref result idx)\n                                                       (* a-ik (vector-ref data2 (+ b-row-k j))))))))))\n                 (list 'matrix r1 c2 result)))))\n  (and (equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50))) (equal? (matrix-mul (matrix-from-lists '((1 2 3))) (matrix-from-lists '((1 2) (3 4)))) '(error dimension-mismatch (1 3) (2 2)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-mul"], "split": "eval"}
{"id": "matrix_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `matrix-submatrix` in `lattice/linalg/matrix.ss`.\nKnown issue: Upper bounds should allow r2=rows and c2=cols for full-edge slices.\n\n```scheme\n(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)] [cols (matrix-cols m)] [data (matrix-data m)])\n    (cond\n      [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n      [(or (>= r2 rows) (>= c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n      [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n      [else\n       (let* ([new-rows (- r2 r1)] [new-cols (- c2 c1)] [result (make-vector (* new-rows new-cols) 0)])\n         (do ([i 0 (+ i 1)])\n             ((= i new-rows) (list 'matrix new-rows new-cols result))\n           (do ([j 0 (+ j 1)])\n               ((= j new-cols))\n             (vector-set! result (+ (* i new-cols) j)\n                          (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))", "verify_expr": "(let ()\n  (define (matrix-rows m)\n  (cadr m))\n  (define (matrix-cols m)\n  (caddr m))\n  (define (matrix-data m)\n  (cadddr m))\n  (define (matrix-from-lists rows)\n  (if (null? rows)\n      (list 'matrix 0 0 (vector))\n      (let* ([m (length rows)]\n             [n (length (car rows))])\n            (let check-rows ([rs rows] [i 0])\n                 (cond\n                  [(null? rs)\n                   (let ([data (make-vector (* m n) 0)])\n                        (do ([i 0 (+ i 1)]\n                             [rs rows (cdr rs)])\n                            ((= i m))\n                            (do ([j 0 (+ j 1)]\n                                 [cs (car rs) (cdr cs)])\n                                ((= j n))\n                                (vector-set! data (+ (* i n) j) (car cs))))\n                        (list 'matrix m n data))]\n                  [(not (= (length (car rs)) n))\n                   `(error ragged-input row ,i expected-length ,n actual-length ,(length (car rs)))]\n                  [else\n                   (check-rows (cdr rs) (+ i 1))])))))\n  (define (matrix->lists m)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (do ([i (- rows 1) (- i 1)]\n            [result '() (cons (do ([j (- cols 1) (- j 1)]\n                                   [row '() (cons (vector-ref data (+ (* i cols) j)) row)])\n                                  ((< j 0) row))\n                              result)])\n           ((< i 0) result))))\n  (define (matrix-submatrix m r1 c1 r2 c2)\n  (let ([rows (matrix-rows m)]\n        [cols (matrix-cols m)]\n        [data (matrix-data m)])\n       (cond\n        [(or (< r1 0) (< c1 0)) `(error out-of-bounds (,r1 ,c1))]\n        [(or (> r2 rows) (> c2 cols)) `(error out-of-bounds (,r2 ,c2))]\n        [(or (> r1 r2) (> c1 c2)) `(error invalid-range)]\n        [else\n         (let* ([new-rows (- r2 r1)]\n                [new-cols (- c2 c1)]\n                [result (make-vector (* new-rows new-cols) 0)])\n               (do ([i 0 (+ i 1)])\n                   ((= i new-rows) (list 'matrix new-rows new-cols result))\n                   (do ([j 0 (+ j 1)])\n                       ((= j new-cols))\n                       (vector-set! result (+ (* i new-cols) j)\n                                    (vector-ref data (+ (* (+ r1 i) cols) (+ c1 j)))))))])))\n  (and (equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((1 2 3 4) (5 6 7 8) (9 10 11 12))) 1 1 3 3)) '((6 7) (10 11))) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) 2 0 1 1) '(error invalid-range)) (equal? (matrix-submatrix (matrix-from-lists '((1 2) (3 4))) -1 0 1 1) '(error out-of-bounds (-1 0)))))", "tags": ["linalg", "matrix", "bugfix", "matrix-submatrix"], "split": "eval"}
{"id": "matrix_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-from-lists", "prompt": "Task mode: small integration task across module primitives.\n\nBuild matrix from '((1 2) (3 4)) and return as lists.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-from-lists '((1 2) (3 4)))) '((1 2) (3 4)))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix->lists (matrix-from-lists '((1 2) (3 4))))", "verify_expr": "(equal? (matrix->lists (matrix-from-lists '((1 2) (3 4)))) '((1 2) (3 4)))", "tags": ["linalg", "matrix", "composition", "matrix-from-lists", "direct"], "split": "eval"}
{"id": "matrix_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-transpose", "prompt": "Task mode: compose existing APIs into one expression.\n\nTranspose ((1 2 3) (4 5 6)).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))))", "verify_expr": "(equal? (matrix->lists (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6))))) '((1 4) (2 5) (3 6)))", "tags": ["linalg", "matrix", "composition", "matrix-transpose", "direct"], "split": "eval"}
{"id": "matrix_composition_017", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-mul", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMultiply ((1 2)(3 4)) by ((5 6)(7 8)).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8)))))", "verify_expr": "(equal? (matrix->lists (matrix-mul (matrix-from-lists '((1 2) (3 4))) (matrix-from-lists '((5 6) (7 8))))) '((19 22) (43 50)))", "tags": ["linalg", "matrix", "composition", "matrix-mul", "direct"], "split": "eval"}
{"id": "matrix_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-vec-mul", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMultiply transpose(((1 2 3)(4 5 6))) by #(1 1) and return vector.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix-vec-mul (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) (vector 1 1)) (vector 5 7 9))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(matrix-vec-mul (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) (vector 1 1))", "verify_expr": "(equal? (matrix-vec-mul (matrix-transpose (matrix-from-lists '((1 2 3) (4 5 6)))) (vector 1 1)) (vector 5 7 9))", "tags": ["linalg", "matrix", "composition", "matrix-vec-mul", "integration"], "split": "eval"}
{"id": "matrix_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/matrix.ss", "source_test": "lattice/linalg/test-matrix.ss", "source_function": "matrix-submatrix", "prompt": "Task mode: compose existing APIs into one expression.\n\nTake full-range submatrix and compare to original lists.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((2 3) (4 5))) 0 0 2 2)) '((2 3) (4 5)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(matrix->lists (matrix-submatrix (matrix-from-lists '((2 3) (4 5))) 0 0 2 2))", "verify_expr": "(equal? (matrix->lists (matrix-submatrix (matrix-from-lists '((2 3) (4 5))) 0 0 2 2)) '((2 3) (4 5)))", "tags": ["linalg", "matrix", "composition", "matrix-submatrix", "property"], "split": "eval"}
