{"id": "core_prelude_ext_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `cons*`\nSpec: Build an improper list from arguments; with one arg return it directly.\n\nWrite exactly one Scheme function definition for `cons*`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `cons*`\nSpec: Build an improper list from arguments; with one arg return it directly.\n\nWrite exactly one Scheme function definition for `cons*`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (cons* 'a) 'a))\n(let () (equal? (cons* 'a 'b) '(a . b)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "cons*"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assq-ref`\nSpec: Lookup symbol key using assq/eq? and return value or #f.\n\nWrite exactly one Scheme function definition for `assq-ref`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assq-ref`\nSpec: Lookup symbol key using assq/eq? and return value or #f.\n\nWrite exactly one Scheme function definition for `assq-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "assq-ref"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `alist-update`\nSpec: Return new alist with key updated/replaced at front and old entries removed.\n\nWrite exactly one Scheme function definition for `alist-update`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `alist-update`\nSpec: Return new alist with key updated/replaced at front and old entries removed.\n\nWrite exactly one Scheme function definition for `alist-update`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "alist-update"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `error?`\nSpec: Return #t iff value is tagged `(error ...)`.\n\nWrite exactly one Scheme function definition for `error?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `error?`\nSpec: Return #t iff value is tagged `(error ...)`.\n\nWrite exactly one Scheme function definition for `error?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (error? '(error bad detail)))\n(let () (not (error? '(ok 1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "error?"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-bind`\nSpec: Monadic bind: apply f to ok payload, short-circuit errors.\n\nWrite exactly one Scheme function definition for `result-bind`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-bind`\nSpec: Monadic bind: apply f to ok payload, short-circuit errors.\n\nWrite exactly one Scheme function definition for `result-bind`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "result-bind"], "split": "eval"}
{"id": "core_prelude_ext_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-fast`.\nReturn only the Scheme definition.\n\n```python\ndef unique_fast(xs):\n    seen=set()\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-fast`.\nReturn only the Scheme definition.\n\n```python\ndef unique_fast(xs):\n    seen=set()\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unique-fast"], "split": "eval"}
{"id": "core_prelude_ext_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-ok`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_ok(result):\n    return result[1]\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-ok`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_ok(result):\n    return result[1]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unwrap-ok"], "split": "eval"}
{"id": "core_prelude_ext_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-map`.\nReturn only the Scheme definition.\n\n```python\ndef result_map(f, result):\n    if result[0] == 'ok':\n        return ('ok', f(result[1]))\n    return result\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-map`.\nReturn only the Scheme definition.\n\n```python\ndef result_map(f, result):\n    if result[0] == 'ok':\n        return ('ok', f(result[1]))\n    return result\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "result-map"], "split": "eval"}
{"id": "core_prelude_ext_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-simple` in `core/base/prelude.ss`.\nKnown issue: Must remove duplicates while preserving first occurrence.\n\n```scheme\n(define (unique-simple lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-simple` in `core/base/prelude.ss`.\nKnown issue: Must remove duplicates while preserving first occurrence.\n\n```scheme\n(define (unique-simple lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must remove duplicates while preserving first occurrence.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unique-simple '(a b a c b a)) '(a b c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unique-simple"], "split": "eval"}
{"id": "core_prelude_ext_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ok?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (ok? result)\n  (and (pair? result) (eq? (car result) 'error)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ok?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (ok? result)\n  (and (pair? result) (eq? (car result) 'error)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tag check is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (ok? '(ok 42)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "ok?"], "split": "eval"}
{"id": "core_prelude_ext_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-sequence` in `core/base/prelude.ss`.\nKnown issue: Must preserve ok values and short-circuit on first error.\n\n```scheme\n(define (result-sequence results)\n  '(ok ()))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-sequence` in `core/base/prelude.ss`.\nKnown issue: Must preserve ok values and short-circuit on first error.\n\n```scheme\n(define (result-sequence results)\n  '(ok ()))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must preserve ok values and short-circuit on first error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "result-sequence"], "split": "eval"}
{"id": "core_prelude_ext_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Remove duplicates from `(a b a c b a)` with unique-simple.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove duplicates from `(a b a c b a)` with unique-simple.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(unique-simple '(a b a c b a))", "verify_expr": "(equal? (unique-simple '(a b a c b a)) '(a b c))", "tags": ["core", "base", "prelude", "extended", "composition", "unique-simple", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Lookup key `b` in `((a . 1) (b . 2))`.", "prompt": "Task mode: small integration task across module primitives.\n\nLookup key `b` in `((a . 1) (b . 2))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(assoc-ref '((a . 1) (b . 2)) 'b)", "verify_expr": "(equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2)", "tags": ["core", "base", "prelude", "extended", "composition", "assoc-ref", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Check ok? on `(ok 42)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck ok? on `(ok 42)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(ok? '(ok 42))", "verify_expr": "(equal? (ok? '(ok 42)) #t)", "tags": ["core", "base", "prelude", "extended", "composition", "ok?", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Unwrap error with one tag.", "prompt": "Task mode: small integration task across module primitives.\n\nUnwrap error with one tag.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(unwrap-error '(error oops))", "verify_expr": "(equal? (unwrap-error '(error oops)) '(oops))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-error", "edge-case"], "split": "eval"}
{"id": "core_prelude_ext_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Short-circuit result-sequence on first error.", "prompt": "Task mode: compose existing APIs into one expression.\n\nShort-circuit result-sequence on first error.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(result-sequence '((ok 1) (error bad) (ok 3)))", "verify_expr": "(equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad))", "tags": ["core", "base", "prelude", "extended", "composition", "result-sequence", "direct"], "split": "eval"}
