{"id": "core_prelude_ext_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-simple`\nSpec: Remove duplicates using memq (eq?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-simple`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-simple`\nSpec: Remove duplicates using memq (eq?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-simple`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unique-simple"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-simple lst)\n  ;; TODO: O(n^2) duplicate removal using memq\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-simple`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-simple lst)\n  ;; TODO: O(n^2) duplicate removal using memq\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-simple`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unique-simple"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-fast`\nSpec: Remove duplicates using a hashtable (equal?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-fast`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unique-fast`\nSpec: Remove duplicates using a hashtable (equal?) while preserving first occurrence order.\n\nWrite exactly one Scheme function definition for `unique-fast`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unique-fast"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-fast lst)\n  ;; TODO: O(n) duplicate removal using hashtable\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-fast`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-fast lst)\n  ;; TODO: O(n) duplicate removal using hashtable\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-fast`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unique-fast"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `cons*`\nSpec: Build an improper list from arguments; with one arg return it directly.\n\nWrite exactly one Scheme function definition for `cons*`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `cons*`\nSpec: Build an improper list from arguments; with one arg return it directly.\n\nWrite exactly one Scheme function definition for `cons*`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (cons* 'a) 'a))\n(let () (equal? (cons* 'a 'b) '(a . b)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "cons*"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (cons* . args)\n  ;; TODO: improper-list constructor with variadic args\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `cons*`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (cons* . args)\n  ;; TODO: improper-list constructor with variadic args\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `cons*`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (cons* 'a) 'a))\n(let () (equal? (cons* 'a 'b) '(a . b)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "cons*"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assoc-ref`\nSpec: Lookup key using assoc/equal? and return value or #f.\n\nWrite exactly one Scheme function definition for `assoc-ref`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assoc-ref`\nSpec: Lookup key using assoc/equal? and return value or #f.\n\nWrite exactly one Scheme function definition for `assoc-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (assoc-ref alist key)\n  ;; TODO: assoc lookup by equal?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assoc-ref`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (assoc-ref alist key)\n  ;; TODO: assoc lookup by equal?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assoc-ref`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assq-ref`\nSpec: Lookup symbol key using assq/eq? and return value or #f.\n\nWrite exactly one Scheme function definition for `assq-ref`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `assq-ref`\nSpec: Lookup symbol key using assq/eq? and return value or #f.\n\nWrite exactly one Scheme function definition for `assq-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "assq-ref"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (assq-ref alist key)\n  ;; TODO: assq lookup by eq?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assq-ref`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (assq-ref alist key)\n  ;; TODO: assq lookup by eq?\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `assq-ref`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "assq-ref"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `alist-update`\nSpec: Return new alist with key updated/replaced at front and old entries removed.\n\nWrite exactly one Scheme function definition for `alist-update`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `alist-update`\nSpec: Return new alist with key updated/replaced at front and old entries removed.\n\nWrite exactly one Scheme function definition for `alist-update`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "alist-update"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-update alist key value)\n  ;; TODO: insert new key/value and remove stale entries\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-update`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist-update alist key value)\n  ;; TODO: insert new key/value and remove stale entries\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist-update`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "alist-update"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ok?`\nSpec: Return #t iff value is tagged `(ok ...)`.\n\nWrite exactly one Scheme function definition for `ok?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `ok?`\nSpec: Return #t iff value is tagged `(ok ...)`.\n\nWrite exactly one Scheme function definition for `ok?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (ok? '(ok 42)))\n(let () (not (ok? '(error bad))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "ok?"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ok? result)\n  ;; TODO: tag check for ok\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ok?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ok? result)\n  ;; TODO: tag check for ok\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ok?`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "ok?"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `error?`\nSpec: Return #t iff value is tagged `(error ...)`.\n\nWrite exactly one Scheme function definition for `error?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `error?`\nSpec: Return #t iff value is tagged `(error ...)`.\n\nWrite exactly one Scheme function definition for `error?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (error? '(error bad detail)))\n(let () (not (error? '(ok 1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "error?"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (error? result)\n  ;; TODO: tag check for error\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (error? result)\n  ;; TODO: tag check for error\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (error? '(error bad detail)))\n(let () (not (error? '(ok 1))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "error?"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-ok`\nSpec: Extract ok payload from `(ok value)`.\n\nWrite exactly one Scheme function definition for `unwrap-ok`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-ok`\nSpec: Extract ok payload from `(ok value)`.\n\nWrite exactly one Scheme function definition for `unwrap-ok`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (unwrap-ok '(ok (1 2))) '(1 2)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unwrap-ok"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-ok result)\n  ;; TODO: extract ok payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-ok`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-ok result)\n  ;; TODO: extract ok payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-ok`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unwrap-ok"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-error`\nSpec: Extract error payload tail from `(error tag ...)`.\n\nWrite exactly one Scheme function definition for `unwrap-error`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `unwrap-error`\nSpec: Extract error payload tail from `(error tag ...)`.\n\nWrite exactly one Scheme function definition for `unwrap-error`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "unwrap-error"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-error result)\n  ;; TODO: extract error payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-error`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unwrap-error result)\n  ;; TODO: extract error payload\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unwrap-error`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "unwrap-error"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-map`\nSpec: Apply function to ok payload and pass through errors unchanged.\n\nWrite exactly one Scheme function definition for `result-map`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-map`\nSpec: Apply function to ok payload and pass through errors unchanged.\n\nWrite exactly one Scheme function definition for `result-map`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)))\n(let () (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "result-map"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (result-map f result)\n  ;; TODO: map only successful results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-map`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (result-map f result)\n  ;; TODO: map only successful results\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-map`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "result-map"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-bind`\nSpec: Monadic bind: apply f to ok payload, short-circuit errors.\n\nWrite exactly one Scheme function definition for `result-bind`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-bind`\nSpec: Monadic bind: apply f to ok payload, short-circuit errors.\n\nWrite exactly one Scheme function definition for `result-bind`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "result-bind"], "split": "eval"}
{"id": "core_prelude_ext_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (result-bind result f)\n  ;; TODO: bind successful result through f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-bind`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (result-bind result f)\n  ;; TODO: bind successful result through f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-bind`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)))\n(let () (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "result-bind"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "You are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-sequence`\nSpec: Convert list of results to result of list, stopping at first error.\n\nWrite exactly one Scheme function definition for `result-sequence`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing additional core prelude utilities in Fold-native Scheme.\n\nTarget module: core/base/prelude.ss\nFunction: `result-sequence`\nSpec: Convert list of results to result of list, stopping at first error.\n\nWrite exactly one Scheme function definition for `result-sequence`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "spec-to-code", "result-sequence"], "split": "train"}
{"id": "core_prelude_ext_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (result-sequence results)\n  ;; TODO: sequence list of results with short-circuiting\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-sequence`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (result-sequence results)\n  ;; TODO: sequence list of results with short-circuiting\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `result-sequence`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "skeleton-completion", "result-sequence"], "split": "train"}
{"id": "core_prelude_ext_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-simple`.\nReturn only the Scheme definition.\n\n```python\ndef unique_simple(xs):\n    seen=[]\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.append(x)\n            out.append(x)\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-simple`.\nReturn only the Scheme definition.\n\n```python\ndef unique_simple(xs):\n    seen=[]\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.append(x)\n            out.append(x)\n    return out\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (unique-simple '(a b a c b a)) '(a b c)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unique-simple"], "split": "train"}
{"id": "core_prelude_ext_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-fast`.\nReturn only the Scheme definition.\n\n```python\ndef unique_fast(xs):\n    seen=set()\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-fast`.\nReturn only the Scheme definition.\n\n```python\ndef unique_fast(xs):\n    seen=set()\n    out=[]\n    for x in xs:\n        if x not in seen:\n            seen.add(x)\n            out.append(x)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unique-fast"], "split": "eval"}
{"id": "core_prelude_ext_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `cons*`.\nReturn only the Scheme definition.\n\n```python\ndef cons_star(*args):\n    if len(args)==0:\n        raise ValueError('requires at least one argument')\n    if len(args)==1:\n        return args[0]\n    return (args[0], cons_star(*args[1:]))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `cons*`.\nReturn only the Scheme definition.\n\n```python\ndef cons_star(*args):\n    if len(args)==0:\n        raise ValueError('requires at least one argument')\n    if len(args)==1:\n        return args[0]\n    return (args[0], cons_star(*args[1:]))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (cons* 'a) 'a))\n(let () (equal? (cons* 'a 'b) '(a . b)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "cons*"], "split": "train"}
{"id": "core_prelude_ext_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assoc-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assoc_ref(alist, key):\n    for k,v in alist:\n        if k == key:\n            return v\n    return None\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assoc-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assoc_ref(alist, key):\n    for k,v in alist:\n        if k == key:\n            return v\n    return None\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2))\n(let () (not (assoc-ref '((a . 1)) 'z)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assq-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assq_ref(alist, key):\n    for k,v in alist:\n        if k is key:\n            return v\n    return None\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `assq-ref`.\nReturn only the Scheme definition.\n\n```python\ndef assq_ref(alist, key):\n    for k,v in alist:\n        if k is key:\n            return v\n    return None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1))\n(let () (not (assq-ref '((a . 1)) 'z)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "assq-ref"], "split": "train"}
{"id": "core_prelude_ext_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `alist-update`.\nReturn only the Scheme definition.\n\n```python\ndef alist_update(alist, key, value):\n    return [(key, value)] + [(k,v) for (k,v) in alist if k != key]\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `alist-update`.\nReturn only the Scheme definition.\n\n```python\ndef alist_update(alist, key, value):\n    return [(key, value)] + [(k,v) for (k,v) in alist if k != key]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "alist-update"], "split": "train"}
{"id": "core_prelude_ext_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `ok?`.\nReturn only the Scheme definition.\n\n```python\ndef is_ok(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'ok'\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `ok?`.\nReturn only the Scheme definition.\n\n```python\ndef is_ok(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'ok'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (ok? '(ok 42)))\n(let () (not (ok? '(error bad))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "ok?"], "split": "train"}
{"id": "core_prelude_ext_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `error?`.\nReturn only the Scheme definition.\n\n```python\ndef is_error(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'error'\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `error?`.\nReturn only the Scheme definition.\n\n```python\ndef is_error(result):\n    return isinstance(result, (list, tuple)) and len(result) > 0 and result[0] == 'error'\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "error?"], "split": "train"}
{"id": "core_prelude_ext_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-ok`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_ok(result):\n    return result[1]\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-ok`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_ok(result):\n    return result[1]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unwrap-ok"], "split": "eval"}
{"id": "core_prelude_ext_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-error`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_error(result):\n    return result[1:]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unwrap-error`.\nReturn only the Scheme definition.\n\n```python\ndef unwrap_error(result):\n    return result[1:]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (unwrap-error '(error bad detail)) '(bad detail)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "unwrap-error"], "split": "train"}
{"id": "core_prelude_ext_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-map`.\nReturn only the Scheme definition.\n\n```python\ndef result_map(f, result):\n    if result[0] == 'ok':\n        return ('ok', f(result[1]))\n    return result\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-map`.\nReturn only the Scheme definition.\n\n```python\ndef result_map(f, result):\n    if result[0] == 'ok':\n        return ('ok', f(result[1]))\n    return result\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "result-map"], "split": "eval"}
{"id": "core_prelude_ext_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-bind`.\nReturn only the Scheme definition.\n\n```python\ndef result_bind(result, f):\n    if result[0] == 'ok':\n        return f(result[1])\n    return result\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-bind`.\nReturn only the Scheme definition.\n\n```python\ndef result_bind(result, f):\n    if result[0] == 'ok':\n        return f(result[1])\n    return result\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "result-bind"], "split": "train"}
{"id": "core_prelude_ext_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-sequence`.\nReturn only the Scheme definition.\n\n```python\ndef result_sequence(results):\n    out=[]\n    for r in results:\n        if r[0] == 'error':\n            return r\n        out.append(r[1])\n    return ('ok', out)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `result-sequence`.\nReturn only the Scheme definition.\n\n```python\ndef result_sequence(results):\n    out=[]\n    for r in results:\n        if r[0] == 'error':\n            return r\n        out.append(r[1])\n    return ('ok', out)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "python-to-scheme", "result-sequence"], "split": "train"}
{"id": "core_prelude_ext_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-simple` in `core/base/prelude.ss`.\nKnown issue: Must remove duplicates while preserving first occurrence.\n\n```scheme\n(define (unique-simple lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-simple` in `core/base/prelude.ss`.\nKnown issue: Must remove duplicates while preserving first occurrence.\n\n```scheme\n(define (unique-simple lst)\n  (reverse lst))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must remove duplicates while preserving first occurrence.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unique-simple '(a b a c b a)) '(a b c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))", "verify_expr": "(let ()\n  (define (unique-simple lst)\n  (let loop ([lst lst] [seen '()] [acc '()])\n       (cond\n        [(null? lst) (reverse acc)]\n        [(memq (car lst) seen) (loop (cdr lst) seen acc)]\n        [else (loop (cdr lst) (cons (car lst) seen) (cons (car lst) acc))])))\n  (equal? (unique-simple '(a b a c b a)) '(a b c)))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unique-simple"], "split": "eval"}
{"id": "core_prelude_ext_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-fast` in `core/base/prelude.ss`.\nKnown issue: Order and complexity behavior are wrong.\n\n```scheme\n(define (unique-fast lst)\n  (unique-simple (reverse lst)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-fast` in `core/base/prelude.ss`.\nKnown issue: Order and complexity behavior are wrong.\n\n```scheme\n(define (unique-fast lst)\n  (unique-simple (reverse lst)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Order and complexity behavior are wrong.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))", "verify_expr": "(let ()\n  (define (unique-fast lst)\n  (let ([seen (make-hashtable equal-hash equal?)])\n       (let loop ([items lst] [acc '()])\n            (if (null? items)\n                (reverse acc)\n                (let ([x (car items)])\n                     (if (hashtable-contains? seen x)\n                         (loop (cdr items) acc)\n                         (begin\n                          (hashtable-set! seen x #t)\n                          (loop (cdr items) (cons x acc)))))))))\n  (equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\")))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unique-fast"], "split": "train"}
{"id": "core_prelude_ext_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cons*` in `core/base/prelude.ss`.\nKnown issue: cons* builds improper lists, not always proper lists.\n\n```scheme\n(define (cons* . args)\n  (apply list args))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `cons*` in `core/base/prelude.ss`.\nKnown issue: cons* builds improper lists, not always proper lists.\n\n```scheme\n(define (cons* . args)\n  (apply list args))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))", "verify_expr": "(let ()\n  (define (cons* . args)\n  (cond\n   [(null? args) (error 'cons* \"requires at least one argument\")]\n   [(null? (cdr args)) (car args)]\n   [else (cons (car args) (apply cons* (cdr args)))]))\n  (and (equal? (cons* 'a) 'a) (equal? (cons* 'a 'b) '(a . b)) (equal? (cons* 'a 'b 'c) '(a b . c))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "cons*"], "split": "train"}
{"id": "core_prelude_ext_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assoc-ref` in `core/base/prelude.ss`.\nKnown issue: assoc-ref must use assoc/equal?, not assq/eq?.\n\n```scheme\n(define (assoc-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assoc-ref` in `core/base/prelude.ss`.\nKnown issue: assoc-ref must use assoc/equal?, not assq/eq?.\n\n```scheme\n(define (assoc-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2))\n(let () (not (assoc-ref '((a . 1)) 'z)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2) (not (assoc-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "assoc-ref"], "split": "train"}
{"id": "core_prelude_ext_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assq-ref` in `core/base/prelude.ss`.\nKnown issue: assq-ref must use assq/eq? semantics.\n\n```scheme\n(define (assq-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `assq-ref` in `core/base/prelude.ss`.\nKnown issue: assq-ref must use assq/eq? semantics.\n\n```scheme\n(define (assq-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: assq-ref must use assq/eq? semantics.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1))\n(let () (not (assq-ref '((a . 1)) 'z)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))", "verify_expr": "(let ()\n  (define (assq-ref alist key)\n  (let ([pair (assq key alist)])\n    (and pair (cdr pair))))\n  (and (equal? (assq-ref '((a . 1) (b . 2)) 'a) 1) (not (assq-ref '((a . 1)) 'z))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "assq-ref"], "split": "train"}
{"id": "core_prelude_ext_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-update` in `core/base/prelude.ss`.\nKnown issue: Must replace existing key entries and put new mapping at front.\n\n```scheme\n(define (alist-update alist key value)\n  (append alist (list (cons key value))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist-update` in `core/base/prelude.ss`.\nKnown issue: Must replace existing key entries and put new mapping at front.\n\n```scheme\n(define (alist-update alist key value)\n  (append alist (list (cons key value))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must replace existing key entries and put new mapping at front.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))", "verify_expr": "(let ()\n  (define (filter pred lst)\n  (cond\n    [(null? lst) '()]\n    [(pred (car lst)) (cons (car lst) (filter pred (cdr lst)))]\n    [else (filter pred (cdr lst))]))\n  (define (assoc-ref alist key)\n  (let ([pair (assoc key alist)])\n    (and pair (cdr pair))))\n  (define (alist-update alist key value)\n  (cons (cons key value)\n        (filter (lambda (pair) (not (equal? (car pair) key))) alist)))\n  (let ([updated (alist-update '((a . 1) (b . 2)) 'a 9)] [inserted (alist-update '((a . 1)) 'c 7)]) (and (equal? (assoc-ref updated 'a) 9) (equal? (assoc-ref inserted 'c) 7) (= (length (filter (lambda (p) (equal? (car p) 'a)) updated)) 1))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "alist-update"], "split": "train"}
{"id": "core_prelude_ext_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ok?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (ok? result)\n  (and (pair? result) (eq? (car result) 'error)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ok?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (ok? result)\n  (and (pair? result) (eq? (car result) 'error)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tag check is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (ok? '(ok 42)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (and (ok? '(ok 42)) (not (ok? '(error bad)))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "ok?"], "split": "eval"}
{"id": "core_prelude_ext_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (error? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error?` in `core/base/prelude.ss`.\nKnown issue: Tag check is inverted.\n\n```scheme\n(define (error? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tag check is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (error? '(error bad detail)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (and (error? '(error bad detail)) (not (error? '(ok 1)))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "error?"], "split": "train"}
{"id": "core_prelude_ext_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-ok` in `core/base/prelude.ss`.\nKnown issue: Should return payload, not tag.\n\n```scheme\n(define (unwrap-ok result)\n  (car result))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-ok` in `core/base/prelude.ss`.\nKnown issue: Should return payload, not tag.\n\n```scheme\n(define (unwrap-ok result)\n  (car result))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (unwrap-ok result)\n  (cadr result))", "verify_expr": "(let ()\n  (define (unwrap-ok result)\n  (cadr result))\n  (equal? (unwrap-ok '(ok (1 2))) '(1 2)))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unwrap-ok"], "split": "train"}
{"id": "core_prelude_ext_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-error` in `core/base/prelude.ss`.\nKnown issue: Should return full error payload tail.\n\n```scheme\n(define (unwrap-error result)\n  (cadr result))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unwrap-error` in `core/base/prelude.ss`.\nKnown issue: Should return full error payload tail.\n\n```scheme\n(define (unwrap-error result)\n  (cadr result))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Should return full error payload tail.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unwrap-error '(error bad detail)) '(bad detail)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (unwrap-error result)\n  (cdr result))", "verify_expr": "(let ()\n  (define (unwrap-error result)\n  (cdr result))\n  (equal? (unwrap-error '(error bad detail)) '(bad detail)))", "tags": ["core", "base", "prelude", "extended", "bugfix", "unwrap-error"], "split": "train"}
{"id": "core_prelude_ext_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-map` in `core/base/prelude.ss`.\nKnown issue: Errors must pass through unchanged.\n\n```scheme\n(define (result-map f result)\n  `(ok ,(f (unwrap-ok result))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-map` in `core/base/prelude.ss`.\nKnown issue: Errors must pass through unchanged.\n\n```scheme\n(define (result-map f result)\n  `(ok ,(f (unwrap-ok result))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Errors must pass through unchanged.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-map f result)\n  (if (ok? result)\n      `(ok ,(f (unwrap-ok result)))\n      result))\n  (and (equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10)) (equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "result-map"], "split": "train"}
{"id": "core_prelude_ext_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-bind` in `core/base/prelude.ss`.\nKnown issue: Bind should return f's result directly for ok case.\n\n```scheme\n(define (result-bind result f)\n  (result-map f result))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-bind` in `core/base/prelude.ss`.\nKnown issue: Bind should return f's result directly for ok case.\n\n```scheme\n(define (result-bind result f)\n  (result-map f result))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Bind should return f's result directly for ok case.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))", "verify_expr": "(let ()\n  (define (ok? result)\n  (and (pair? result) (eq? (car result) 'ok)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-bind result f)\n  (if (ok? result)\n      (f (unwrap-ok result))\n      result))\n  (and (equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6)) (equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "result-bind"], "split": "train"}
{"id": "core_prelude_ext_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-sequence` in `core/base/prelude.ss`.\nKnown issue: Must preserve ok values and short-circuit on first error.\n\n```scheme\n(define (result-sequence results)\n  '(ok ()))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `result-sequence` in `core/base/prelude.ss`.\nKnown issue: Must preserve ok values and short-circuit on first error.\n\n```scheme\n(define (result-sequence results)\n  '(ok ()))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Must preserve ok values and short-circuit on first error.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))))\n(let () (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))", "verify_expr": "(let ()\n  (define (error? result)\n  (and (pair? result) (eq? (car result) 'error)))\n  (define (unwrap-ok result)\n  (cadr result))\n  (define (result-sequence results)\n  (if (null? results)\n      '(ok ())\n      (let ([first (car results)])\n           (if (error? first)\n               first\n               (let ([rest (result-sequence (cdr results))])\n                    (if (error? rest)\n                        rest\n                        `(ok ,(cons (unwrap-ok first) (unwrap-ok rest)))))))))\n  (and (equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3))) (equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad)) (equal? (result-sequence '()) '(ok ()))))", "tags": ["core", "base", "prelude", "extended", "bugfix", "result-sequence"], "split": "eval"}
{"id": "core_prelude_ext_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Remove duplicates from `(a b a c b a)` with unique-simple.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove duplicates from `(a b a c b a)` with unique-simple.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(unique-simple '(a b a c b a))", "verify_expr": "(equal? (unique-simple '(a b a c b a)) '(a b c))", "tags": ["core", "base", "prelude", "extended", "composition", "unique-simple", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-simple", "prompt_body": "Return length of unique-simple over `(x x y y z)`.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn length of unique-simple over `(x x y y z)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(length (unique-simple '(x x y y z)))", "verify_expr": "(equal? (length (unique-simple '(x x y y z))) 3)", "tags": ["core", "base", "prelude", "extended", "composition", "unique-simple", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Remove duplicates from string list with unique-fast.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRemove duplicates from string list with unique-fast.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\"))", "verify_expr": "(equal? (unique-fast '(\"a\" \"b\" \"a\" \"c\" \"b\")) '(\"a\" \"b\" \"c\"))", "tags": ["core", "base", "prelude", "extended", "composition", "unique-fast", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unique-fast", "prompt_body": "Return #t iff unique-fast preserves first occurrence order.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff unique-fast preserves first occurrence order.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (unique-fast '(3 1 3 2 1)) '(3 1 2))", "verify_expr": "(equal? (unique-fast '(3 1 3 2 1)) '(3 1 2))", "tags": ["core", "base", "prelude", "extended", "composition", "unique-fast", "property"], "split": "train"}
{"id": "core_prelude_ext_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Build `(a b . c)` using cons*.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild `(a b . c)` using cons*.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(cons* 'a 'b 'c)", "verify_expr": "(equal? (cons* 'a 'b 'c) '(a b . c))", "tags": ["core", "base", "prelude", "extended", "composition", "cons*", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "cons*", "prompt_body": "Call cons* with one argument `q`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCall cons* with one argument `q`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(cons* 'q)", "verify_expr": "(equal? (cons* 'q) 'q)", "tags": ["core", "base", "prelude", "extended", "composition", "cons*", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Lookup key `b` in `((a . 1) (b . 2))`.", "prompt": "Task mode: small integration task across module primitives.\n\nLookup key `b` in `((a . 1) (b . 2))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(assoc-ref '((a . 1) (b . 2)) 'b)", "verify_expr": "(equal? (assoc-ref '((a . 1) (b . 2)) 'b) 2)", "tags": ["core", "base", "prelude", "extended", "composition", "assoc-ref", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assoc-ref", "prompt_body": "Return #f when assoc-ref key is missing.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #f when assoc-ref key is missing.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assoc-ref '((a . 1)) 'z)", "verify_expr": "(equal? (assoc-ref '((a . 1)) 'z) #f)", "tags": ["core", "base", "prelude", "extended", "composition", "assoc-ref", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Lookup symbol `a` via assq-ref.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nLookup symbol `a` via assq-ref.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assq-ref '((a . 1) (b . 2)) 'a)", "verify_expr": "(equal? (assq-ref '((a . 1) (b . 2)) 'a) 1)", "tags": ["core", "base", "prelude", "extended", "composition", "assq-ref", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "assq-ref", "prompt_body": "Return #f when assq-ref key is missing.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #f when assq-ref key is missing.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assq-ref '((a . 1)) 'z)", "verify_expr": "(equal? (assq-ref '((a . 1)) 'z) #f)", "tags": ["core", "base", "prelude", "extended", "composition", "assq-ref", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Update existing key `a` to 9.", "prompt": "Task mode: compose existing APIs into one expression.\n\nUpdate existing key `a` to 9.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(assoc-ref (alist-update '((a . 1) (b . 2)) 'a 9) 'a)", "verify_expr": "(equal? (assoc-ref (alist-update '((a . 1) (b . 2)) 'a 9) 'a) 9)", "tags": ["core", "base", "prelude", "extended", "composition", "alist-update", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "alist-update", "prompt_body": "Insert new key `c` with value 7.", "prompt": "Task mode: small integration task across module primitives.\n\nInsert new key `c` with value 7.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(assoc-ref (alist-update '((a . 1)) 'c 7) 'c)", "verify_expr": "(equal? (assoc-ref (alist-update '((a . 1)) 'c 7) 'c) 7)", "tags": ["core", "base", "prelude", "extended", "composition", "alist-update", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Check ok? on `(ok 42)`.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck ok? on `(ok 42)`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(ok? '(ok 42))", "verify_expr": "(equal? (ok? '(ok 42)) #t)", "tags": ["core", "base", "prelude", "extended", "composition", "ok?", "direct"], "split": "eval"}
{"id": "core_prelude_ext_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "ok?", "prompt_body": "Count ok? results in a mixed list.", "prompt": "Task mode: small integration task across module primitives.\n\nCount ok? results in a mixed list.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(length (filter ok? '((ok 1) (error bad) (ok 2))))", "verify_expr": "(equal? (length (filter ok? '((ok 1) (error bad) (ok 2)))) 2)", "tags": ["core", "base", "prelude", "extended", "composition", "ok?", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Check error? on `(error bad detail)`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck error? on `(error bad detail)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(error? '(error bad detail))", "verify_expr": "(equal? (error? '(error bad detail)) #t)", "tags": ["core", "base", "prelude", "extended", "composition", "error?", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "error?", "prompt_body": "Count error? results in a mixed list.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCount error? results in a mixed list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(length (filter error? '((ok 1) (error bad) (error x))))", "verify_expr": "(equal? (length (filter error? '((ok 1) (error bad) (error x)))) 2)", "tags": ["core", "base", "prelude", "extended", "composition", "error?", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Unwrap `(ok (1 2 3))`.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUnwrap `(ok (1 2 3))`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(unwrap-ok '(ok (1 2 3)))", "verify_expr": "(equal? (unwrap-ok '(ok (1 2 3))) '(1 2 3))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-ok", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-ok", "prompt_body": "Map unwrap-ok across only ok values.", "prompt": "Task mode: small integration task across module primitives.\n\nMap unwrap-ok across only ok values.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map unwrap-ok '((ok 1) (ok 2) (ok 3)))", "verify_expr": "(equal? (map unwrap-ok '((ok 1) (ok 2) (ok 3))) '(1 2 3))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-ok", "integration"], "split": "train"}
{"id": "core_prelude_ext_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Unwrap `(error bad detail)` payload.", "prompt": "Task mode: small integration task across module primitives.\n\nUnwrap `(error bad detail)` payload.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(unwrap-error '(error bad detail))", "verify_expr": "(equal? (unwrap-error '(error bad detail)) '(bad detail))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-error", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "unwrap-error", "prompt_body": "Unwrap error with one tag.", "prompt": "Task mode: small integration task across module primitives.\n\nUnwrap error with one tag.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(unwrap-error '(error oops))", "verify_expr": "(equal? (unwrap-error '(error oops)) '(oops))", "tags": ["core", "base", "prelude", "extended", "composition", "unwrap-error", "edge-case"], "split": "eval"}
{"id": "core_prelude_ext_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Double an ok result using result-map.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDouble an ok result using result-map.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-map (lambda (x) (* x 2)) '(ok 5))", "verify_expr": "(equal? (result-map (lambda (x) (* x 2)) '(ok 5)) '(ok 10))", "tags": ["core", "base", "prelude", "extended", "composition", "result-map", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-map", "prompt_body": "Return unchanged error through result-map.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn unchanged error through result-map.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(result-map (lambda (x) (* x 2)) '(error bad))", "verify_expr": "(equal? (result-map (lambda (x) (* x 2)) '(error bad)) '(error bad))", "tags": ["core", "base", "prelude", "extended", "composition", "result-map", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Bind ok result through increment function.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBind ok result through increment function.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1))))", "verify_expr": "(equal? (result-bind '(ok 5) (lambda (x) `(ok ,(+ x 1)))) '(ok 6))", "tags": ["core", "base", "prelude", "extended", "composition", "result-bind", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-bind", "prompt_body": "Return unchanged error through result-bind.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn unchanged error through result-bind.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-bind '(error bad) (lambda (x) `(ok ,(+ x 1))))", "verify_expr": "(equal? (result-bind '(error bad) (lambda (x) `(ok ,(+ x 1)))) '(error bad))", "tags": ["core", "base", "prelude", "extended", "composition", "result-bind", "edge-case"], "split": "train"}
{"id": "core_prelude_ext_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Sequence three ok results.", "prompt": "Task mode: compose existing APIs into one expression.\n\nSequence three ok results.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(result-sequence '((ok 1) (ok 2) (ok 3)))", "verify_expr": "(equal? (result-sequence '((ok 1) (ok 2) (ok 3))) '(ok (1 2 3)))", "tags": ["core", "base", "prelude", "extended", "composition", "result-sequence", "direct"], "split": "train"}
{"id": "core_prelude_ext_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/prelude.ss", "source_test": "core/base/test-prelude.ss", "source_function": "result-sequence", "prompt_body": "Short-circuit result-sequence on first error.", "prompt": "Task mode: compose existing APIs into one expression.\n\nShort-circuit result-sequence on first error.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(result-sequence '((ok 1) (error bad) (ok 3)))", "verify_expr": "(equal? (result-sequence '((ok 1) (error bad) (ok 3))) '(error bad))", "tags": ["core", "base", "prelude", "extended", "composition", "result-sequence", "direct"], "split": "eval"}
