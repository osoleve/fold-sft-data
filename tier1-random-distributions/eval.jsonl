{"id": "random_distributions_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `safe-log`\nSpec: Compute natural log while clamping input at 1e-300 to avoid log(0).\n\nWrite exactly one Scheme function definition for `safe-log`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (safe-log u)\n  (log-num (max u 1e-300)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (and\n  (approx=? (safe-log 1.0) 0.0 1e-12)\n  (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)\n  (approx=? (safe-log 2.5) (log-num 2.5) 1e-12)\n  (<= (safe-log 1e-400) (safe-log 1e-300))))", "tags": ["tier1", "random", "distributions", "spec-to-code", "safe-log"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `safe-log`\nSpec: Compute natural log while clamping input at 1e-300 to avoid log(0).\n\nWrite exactly one Scheme function definition for `safe-log`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `standard-normal-quantile`\nSpec: Approximate inverse standard normal CDF; reject p outside (0,1).\n\nWrite exactly one Scheme function definition for `standard-normal-quantile`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([q50 (standard-normal-quantile 0.5)]\n       [q975 (standard-normal-quantile 0.975)]\n       [q20 (standard-normal-quantile 0.2)]\n       [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))])\n  (and (approx=? q50 0.0 0.03)\n       (approx=? q975 1.96 0.12)\n       (approx=? (standard-normal-cdf q20) 0.2 0.03)\n       err?)))", "tags": ["tier1", "random", "distributions", "spec-to-code", "standard-normal-quantile"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `standard-normal-quantile`\nSpec: Approximate inverse standard normal CDF; reject p outside (0,1).\n\nWrite exactly one Scheme function definition for `standard-normal-quantile`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `poisson-pmf`\nSpec: Compute Poisson(rate) PMF for nonnegative k; return 0 for k<0.\n\nWrite exactly one Scheme function definition for `poisson-pmf`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p0 (poisson-pmf 0 2.0)]\n       [p1 (poisson-pmf 1 2.0)]\n       [p2 (poisson-pmf 2 2.0)])\n  (and (approx=? p0 (exp-num -2.0) 1e-12)\n       (approx=? (/ p2 p1) 1.0 1e-12)\n       (= (poisson-pmf -1 2.0) 0)\n       (> p1 p0))))", "tags": ["tier1", "random", "distributions", "spec-to-code", "poisson-pmf"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `poisson-pmf`\nSpec: Compute Poisson(rate) PMF for nonnegative k; return 0 for k<0.\n\nWrite exactly one Scheme function definition for `poisson-pmf`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "random_distributions_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `horner-eval`\n\n```python\ndef horner_eval(coeffs, x):\n    acc = 0\n    for c in reversed(coeffs):\n        acc = c + acc * x\n    return acc\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "translation", "python", "horner-eval"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `horner-eval`\n\n```python\ndef horner_eval(coeffs, x):\n    acc = 0\n    for c in reversed(coeffs):\n        acc = c + acc * x\n    return acc\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "random_distributions_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `uniform-cdf`\n\n```python\ndef uniform_cdf(x, a, b):\n    if x < a:\n        return 0\n    if x > b:\n        return 1\n    return (x - a) / (b - a)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "translation", "python", "uniform-cdf"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `uniform-cdf`\n\n```python\ndef uniform_cdf(x, a, b):\n    if x < a:\n        return 0\n    if x > b:\n        return 1\n    return (x - a) / (b - a)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "random_distributions_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `binomial-pmf`\n\n```scheme\n(define (binom-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([n 5] [p 0.3] [s (+ (binomial-pmf 0 n p) (binomial-pmf 1 n p) (binomial-pmf 2 n p) (binomial-pmf 3 n p) (binomial-pmf 4 n p) (binomial-pmf 5 n p))]) (and (= (binomial-pmf -1 n p) 0) (= (binomial-pmf 6 n p) 0) (approx=? s 1.0 1e-9) (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "translation", "chez", "binomial-pmf"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `binomial-pmf`\n\n```scheme\n(define (binom-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([n 5] [p 0.3] [s (+ (binomial-pmf 0 n p) (binomial-pmf 1 n p) (binomial-pmf 2 n p) (binomial-pmf 3 n p) (binomial-pmf 4 n p) (binomial-pmf 5 n p))]) (and (= (binomial-pmf -1 n p) 0) (= (binomial-pmf 6 n p) 0) (approx=? s 1.0 1e-9) (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `horner-eval` in `lattice/random/distributions.ss`.\nKnown issue: Horner recurrence must consume coefficients from highest degree side (right fold here), not left fold.\n\n```scheme\n(define (horner-eval coeffs x)\n  (fold-left (lambda (acc c) (+ c (* acc x))) 0 coeffs))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "bugfix", "horner-eval"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `horner-eval` in `lattice/random/distributions.ss`.\nKnown issue: Horner recurrence must consume coefficients from highest degree side (right fold here), not left fold.\n\n```scheme\n(define (horner-eval coeffs x)\n  (fold-left (lambda (acc c) (+ c (* acc x))) 0 coeffs))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uniform-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Upper tail should be 1 for x>b, not 0.\n\n```scheme\n(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 0]\n    [else (/ (- x a) (- b a))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "bugfix", "uniform-cdf"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uniform-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Upper tail should be 1 for x>b, not 0.\n\n```scheme\n(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 0]\n    [else (/ (- x a) (- b a))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault."}
{"id": "random_distributions_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binomial-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Failure term must use remaining trials `(n-k)`, not `k`.\n\n```scheme\n(define (binomial-pmf k n p)\n  (if (< k 0)\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) k))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "bugfix", "binomial-pmf"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binomial-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Failure term must use remaining trials `(n-k)`, not `k`.\n\n```scheme\n(define (binomial-pmf k n p)\n  (if (< k 0)\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) k))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "random_distributions_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate polynomial `1 + 0*x - 2*x^2 + x^3` at x=2 using `horner-eval`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(horner-eval '(1 0 -2 1) 2)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (equal? (horner-eval '(1 0 -2 1) 2) 1))", "tags": ["tier1", "random", "distributions", "composition", "horner-eval", "direct"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nEvaluate polynomial `1 + 0*x - 2*x^2 + x^3` at x=2 using `horner-eval`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `standard-normal-cdf` at 0.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(standard-normal-cdf 0.0)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (standard-normal-cdf 0.0) 0.5 0.001))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-cdf", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `standard-normal-cdf` at 0.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate `uniform-cdf` at x=4 on interval [2,6].\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(uniform-cdf 4.0 2.0 6.0)", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (uniform-cdf 4.0 2.0 6.0) 0.5 1e-12))", "tags": ["tier1", "random", "distributions", "composition", "uniform-cdf", "direct"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nEvaluate `uniform-cdf` at x=4 on interval [2,6].\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompare `exponential-quantile` at p=0.5 for rates 1 and 3.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(> (exponential-quantile 0.5 1.0) (exponential-quantile 0.5 3.0))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (equal? (> (exponential-quantile 0.5 1.0) (exponential-quantile 0.5 3.0)) #t))", "tags": ["tier1", "random", "distributions", "composition", "exponential-quantile", "rate-effect"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompare `exponential-quantile` at p=0.5 for rates 1 and 3.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nVerify explicit coefficient formula for `binomial-pmf` at k=2, n=5, p=0.4.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12)", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12) #t))", "tags": ["tier1", "random", "distributions", "composition", "binomial-pmf", "formula"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nVerify explicit coefficient formula for `binomial-pmf` at k=2, n=5, p=0.4.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
