{"id": "random_distributions_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `horner-eval`\nSpec: Evaluate polynomial coefficients a0..an at x using Horner's method.\n\nWrite exactly one Scheme function definition for `horner-eval`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "spec-to-code", "horner-eval"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `horner-eval`\nSpec: Evaluate polynomial coefficients a0..an at x using Horner's method.\n\nWrite exactly one Scheme function definition for `horner-eval`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `horner-eval`\nBehavior contract: Evaluate polynomial coefficients a0..an at x using Horner's method.\n\n```scheme\n(define (horner-eval coeffs x)\n  ;; TODO: use Horner's method over coeffs\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "skeleton", "horner-eval"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `horner-eval`\nBehavior contract: Evaluate polynomial coefficients a0..an at x using Horner's method.\n\n```scheme\n(define (horner-eval coeffs x)\n  ;; TODO: use Horner's method over coeffs\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "random_distributions_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `safe-log`\nSpec: Compute natural log while clamping input at 1e-300 to avoid log(0).\n\nWrite exactly one Scheme function definition for `safe-log`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (safe-log u)\n  (log-num (max u 1e-300)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (and\n  (approx=? (safe-log 1.0) 0.0 1e-12)\n  (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)\n  (approx=? (safe-log 2.5) (log-num 2.5) 1e-12)\n  (<= (safe-log 1e-400) (safe-log 1e-300))))", "tags": ["tier1", "random", "distributions", "spec-to-code", "safe-log"], "split": "eval", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `safe-log`\nSpec: Compute natural log while clamping input at 1e-300 to avoid log(0).\n\nWrite exactly one Scheme function definition for `safe-log`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `safe-log`\nBehavior contract: Compute natural log while clamping input at 1e-300 to avoid log(0).\n\n```scheme\n(define (safe-log u)\n  ;; TODO: guard against zero before applying log\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (safe-log u)\n  (log-num (max u 1e-300)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (and\n  (approx=? (safe-log 1.0) 0.0 1e-12)\n  (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)\n  (approx=? (safe-log 2.5) (log-num 2.5) 1e-12)\n  (<= (safe-log 1e-400) (safe-log 1e-300))))", "tags": ["tier1", "random", "distributions", "skeleton", "safe-log"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `safe-log`\nBehavior contract: Compute natural log while clamping input at 1e-300 to avoid log(0).\n\n```scheme\n(define (safe-log u)\n  ;; TODO: guard against zero before applying log\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "random_distributions_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `standard-normal-cdf`\nSpec: Approximate the standard normal CDF using erfc-style polynomial approximation.\n\nWrite exactly one Scheme function definition for `standard-normal-cdf`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([c0 (standard-normal-cdf 0.0)] [c1 (standard-normal-cdf 1.96)] [cm (standard-normal-cdf -1.5)] [cp (standard-normal-cdf 1.5)]) (and (approx=? c0 0.5 0.001) (approx=? c1 0.975 0.02) (approx=? (+ cm cp) 1.0 0.02) (< cm c0) (< c0 cp))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([c0 (standard-normal-cdf 0.0)]\n       [c1 (standard-normal-cdf 1.96)]\n       [cm (standard-normal-cdf -1.5)]\n       [cp (standard-normal-cdf 1.5)])\n  (and (approx=? c0 0.5 0.001)\n       (approx=? c1 0.975 0.02)\n       (approx=? (+ cm cp) 1.0 0.02)\n       (< cm c0)\n       (< c0 cp))))", "tags": ["tier1", "random", "distributions", "spec-to-code", "standard-normal-cdf"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `standard-normal-cdf`\nSpec: Approximate the standard normal CDF using erfc-style polynomial approximation.\n\nWrite exactly one Scheme function definition for `standard-normal-cdf`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([c0 (standard-normal-cdf 0.0)] [c1 (standard-normal-cdf 1.96)] [cm (standard-normal-cdf -1.5)] [cp (standard-normal-cdf 1.5)]) (and (approx=? c0 0.5 0.001) (approx=? c1 0.975 0.02) (approx=? (+ cm cp) 1.0 0.02) (< cm c0) (< c0 cp))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `standard-normal-cdf`\nBehavior contract: Approximate the standard normal CDF using erfc-style polynomial approximation.\n\n```scheme\n(define (standard-normal-cdf x)\n  ;; TODO: compute CDF with sign symmetry and erfc-style approximation\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([c0 (standard-normal-cdf 0.0)] [c1 (standard-normal-cdf 1.96)] [cm (standard-normal-cdf -1.5)] [cp (standard-normal-cdf 1.5)]) (and (approx=? c0 0.5 0.001) (approx=? c1 0.975 0.02) (approx=? (+ cm cp) 1.0 0.02) (< cm c0) (< c0 cp))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([c0 (standard-normal-cdf 0.0)]\n       [c1 (standard-normal-cdf 1.96)]\n       [cm (standard-normal-cdf -1.5)]\n       [cp (standard-normal-cdf 1.5)])\n  (and (approx=? c0 0.5 0.001)\n       (approx=? c1 0.975 0.02)\n       (approx=? (+ cm cp) 1.0 0.02)\n       (< cm c0)\n       (< c0 cp))))", "tags": ["tier1", "random", "distributions", "skeleton", "standard-normal-cdf"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `standard-normal-cdf`\nBehavior contract: Approximate the standard normal CDF using erfc-style polynomial approximation.\n\n```scheme\n(define (standard-normal-cdf x)\n  ;; TODO: compute CDF with sign symmetry and erfc-style approximation\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([c0 (standard-normal-cdf 0.0)] [c1 (standard-normal-cdf 1.96)] [cm (standard-normal-cdf -1.5)] [cp (standard-normal-cdf 1.5)]) (and (approx=? c0 0.5 0.001) (approx=? c1 0.975 0.02) (approx=? (+ cm cp) 1.0 0.02) (< cm c0) (< c0 cp))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "random_distributions_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `standard-normal-quantile`\nSpec: Approximate inverse standard normal CDF; reject p outside (0,1).\n\nWrite exactly one Scheme function definition for `standard-normal-quantile`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([q50 (standard-normal-quantile 0.5)]\n       [q975 (standard-normal-quantile 0.975)]\n       [q20 (standard-normal-quantile 0.2)]\n       [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))])\n  (and (approx=? q50 0.0 0.03)\n       (approx=? q975 1.96 0.12)\n       (approx=? (standard-normal-cdf q20) 0.2 0.03)\n       err?)))", "tags": ["tier1", "random", "distributions", "spec-to-code", "standard-normal-quantile"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `standard-normal-quantile`\nSpec: Approximate inverse standard normal CDF; reject p outside (0,1).\n\nWrite exactly one Scheme function definition for `standard-normal-quantile`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `standard-normal-quantile`\nBehavior contract: Approximate inverse standard normal CDF; reject p outside (0,1).\n\n```scheme\n(define (standard-normal-quantile p)\n  ;; TODO: enforce p in (0,1), then apply rational approximation\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([q50 (standard-normal-quantile 0.5)]\n       [q975 (standard-normal-quantile 0.975)]\n       [q20 (standard-normal-quantile 0.2)]\n       [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))])\n  (and (approx=? q50 0.0 0.03)\n       (approx=? q975 1.96 0.12)\n       (approx=? (standard-normal-cdf q20) 0.2 0.03)\n       err?)))", "tags": ["tier1", "random", "distributions", "skeleton", "standard-normal-quantile"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `standard-normal-quantile`\nBehavior contract: Approximate inverse standard normal CDF; reject p outside (0,1).\n\n```scheme\n(define (standard-normal-quantile p)\n  ;; TODO: enforce p in (0,1), then apply rational approximation\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `uniform-cdf`\nSpec: Compute Uniform(a,b) CDF with correct piecewise behavior below/inside/above interval.\n\nWrite exactly one Scheme function definition for `uniform-cdf`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "spec-to-code", "uniform-cdf"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `uniform-cdf`\nSpec: Compute Uniform(a,b) CDF with correct piecewise behavior below/inside/above interval.\n\nWrite exactly one Scheme function definition for `uniform-cdf`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `uniform-cdf`\nBehavior contract: Compute Uniform(a,b) CDF with correct piecewise behavior below/inside/above interval.\n\n```scheme\n(define (uniform-cdf x a b)\n  ;; TODO: piecewise CDF on [a,b]\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "skeleton", "uniform-cdf"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `uniform-cdf`\nBehavior contract: Compute Uniform(a,b) CDF with correct piecewise behavior below/inside/above interval.\n\n```scheme\n(define (uniform-cdf x a b)\n  ;; TODO: piecewise CDF on [a,b]\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `exponential-quantile`\nSpec: Compute Exp(rate) quantile with domain checks and p=1 -> +inf.0.\n\nWrite exactly one Scheme function definition for `exponential-quantile`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (exp-num x)\n  (exp x))\n  (define (exponential-cdf x rate)\n  (if (< x 0) 0 (- 1 (exp-num (* (- rate) x)))))\n  (let* ([q (exponential-quantile 0.5 2.0)]\n       [q0 (exponential-quantile 0.0 3.0)]\n       [q1 (exponential-quantile 1.0 4.0)]\n       [back (exponential-cdf q 2.0)]\n       [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))])\n  (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9)\n       (approx=? q0 0.0 1e-12)\n       (eqv? q1 +inf.0)\n       (approx=? back 0.5 1e-9)\n       err?)))", "tags": ["tier1", "random", "distributions", "spec-to-code", "exponential-quantile"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `exponential-quantile`\nSpec: Compute Exp(rate) quantile with domain checks and p=1 -> +inf.0.\n\nWrite exactly one Scheme function definition for `exponential-quantile`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `exponential-quantile`\nBehavior contract: Compute Exp(rate) quantile with domain checks and p=1 -> +inf.0.\n\n```scheme\n(define (exponential-quantile p rate)\n  ;; TODO: validate p in [0,1], handle p=1, compute inverse CDF\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (exp-num x)\n  (exp x))\n  (define (exponential-cdf x rate)\n  (if (< x 0) 0 (- 1 (exp-num (* (- rate) x)))))\n  (let* ([q (exponential-quantile 0.5 2.0)]\n       [q0 (exponential-quantile 0.0 3.0)]\n       [q1 (exponential-quantile 1.0 4.0)]\n       [back (exponential-cdf q 2.0)]\n       [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))])\n  (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9)\n       (approx=? q0 0.0 1e-12)\n       (eqv? q1 +inf.0)\n       (approx=? back 0.5 1e-9)\n       err?)))", "tags": ["tier1", "random", "distributions", "skeleton", "exponential-quantile"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `exponential-quantile`\nBehavior contract: Compute Exp(rate) quantile with domain checks and p=1 -> +inf.0.\n\n```scheme\n(define (exponential-quantile p rate)\n  ;; TODO: validate p in [0,1], handle p=1, compute inverse CDF\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "random_distributions_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `poisson-pmf`\nSpec: Compute Poisson(rate) PMF for nonnegative k; return 0 for k<0.\n\nWrite exactly one Scheme function definition for `poisson-pmf`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p0 (poisson-pmf 0 2.0)]\n       [p1 (poisson-pmf 1 2.0)]\n       [p2 (poisson-pmf 2 2.0)])\n  (and (approx=? p0 (exp-num -2.0) 1e-12)\n       (approx=? (/ p2 p1) 1.0 1e-12)\n       (= (poisson-pmf -1 2.0) 0)\n       (> p1 p0))))", "tags": ["tier1", "random", "distributions", "spec-to-code", "poisson-pmf"], "split": "eval", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `poisson-pmf`\nSpec: Compute Poisson(rate) PMF for nonnegative k; return 0 for k<0.\n\nWrite exactly one Scheme function definition for `poisson-pmf`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "random_distributions_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `poisson-pmf`\nBehavior contract: Compute Poisson(rate) PMF for nonnegative k; return 0 for k<0.\n\n```scheme\n(define (poisson-pmf k rate)\n  ;; TODO: return 0 for k<0; otherwise Poisson PMF formula\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p0 (poisson-pmf 0 2.0)]\n       [p1 (poisson-pmf 1 2.0)]\n       [p2 (poisson-pmf 2 2.0)])\n  (and (approx=? p0 (exp-num -2.0) 1e-12)\n       (approx=? (/ p2 p1) 1.0 1e-12)\n       (= (poisson-pmf -1 2.0) 0)\n       (> p1 p0))))", "tags": ["tier1", "random", "distributions", "skeleton", "poisson-pmf"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `poisson-pmf`\nBehavior contract: Compute Poisson(rate) PMF for nonnegative k; return 0 for k<0.\n\n```scheme\n(define (poisson-pmf k rate)\n  ;; TODO: return 0 for k<0; otherwise Poisson PMF formula\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "random_distributions_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `binomial-pmf`\nSpec: Compute Binomial(n,p) PMF and return 0 for out-of-range k.\n\nWrite exactly one Scheme function definition for `binomial-pmf`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([n 5] [p 0.3] [s (+ (binomial-pmf 0 n p) (binomial-pmf 1 n p) (binomial-pmf 2 n p) (binomial-pmf 3 n p) (binomial-pmf 4 n p) (binomial-pmf 5 n p))]) (and (= (binomial-pmf -1 n p) 0) (= (binomial-pmf 6 n p) 0) (approx=? s 1.0 1e-9) (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "spec-to-code", "binomial-pmf"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/distributions.ss\nFunction: `binomial-pmf`\nSpec: Compute Binomial(n,p) PMF and return 0 for out-of-range k.\n\nWrite exactly one Scheme function definition for `binomial-pmf`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([n 5] [p 0.3] [s (+ (binomial-pmf 0 n p) (binomial-pmf 1 n p) (binomial-pmf 2 n p) (binomial-pmf 3 n p) (binomial-pmf 4 n p) (binomial-pmf 5 n p))]) (and (= (binomial-pmf -1 n p) 0) (= (binomial-pmf 6 n p) 0) (approx=? s 1.0 1e-9) (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12))))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "random_distributions_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `binomial-pmf`\nBehavior contract: Compute Binomial(n,p) PMF and return 0 for out-of-range k.\n\n```scheme\n(define (binomial-pmf k n p)\n  ;; TODO: handle out-of-range k and compute binomial PMF\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "skeleton", "binomial-pmf"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/distributions.ss\nFunction target: `binomial-pmf`\nBehavior contract: Compute Binomial(n,p) PMF and return 0 for out-of-range k.\n\n```scheme\n(define (binomial-pmf k n p)\n  ;; TODO: handle out-of-range k and compute binomial PMF\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration."}
{"id": "random_distributions_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `horner-eval`\n\n```python\ndef horner_eval(coeffs, x):\n    acc = 0\n    for c in reversed(coeffs):\n        acc = c + acc * x\n    return acc\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "translation", "python", "horner-eval"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `horner-eval`\n\n```python\ndef horner_eval(coeffs, x):\n    acc = 0\n    for c in reversed(coeffs):\n        acc = c + acc * x\n    return acc\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "random_distributions_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `horner-eval`\n\n```scheme\n(define (poly-eval cs x)\n  (fold-right (lambda (c acc)\n                (+ c (* acc x)))\n              0\n              cs))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "translation", "chez", "horner-eval"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `horner-eval`\n\n```scheme\n(define (poly-eval cs x)\n  (fold-right (lambda (c acc)\n                (+ c (* acc x)))\n              0\n              cs))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "random_distributions_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `safe-log`\n\n```python\ndef safe_log(u):\n    return log_num(max(u, 1e-300))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (safe-log u)\n  (log-num (max u 1e-300)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (and\n  (approx=? (safe-log 1.0) 0.0 1e-12)\n  (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)\n  (approx=? (safe-log 2.5) (log-num 2.5) 1e-12)\n  (<= (safe-log 1e-400) (safe-log 1e-300))))", "tags": ["tier1", "random", "distributions", "translation", "python", "safe-log"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `safe-log`\n\n```python\ndef safe_log(u):\n    return log_num(max(u, 1e-300))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "random_distributions_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `safe-log`\n\n```scheme\n(define (guarded-log u)\n  (log-num (max u 1e-300)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (safe-log u)\n  (log-num (max u 1e-300)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (and\n  (approx=? (safe-log 1.0) 0.0 1e-12)\n  (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)\n  (approx=? (safe-log 2.5) (log-num 2.5) 1e-12)\n  (<= (safe-log 1e-400) (safe-log 1e-300))))", "tags": ["tier1", "random", "distributions", "translation", "chez", "safe-log"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `safe-log`\n\n```scheme\n(define (guarded-log u)\n  (log-num (max u 1e-300)))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `standard-normal-cdf`\n\n```python\ndef standard_normal_cdf(x):\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    t = 1 / (1 + ERFC_P * (x / (2 ** 0.5)))\n    y = 1 - (horner_eval(ERFC_COEFFS, t) * t * exp_num(-0.5 * x * x))\n    return 0.5 * (1 + sign * y)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([c0 (standard-normal-cdf 0.0)]\n       [c1 (standard-normal-cdf 1.96)]\n       [cm (standard-normal-cdf -1.5)]\n       [cp (standard-normal-cdf 1.5)])\n  (and (approx=? c0 0.5 0.001)\n       (approx=? c1 0.975 0.02)\n       (approx=? (+ cm cp) 1.0 0.02)\n       (< cm c0)\n       (< c0 cp))))", "tags": ["tier1", "random", "distributions", "translation", "python", "standard-normal-cdf"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `standard-normal-cdf`\n\n```python\ndef standard_normal_cdf(x):\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    t = 1 / (1 + ERFC_P * (x / (2 ** 0.5)))\n    y = 1 - (horner_eval(ERFC_COEFFS, t) * t * exp_num(-0.5 * x * x))\n    return 0.5 * (1 + sign * y)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "random_distributions_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `standard-normal-cdf`\n\n```scheme\n(define (stdnorm-cdf x)\n  (let* ([sgn (if (< x 0) -1 1)]\n         [ax (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ ax (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t)\n                    t\n                    (exp-num (* -0.5 ax ax))))])\n    (* 0.5 (+ 1 (* sgn y)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([c0 (standard-normal-cdf 0.0)]\n       [c1 (standard-normal-cdf 1.96)]\n       [cm (standard-normal-cdf -1.5)]\n       [cp (standard-normal-cdf 1.5)])\n  (and (approx=? c0 0.5 0.001)\n       (approx=? c1 0.975 0.02)\n       (approx=? (+ cm cp) 1.0 0.02)\n       (< cm c0)\n       (< c0 cp))))", "tags": ["tier1", "random", "distributions", "translation", "chez", "standard-normal-cdf"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `standard-normal-cdf`\n\n```scheme\n(define (stdnorm-cdf x)\n  (let* ([sgn (if (< x 0) -1 1)]\n         [ax (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ ax (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t)\n                    t\n                    (exp-num (* -0.5 ax ax))))])\n    (* 0.5 (+ 1 (* sgn y)))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `standard-normal-quantile`\n\n```python\ndef standard_normal_quantile(p):\n    if p <= 0 or p >= 1:\n        raise ValueError(\"p must be in (0,1)\")\n    sign = -1 if p < 0.5 else 1\n    p_star = p if p < 0.5 else (1 - p)\n    t = (-2 * log_num(p_star)) ** 0.5\n    return sign * (t - (horner_eval(QUANTILE_NUM_COEFFS, t) / horner_eval(QUANTILE_DEN_COEFFS, t)))\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([q50 (standard-normal-quantile 0.5)]\n       [q975 (standard-normal-quantile 0.975)]\n       [q20 (standard-normal-quantile 0.2)]\n       [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))])\n  (and (approx=? q50 0.0 0.03)\n       (approx=? q975 1.96 0.12)\n       (approx=? (standard-normal-cdf q20) 0.2 0.03)\n       err?)))", "tags": ["tier1", "random", "distributions", "translation", "python", "standard-normal-quantile"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `standard-normal-quantile`\n\n```python\ndef standard_normal_quantile(p):\n    if p <= 0 or p >= 1:\n        raise ValueError(\"p must be in (0,1)\")\n    sign = -1 if p < 0.5 else 1\n    p_star = p if p < 0.5 else (1 - p)\n    t = (-2 * log_num(p_star)) ** 0.5\n    return sign * (t - (horner_eval(QUANTILE_NUM_COEFFS, t) / horner_eval(QUANTILE_DEN_COEFFS, t)))\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_translation_008", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `standard-normal-quantile`\n\n```scheme\n(define (stdnorm-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'stdnorm-quantile \"p out of range\" p)\n      (let* ([sgn (if (< p 0.5) -1 1)]\n             [pp (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num pp)))])\n        (* sgn\n           (- t\n              (/ (horner-eval *quantile-num-coeffs* t)\n                 (horner-eval *quantile-den-coeffs* t)))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([q50 (standard-normal-quantile 0.5)]\n       [q975 (standard-normal-quantile 0.975)]\n       [q20 (standard-normal-quantile 0.2)]\n       [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))])\n  (and (approx=? q50 0.0 0.03)\n       (approx=? q975 1.96 0.12)\n       (approx=? (standard-normal-cdf q20) 0.2 0.03)\n       err?)))", "tags": ["tier1", "random", "distributions", "translation", "chez", "standard-normal-quantile"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `standard-normal-quantile`\n\n```scheme\n(define (stdnorm-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'stdnorm-quantile \"p out of range\" p)\n      (let* ([sgn (if (< p 0.5) -1 1)]\n             [pp (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num pp)))])\n        (* sgn\n           (- t\n              (/ (horner-eval *quantile-num-coeffs* t)\n                 (horner-eval *quantile-den-coeffs* t)))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `uniform-cdf`\n\n```python\ndef uniform_cdf(x, a, b):\n    if x < a:\n        return 0\n    if x > b:\n        return 1\n    return (x - a) / (b - a)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "translation", "python", "uniform-cdf"], "split": "eval", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `uniform-cdf`\n\n```python\ndef uniform_cdf(x, a, b):\n    if x < a:\n        return 0\n    if x > b:\n        return 1\n    return (x - a) / (b - a)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "random_distributions_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `uniform-cdf`\n\n```scheme\n(define (u-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "translation", "chez", "uniform-cdf"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `uniform-cdf`\n\n```scheme\n(define (u-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `exponential-quantile`\n\n```python\ndef exponential_quantile(p, rate):\n    if p < 0 or p > 1:\n        raise ValueError(\"p must be in [0,1]\")\n    if p == 1:\n        return float('inf')\n    return -log_num(1 - p) / rate\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (exp-num x)\n  (exp x))\n  (define (exponential-cdf x rate)\n  (if (< x 0) 0 (- 1 (exp-num (* (- rate) x)))))\n  (let* ([q (exponential-quantile 0.5 2.0)]\n       [q0 (exponential-quantile 0.0 3.0)]\n       [q1 (exponential-quantile 1.0 4.0)]\n       [back (exponential-cdf q 2.0)]\n       [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))])\n  (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9)\n       (approx=? q0 0.0 1e-12)\n       (eqv? q1 +inf.0)\n       (approx=? back 0.5 1e-9)\n       err?)))", "tags": ["tier1", "random", "distributions", "translation", "python", "exponential-quantile"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `exponential-quantile`\n\n```python\ndef exponential_quantile(p, rate):\n    if p < 0 or p > 1:\n        raise ValueError(\"p must be in [0,1]\")\n    if p == 1:\n        return float('inf')\n    return -log_num(1 - p) / rate\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `exponential-quantile`\n\n```scheme\n(define (exp-q p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exp-q \"p out of range\" p)\n      (if (= p 1)\n          +inf.0\n          (/ (- (log-num (- 1 p))) rate))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (exp-num x)\n  (exp x))\n  (define (exponential-cdf x rate)\n  (if (< x 0) 0 (- 1 (exp-num (* (- rate) x)))))\n  (let* ([q (exponential-quantile 0.5 2.0)]\n       [q0 (exponential-quantile 0.0 3.0)]\n       [q1 (exponential-quantile 1.0 4.0)]\n       [back (exponential-cdf q 2.0)]\n       [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))])\n  (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9)\n       (approx=? q0 0.0 1e-12)\n       (eqv? q1 +inf.0)\n       (approx=? back 0.5 1e-9)\n       err?)))", "tags": ["tier1", "random", "distributions", "translation", "chez", "exponential-quantile"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `exponential-quantile`\n\n```scheme\n(define (exp-q p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exp-q \"p out of range\" p)\n      (if (= p 1)\n          +inf.0\n          (/ (- (log-num (- 1 p))) rate))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "random_distributions_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `poisson-pmf`\n\n```python\ndef poisson_pmf(k, rate):\n    if k < 0:\n        return 0\n    return (rate ** k) * exp_num(-rate) / factorial(k)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p0 (poisson-pmf 0 2.0)]\n       [p1 (poisson-pmf 1 2.0)]\n       [p2 (poisson-pmf 2 2.0)])\n  (and (approx=? p0 (exp-num -2.0) 1e-12)\n       (approx=? (/ p2 p1) 1.0 1e-12)\n       (= (poisson-pmf -1 2.0) 0)\n       (> p1 p0))))", "tags": ["tier1", "random", "distributions", "translation", "python", "poisson-pmf"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `poisson-pmf`\n\n```python\ndef poisson_pmf(k, rate):\n    if k < 0:\n        return 0\n    return (rate ** k) * exp_num(-rate) / factorial(k)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "random_distributions_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `poisson-pmf`\n\n```scheme\n(define (pois-pmf k lam)\n  (if (< k 0)\n      0\n      (/ (* (expt lam k) (exp-num (- lam)))\n         (factorial k))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p0 (poisson-pmf 0 2.0)]\n       [p1 (poisson-pmf 1 2.0)]\n       [p2 (poisson-pmf 2 2.0)])\n  (and (approx=? p0 (exp-num -2.0) 1e-12)\n       (approx=? (/ p2 p1) 1.0 1e-12)\n       (= (poisson-pmf -1 2.0) 0)\n       (> p1 p0))))", "tags": ["tier1", "random", "distributions", "translation", "chez", "poisson-pmf"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `poisson-pmf`\n\n```scheme\n(define (pois-pmf k lam)\n  (if (< k 0)\n      0\n      (/ (* (expt lam k) (exp-num (- lam)))\n         (factorial k))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `binomial-pmf`\n\n```python\ndef binomial_pmf(k, n, p):\n    if k < 0 or k > n:\n        return 0\n    return binomial_coeff(n, k) * (p ** k) * ((1 - p) ** (n - k))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "translation", "python", "binomial-pmf"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `binomial-pmf`\n\n```python\ndef binomial_pmf(k, n, p):\n    if k < 0 or k > n:\n        return 0\n    return binomial_coeff(n, k) * (p ** k) * ((1 - p) ** (n - k))\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "random_distributions_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `binomial-pmf`\n\n```scheme\n(define (binom-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([n 5] [p 0.3] [s (+ (binomial-pmf 0 n p) (binomial-pmf 1 n p) (binomial-pmf 2 n p) (binomial-pmf 3 n p) (binomial-pmf 4 n p) (binomial-pmf 5 n p))]) (and (= (binomial-pmf -1 n p) 0) (= (binomial-pmf 6 n p) 0) (approx=? s 1.0 1e-9) (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "translation", "chez", "binomial-pmf"], "split": "eval", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `binomial-pmf`\n\n```scheme\n(define (binom-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([n 5] [p 0.3] [s (+ (binomial-pmf 0 n p) (binomial-pmf 1 n p) (binomial-pmf 2 n p) (binomial-pmf 3 n p) (binomial-pmf 4 n p) (binomial-pmf 5 n p))]) (and (= (binomial-pmf -1 n p) 0) (= (binomial-pmf 6 n p) 0) (approx=? s 1.0 1e-9) (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "random_distributions_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `horner-eval` in `lattice/random/distributions.ss`.\nKnown issue: Horner recurrence must consume coefficients from highest degree side (right fold here), not left fold.\n\n```scheme\n(define (horner-eval coeffs x)\n  (fold-left (lambda (acc c) (+ c (* acc x))) 0 coeffs))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "bugfix", "horner-eval"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `horner-eval` in `lattice/random/distributions.ss`.\nKnown issue: Horner recurrence must consume coefficients from highest degree side (right fold here), not left fold.\n\n```scheme\n(define (horner-eval coeffs x)\n  (fold-left (lambda (acc c) (+ c (* acc x))) 0 coeffs))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `horner-eval` in `lattice/random/distributions.ss`.\nKnown issue: Accumulator seed must be 0; seeding with 1 shifts every polynomial result.\n\n```scheme\n(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 1 coeffs))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Accumulator seed must be 0; seeding with 1 shifts every polynomial result.\n\nExpected behavior after patch:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (and\n  (= (horner-eval '(1 2 3) 2) 17)\n  (= (horner-eval '(5) 9) 5)\n  (= (horner-eval '() 10) 0)\n  (= (horner-eval '(3 -1 2) -2) 13)))", "tags": ["tier1", "random", "distributions", "bugfix", "horner-eval"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `horner-eval` in `lattice/random/distributions.ss`.\nKnown issue: Accumulator seed must be 0; seeding with 1 shifts every polynomial result.\n\n```scheme\n(define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 1 coeffs))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Accumulator seed must be 0; seeding with 1 shifts every polynomial result.\n\nExpected behavior after patch:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (horner-eval '(1 2 3) 2) 17))\n(let () (= (horner-eval '(5) 9) 5))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `safe-log` in `lattice/random/distributions.ss`.\nKnown issue: Clamp must use max to enforce a lower bound, not min.\n\n```scheme\n(define (safe-log u)\n  (log-num (min u 1e-300)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Clamp must use max to enforce a lower bound, not min.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (safe-log u)\n  (log-num (max u 1e-300)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (and\n  (approx=? (safe-log 1.0) 0.0 1e-12)\n  (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)\n  (approx=? (safe-log 2.5) (log-num 2.5) 1e-12)\n  (<= (safe-log 1e-400) (safe-log 1e-300))))", "tags": ["tier1", "random", "distributions", "bugfix", "safe-log"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `safe-log` in `lattice/random/distributions.ss`.\nKnown issue: Clamp must use max to enforce a lower bound, not min.\n\n```scheme\n(define (safe-log u)\n  (log-num (min u 1e-300)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Clamp must use max to enforce a lower bound, not min.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "random_distributions_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `safe-log` in `lattice/random/distributions.ss`.\nKnown issue: Clamp threshold changed by 270 orders of magnitude; keep 1e-300.\n\n```scheme\n(define (safe-log u)\n  (log-num (max u 1e-30)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Clamp threshold changed by 270 orders of magnitude; keep 1e-300.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (safe-log u)\n  (log-num (max u 1e-300)))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (and\n  (approx=? (safe-log 1.0) 0.0 1e-12)\n  (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)\n  (approx=? (safe-log 2.5) (log-num 2.5) 1e-12)\n  (<= (safe-log 1e-400) (safe-log 1e-300))))", "tags": ["tier1", "random", "distributions", "bugfix", "safe-log"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `safe-log` in `lattice/random/distributions.ss`.\nKnown issue: Clamp threshold changed by 270 orders of magnitude; keep 1e-300.\n\n```scheme\n(define (safe-log u)\n  (log-num (max u 1e-30)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Clamp threshold changed by 270 orders of magnitude; keep 1e-300.\n\nExpected behavior after patch:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (approx=? (safe-log 1.0) 0.0 1e-12))\n(let () (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Negative-side symmetry is broken: sign factor must be applied to y.\n\n```scheme\n(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 y))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([c0 (standard-normal-cdf 0.0)] [c1 (standard-normal-cdf 1.96)] [cm (standard-normal-cdf -1.5)] [cp (standard-normal-cdf 1.5)]) (and (approx=? c0 0.5 0.001) (approx=? c1 0.975 0.02) (approx=? (+ cm cp) 1.0 0.02) (< cm c0) (< c0 cp))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([c0 (standard-normal-cdf 0.0)]\n       [c1 (standard-normal-cdf 1.96)]\n       [cm (standard-normal-cdf -1.5)]\n       [cp (standard-normal-cdf 1.5)])\n  (and (approx=? c0 0.5 0.001)\n       (approx=? c1 0.975 0.02)\n       (approx=? (+ cm cp) 1.0 0.02)\n       (< cm c0)\n       (< c0 cp))))", "tags": ["tier1", "random", "distributions", "bugfix", "standard-normal-cdf"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Negative-side symmetry is broken: sign factor must be applied to y.\n\n```scheme\n(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 y))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([c0 (standard-normal-cdf 0.0)] [c1 (standard-normal-cdf 1.96)] [cm (standard-normal-cdf -1.5)] [cp (standard-normal-cdf 1.5)]) (and (approx=? c0 0.5 0.001) (approx=? c1 0.975 0.02) (approx=? (+ cm cp) 1.0 0.02) (< cm c0) (< c0 cp))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "random_distributions_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Gaussian exponent must use x squared; dropping one x distorts the tail.\n\n```scheme\n(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([c0 (standard-normal-cdf 0.0)]\n       [c1 (standard-normal-cdf 1.96)]\n       [cm (standard-normal-cdf -1.5)]\n       [cp (standard-normal-cdf 1.5)])\n  (and (approx=? c0 0.5 0.001)\n       (approx=? c1 0.975 0.02)\n       (approx=? (+ cm cp) 1.0 0.02)\n       (< cm c0)\n       (< c0 cp))))", "tags": ["tier1", "random", "distributions", "bugfix", "standard-normal-cdf"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Gaussian exponent must use x squared; dropping one x distorts the tail.\n\n```scheme\n(define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-quantile` in `lattice/random/distributions.ss`.\nKnown issue: Quantiles below 0.5 must be negative; forcing sign=1 breaks symmetry.\n\n```scheme\n(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign 1]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Quantiles below 0.5 must be negative; forcing sign=1 breaks symmetry.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([q50 (standard-normal-quantile 0.5)]\n       [q975 (standard-normal-quantile 0.975)]\n       [q20 (standard-normal-quantile 0.2)]\n       [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))])\n  (and (approx=? q50 0.0 0.03)\n       (approx=? q975 1.96 0.12)\n       (approx=? (standard-normal-cdf q20) 0.2 0.03)\n       err?)))", "tags": ["tier1", "random", "distributions", "bugfix", "standard-normal-quantile"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-quantile` in `lattice/random/distributions.ss`.\nKnown issue: Quantiles below 0.5 must be negative; forcing sign=1 breaks symmetry.\n\n```scheme\n(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign 1]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Quantiles below 0.5 must be negative; forcing sign=1 breaks symmetry.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([q50 (standard-normal-quantile 0.5)] [q975 (standard-normal-quantile 0.975)] [q20 (standard-normal-quantile 0.2)] [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))]) (and (approx=? q50 0.0 0.03) (approx=? q975 1.96 0.12) (approx=? (standard-normal-cdf q20) 0.2 0.03) err?)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "random_distributions_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-quantile` in `lattice/random/distributions.ss`.\nKnown issue: Domain guard must reject p=0 and p=1 as well, not only strict out-of-range values.\n\n```scheme\n(define (standard-normal-quantile p)\n  (if (or (< p 0) (> p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([q50 (standard-normal-quantile 0.5)]\n       [q975 (standard-normal-quantile 0.975)]\n       [q20 (standard-normal-quantile 0.2)]\n       [err? (guard (ex [else #t]) (begin (standard-normal-quantile 1.0) #f))])\n  (and (approx=? q50 0.0 0.03)\n       (approx=? q975 1.96 0.12)\n       (approx=? (standard-normal-cdf q20) 0.2 0.03)\n       err?)))", "tags": ["tier1", "random", "distributions", "bugfix", "standard-normal-quantile"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `standard-normal-quantile` in `lattice/random/distributions.ss`.\nKnown issue: Domain guard must reject p=0 and p=1 as well, not only strict out-of-range values.\n\n```scheme\n(define (standard-normal-quantile p)\n  (if (or (< p 0) (> p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault."}
{"id": "random_distributions_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uniform-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Upper tail should be 1 for x>b, not 0.\n\n```scheme\n(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 0]\n    [else (/ (- x a) (- b a))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "bugfix", "uniform-cdf"], "split": "eval", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uniform-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Upper tail should be 1 for x>b, not 0.\n\n```scheme\n(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 0]\n    [else (/ (- x a) (- b a))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault."}
{"id": "random_distributions_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uniform-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Interior branch is reversed; CDF must increase with x.\n\n```scheme\n(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- b x) (- b a))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([a 2.0] [b 6.0])\n  (and (= (uniform-cdf 1.0 a b) 0)\n       (= (uniform-cdf 7.0 a b) 1)\n       (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12)\n       (approx=? (uniform-cdf a a b) 0.0 1e-12)\n       (approx=? (uniform-cdf b a b) 1.0 1e-12))))", "tags": ["tier1", "random", "distributions", "bugfix", "uniform-cdf"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `uniform-cdf` in `lattice/random/distributions.ss`.\nKnown issue: Interior branch is reversed; CDF must increase with x.\n\n```scheme\n(define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- b x) (- b a))]))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([a 2.0] [b 6.0]) (and (= (uniform-cdf 1.0 a b) 0) (= (uniform-cdf 7.0 a b) 1) (approx=? (uniform-cdf 4.0 a b) 0.5 1e-12) (approx=? (uniform-cdf a a b) 0.0 1e-12) (approx=? (uniform-cdf b a b) 1.0 1e-12))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `exponential-quantile` in `lattice/random/distributions.ss`.\nKnown issue: Inverse CDF uses log(1-p), not log(p).\n\n```scheme\n(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num p)) rate))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Inverse CDF uses log(1-p), not log(p).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (exp-num x)\n  (exp x))\n  (define (exponential-cdf x rate)\n  (if (< x 0) 0 (- 1 (exp-num (* (- rate) x)))))\n  (let* ([q (exponential-quantile 0.5 2.0)]\n       [q0 (exponential-quantile 0.0 3.0)]\n       [q1 (exponential-quantile 1.0 4.0)]\n       [back (exponential-cdf q 2.0)]\n       [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))])\n  (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9)\n       (approx=? q0 0.0 1e-12)\n       (eqv? q1 +inf.0)\n       (approx=? back 0.5 1e-9)\n       err?)))", "tags": ["tier1", "random", "distributions", "bugfix", "exponential-quantile"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `exponential-quantile` in `lattice/random/distributions.ss`.\nKnown issue: Inverse CDF uses log(1-p), not log(p).\n\n```scheme\n(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num p)) rate))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Inverse CDF uses log(1-p), not log(p).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `exponential-quantile` in `lattice/random/distributions.ss`.\nKnown issue: At p=1, exponential quantile diverges to +inf.0, not 0.\n\n```scheme\n(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) 0 (/ (- (log-num (- 1 p))) rate))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: At p=1, exponential quantile diverges to +inf.0, not 0.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (exp-num x)\n  (exp x))\n  (define (exponential-cdf x rate)\n  (if (< x 0) 0 (- 1 (exp-num (* (- rate) x)))))\n  (let* ([q (exponential-quantile 0.5 2.0)]\n       [q0 (exponential-quantile 0.0 3.0)]\n       [q1 (exponential-quantile 1.0 4.0)]\n       [back (exponential-cdf q 2.0)]\n       [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))])\n  (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9)\n       (approx=? q0 0.0 1e-12)\n       (eqv? q1 +inf.0)\n       (approx=? back 0.5 1e-9)\n       err?)))", "tags": ["tier1", "random", "distributions", "bugfix", "exponential-quantile"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `exponential-quantile` in `lattice/random/distributions.ss`.\nKnown issue: At p=1, exponential quantile diverges to +inf.0, not 0.\n\n```scheme\n(define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) 0 (/ (- (log-num (- 1 p))) rate))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: At p=1, exponential quantile diverges to +inf.0, not 0.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([q (exponential-quantile 0.5 2.0)] [q0 (exponential-quantile 0.0 3.0)] [q1 (exponential-quantile 1.0 4.0)] [back (exponential-cdf q 2.0)] [err? (guard (ex [else #t]) (begin (exponential-quantile 1.1 2.0) #f))]) (and (approx=? q (/ (log-num 2.0) 2.0) 1e-9) (approx=? q0 0.0 1e-12) (eqv? q1 +inf.0) (approx=? back 0.5 1e-9) err?)))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poisson-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Poisson PMF must include the exp(-rate) factor.\n\n```scheme\n(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (expt rate k)\n         (factorial k))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Poisson PMF must include the exp(-rate) factor.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p0 (poisson-pmf 0 2.0)]\n       [p1 (poisson-pmf 1 2.0)]\n       [p2 (poisson-pmf 2 2.0)])\n  (and (approx=? p0 (exp-num -2.0) 1e-12)\n       (approx=? (/ p2 p1) 1.0 1e-12)\n       (= (poisson-pmf -1 2.0) 0)\n       (> p1 p0))))", "tags": ["tier1", "random", "distributions", "bugfix", "poisson-pmf"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poisson-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Poisson PMF must include the exp(-rate) factor.\n\n```scheme\n(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (expt rate k)\n         (factorial k))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Poisson PMF must include the exp(-rate) factor.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "random_distributions_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poisson-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Denominator should be k!, not (k+1)!.\n\n```scheme\n(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial (+ k 1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Denominator should be k!, not (k+1)!.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([p0 (poisson-pmf 0 2.0)]\n       [p1 (poisson-pmf 1 2.0)]\n       [p2 (poisson-pmf 2 2.0)])\n  (and (approx=? p0 (exp-num -2.0) 1e-12)\n       (approx=? (/ p2 p1) 1.0 1e-12)\n       (= (poisson-pmf -1 2.0) 0)\n       (> p1 p0))))", "tags": ["tier1", "random", "distributions", "bugfix", "poisson-pmf"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poisson-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Denominator should be k!, not (k+1)!.\n\n```scheme\n(define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial (+ k 1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Denominator should be k!, not (k+1)!.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([p0 (poisson-pmf 0 2.0)] [p1 (poisson-pmf 1 2.0)] [p2 (poisson-pmf 2 2.0)]) (and (approx=? p0 (exp-num -2.0) 1e-12) (approx=? (/ p2 p1) 1.0 1e-12) (= (poisson-pmf -1 2.0) 0) (> p1 p0))))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "random_distributions_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binomial-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Failure term exponent must be (n-k), not (n+k).\n\n```scheme\n(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (+ n k)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "bugfix", "binomial-pmf"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binomial-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Failure term exponent must be (n-k), not (n+k).\n\n```scheme\n(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (+ n k)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault."}
{"id": "random_distributions_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binomial-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Failure term must use remaining trials `(n-k)`, not `k`.\n\n```scheme\n(define (binomial-pmf k n p)\n  (if (< k 0)\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) k))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let* ([n 5]\n       [p 0.3]\n       [s (+ (binomial-pmf 0 n p)\n             (binomial-pmf 1 n p)\n             (binomial-pmf 2 n p)\n             (binomial-pmf 3 n p)\n             (binomial-pmf 4 n p)\n             (binomial-pmf 5 n p))])\n  (and (= (binomial-pmf -1 n p) 0)\n       (= (binomial-pmf 6 n p) 0)\n       (approx=? s 1.0 1e-9)\n       (approx=? (binomial-pmf 2 5 0.4)\n                 (* 10 (expt 0.4 2) (expt 0.6 3))\n                 1e-12))))", "tags": ["tier1", "random", "distributions", "bugfix", "binomial-pmf"], "split": "eval", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `binomial-pmf` in `lattice/random/distributions.ss`.\nKnown issue: Failure term must use remaining trials `(n-k)`, not `k`.\n\n```scheme\n(define (binomial-pmf k n p)\n  (if (< k 0)\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) k))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "random_distributions_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate polynomial `1 + 0*x - 2*x^2 + x^3` at x=2 using `horner-eval`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(horner-eval '(1 0 -2 1) 2)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (equal? (horner-eval '(1 0 -2 1) 2) 1))", "tags": ["tier1", "random", "distributions", "composition", "horner-eval", "direct"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nEvaluate polynomial `1 + 0*x - 2*x^2 + x^3` at x=2 using `horner-eval`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether `horner-eval` matches explicit polynomial evaluation for coefficients `(2 -1 4)` at x=3.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (horner-eval '(2 -1 4) 3) (+ 2 (* -1 3) (* 4 3 3)))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (equal? (= (horner-eval '(2 -1 4) 3) (+ 2 (* -1 3) (* 4 3 3))) #t))", "tags": ["tier1", "random", "distributions", "composition", "horner-eval", "equivalence"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether `horner-eval` matches explicit polynomial evaluation for coefficients `(2 -1 4)` at x=3.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: small integration task across module primitives.\n\nMap `horner-eval` with coefficients `(1 2)` over x in `(0 1 2)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map (lambda (x) (horner-eval '(1 2) x)) '(0 1 2))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (equal? (map (lambda (x) (horner-eval '(1 2) x)) '(0 1 2)) '(1 3 5)))", "tags": ["tier1", "random", "distributions", "composition", "horner-eval", "map"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nMap `horner-eval` with coefficients `(1 2)` over x in `(0 1 2)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_004", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "horner-eval", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `horner-eval` on `*quantile-den-coeffs*` at t=1.5 and return whether result is positive.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(> (horner-eval *quantile-den-coeffs* 1.5) 0)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (equal? (> (horner-eval *quantile-den-coeffs* 1.5) 0) #t))", "tags": ["tier1", "random", "distributions", "composition", "horner-eval", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `horner-eval` on `*quantile-den-coeffs*` at t=1.5 and return whether result is positive.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `safe-log` at zero equals `log-num 1e-300`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(approx=? (safe-log 0.0) (log-num 1e-300) 1e-12)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (safe-log 0.0) (log-num 1e-300) 1e-12) #t))", "tags": ["tier1", "random", "distributions", "composition", "safe-log", "guard"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether `safe-log` at zero equals `log-num 1e-300`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: small integration task across module primitives.\n\nMap `safe-log` over `(1.0 0.5 0.0)` and return the resulting list.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map safe-log '(1.0 0.5 0.0))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (let ([xs (map safe-log '(1.0 0.5 0.0))]) (and (approx=? (car xs) 0.0 1e-12) (< (cadr xs) 0) (< (caddr xs) (cadr xs)))))", "tags": ["tier1", "random", "distributions", "composition", "safe-log", "map"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nMap `safe-log` over `(1.0 0.5 0.0)` and return the resulting list.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: small integration task across module primitives.\n\nUse `safe-log` to compute `log(4)-log(2)` and compare against `log(2)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(approx=? (- (safe-log 4.0) (safe-log 2.0)) (log-num 2.0) 1e-12)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (- (safe-log 4.0) (safe-log 2.0)) (log-num 2.0) 1e-12) #t))", "tags": ["tier1", "random", "distributions", "composition", "safe-log", "identity"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nUse `safe-log` to compute `log(4)-log(2)` and compare against `log(2)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "safe-log", "prompt": "Task mode: small integration task across module primitives.\n\nExpress the exponential median formula with `safe-log` and verify it matches `exponential-quantile` at p=0.25, rate=2.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(approx=? (/ (- (safe-log (- 1 0.25))) 2.0) (exponential-quantile 0.25 2.0) 1e-12)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (safe-log u)\n  (log-num (max u 1e-300)))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (/ (- (safe-log (- 1 0.25))) 2.0) (exponential-quantile 0.25 2.0) 1e-12) #t))", "tags": ["tier1", "random", "distributions", "composition", "safe-log", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nExpress the exponential median formula with `safe-log` and verify it matches `exponential-quantile` at p=0.25, rate=2.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `standard-normal-cdf` at 0.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(standard-normal-cdf 0.0)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (standard-normal-cdf 0.0) 0.5 0.001))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-cdf", "direct"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `standard-normal-cdf` at 0.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether `standard-normal-cdf` satisfies symmetry at x=1.2: CDF(-x)+CDF(x)=1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(approx=? (+ (standard-normal-cdf -1.2) (standard-normal-cdf 1.2)) 1.0 0.02)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (+ (standard-normal-cdf -1.2) (standard-normal-cdf 1.2)) 1.0 0.02) #t))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-cdf", "symmetry"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether `standard-normal-cdf` satisfies symmetry at x=1.2: CDF(-x)+CDF(x)=1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose `standard-normal-cdf` with `standard-normal-quantile` at p=0.8.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(standard-normal-cdf (standard-normal-quantile 0.8))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (standard-normal-cdf (standard-normal-quantile 0.8)) 0.8 0.03))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-cdf", "inverse"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompose `standard-normal-cdf` with `standard-normal-quantile` at p=0.8.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-cdf", "prompt": "Task mode: small integration task across module primitives.\n\nCheck monotonicity of `standard-normal-cdf` at x=-1,0,1.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([a (standard-normal-cdf -1.0)] [b (standard-normal-cdf 0.0)] [c (standard-normal-cdf 1.0)]) (and (< a b) (< b c)))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (equal? (let ([a (standard-normal-cdf -1.0)] [b (standard-normal-cdf 0.0)] [c (standard-normal-cdf 1.0)]) (and (< a b) (< b c))) #t))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-cdf", "ordering"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCheck monotonicity of `standard-normal-cdf` at x=-1,0,1.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: small integration task across module primitives.\n\nEvaluate `standard-normal-quantile` at p=0.5.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(standard-normal-quantile 0.5)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (standard-normal-quantile 0.5) 0.0 0.03))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-quantile", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nEvaluate `standard-normal-quantile` at p=0.5.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute `standard-normal-quantile` at p=0.95 and check it is near 1.64.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(standard-normal-quantile 0.95)", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (standard-normal-quantile 0.95) 1.64 0.12))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-quantile", "tail"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompute `standard-normal-quantile` at p=0.95 and check it is near 1.64.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `standard-normal-quantile 0.2` is less than `standard-normal-quantile 0.8`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(< (standard-normal-quantile 0.2) (standard-normal-quantile 0.8))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (equal? (< (standard-normal-quantile 0.2) (standard-normal-quantile 0.8)) #t))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-quantile", "ordering"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether `standard-normal-quantile 0.2` is less than `standard-normal-quantile 0.8`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "standard-normal-quantile", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRound-trip p=0.33 through `standard-normal-quantile` then `standard-normal-cdf`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(standard-normal-cdf (standard-normal-quantile 0.33))", "verify_expr": "(let ()\n  (define (horner-eval coeffs x)\n  (fold-right (lambda (c acc) (+ c (* acc x))) 0 coeffs))\n  (define *quantile-num-coeffs* '(2.515517 0.802853 0.010328))\n  (define *quantile-den-coeffs* '(1 1.432788 0.189269 0.001308))\n  (define (log-num x)\n  (log x))\n  (define (standard-normal-quantile p)\n  (if (or (<= p 0) (>= p 1))\n      (error 'standard-normal-quantile \"p must be in (0,1)\" p)\n      (let* ([sign (if (< p 0.5) -1 1)]\n             [p* (if (< p 0.5) p (- 1 p))]\n             [t (sqrt (* -2 (log-num p*)))])\n        (* sign (- t (/ (horner-eval *quantile-num-coeffs* t)\n                        (horner-eval *quantile-den-coeffs* t)))))))\n  (define *erfc-coeffs* '(0.254829592 -0.284496736 1.421413741 -1.453152027 1.061405429))\n  (define *erfc-p* 0.3275911)\n  (define (exp-num x)\n  (exp x))\n  (define (standard-normal-cdf x)\n  (let* ([sign (if (< x 0) -1 1)]\n         [x (abs x)]\n         [t (/ 1 (+ 1 (* *erfc-p* (/ x (sqrt 2)))))]\n         [y (- 1 (* (horner-eval *erfc-coeffs* t) t (exp-num (* -0.5 x x))))])\n    (* 0.5 (+ 1 (* sign y)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (standard-normal-cdf (standard-normal-quantile 0.33)) 0.33 0.03))", "tags": ["tier1", "random", "distributions", "composition", "standard-normal-quantile", "inverse"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nRound-trip p=0.33 through `standard-normal-quantile` then `standard-normal-cdf`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate `uniform-cdf` at x=4 on interval [2,6].\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(uniform-cdf 4.0 2.0 6.0)", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (uniform-cdf 4.0 2.0 6.0) 0.5 1e-12))", "tags": ["tier1", "random", "distributions", "composition", "uniform-cdf", "direct"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nEvaluate `uniform-cdf` at x=4 on interval [2,6].\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn the three-way piecewise outputs of `uniform-cdf` for x in (1,3,8) on [2,6].\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(list (uniform-cdf 1.0 2.0 6.0) (uniform-cdf 3.0 2.0 6.0) (uniform-cdf 8.0 2.0 6.0))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (equal? (list (uniform-cdf 1.0 2.0 6.0) (uniform-cdf 3.0 2.0 6.0) (uniform-cdf 8.0 2.0 6.0)) '(0 0.25 1)))", "tags": ["tier1", "random", "distributions", "composition", "uniform-cdf", "piecewise"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn the three-way piecewise outputs of `uniform-cdf` for x in (1,3,8) on [2,6].\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose `uniform-cdf` with `uniform-quantile` at p=0.3 on [10,20].\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(uniform-cdf (uniform-quantile 0.3 10.0 20.0) 10.0 20.0)", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (uniform-quantile p a b)\n  (if (or (< p 0) (> p 1))\n      (error 'uniform-quantile \"p must be in [0,1]\" p)\n      (+ a (* p (- b a)))))\n  (approx=? (uniform-cdf (uniform-quantile 0.3 10.0 20.0) 10.0 20.0) 0.3 1e-12))", "tags": ["tier1", "random", "distributions", "composition", "uniform-cdf", "inverse"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCompose `uniform-cdf` with `uniform-quantile` at p=0.3 on [10,20].\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "uniform-cdf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck monotonicity of `uniform-cdf` on [0,5] for x=1,2,4.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([a (uniform-cdf 1.0 0.0 5.0)] [b (uniform-cdf 2.0 0.0 5.0)] [c (uniform-cdf 4.0 0.0 5.0)]) (and (< a b) (< b c)))", "verify_expr": "(let ()\n  (define (uniform-cdf x a b)\n  (cond\n    [(< x a) 0]\n    [(> x b) 1]\n    [else (/ (- x a) (- b a))]))\n  (equal? (let ([a (uniform-cdf 1.0 0.0 5.0)] [b (uniform-cdf 2.0 0.0 5.0)] [c (uniform-cdf 4.0 0.0 5.0)]) (and (< a b) (< b c))) #t))", "tags": ["tier1", "random", "distributions", "composition", "uniform-cdf", "ordering"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCheck monotonicity of `uniform-cdf` on [0,5] for x=1,2,4.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "random_distributions_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: compose existing APIs into one expression.\n\nEvaluate `exponential-quantile` at p=0.5 with rate=1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(exponential-quantile 0.5 1.0)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (exponential-quantile 0.5 1.0) (log-num 2.0) 1e-9))", "tags": ["tier1", "random", "distributions", "composition", "exponential-quantile", "median"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nEvaluate `exponential-quantile` at p=0.5 with rate=1.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_022", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRound-trip p=0.7 through `exponential-quantile` then `exponential-cdf` at rate=2.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(exponential-cdf (exponential-quantile 0.7 2.0) 2.0)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (define (exp-num x)\n  (exp x))\n  (define (exponential-cdf x rate)\n  (if (< x 0) 0 (- 1 (exp-num (* (- rate) x)))))\n  (approx=? (exponential-cdf (exponential-quantile 0.7 2.0) 2.0) 0.7 1e-9))", "tags": ["tier1", "random", "distributions", "composition", "exponential-quantile", "inverse"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nRound-trip p=0.7 through `exponential-quantile` then `exponential-cdf` at rate=2.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `exponential-quantile` maps p=1 to `+inf.0`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(eqv? (exponential-quantile 1.0 3.0) +inf.0)", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (equal? (eqv? (exponential-quantile 1.0 3.0) +inf.0) #t))", "tags": ["tier1", "random", "distributions", "composition", "exponential-quantile", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn whether `exponential-quantile` maps p=1 to `+inf.0`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "exponential-quantile", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompare `exponential-quantile` at p=0.5 for rates 1 and 3.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(> (exponential-quantile 0.5 1.0) (exponential-quantile 0.5 3.0))", "verify_expr": "(let ()\n  (define (log-num x)\n  (log x))\n  (define (exponential-quantile p rate)\n  (if (or (< p 0) (> p 1))\n      (error 'exponential-quantile \"p must be in [0,1]\" p)\n      (if (= p 1) +inf.0 (/ (- (log-num (- 1 p))) rate))))\n  (equal? (> (exponential-quantile 0.5 1.0) (exponential-quantile 0.5 3.0)) #t))", "tags": ["tier1", "random", "distributions", "composition", "exponential-quantile", "rate-effect"], "split": "eval", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompare `exponential-quantile` at p=0.5 for rates 1 and 3.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `poisson-pmf` at k=0, rate=2.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(poisson-pmf 0 2.0)", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (poisson-pmf 0 2.0) (exp-num -2.0) 1e-12))", "tags": ["tier1", "random", "distributions", "composition", "poisson-pmf", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nEvaluate `poisson-pmf` at k=0, rate=2.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether ratio `poisson-pmf(3,4)/poisson-pmf(2,4)` equals 4/3.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(/ (poisson-pmf 3 4.0) (poisson-pmf 2 4.0))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (/ (poisson-pmf 3 4.0) (poisson-pmf 2 4.0)) (/ 4.0 3.0) 1e-12))", "tags": ["tier1", "random", "distributions", "composition", "poisson-pmf", "ratio"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn whether ratio `poisson-pmf(3,4)/poisson-pmf(2,4)` equals 4/3.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: compose existing APIs into one expression.\n\nSum `poisson-pmf` from k=0..12 for rate=3 and return whether total is near 1.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let loop ([k 0] [acc 0.0]) (if (> k 12) acc (loop (+ k 1) (+ acc (poisson-pmf k 3.0)))))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (let loop ([k 0] [acc 0.0]) (if (> k 12) acc (loop (+ k 1) (+ acc (poisson-pmf k 3.0))))) 1.0 0.01))", "tags": ["tier1", "random", "distributions", "composition", "poisson-pmf", "normalization"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSum `poisson-pmf` from k=0..12 for rate=3 and return whether total is near 1.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "random_distributions_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "poisson-pmf", "prompt": "Task mode: compose existing APIs into one expression.\n\nFor rate=4, check that `poisson-pmf` at k=4 is at least as large as k=3 and k=5.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([p3 (poisson-pmf 3 4.0)] [p4 (poisson-pmf 4 4.0)] [p5 (poisson-pmf 5 4.0)]) (and (>= p4 p3) (>= p4 p5)))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (exp-num x)\n  (exp x))\n  (define (poisson-pmf k rate)\n  (if (< k 0)\n      0\n      (/ (* (expt rate k) (exp-num (- rate)))\n         (factorial k))))\n  (equal? (let ([p3 (poisson-pmf 3 4.0)] [p4 (poisson-pmf 4 4.0)] [p5 (poisson-pmf 5 4.0)]) (and (>= p4 p3) (>= p4 p5))) #t))", "tags": ["tier1", "random", "distributions", "composition", "poisson-pmf", "mode"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nFor rate=4, check that `poisson-pmf` at k=4 is at least as large as k=3 and k=5.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn out-of-range checks for `binomial-pmf` with n=5, p=0.3 at k=-1 and k=6.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(list (binomial-pmf -1 5 0.3) (binomial-pmf 6 5 0.3))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (equal? (list (binomial-pmf -1 5 0.3) (binomial-pmf 6 5 0.3)) '(0 0)))", "tags": ["tier1", "random", "distributions", "composition", "binomial-pmf", "bounds"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn out-of-range checks for `binomial-pmf` with n=5, p=0.3 at k=-1 and k=6.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSum `binomial-pmf` over k=0..5 for n=5, p=0.3 and check normalization.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(+ (binomial-pmf 0 5 0.3) (binomial-pmf 1 5 0.3) (binomial-pmf 2 5 0.3) (binomial-pmf 3 5 0.3) (binomial-pmf 4 5 0.3) (binomial-pmf 5 5 0.3))", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (approx=? (+ (binomial-pmf 0 5 0.3) (binomial-pmf 1 5 0.3) (binomial-pmf 2 5 0.3) (binomial-pmf 3 5 0.3) (binomial-pmf 4 5 0.3) (binomial-pmf 5 5 0.3)) 1.0 1e-9))", "tags": ["tier1", "random", "distributions", "composition", "binomial-pmf", "normalization"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nSum `binomial-pmf` over k=0..5 for n=5, p=0.3 and check normalization.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck symmetry of `binomial-pmf` for n=6, p=0.5 at k=2 and k=4.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(approx=? (binomial-pmf 2 6 0.5) (binomial-pmf 4 6 0.5) 1e-12)", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (binomial-pmf 2 6 0.5) (binomial-pmf 4 6 0.5) 1e-12) #t))", "tags": ["tier1", "random", "distributions", "composition", "binomial-pmf", "symmetry"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCheck symmetry of `binomial-pmf` for n=6, p=0.5 at k=2 and k=4.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "random_distributions_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/distributions.ss", "source_test": "lattice/random/test-distributions.ss", "source_function": "binomial-pmf", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nVerify explicit coefficient formula for `binomial-pmf` at k=2, n=5, p=0.4.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12)", "verify_expr": "(let ()\n  (define (factorial n)\n  (if (<= n 1) 1 (* n (factorial (- n 1)))))\n  (define (binomial-coeff n k)\n  (if (or (< k 0) (> k n))\n      0\n      (/ (factorial n) (* (factorial k) (factorial (- n k))))))\n  (define (binomial-pmf k n p)\n  (if (or (< k 0) (> k n))\n      0\n      (* (binomial-coeff n k)\n         (expt p k)\n         (expt (- 1 p) (- n k)))))\n  (define (approx=? a b tol)\n  (< (abs (- a b)) tol))\n  (equal? (approx=? (binomial-pmf 2 5 0.4) (* 10 (expt 0.4 2) (expt 0.6 3)) 1e-12) #t))", "tags": ["tier1", "random", "distributions", "composition", "binomial-pmf", "formula"], "split": "eval", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nVerify explicit coefficient formula for `binomial-pmf` at k=2, n=5, p=0.4.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
