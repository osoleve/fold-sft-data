{"id": "dict_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-empty?`\nSpec: Return #t iff dictionary has zero entries.\n\nWrite exactly one Scheme function definition for `dict-empty?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (dict-empty? '()))\n(let () (not (dict-empty? '((a . 1)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-empty?"], "split": "train"}
{"id": "dict_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-empty? dict)\n  ;; TODO: return whether dictionary is empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-empty?`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-empty?"], "split": "train"}
{"id": "dict_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-lookup`\nSpec: Lookup key and return value, else #f if key is absent.\n\nWrite exactly one Scheme function definition for `dict-lookup`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (dict-lookup 'a '((a . 10) (b . 20))) 10))\n(let () (not (dict-lookup 'z '((a . 10) (b . 20)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (and (= (dict-lookup 'a '((a . 10) (b . 20))) 10) (not (dict-lookup 'z '((a . 10) (b . 20))))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-lookup"], "split": "train"}
{"id": "dict_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-lookup key dict)\n  ;; TODO: return value for key, else #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-lookup`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (and (= (dict-lookup 'a '((a . 10) (b . 20))) 10) (not (dict-lookup 'z '((a . 10) (b . 20))))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-lookup"], "split": "train"}
{"id": "dict_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-has-key?`\nSpec: Return #t iff key exists in dictionary.\n\nWrite exactly one Scheme function definition for `dict-has-key?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (dict-has-key? 'a '((a . 1))))\n(let () (dict-has-key? 'a '((a . #f))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))", "verify_expr": "(let ()\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (and (dict-has-key? 'a '((a . 1))) (dict-has-key? 'a '((a . #f))) (not (dict-has-key? 'b '((a . 1))))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-has-key?"], "split": "eval"}
{"id": "dict_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-has-key? key dict)\n  ;; TODO: return whether key exists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-has-key?`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (dict-has-key? 'a '((a . 1))))\n(let () (dict-has-key? 'a '((a . #f))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))", "verify_expr": "(let ()\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (and (dict-has-key? 'a '((a . 1))) (dict-has-key? 'a '((a . #f))) (not (dict-has-key? 'b '((a . 1))))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-has-key?"], "split": "train"}
{"id": "dict_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-assoc`\nSpec: Associate key with value; replace existing key binding if present.\n\nWrite exactly one Scheme function definition for `dict-assoc`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-assoc"], "split": "train"}
{"id": "dict_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-assoc key value dict)\n  ;; TODO: upsert key-value pair\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-assoc`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-assoc"], "split": "train"}
{"id": "dict_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-dissoc`\nSpec: Remove key from dictionary, leaving other entries unchanged.\n\nWrite exactly one Scheme function definition for `dict-dissoc`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-dissoc"], "split": "train"}
{"id": "dict_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-dissoc key dict)\n  ;; TODO: remove key while preserving other entries\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-dissoc`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-dissoc"], "split": "train"}
{"id": "dict_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-keys`\nSpec: Return list of dictionary keys.\n\nWrite exactly one Scheme function definition for `dict-keys`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-keys dict)\n  (map car dict))", "verify_expr": "(let ()\n  (define (dict-keys dict)\n  (map car dict))\n  (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-keys"], "split": "eval"}
{"id": "dict_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-keys dict)\n  ;; TODO: extract keys\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-keys`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-keys dict)\n  (map car dict))", "verify_expr": "(let ()\n  (define (dict-keys dict)\n  (map car dict))\n  (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-keys"], "split": "train"}
{"id": "dict_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-values`\nSpec: Return list of dictionary values.\n\nWrite exactly one Scheme function definition for `dict-values`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (dict-values dict)\n  (map cdr dict))", "verify_expr": "(let ()\n  (define (dict-values dict)\n  (map cdr dict))\n  (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-values"], "split": "eval"}
{"id": "dict_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-values dict)\n  ;; TODO: extract values\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-values`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-values dict)\n  (map cdr dict))", "verify_expr": "(let ()\n  (define (dict-values dict)\n  (map cdr dict))\n  (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-values"], "split": "train"}
{"id": "dict_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-entries`\nSpec: Return list of key-value pairs.\n\nWrite exactly one Scheme function definition for `dict-entries`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-entries dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict-entries dict)\n  dict)\n  (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-entries"], "split": "eval"}
{"id": "dict_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-entries dict)\n  ;; TODO: return entries\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-entries`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-entries dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict-entries dict)\n  dict)\n  (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-entries"], "split": "train"}
{"id": "dict_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-merge`\nSpec: Merge dictionaries; for overlapping keys, dict2 values win.\n\nWrite exactly one Scheme function definition for `dict-merge`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))\n  (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-merge"], "split": "train"}
{"id": "dict_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-merge dict1 dict2)\n  ;; TODO: merge dictionaries with dict2 precedence\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-merge`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))\n  (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-merge"], "split": "train"}
{"id": "dict_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-map-values`\nSpec: Apply function to each value while preserving keys.\n\nWrite exactly one Scheme function definition for `dict-map-values`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-map-values"], "split": "train"}
{"id": "dict_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-map-values f dict)\n  ;; TODO: map function over values\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-map-values`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-map-values"], "split": "train"}
{"id": "dict_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-filter`\nSpec: Keep entries where predicate (key value) returns true.\n\nWrite exactly one Scheme function definition for `dict-filter`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-filter"], "split": "train"}
{"id": "dict_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-filter pred dict)\n  ;; TODO: keep entries satisfying pred\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-filter`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-filter"], "split": "train"}
{"id": "dict_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-size`\nSpec: Return number of key-value pairs.\n\nWrite exactly one Scheme function definition for `dict-size`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-size dict)\n  (length dict))", "verify_expr": "(let ()\n  (define (dict-size dict)\n  (length dict))\n  (and (= (dict-size '()) 0) (= (dict-size '((a . 1) (b . 2))) 2)))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-size"], "split": "train"}
{"id": "dict_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict-size dict)\n  ;; TODO: return entry count\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict-size`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (dict-size '()) 0))\n(let () (= (dict-size '((a . 1) (b . 2))) 2))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict-size dict)\n  (length dict))", "verify_expr": "(let ()\n  (define (dict-size dict)\n  (length dict))\n  (and (= (dict-size '()) 0) (= (dict-size '((a . 1) (b . 2))) 2)))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict-size"], "split": "train"}
{"id": "dict_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict->alist`\nSpec: Convert dictionary to association list (identity).\n\nWrite exactly one Scheme function definition for `dict->alist`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (dict->alist dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict->alist dict)\n  dict)\n  (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict->alist"], "split": "train"}
{"id": "dict_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (dict->alist dict)\n  ;; TODO: convert dict to alist\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `dict->alist`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (dict->alist dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict->alist dict)\n  dict)\n  (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "dict->alist"], "split": "train"}
{"id": "dict_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `alist->dict`\nSpec: Convert association list to dictionary (identity).\n\nWrite exactly one Scheme function definition for `alist->dict`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "spec-to-code", "alist->dict"], "split": "train"}
{"id": "dict_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (alist->dict alist)\n  ;; TODO: convert alist to dict\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `alist->dict`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "skeleton-completion", "alist->dict"], "split": "train"}
{"id": "dict_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef dict_empty(d):\n    return len(d) == 0\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-empty?"], "split": "eval"}
{"id": "dict_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? d)\n  (null? d))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (dict-empty? '()))\n(let () (not (dict-empty? '((a . 1)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-empty?"], "split": "train"}
{"id": "dict_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-lookup`.\nReturn only the Scheme definition.\n\n```python\ndef dict_lookup(key, d):\n    return d[key] if key in d else None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (dict-lookup 'a '((a . 10) (b . 20))) 10))\n(let () (not (dict-lookup 'z '((a . 10) (b . 20)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (and (= (dict-lookup 'a '((a . 10) (b . 20))) 10) (not (dict-lookup 'z '((a . 10) (b . 20))))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-lookup"], "split": "train"}
{"id": "dict_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-lookup`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (lookup k d)\n  (let ([p (assoc k d)])\n    (if p (cdr p) #f)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (dict-lookup 'a '((a . 10) (b . 20))) 10))\n(let () (not (dict-lookup 'z '((a . 10) (b . 20)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (and (= (dict-lookup 'a '((a . 10) (b . 20))) 10) (not (dict-lookup 'z '((a . 10) (b . 20))))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-lookup"], "split": "train"}
{"id": "dict_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-has-key?`.\nReturn only the Scheme definition.\n\n```python\ndef dict_has_key(key, d):\n    return key in d\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))", "verify_expr": "(let ()\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (and (dict-has-key? 'a '((a . 1))) (dict-has-key? 'a '((a . #f))) (not (dict-has-key? 'b '((a . 1))))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-has-key?"], "split": "train"}
{"id": "dict_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-has-key?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (has-key? k d)\n  (if (assoc k d) #t #f))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (dict-has-key? 'a '((a . 1))))\n(let () (dict-has-key? 'a '((a . #f))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))", "verify_expr": "(let ()\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (and (dict-has-key? 'a '((a . 1))) (dict-has-key? 'a '((a . #f))) (not (dict-has-key? 'b '((a . 1))))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-has-key?"], "split": "train"}
{"id": "dict_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-assoc`.\nReturn only the Scheme definition.\n\n```python\ndef dict_assoc(key, value, d):\n    out = {k: v for k, v in d.items() if k != key}\n    out[key] = value\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-assoc"], "split": "train"}
{"id": "dict_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-assoc`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (put k v d)\n  (cons (cons k v) (dict-dissoc k d)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-assoc"], "split": "train"}
{"id": "dict_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-dissoc`.\nReturn only the Scheme definition.\n\n```python\ndef dict_dissoc(key, d):\n    return {k: v for k, v in d.items() if k != key}\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-dissoc"], "split": "train"}
{"id": "dict_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-dissoc`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (drop k d)\n  (filter (lambda (p) (not (equal? k (car p)))) d))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-dissoc"], "split": "eval"}
{"id": "dict_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-keys`.\nReturn only the Scheme definition.\n\n```python\ndef dict_keys(d):\n    return list(d.keys())\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (dict-keys dict)\n  (map car dict))", "verify_expr": "(let ()\n  (define (dict-keys dict)\n  (map car dict))\n  (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-keys"], "split": "train"}
{"id": "dict_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-keys`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (keys d)\n  (map car d))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-keys dict)\n  (map car dict))", "verify_expr": "(let ()\n  (define (dict-keys dict)\n  (map car dict))\n  (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-keys"], "split": "train"}
{"id": "dict_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-values`.\nReturn only the Scheme definition.\n\n```python\ndef dict_values(d):\n    return list(d.values())\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-values dict)\n  (map cdr dict))", "verify_expr": "(let ()\n  (define (dict-values dict)\n  (map cdr dict))\n  (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-values"], "split": "train"}
{"id": "dict_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-values`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (values0 d)\n  (map cdr d))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-values dict)\n  (map cdr dict))", "verify_expr": "(let ()\n  (define (dict-values dict)\n  (map cdr dict))\n  (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-values"], "split": "train"}
{"id": "dict_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-entries`.\nReturn only the Scheme definition.\n\n```python\ndef dict_entries(d):\n    return list(d.items())\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-entries dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict-entries dict)\n  dict)\n  (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-entries"], "split": "train"}
{"id": "dict_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-entries`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (entries d)\n  d)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (dict-entries dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict-entries dict)\n  dict)\n  (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-entries"], "split": "train"}
{"id": "dict_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-merge`.\nReturn only the Scheme definition.\n\n```python\ndef dict_merge(d1, d2):\n    out = dict(d1)\n    out.update(d2)\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))\n  (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-merge"], "split": "train"}
{"id": "dict_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-merge`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge0 d1 d2)\n  (fold-left (lambda (acc p) (dict-assoc (car p) (cdr p) acc)) d1 d2))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))\n  (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-merge"], "split": "train"}
{"id": "dict_translation_019", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-map-values`.\nReturn only the Scheme definition.\n\n```python\ndef dict_map_values(f, d):\n    return {k: f(v) for k, v in d.items()}\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-map-values"], "split": "eval"}
{"id": "dict_translation_020", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-map-values`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (map-values f d)\n  (map (lambda (p) (cons (car p) (f (cdr p)))) d))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-map-values"], "split": "train"}
{"id": "dict_translation_021", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-filter`.\nReturn only the Scheme definition.\n\n```python\ndef dict_filter(pred, d):\n    return {k: v for k, v in d.items() if pred(k, v)}\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-filter"], "split": "train"}
{"id": "dict_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-filter`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (filter-d pred d)\n  (filter (lambda (p) (pred (car p) (cdr p))) d))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-filter"], "split": "train"}
{"id": "dict_translation_023", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-size`.\nReturn only the Scheme definition.\n\n```python\ndef dict_size(d):\n    return len(d)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-size dict)\n  (length dict))", "verify_expr": "(let ()\n  (define (dict-size dict)\n  (length dict))\n  (and (= (dict-size '()) 0) (= (dict-size '((a . 1) (b . 2))) 2)))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-size"], "split": "train"}
{"id": "dict_translation_024", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (size0 d)\n  (length d))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (dict-size '()) 0))\n(let () (= (dict-size '((a . 1) (b . 2))) 2))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-size dict)\n  (length dict))", "verify_expr": "(let ()\n  (define (dict-size dict)\n  (length dict))\n  (and (= (dict-size '()) 0) (= (dict-size '((a . 1) (b . 2))) 2)))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-size"], "split": "train"}
{"id": "dict_translation_025", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict->alist`.\nReturn only the Scheme definition.\n\n```python\ndef dict_to_alist(d):\n    return d\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict->alist dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict->alist dict)\n  dict)\n  (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict->alist"], "split": "train"}
{"id": "dict_translation_026", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict->alist`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (to-alist d)\n  d)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict->alist dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict->alist dict)\n  dict)\n  (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict->alist"], "split": "train"}
{"id": "dict_translation_027", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `alist->dict`.\nReturn only the Scheme definition.\n\n```python\ndef alist_to_dict(xs):\n    return xs\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "alist->dict"], "split": "train"}
{"id": "dict_translation_028", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `alist->dict`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (from-alist xs)\n  xs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "alist->dict"], "split": "eval"}
{"id": "dict_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-empty?` in `lattice/data/dict.ss`.\nKnown issue: A one-entry dictionary should not be empty.\n\n```scheme\n(define (dict-empty? dict)\n  (null? (cdr dict)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (dict-empty? '()))\n(let () (not (dict-empty? '((a . 1)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-empty?"], "split": "eval"}
{"id": "dict_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-empty?` in `lattice/data/dict.ss`.\nKnown issue: Empty dictionary must return #t.\n\n```scheme\n(define (dict-empty? dict)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty dictionary must return #t.\n\nExpected behavior after patch:\n```scheme\n(let () (dict-empty? '()))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (dict-empty? '()))\n(let () (not (dict-empty? '((a . 1)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-empty?"], "split": "train"}
{"id": "dict_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-lookup` in `lattice/data/dict.ss`.\nKnown issue: Lookup should return value, not key-value pair.\n\n```scheme\n(define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair pair #f)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Lookup should return value, not key-value pair.\n\nExpected behavior after patch:\n```scheme\n(let () (= (dict-lookup 'a '((a . 10) (b . 20))) 10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (dict-lookup 'a '((a . 10) (b . 20))) 10))\n(let () (not (dict-lookup 'z '((a . 10) (b . 20)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (and (= (dict-lookup 'a '((a . 10) (b . 20))) 10) (not (dict-lookup 'z '((a . 10) (b . 20))))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-lookup"], "split": "train"}
{"id": "dict_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-lookup` in `lattice/data/dict.ss`.\nKnown issue: Missing keys should yield #f, and present keys must return stored values.\n\n```scheme\n(define (dict-lookup key dict)\n  0)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Missing keys should yield #f, and present keys must return stored values.\n\nExpected behavior after patch:\n```scheme\n(let () (= (dict-lookup 'a '((a . 10) (b . 20))) 10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (and (= (dict-lookup 'a '((a . 10) (b . 20))) 10) (not (dict-lookup 'z '((a . 10) (b . 20))))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-lookup"], "split": "train"}
{"id": "dict_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-has-key?` in `lattice/data/dict.ss`.\nKnown issue: A key with value #f should still count as present.\n\n```scheme\n(define (dict-has-key? key dict)\n  (if (dict-lookup key dict) #t #f))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: A key with value #f should still count as present.\n\nExpected behavior after patch:\n```scheme\n(let () (dict-has-key? 'a '((a . 1))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (dict-has-key? 'a '((a . 1))))\n(let () (dict-has-key? 'a '((a . #f))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))", "verify_expr": "(let ()\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (and (dict-has-key? 'a '((a . 1))) (dict-has-key? 'a '((a . #f))) (not (dict-has-key? 'b '((a . 1))))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-has-key?"], "split": "train"}
{"id": "dict_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-has-key?` in `lattice/data/dict.ss`.\nKnown issue: Absent keys must return #f.\n\n```scheme\n(define (dict-has-key? key dict)\n  #t)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))", "verify_expr": "(let ()\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (and (dict-has-key? 'a '((a . 1))) (dict-has-key? 'a '((a . #f))) (not (dict-has-key? 'b '((a . 1))))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-has-key?"], "split": "train"}
{"id": "dict_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-assoc` in `lattice/data/dict.ss`.\nKnown issue: Existing keys must be replaced, not duplicated.\n\n```scheme\n(define (dict-assoc key value dict)\n  (cons (cons key value) dict))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Existing keys must be replaced, not duplicated.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-assoc"], "split": "train"}
{"id": "dict_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-assoc` in `lattice/data/dict.ss`.\nKnown issue: Association should insert or update the key.\n\n```scheme\n(define (dict-assoc key value dict)\n  dict)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (let* ([d1 (dict-assoc 'a 1 '((b . 2)))] [d2 (dict-assoc 'b 9 '((b . 2) (a . 1)))]) (and (= (dict-lookup 'a d1) 1) (= (dict-size d1) 2) (= (dict-lookup 'b d2) 9) (= (dict-size d2) 2))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-assoc"], "split": "train"}
{"id": "dict_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-dissoc` in `lattice/data/dict.ss`.\nKnown issue: Key should be removed when present.\n\n```scheme\n(define (dict-dissoc key dict)\n  dict)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Key should be removed when present.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-dissoc"], "split": "train"}
{"id": "dict_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-dissoc` in `lattice/data/dict.ss`.\nKnown issue: Removing one key must not erase unrelated entries.\n\n```scheme\n(define (dict-dissoc key dict)\n  '())\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-dissoc"], "split": "eval"}
{"id": "dict_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-keys` in `lattice/data/dict.ss`.\nKnown issue: This returns values, not keys.\n\n```scheme\n(define (dict-keys dict)\n  (map cdr dict))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: This returns values, not keys.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-keys dict)\n  (map car dict))", "verify_expr": "(let ()\n  (define (dict-keys dict)\n  (map car dict))\n  (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "dict", "bugfix", "dict-keys"], "split": "train"}
{"id": "dict_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-keys` in `lattice/data/dict.ss`.\nKnown issue: Keys list should reflect dictionary entries.\n\n```scheme\n(define (dict-keys dict)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-keys dict)\n  (map car dict))", "verify_expr": "(let ()\n  (define (dict-keys dict)\n  (map car dict))\n  (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "dict", "bugfix", "dict-keys"], "split": "train"}
{"id": "dict_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-values` in `lattice/data/dict.ss`.\nKnown issue: This returns keys, not values.\n\n```scheme\n(define (dict-values dict)\n  (map car dict))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-values dict)\n  (map cdr dict))", "verify_expr": "(let ()\n  (define (dict-values dict)\n  (map cdr dict))\n  (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))", "tags": ["tier0", "data", "dict", "bugfix", "dict-values"], "split": "train"}
{"id": "dict_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-values` in `lattice/data/dict.ss`.\nKnown issue: Values list should reflect dictionary entries.\n\n```scheme\n(define (dict-values dict)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Values list should reflect dictionary entries.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-values dict)\n  (map cdr dict))", "verify_expr": "(let ()\n  (define (dict-values dict)\n  (map cdr dict))\n  (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))", "tags": ["tier0", "data", "dict", "bugfix", "dict-values"], "split": "train"}
{"id": "dict_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-entries` in `lattice/data/dict.ss`.\nKnown issue: Entries should be returned unchanged.\n\n```scheme\n(define (dict-entries dict)\n  (reverse dict))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-entries dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict-entries dict)\n  dict)\n  (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-entries"], "split": "train"}
{"id": "dict_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-entries` in `lattice/data/dict.ss`.\nKnown issue: Entries should not be dropped.\n\n```scheme\n(define (dict-entries dict)\n  '())\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-entries dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict-entries dict)\n  dict)\n  (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-entries"], "split": "train"}
{"id": "dict_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-merge` in `lattice/data/dict.ss`.\nKnown issue: Merge must include keys from dict2.\n\n```scheme\n(define (dict-merge dict1 dict2)\n  dict1)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))\n  (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-merge"], "split": "train"}
{"id": "dict_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-merge` in `lattice/data/dict.ss`.\nKnown issue: This gives dict1 precedence; dict2 should win on overlap.\n\n```scheme\n(define (dict-merge dict1 dict2)\n  (let loop ([remaining dict1] [result dict2])\n    (if (null? remaining) result (loop (cdr remaining) (dict-assoc (car (car remaining)) (cdr (car remaining)) result)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))", "verify_expr": "(let ()\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (define (dict-assoc key value dict)\n  (cons (cons key value)\n        (dict-dissoc key dict)))\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-size dict)\n  (length dict))\n  (define (dict-merge dict1 dict2)\n  (let loop ([remaining dict2]\n             [result dict1])\n    (if (null? remaining)\n        result\n        (loop (cdr remaining)\n              (dict-assoc (car (car remaining))\n                          (cdr (car remaining))\n                          result)))))\n  (let* ([d1 '((a . 1) (b . 2))] [d2 '((b . 99) (c . 3))] [m (dict-merge d1 d2)]) (and (= (dict-size m) 3) (= (dict-lookup 'a m) 1) (= (dict-lookup 'b m) 99) (= (dict-lookup 'c m) 3))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-merge"], "split": "train"}
{"id": "dict_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-map-values` in `lattice/data/dict.ss`.\nKnown issue: Function should transform values, not keys.\n\n```scheme\n(define (dict-map-values f dict)\n  (map (lambda (pair) (cons (f (car pair)) (cdr pair))) dict))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-map-values"], "split": "eval"}
{"id": "dict_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-map-values` in `lattice/data/dict.ss`.\nKnown issue: Values must be transformed.\n\n```scheme\n(define (dict-map-values f dict)\n  dict)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Values must be transformed.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-map-values"], "split": "train"}
{"id": "dict_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-filter` in `lattice/data/dict.ss`.\nKnown issue: Entries failing predicate must be removed.\n\n```scheme\n(define (dict-filter pred dict)\n  dict)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Entries failing predicate must be removed.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-filter"], "split": "train"}
{"id": "dict_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-filter` in `lattice/data/dict.ss`.\nKnown issue: Predicate logic is inverted.\n\n```scheme\n(define (dict-filter pred dict)\n  (let loop ([remaining dict] [acc '()])\n    (cond [(null? remaining) (reverse acc)]\n          [(pred (car (car remaining)) (cdr (car remaining))) (loop (cdr remaining) acc)]\n          [else (loop (cdr remaining) (cons (car remaining) acc))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))", "verify_expr": "(let ()\n  (define (dict-filter pred dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(pred (car (car remaining)) (cdr (car remaining)))\n       (loop (cdr remaining) (cons (car remaining) acc))]\n      [else (loop (cdr remaining) acc)])))\n  (equal? (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3))) '((b . 2) (c . 3))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-filter"], "split": "train"}
{"id": "dict_bugfix_023", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-size` in `lattice/data/dict.ss`.\nKnown issue: Size must equal entry count exactly.\n\n```scheme\n(define (dict-size dict)\n  (+ 1 (length dict)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Size must equal entry count exactly.\n\nExpected behavior after patch:\n```scheme\n(let () (= (dict-size '()) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (dict-size '()) 0))\n(let () (= (dict-size '((a . 1) (b . 2))) 2))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (dict-size dict)\n  (length dict))", "verify_expr": "(let ()\n  (define (dict-size dict)\n  (length dict))\n  (and (= (dict-size '()) 0) (= (dict-size '((a . 1) (b . 2))) 2)))", "tags": ["tier0", "data", "dict", "bugfix", "dict-size"], "split": "train"}
{"id": "dict_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-size` in `lattice/data/dict.ss`.\nKnown issue: Non-empty dictionaries must have positive size.\n\n```scheme\n(define (dict-size dict)\n  0)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Non-empty dictionaries must have positive size.\n\nExpected behavior after patch:\n```scheme\n(let () (= (dict-size '()) 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-size dict)\n  (length dict))", "verify_expr": "(let ()\n  (define (dict-size dict)\n  (length dict))\n  (and (= (dict-size '()) 0) (= (dict-size '((a . 1) (b . 2))) 2)))", "tags": ["tier0", "data", "dict", "bugfix", "dict-size"], "split": "train"}
{"id": "dict_bugfix_025", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict->alist` in `lattice/data/dict.ss`.\nKnown issue: Conversion is identity in this representation.\n\n```scheme\n(define (dict->alist dict)\n  (reverse dict))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Conversion is identity in this representation.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict->alist dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict->alist dict)\n  dict)\n  (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "bugfix", "dict->alist"], "split": "train"}
{"id": "dict_bugfix_026", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict->alist` in `lattice/data/dict.ss`.\nKnown issue: Entries should be preserved.\n\n```scheme\n(define (dict->alist dict)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict->alist dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict->alist dict)\n  dict)\n  (equal? (dict->alist '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "bugfix", "dict->alist"], "split": "train"}
{"id": "dict_bugfix_027", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->dict` in `lattice/data/dict.ss`.\nKnown issue: Conversion is identity in this representation.\n\n```scheme\n(define (alist->dict alist)\n  (reverse alist))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Conversion is identity in this representation.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "bugfix", "alist->dict"], "split": "train"}
{"id": "dict_bugfix_028", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->dict` in `lattice/data/dict.ss`.\nKnown issue: Entries should be preserved.\n\n```scheme\n(define (alist->dict alist)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Entries should be preserved.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "bugfix", "alist->dict"], "split": "eval"}
{"id": "dict_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `dict-empty` is empty.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-empty? dict-empty)", "verify_expr": "(equal? (dict-empty? dict-empty) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-empty?", "direct"], "split": "eval"}
{"id": "dict_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether dictionary `'((a . 1))` is empty.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dict-empty? '((a . 1)))", "verify_expr": "(equal? (dict-empty? '((a . 1))) #f)", "tags": ["tier0", "data", "dict", "composition", "dict-empty?", "direct"], "split": "train"}
{"id": "dict_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: small integration task across module primitives.\n\nLookup key `'b` in `'((a . 1) (b . 2) (c . 3))`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-lookup 'b '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(equal? (dict-lookup 'b '((a . 1) (b . 2) (c . 3))) 2)", "tags": ["tier0", "data", "dict", "composition", "dict-lookup", "direct"], "split": "train"}
{"id": "dict_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: compose existing APIs into one expression.\n\nLookup missing key `'z` in `'((a . 1) (b . 2))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-lookup 'z '((a . 1) (b . 2)))", "verify_expr": "(equal? (dict-lookup 'z '((a . 1) (b . 2))) #f)", "tags": ["tier0", "data", "dict", "composition", "dict-lookup", "direct"], "split": "train"}
{"id": "dict_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck whether `'name` exists in `'((name . \"Ada\") (age . 36))`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-has-key? 'name '((name . \"Ada\") (age . 36)))", "verify_expr": "(equal? (dict-has-key? 'name '((name . \"Ada\") (age . 36))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-has-key?", "direct"], "split": "train"}
{"id": "dict_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAssociate `'city` -> \"NYC\" into `'((name . \"Ada\"))`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dict-assoc 'city \"NYC\" '((name . \"Ada\")))", "verify_expr": "(equal? (dict-lookup 'city (dict-assoc 'city \"NYC\" '((name . \"Ada\")))) \"NYC\")", "tags": ["tier0", "data", "dict", "composition", "dict-assoc", "direct"], "split": "eval"}
{"id": "dict_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: compose existing APIs into one expression.\n\nRemove key `'b` from `'((a . 1) (b . 2) (c . 3))`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(equal? (dict-dissoc 'b '((a . 1) (b . 2) (c . 3))) '((a . 1) (c . 3)))", "tags": ["tier0", "data", "dict", "composition", "dict-dissoc", "direct"], "split": "train"}
{"id": "dict_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn keys of `'((x . 24) (y . 25) (z . 26))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-keys '((x . 24) (y . 25) (z . 26)))", "verify_expr": "(equal? (dict-keys '((x . 24) (y . 25) (z . 26))) '(x y z))", "tags": ["tier0", "data", "dict", "composition", "dict-keys", "direct"], "split": "train"}
{"id": "dict_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: small integration task across module primitives.\n\nReturn values of `'((x . 24) (y . 25) (z . 26))`.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dict-values '((x . 24) (y . 25) (z . 26)))", "verify_expr": "(equal? (dict-values '((x . 24) (y . 25) (z . 26))) '(24 25 26))", "tags": ["tier0", "data", "dict", "composition", "dict-values", "direct"], "split": "train"}
{"id": "dict_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn size of `'((a . 1) (b . 2) (c . 3))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-size '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(equal? (dict-size '((a . 1) (b . 2) (c . 3))) 3)", "tags": ["tier0", "data", "dict", "composition", "dict-size", "direct"], "split": "eval"}
{"id": "dict_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: small integration task across module primitives.\n\nReturn entries of `'((id . 7) (ok . #t))`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dict-entries '((id . 7) (ok . #t)))", "verify_expr": "(equal? (dict-entries '((id . 7) (ok . #t))) '((id . 7) (ok . #t)))", "tags": ["tier0", "data", "dict", "composition", "dict-entries", "direct"], "split": "train"}
{"id": "dict_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge `d1='((a . 1) (b . 2))` with `d2='((b . 99) (c . 3))` and return lookup of `'b`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dict-lookup 'b (dict-merge '((a . 1) (b . 2)) '((b . 99) (c . 3))))", "verify_expr": "(equal? (dict-lookup 'b (dict-merge '((a . 1) (b . 2)) '((b . 99) (c . 3)))) 99)", "tags": ["tier0", "data", "dict", "composition", "dict-merge", "direct"], "split": "train"}
{"id": "dict_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff associating an existing key updates value without changing size.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([d (dict-assoc 'b 9 '((a . 1) (b . 2)))]) (and (= (dict-size d) 2) (= (dict-lookup 'b d) 9)))", "verify_expr": "(equal? (let ([d (dict-assoc 'b 9 '((a . 1) (b . 2)))]) (and (= (dict-size d) 2) (= (dict-lookup 'b d) 9))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-assoc", "property"], "split": "train"}
{"id": "dict_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff dissociating a missing key leaves dictionary unchanged.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (dict-dissoc 'z '((a . 1) (b . 2))) '((a . 1) (b . 2)))", "verify_expr": "(equal? (equal? (dict-dissoc 'z '((a . 1) (b . 2))) '((a . 1) (b . 2))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-dissoc", "property"], "split": "train"}
{"id": "dict_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff merge includes keys from both dictionaries.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (dict-merge '((a . 1)) '((b . 2)))]) (and (dict-has-key? 'a m) (dict-has-key? 'b m)))", "verify_expr": "(equal? (let ([m (dict-merge '((a . 1)) '((b . 2)))]) (and (dict-has-key? 'a m) (dict-has-key? 'b m))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-merge", "property"], "split": "eval"}
{"id": "dict_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff dict2 precedence holds for overlapping key `'k`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (dict-lookup 'k (dict-merge '((k . 1)) '((k . 2)))) 2)", "verify_expr": "(equal? (= (dict-lookup 'k (dict-merge '((k . 1)) '((k . 2)))) 2) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-merge", "property"], "split": "train"}
{"id": "dict_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff key/value/entry lengths match dictionary size.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([d '((x . 1) (y . 2) (z . 3))]) (and (= (length (dict-keys d)) (dict-size d)) (= (length (dict-values d)) (dict-size d)) (= (length (dict-entries d)) (dict-size d))))", "verify_expr": "(equal? (let ([d '((x . 1) (y . 2) (z . 3))]) (and (= (length (dict-keys d)) (dict-size d)) (= (length (dict-values d)) (dict-size d)) (= (length (dict-entries d)) (dict-size d)))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-keys", "property"], "split": "train"}
{"id": "dict_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff filtering by `v > 1` removes key `'a` from `'((a . 1) (b . 2) (c . 3))`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([d (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'a d)) (dict-has-key? 'b d) (dict-has-key? 'c d)))", "verify_expr": "(equal? (let ([d (dict-filter (lambda (k v) (> v 1)) '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'a d)) (dict-has-key? 'b d) (dict-has-key? 'c d))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-filter", "property"], "split": "train"}
{"id": "dict_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff dict-map-values preserves keys while changing values.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([d (dict-map-values (lambda (v) (+ v 10)) '((a . 1) (b . 2)))]) (and (dict-has-key? 'a d) (dict-has-key? 'b d) (= (dict-lookup 'a d) 11) (= (dict-lookup 'b d) 12)))", "verify_expr": "(equal? (let ([d (dict-map-values (lambda (v) (+ v 10)) '((a . 1) (b . 2)))]) (and (dict-has-key? 'a d) (dict-has-key? 'b d) (= (dict-lookup 'a d) 11) (= (dict-lookup 'b d) 12))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-map-values", "property"], "split": "train"}
{"id": "dict_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff alist->dict and dict->alist round-trip preserves entries.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (dict->alist (alist->dict '((a . 1) (b . 2)))) '((a . 1) (b . 2)))", "verify_expr": "(equal? (equal? (dict->alist (alist->dict '((a . 1) (b . 2)))) '((a . 1) (b . 2))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict->alist", "property"], "split": "eval"}
{"id": "dict_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff associating then dissociating same key recovers original dict when key absent initially.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (dict-dissoc 'k (dict-assoc 'k 99 '((a . 1) (b . 2)))) '((a . 1) (b . 2)))", "verify_expr": "(equal? (equal? (dict-dissoc 'k (dict-assoc 'k 99 '((a . 1) (b . 2)))) '((a . 1) (b . 2))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-assoc", "property"], "split": "train"}
{"id": "dict_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff dict size after dissoc is one less for existing key.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (dict-size (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))) 2)", "verify_expr": "(equal? (= (dict-size (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))) 2) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-size", "property"], "split": "train"}
{"id": "dict_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild dict from alist `'((a . 1) (b . 2) (c . 3))` using fold-left and dict-assoc.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(fold-left (lambda (d p) (dict-assoc (car p) (cdr p) d)) dict-empty '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(let ([d (fold-left (lambda (d p) (dict-assoc (car p) (cdr p) d)) dict-empty '((a . 1) (b . 2) (c . 3)))]) (and (= (dict-size d) 3) (= (dict-lookup 'a d) 1) (= (dict-lookup 'b d) 2) (= (dict-lookup 'c d) 3)))", "tags": ["tier0", "data", "dict", "composition", "dict-assoc", "fold"], "split": "train"}
{"id": "dict_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: small integration task across module primitives.\n\nDouble values in `'((x . 10) (y . 20))` then return values list.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dict-values (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))))", "verify_expr": "(equal? (dict-values (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20)))) '(20 40))", "tags": ["tier0", "data", "dict", "composition", "dict-map-values", "list"], "split": "train"}
{"id": "dict_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: small integration task across module primitives.\n\nFilter keys with even values from `'((a . 1) (b . 2) (c . 4) (d . 5))`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-filter (lambda (k v) (even? v)) '((a . 1) (b . 2) (c . 4) (d . 5)))", "verify_expr": "(equal? (dict-filter (lambda (k v) (even? v)) '((a . 1) (b . 2) (c . 4) (d . 5))) '((b . 2) (c . 4)))", "tags": ["tier0", "data", "dict", "composition", "dict-filter", "list"], "split": "eval"}
{"id": "dict_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: small integration task across module primitives.\n\nUse a named-let to insert keys `(k1 k2 k3)` with values `(1 2 3)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let loop ([ks '(k1 k2 k3)] [vs '(1 2 3)] [d dict-empty]) (if (null? ks) d (loop (cdr ks) (cdr vs) (dict-assoc (car ks) (car vs) d))))", "verify_expr": "(let ([d (let loop ([ks '(k1 k2 k3)] [vs '(1 2 3)] [d dict-empty]) (if (null? ks) d (loop (cdr ks) (cdr vs) (dict-assoc (car ks) (car vs) d))))]) (and (= (dict-size d) 3) (= (dict-lookup 'k1 d) 1) (= (dict-lookup 'k2 d) 2) (= (dict-lookup 'k3 d) 3)))", "tags": ["tier0", "data", "dict", "composition", "dict-assoc", "loop"], "split": "train"}
{"id": "dict_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCount how many keys in `'(a b c d)` exist in dict `'((a . 1) (c . 3))`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let loop ([ks '(a b c d)] [n 0]) (if (null? ks) n (loop (cdr ks) (if (dict-has-key? (car ks) '((a . 1) (c . 3))) (+ n 1) n))))", "verify_expr": "(equal? (let loop ([ks '(a b c d)] [n 0]) (if (null? ks) n (loop (cdr ks) (if (dict-has-key? (car ks) '((a . 1) (c . 3))) (+ n 1) n)))) 2)", "tags": ["tier0", "data", "dict", "composition", "dict-size", "loop"], "split": "train"}
{"id": "dict_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap `dict-size` over dict list `'(((a . 1)) ((a . 1) (b . 2)) ())`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map dict-size '(((a . 1)) ((a . 1) (b . 2)) ()))", "verify_expr": "(equal? (map dict-size '(((a . 1)) ((a . 1) (b . 2)) ())) '(1 2 0))", "tags": ["tier0", "data", "dict", "composition", "dict-size", "list"], "split": "train"}
{"id": "dict_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge user metadata and score maps, then lookup `'score`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-lookup 'score (dict-merge '((user . \"u1\") (age . 30)) '((score . 88) (age . 31))))", "verify_expr": "(equal? (dict-lookup 'score (dict-merge '((user . \"u1\") (age . 30)) '((score . 88) (age . 31)))) 88)", "tags": ["tier0", "data", "dict", "composition", "dict-merge", "integration"], "split": "eval"}
{"id": "dict_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge overlapping dicts and return `(list age city)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([d (dict-merge '((name . \"Ada\") (age . 36)) '((age . 37) (city . \"London\")))]) (list (dict-lookup 'age d) (dict-lookup 'city d)))", "verify_expr": "(equal? (let ([d (dict-merge '((name . \"Ada\") (age . 36)) '((age . 37) (city . \"London\")))]) (list (dict-lookup 'age d) (dict-lookup 'city d))) '(37 \"London\"))", "tags": ["tier0", "data", "dict", "composition", "dict-merge", "integration"], "split": "train"}
{"id": "dict_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nApply +1 to values, then filter for values >= 3.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-filter (lambda (k v) (>= v 3)) (dict-map-values (lambda (v) (+ v 1)) '((a . 1) (b . 2) (c . 3))))", "verify_expr": "(equal? (dict-filter (lambda (k v) (>= v 3)) (dict-map-values (lambda (v) (+ v 1)) '((a . 1) (b . 2) (c . 3)))) '((b . 3) (c . 4)))", "tags": ["tier0", "data", "dict", "composition", "dict-map-values", "integration"], "split": "train"}
{"id": "dict_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert `'x` into dict then remove it; return resulting size.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-size (dict-dissoc 'x (dict-assoc 'x 5 '((a . 1) (b . 2)))))", "verify_expr": "(equal? (dict-size (dict-dissoc 'x (dict-assoc 'x 5 '((a . 1) (b . 2))))) 2)", "tags": ["tier0", "data", "dict", "composition", "dict-dissoc", "integration"], "split": "train"}
{"id": "dict_composition_033", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFilter entries whose key is in allowed set `'(a c)`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-filter (lambda (k v) (or (equal? k 'a) (equal? k 'c))) '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(equal? (dict-filter (lambda (k v) (or (equal? k 'a) (equal? k 'c))) '((a . 1) (b . 2) (c . 3))) '((a . 1) (c . 3)))", "tags": ["tier0", "data", "dict", "composition", "dict-filter", "integration"], "split": "train"}
{"id": "dict_composition_034", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff every key in `'((a . 1) (b . 2) (c . 3))` is found by dict-lookup.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([d '((a . 1) (b . 2) (c . 3))]) (and (= (dict-lookup 'a d) 1) (= (dict-lookup 'b d) 2) (= (dict-lookup 'c d) 3)))", "verify_expr": "(equal? (let ([d '((a . 1) (b . 2) (c . 3))]) (and (= (dict-lookup 'a d) 1) (= (dict-lookup 'b d) 2) (= (dict-lookup 'c d) 3))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-lookup", "integration"], "split": "eval"}
