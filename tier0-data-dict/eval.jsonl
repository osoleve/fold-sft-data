{"id": "dict_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-has-key?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-has-key?`\nSpec: Return #t iff key exists in dictionary.\n\nWrite exactly one Scheme function definition for `dict-has-key?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (dict-has-key? 'a '((a . 1))))\n(let () (dict-has-key? 'a '((a . #f))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))", "verify_expr": "(let ()\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (and (dict-has-key? 'a '((a . 1))) (dict-has-key? 'a '((a . #f))) (not (dict-has-key? 'b '((a . 1))))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-has-key?"], "split": "eval"}
{"id": "dict_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-keys", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-keys`\nSpec: Return list of dictionary keys.\n\nWrite exactly one Scheme function definition for `dict-keys`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-keys dict)\n  (map car dict))", "verify_expr": "(let ()\n  (define (dict-keys dict)\n  (map car dict))\n  (equal? (dict-keys '((a . 1) (b . 2) (c . 3))) '(a b c)))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-keys"], "split": "eval"}
{"id": "dict_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-values", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-values`\nSpec: Return list of dictionary values.\n\nWrite exactly one Scheme function definition for `dict-values`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (dict-values dict)\n  (map cdr dict))", "verify_expr": "(let ()\n  (define (dict-values dict)\n  (map cdr dict))\n  (equal? (dict-values '((a . 1) (b . 2) (c . 3))) '(1 2 3)))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-values"], "split": "eval"}
{"id": "dict_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-entries", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 dictionary code in Fold-native Scheme.\n\nTarget module: lattice/data/dict.ss\nFunction: `dict-entries`\nSpec: Return list of key-value pairs.\n\nWrite exactly one Scheme function definition for `dict-entries`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (dict-entries dict)\n  dict)", "verify_expr": "(let ()\n  (define (dict-entries dict)\n  dict)\n  (equal? (dict-entries '((x . 7) (y . 8))) '((x . 7) (y . 8))))", "tags": ["tier0", "data", "dict", "spec-to-code", "dict-entries"], "split": "eval"}
{"id": "dict_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef dict_empty(d):\n    return len(d) == 0\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-empty?"], "split": "eval"}
{"id": "dict_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `dict-dissoc`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (drop k d)\n  (filter (lambda (p) (not (equal? k (car p)))) d))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "dict-dissoc"], "split": "eval"}
{"id": "dict_translation_019", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `dict-map-values`.\nReturn only the Scheme definition.\n\n```python\ndef dict_map_values(f, d):\n    return {k: f(v) for k, v in d.items()}\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "python-to-scheme", "dict-map-values"], "split": "eval"}
{"id": "dict_translation_028", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `alist->dict`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (from-alist xs)\n  xs)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "chez-to-fold", "alist->dict"], "split": "eval"}
{"id": "dict_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-empty?` in `lattice/data/dict.ss`.\nKnown issue: A one-entry dictionary should not be empty.\n\n```scheme\n(define (dict-empty? dict)\n  (null? (cdr dict)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (dict-empty? '()))\n(let () (not (dict-empty? '((a . 1)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (dict-empty? dict)\n  (null? dict))", "verify_expr": "(let ()\n  (define (dict-empty? dict)\n  (null? dict))\n  (and (dict-empty? '()) (not (dict-empty? '((a . 1))))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-empty?"], "split": "eval"}
{"id": "dict_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-dissoc", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-dissoc` in `lattice/data/dict.ss`.\nKnown issue: Removing one key must not erase unrelated entries.\n\n```scheme\n(define (dict-dissoc key dict)\n  '())\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))", "verify_expr": "(let ()\n  (define (dict-lookup key dict)\n  (let ([pair (assoc key dict)])\n    (if pair\n        (cdr pair)\n        #f)))\n  (define (dict-has-key? key dict)\n  (if (assoc key dict) #t #f))\n  (define (dict-dissoc key dict)\n  (let loop ([remaining dict]\n             [acc '()])\n    (cond\n      [(null? remaining) (reverse acc)]\n      [(equal? key (car (car remaining)))\n       (append (reverse acc) (cdr remaining))]\n      [else (loop (cdr remaining) (cons (car remaining) acc))])))\n  (let ([d (dict-dissoc 'b '((a . 1) (b . 2) (c . 3)))]) (and (not (dict-has-key? 'b d)) (= (dict-lookup 'a d) 1) (= (dict-lookup 'c d) 3))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-dissoc"], "split": "eval"}
{"id": "dict_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-map-values", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `dict-map-values` in `lattice/data/dict.ss`.\nKnown issue: Function should transform values, not keys.\n\n```scheme\n(define (dict-map-values f dict)\n  (map (lambda (pair) (cons (f (car pair)) (cdr pair))) dict))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))", "verify_expr": "(let ()\n  (define (dict-map-values f dict)\n  (map (lambda (pair)\n         (cons (car pair) (f (cdr pair))))\n       dict))\n  (equal? (dict-map-values (lambda (v) (* 2 v)) '((x . 10) (y . 20))) '((x . 20) (y . 40))))", "tags": ["tier0", "data", "dict", "bugfix", "dict-map-values"], "split": "eval"}
{"id": "dict_bugfix_028", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "alist->dict", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `alist->dict` in `lattice/data/dict.ss`.\nKnown issue: Entries should be preserved.\n\n```scheme\n(define (alist->dict alist)\n  '())\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Entries should be preserved.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (alist->dict alist)\n  alist)", "verify_expr": "(let ()\n  (define (alist->dict alist)\n  alist)\n  (equal? (alist->dict '((a . 1) (b . 2))) '((a . 1) (b . 2))))", "tags": ["tier0", "data", "dict", "bugfix", "alist->dict"], "split": "eval"}
{"id": "dict_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-empty?", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether `dict-empty` is empty.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-empty? dict-empty)", "verify_expr": "(equal? (dict-empty? dict-empty) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-empty?", "direct"], "split": "eval"}
{"id": "dict_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-assoc", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nAssociate `'city` -> \"NYC\" into `'((name . \"Ada\"))`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(dict-assoc 'city \"NYC\" '((name . \"Ada\")))", "verify_expr": "(equal? (dict-lookup 'city (dict-assoc 'city \"NYC\" '((name . \"Ada\")))) \"NYC\")", "tags": ["tier0", "data", "dict", "composition", "dict-assoc", "direct"], "split": "eval"}
{"id": "dict_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn size of `'((a . 1) (b . 2) (c . 3))`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-size '((a . 1) (b . 2) (c . 3)))", "verify_expr": "(equal? (dict-size '((a . 1) (b . 2) (c . 3))) 3)", "tags": ["tier0", "data", "dict", "composition", "dict-size", "direct"], "split": "eval"}
{"id": "dict_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff merge includes keys from both dictionaries.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (dict-merge '((a . 1)) '((b . 2)))]) (and (dict-has-key? 'a m) (dict-has-key? 'b m)))", "verify_expr": "(equal? (let ([m (dict-merge '((a . 1)) '((b . 2)))]) (and (dict-has-key? 'a m) (dict-has-key? 'b m))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-merge", "property"], "split": "eval"}
{"id": "dict_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict->alist", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff alist->dict and dict->alist round-trip preserves entries.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (dict->alist (alist->dict '((a . 1) (b . 2)))) '((a . 1) (b . 2)))", "verify_expr": "(equal? (equal? (dict->alist (alist->dict '((a . 1) (b . 2)))) '((a . 1) (b . 2))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict->alist", "property"], "split": "eval"}
{"id": "dict_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-filter", "prompt": "Task mode: small integration task across module primitives.\n\nFilter keys with even values from `'((a . 1) (b . 2) (c . 4) (d . 5))`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(dict-filter (lambda (k v) (even? v)) '((a . 1) (b . 2) (c . 4) (d . 5)))", "verify_expr": "(equal? (dict-filter (lambda (k v) (even? v)) '((a . 1) (b . 2) (c . 4) (d . 5))) '((b . 2) (c . 4)))", "tags": ["tier0", "data", "dict", "composition", "dict-filter", "list"], "split": "eval"}
{"id": "dict_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge user metadata and score maps, then lookup `'score`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(dict-lookup 'score (dict-merge '((user . \"u1\") (age . 30)) '((score . 88) (age . 31))))", "verify_expr": "(equal? (dict-lookup 'score (dict-merge '((user . \"u1\") (age . 30)) '((score . 88) (age . 31)))) 88)", "tags": ["tier0", "data", "dict", "composition", "dict-merge", "integration"], "split": "eval"}
{"id": "dict_composition_034", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/dict.ss", "source_test": "lattice/data/test-data-structures.ss", "source_function": "dict-lookup", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff every key in `'((a . 1) (b . 2) (c . 3))` is found by dict-lookup.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([d '((a . 1) (b . 2) (c . 3))]) (and (= (dict-lookup 'a d) 1) (= (dict-lookup 'b d) 2) (= (dict-lookup 'c d) 3)))", "verify_expr": "(equal? (let ([d '((a . 1) (b . 2) (c . 3))]) (and (= (dict-lookup 'a d) 1) (= (dict-lookup 'b d) 2) (= (dict-lookup 'c d) 3))) #t)", "tags": ["tier0", "data", "dict", "composition", "dict-lookup", "integration"], "split": "eval"}
