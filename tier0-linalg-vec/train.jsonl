{"id": "vec_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-ref`\nSpec: Return element at index i, or `(error out-of-bounds i len)` when i is invalid.\n\nWrite exactly one Scheme function definition for `vec-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n(let () (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))", "verify_expr": "(let ()\n  (and (= (vec-ref (vector 10 20 30) 1) 20) (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3))))", "tags": ["linalg", "vec", "spec-to-code", "vec-ref"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-ref`\nSpec: Return element at index i, or `(error out-of-bounds i len)` when i is invalid.\n\nWrite exactly one Scheme function definition for `vec-ref`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n(let () (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3)))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-ref`\nBehavior contract: Return element at index i, or `(error out-of-bounds i len)` when i is invalid.\n\n```scheme\n(define (vec-ref v i)\n  ;; TODO: bounds-check and return element or error\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n(let () (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))", "verify_expr": "(let ()\n  (and (= (vec-ref (vector 10 20 30) 1) 20) (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3))))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-ref"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-ref`\nBehavior contract: Return element at index i, or `(error out-of-bounds i len)` when i is invalid.\n\n```scheme\n(define (vec-ref v i)\n  ;; TODO: bounds-check and return element or error\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n(let () (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "vec_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-first`\nBehavior contract: Return first element of vector, or `(error empty-vector)` for empty vectors.\n\n```scheme\n(define (vec-first v)\n  ;; TODO: handle empty vector case\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))", "verify_expr": "(let ()\n  (and (= (vec-first (vector 5 6 7)) 5) (equal? (vec-first (vector)) '(error empty-vector))))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-first"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-first`\nBehavior contract: Return first element of vector, or `(error empty-vector)` for empty vectors.\n\n```scheme\n(define (vec-first v)\n  ;; TODO: handle empty vector case\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-map`\nSpec: Return a new vector by applying function f to each element in v.\n\nWrite exactly one Scheme function definition for `vec-map`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)))\n(let () (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))", "verify_expr": "(let ()\n  (and (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)) (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector))))", "tags": ["linalg", "vec", "spec-to-code", "vec-map"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-map`\nSpec: Return a new vector by applying function f to each element in v.\n\nWrite exactly one Scheme function definition for `vec-map`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)))\n(let () (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector)))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-map`\nBehavior contract: Return a new vector by applying function f to each element in v.\n\n```scheme\n(define (vec-map f v)\n  ;; TODO: map f across all elements\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))", "verify_expr": "(let ()\n  (and (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)) (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector))))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-map"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-map`\nBehavior contract: Return a new vector by applying function f to each element in v.\n\n```scheme\n(define (vec-map f v)\n  ;; TODO: map f across all elements\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-zip-with`\nBehavior contract: Zip two equal-length vectors with f, otherwise return dimension-mismatch error.\n\n```scheme\n(define (vec-zip-with f v1 v2)\n  ;; TODO: enforce equal lengths, then zip with f\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n(let () (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))", "verify_expr": "(let ()\n  (and (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)) (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-zip-with"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-zip-with`\nBehavior contract: Zip two equal-length vectors with f, otherwise return dimension-mismatch error.\n\n```scheme\n(define (vec-zip-with f v1 v2)\n  ;; TODO: enforce equal lengths, then zip with f\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n(let () (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "vec_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-slice`\nSpec: Return subvector from start (inclusive) to end (exclusive) with bounds checks.\n\nWrite exactly one Scheme function definition for `vec-slice`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)))\n(let () (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))", "verify_expr": "(let ()\n  (and (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)) (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)) (equal? (vec-slice (vector 1 2 3) 0 3) (vector 1 2 3))))", "tags": ["linalg", "vec", "spec-to-code", "vec-slice"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-slice`\nSpec: Return subvector from start (inclusive) to end (exclusive) with bounds checks.\n\nWrite exactly one Scheme function definition for `vec-slice`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)))\n(let () (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-slice`\nBehavior contract: Return subvector from start (inclusive) to end (exclusive) with bounds checks.\n\n```scheme\n(define (vec-slice v start end)\n  ;; TODO: validate range and return subvector\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))", "verify_expr": "(let ()\n  (and (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)) (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)) (equal? (vec-slice (vector 1 2 3) 0 3) (vector 1 2 3))))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-slice"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-slice`\nBehavior contract: Return subvector from start (inclusive) to end (exclusive) with bounds checks.\n\n```scheme\n(define (vec-slice v start end)\n  ;; TODO: validate range and return subvector\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "vec_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-dot`\nSpec: Compute dot product for equal-length numeric vectors, else return dimension-mismatch error.\n\nWrite exactly one Scheme function definition for `vec-dot`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))", "verify_expr": "(let ()\n  (and (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32) (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "spec-to-code", "vec-dot"], "split": "train", "prompt_body": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-dot`\nSpec: Compute dot product for equal-length numeric vectors, else return dimension-mismatch error.\n\nWrite exactly one Scheme function definition for `vec-dot`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract."}
{"id": "vec_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-dot`\nBehavior contract: Compute dot product for equal-length numeric vectors, else return dimension-mismatch error.\n\n```scheme\n(define (vec-dot v1 v2)\n  ;; TODO: dimension check and dot-product accumulation\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))", "verify_expr": "(let ()\n  (and (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32) (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-dot"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-dot`\nBehavior contract: Compute dot product for equal-length numeric vectors, else return dimension-mismatch error.\n\n```scheme\n(define (vec-dot v1 v2)\n  ;; TODO: dimension check and dot-product accumulation\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-normalize`\nBehavior contract: Return unit-length vector in same direction, or `(error zero-vector)` if norm is zero.\n\n```scheme\n(define (vec-normalize v)\n  ;; TODO: normalize unless norm is zero\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n       (if (= n 0)\n           '(error zero-vector)\n           (vec-scale (/ 1 n) v))))", "verify_expr": "(let ()\n  (define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n  (define (vec-norm-squared v)\n  (vec-dot v v))\n  (define (vec-norm v)\n  (sqrt (vec-norm-squared v)))\n  (define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n  (define (vec-scale k v)\n  (vec-map (lambda (x) (* k x)) v))\n  (and (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)) (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-normalize"], "split": "train", "prompt_body": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-normalize`\nBehavior contract: Return unit-length vector in same direction, or `(error zero-vector)` if norm is zero.\n\n```scheme\n(define (vec-normalize v)\n  ;; TODO: normalize unless norm is zero\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-approx-equal?`\nSpec: Approximate vector equality with optional epsilon argument (default 1e-10).\n\nWrite exactly one Scheme function definition for `vec-approx-equal?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n(let () (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))", "verify_expr": "(let ()\n  (and (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)) (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))) (vec-approx-equal? (vector 1.0) (vector 1.05) 0.1)))", "tags": ["linalg", "vec", "spec-to-code", "vec-approx-equal?"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-approx-equal?`\nSpec: Approximate vector equality with optional epsilon argument (default 1e-10).\n\nWrite exactly one Scheme function definition for `vec-approx-equal?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n(let () (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))))\n```\n\nKeep the implementation idiomatic and dependency-aware."}
{"id": "vec_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-approx-equal?`\nBehavior contract: Approximate vector equality with optional epsilon argument (default 1e-10).\n\n```scheme\n(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  ;; TODO: optional epsilon + elementwise tolerance check\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n(let () (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))", "verify_expr": "(let ()\n  (and (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)) (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))) (vec-approx-equal? (vector 1.0) (vector 1.05) 0.1)))", "tags": ["linalg", "vec", "spec-to-code", "skeleton", "vec-approx-equal?"], "split": "train", "prompt_body": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/linalg/vec.ss\nFunction target: `vec-approx-equal?`\nBehavior contract: Approximate vector equality with optional epsilon argument (default 1e-10).\n\n```scheme\n(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  ;; TODO: optional epsilon + elementwise tolerance check\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n(let () (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))))\n```\n\nEnsure the definition is production-ready for module integration."}
{"id": "vec_translation_002", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-ref`\n\n```scheme\n(define (vref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))", "verify_expr": "(let ()\n  (and (= (vec-ref (vector 10 20 30) 1) 20) (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3))))", "tags": ["linalg", "vec", "translation", "chez", "vec-ref"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-ref`\n\n```scheme\n(define (vref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "vec_translation_003", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-first`\n\n```python\ndef vec_first(v):\n    if len(v) > 0:\n        return v[0]\n    return ['error', 'empty-vector']\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))", "verify_expr": "(let ()\n  (and (= (vec-first (vector 5 6 7)) 5) (equal? (vec-first (vector)) '(error empty-vector))))", "tags": ["linalg", "vec", "translation", "python", "vec-first"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-first`\n\n```python\ndef vec_first(v):\n    if len(v) > 0:\n        return v[0]\n    return ['error', 'empty-vector']\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "vec_translation_004", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-first`\n\n```scheme\n(define (vfirst v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))", "verify_expr": "(let ()\n  (and (= (vec-first (vector 5 6 7)) 5) (equal? (vec-first (vector)) '(error empty-vector))))", "tags": ["linalg", "vec", "translation", "chez", "vec-first"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-first`\n\n```scheme\n(define (vfirst v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "vec_translation_005", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-map`\n\n```python\ndef vec_map(f, v):\n    out = [0] * len(v)\n    for i in range(len(v)):\n        out[i] = f(v[i])\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)))\n(let () (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))", "verify_expr": "(let ()\n  (and (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)) (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector))))", "tags": ["linalg", "vec", "translation", "python", "vec-map"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-map`\n\n```python\ndef vec_map(f, v):\n    out = [0] * len(v)\n    for i in range(len(v)):\n        out[i] = f(v[i])\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)))\n(let () (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "vec_translation_006", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-map`\n\n```scheme\n(define (vmap f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))", "verify_expr": "(let ()\n  (and (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)) (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector))))", "tags": ["linalg", "vec", "translation", "chez", "vec-map"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-map`\n\n```scheme\n(define (vmap f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "vec_translation_007", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-zip-with`\n\n```python\ndef vec_zip_with(f, v1, v2):\n    if len(v1) != len(v2):\n        return ['error', 'dimension-mismatch', len(v1), len(v2)]\n    out = [0] * len(v1)\n    for i in range(len(v1)):\n        out[i] = f(v1[i], v2[i])\n    return out\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))", "verify_expr": "(let ()\n  (and (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)) (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "translation", "python", "vec-zip-with"], "split": "train", "prompt_body": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-zip-with`\n\n```python\ndef vec_zip_with(f, v1, v2):\n    if len(v1) != len(v2):\n        return ['error', 'dimension-mismatch', len(v1), len(v2)]\n    out = [0] * len(v1)\n    for i in range(len(v1)):\n        out[i] = f(v1[i], v2[i])\n    return out\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "vec_translation_008", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-zip-with`\n\n```scheme\n(define (vzip f a b)\n  (let ((n1 (vector-length a))\n        (n2 (vector-length b)))\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (vec-zip-map-idx i a b (f (vector-ref a i) (vector-ref b i))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n(let () (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))", "verify_expr": "(let ()\n  (and (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)) (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "translation", "chez", "vec-zip-with"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-zip-with`\n\n```scheme\n(define (vzip f a b)\n  (let ((n1 (vector-length a))\n        (n2 (vector-length b)))\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (vec-zip-map-idx i a b (f (vector-ref a i) (vector-ref b i))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n(let () (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "vec_translation_010", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-slice`\n\n```scheme\n(define (vslice v s e)\n  (let ((len (vector-length v)))\n    (cond ((< s 0) `(error out-of-bounds ,s ,len))\n          ((> e len) `(error out-of-bounds ,e ,len))\n          ((> s e) `(error invalid-range ,s ,e))\n          (else\n           (let ((n (- e s))\n                 (src v)\n                 (off s))\n             (vec-tabulate n i (vector-ref src (+ off i))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)))\n(let () (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))", "verify_expr": "(let ()\n  (and (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)) (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)) (equal? (vec-slice (vector 1 2 3) 0 3) (vector 1 2 3))))", "tags": ["linalg", "vec", "translation", "chez", "vec-slice"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-slice`\n\n```scheme\n(define (vslice v s e)\n  (let ((len (vector-length v)))\n    (cond ((< s 0) `(error out-of-bounds ,s ,len))\n          ((> e len) `(error out-of-bounds ,e ,len))\n          ((> s e) `(error invalid-range ,s ,e))\n          (else\n           (let ((n (- e s))\n                 (src v)\n                 (off s))\n             (vec-tabulate n i (vector-ref src (+ off i))))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)))\n(let () (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "vec_translation_011", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-dot`\n\n```python\ndef vec_dot(v1, v2):\n    if len(v1) != len(v2):\n        return ['error', 'dimension-mismatch', len(v1), len(v2)]\n    s = 0\n    for i in range(len(v1)):\n        s += v1[i] * v2[i]\n    return s\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))", "verify_expr": "(let ()\n  (and (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32) (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "translation", "python", "vec-dot"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-dot`\n\n```python\ndef vec_dot(v1, v2):\n    if len(v1) != len(v2):\n        return ['error', 'dimension-mismatch', len(v1), len(v2)]\n    s = 0\n    for i in range(len(v1)):\n        s += v1[i] * v2[i]\n    return s\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "vec_translation_012", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-dot`\n\n```scheme\n(define (vdot a b)\n  (let ((n1 (vector-length a))\n        (n2 (vector-length b)))\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (dot-product-loop i n1 (vector-ref a i) (vector-ref b i)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))", "verify_expr": "(let ()\n  (and (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32) (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "translation", "chez", "vec-dot"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-dot`\n\n```scheme\n(define (vdot a b)\n  (let ((n1 (vector-length a))\n        (n2 (vector-length b)))\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (dot-product-loop i n1 (vector-ref a i) (vector-ref b i)))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nSemantic equivalence is more important than token-level similarity."}
{"id": "vec_translation_013", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-normalize`\n\n```python\ndef vec_normalize(v):\n    n2 = 0\n    for x in v:\n        n2 += x * x\n    n = n2 ** 0.5\n    if n == 0:\n        return ['error', 'zero-vector']\n    return [(1 / n) * x for x in v]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n       (if (= n 0)\n           '(error zero-vector)\n           (vec-scale (/ 1 n) v))))", "verify_expr": "(let ()\n  (define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n  (define (vec-norm-squared v)\n  (vec-dot v v))\n  (define (vec-norm v)\n  (sqrt (vec-norm-squared v)))\n  (define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n  (define (vec-scale k v)\n  (vec-map (lambda (x) (* k x)) v))\n  (and (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)) (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))))", "tags": ["linalg", "vec", "translation", "python", "vec-normalize"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-normalize`\n\n```python\ndef vec_normalize(v):\n    n2 = 0\n    for x in v:\n        n2 += x * x\n    n = n2 ** 0.5\n    if n == 0:\n        return ['error', 'zero-vector']\n    return [(1 / n) * x for x in v]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "vec_translation_014", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-normalize`\n\n```scheme\n(define (vnormalize v)\n  (let ((n (sqrt (vec-dot v v))))\n    (if (= n 0)\n        '(error zero-vector)\n        (vec-map (lambda (x) (* (/ 1 n) x)) v))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n       (if (= n 0)\n           '(error zero-vector)\n           (vec-scale (/ 1 n) v))))", "verify_expr": "(let ()\n  (define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n  (define (vec-norm-squared v)\n  (vec-dot v v))\n  (define (vec-norm v)\n  (sqrt (vec-norm-squared v)))\n  (define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n  (define (vec-scale k v)\n  (vec-map (lambda (x) (* k x)) v))\n  (and (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)) (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))))", "tags": ["linalg", "vec", "translation", "chez", "vec-normalize"], "split": "train", "prompt_body": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-normalize`\n\n```scheme\n(define (vnormalize v)\n  (let ((n (sqrt (vec-dot v v))))\n    (if (= n 0)\n        '(error zero-vector)\n        (vec-map (lambda (x) (* (/ 1 n) x)) v))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior."}
{"id": "vec_translation_015", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-approx-equal?`\n\n```python\ndef vec_approx_equal(v1, v2, epsilon=1e-10):\n    if len(v1) != len(v2):\n        return False\n    for i in range(len(v1)):\n        if abs(v1[i] - v2[i]) >= epsilon:\n            return False\n    return True\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n(let () (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))", "verify_expr": "(let ()\n  (and (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)) (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))) (vec-approx-equal? (vector 1.0) (vector 1.05) 0.1)))", "tags": ["linalg", "vec", "translation", "python", "vec-approx-equal?"], "split": "train", "prompt_body": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-approx-equal?`\n\n```python\ndef vec_approx_equal(v1, v2, epsilon=1e-10):\n    if len(v1) != len(v2):\n        return False\n    for i in range(len(v1)):\n        if abs(v1[i] - v2[i]) >= epsilon:\n            return False\n    return True\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n(let () (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet."}
{"id": "vec_bugfix_002", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-ref` in `lattice/linalg/vec.ss`.\nKnown issue: Error payload order is wrong; keep `(error out-of-bounds i len)`.\n\n```scheme\n(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,(vector-length v) ,i)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Error payload order is wrong; keep `(error out-of-bounds i len)`.\n\nExpected behavior after patch:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n(let () (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))", "verify_expr": "(let ()\n  (and (= (vec-ref (vector 10 20 30) 1) 20) (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3))))", "tags": ["linalg", "vec", "bugfix", "vec-ref"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-ref` in `lattice/linalg/vec.ss`.\nKnown issue: Error payload order is wrong; keep `(error out-of-bounds i len)`.\n\n```scheme\n(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,(vector-length v) ,i)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Error payload order is wrong; keep `(error out-of-bounds i len)`.\n\nExpected behavior after patch:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-ref (vector 10 20 30) 1) 20))\n(let () (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3)))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "vec_bugfix_003", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-first` in `lattice/linalg/vec.ss`.\nKnown issue: Function should return first element, not last.\n\n```scheme\n(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v (- (vector-length v) 1))\n      '(error empty-vector)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))", "verify_expr": "(let ()\n  (and (= (vec-first (vector 5 6 7)) 5) (equal? (vec-first (vector)) '(error empty-vector))))", "tags": ["linalg", "vec", "bugfix", "vec-first"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-first` in `lattice/linalg/vec.ss`.\nKnown issue: Function should return first element, not last.\n\n```scheme\n(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v (- (vector-length v) 1))\n      '(error empty-vector)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "vec_bugfix_004", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-first` in `lattice/linalg/vec.ss`.\nKnown issue: Empty vectors must return `(error empty-vector)`.\n\n```scheme\n(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      0))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Empty vectors must return `(error empty-vector)`.\n\nExpected behavior after patch:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))", "verify_expr": "(let ()\n  (and (= (vec-first (vector 5 6 7)) 5) (equal? (vec-first (vector)) '(error empty-vector))))", "tags": ["linalg", "vec", "bugfix", "vec-first"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-first` in `lattice/linalg/vec.ss`.\nKnown issue: Empty vectors must return `(error empty-vector)`.\n\n```scheme\n(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      0))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Empty vectors must return `(error empty-vector)`.\n\nExpected behavior after patch:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-first (vector 5 6 7)) 5))\n(let () (equal? (vec-first (vector)) '(error empty-vector)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "vec_bugfix_005", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-map` in `lattice/linalg/vec.ss`.\nKnown issue: Mapped function `f` is ignored; each output element must be transformed by `f`.\n\n```scheme\n(define (vec-map f v)\n  (vec-map-idx i v (vector-ref v i)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)))\n(let () (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))", "verify_expr": "(let ()\n  (and (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)) (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector))))", "tags": ["linalg", "vec", "bugfix", "vec-map"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-map` in `lattice/linalg/vec.ss`.\nKnown issue: Mapped function `f` is ignored; each output element must be transformed by `f`.\n\n```scheme\n(define (vec-map f v)\n  (vec-map-idx i v (vector-ref v i)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)))\n(let () (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "vec_bugfix_006", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-map` in `lattice/linalg/vec.ss`.\nKnown issue: Mapping input should be vector values, not indices.\n\n```scheme\n(define (vec-map f v)\n  (vec-map-idx i v (f i)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))", "verify_expr": "(let ()\n  (and (equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6)) (equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector))))", "tags": ["linalg", "vec", "bugfix", "vec-map"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-map` in `lattice/linalg/vec.ss`.\nKnown issue: Mapping input should be vector values, not indices.\n\n```scheme\n(define (vec-map f v)\n  (vec-map-idx i v (f i)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "vec_bugfix_007", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-zip-with` in `lattice/linalg/vec.ss`.\nKnown issue: Dimension check is inverted.\n\n```scheme\n(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (= n1 n2)\n        `(error dimension-mismatch ,n1 ,n2)\n        (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n(let () (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))", "verify_expr": "(let ()\n  (and (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)) (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "bugfix", "vec-zip-with"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-zip-with` in `lattice/linalg/vec.ss`.\nKnown issue: Dimension check is inverted.\n\n```scheme\n(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (= n1 n2)\n        `(error dimension-mismatch ,n1 ,n2)\n        (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n(let () (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness."}
{"id": "vec_bugfix_008", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-zip-with` in `lattice/linalg/vec.ss`.\nKnown issue: Zipping should use one element from each vector.\n\n```scheme\n(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v1 i))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Zipping should use one element from each vector.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))", "verify_expr": "(let ()\n  (and (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)) (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "bugfix", "vec-zip-with"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-zip-with` in `lattice/linalg/vec.ss`.\nKnown issue: Zipping should use one element from each vector.\n\n```scheme\n(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v1 i))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Zipping should use one element from each vector.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "vec_bugfix_010", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-slice` in `lattice/linalg/vec.ss`.\nKnown issue: Invalid-range error payload should preserve `(start end)` order.\n\n```scheme\n(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n    (cond\n      [(< start 0) `(error out-of-bounds ,start ,len)]\n      [(> end len) `(error out-of-bounds ,end ,len)]\n      [(> start end) `(error invalid-range ,end ,start)]\n      [else\n       (let ([new-len (- end start)] [src v] [offset start])\n         (vec-tabulate new-len i (vector-ref src (+ offset i))))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)))\n(let () (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))", "verify_expr": "(let ()\n  (and (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)) (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)) (equal? (vec-slice (vector 1 2 3) 0 3) (vector 1 2 3))))", "tags": ["linalg", "vec", "bugfix", "vec-slice"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-slice` in `lattice/linalg/vec.ss`.\nKnown issue: Invalid-range error payload should preserve `(start end)` order.\n\n```scheme\n(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n    (cond\n      [(< start 0) `(error out-of-bounds ,start ,len)]\n      [(> end len) `(error out-of-bounds ,end ,len)]\n      [(> start end) `(error invalid-range ,end ,start)]\n      [else\n       (let ([new-len (- end start)] [src v] [offset start])\n         (vec-tabulate new-len i (vector-ref src (+ offset i))))])))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)))\n(let () (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "vec_bugfix_011", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-dot` in `lattice/linalg/vec.ss`.\nKnown issue: Dimension mismatch must return an error value, not 0.\n\n```scheme\n(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (not (= n1 n2))\n        0\n        (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Dimension mismatch must return an error value, not 0.\n\nExpected behavior after patch:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))", "verify_expr": "(let ()\n  (and (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32) (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "bugfix", "vec-dot"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-dot` in `lattice/linalg/vec.ss`.\nKnown issue: Dimension mismatch must return an error value, not 0.\n\n```scheme\n(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (not (= n1 n2))\n        0\n        (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Dimension mismatch must return an error value, not 0.\n\nExpected behavior after patch:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "vec_bugfix_012", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-dot` in `lattice/linalg/vec.ss`.\nKnown issue: Dot product must multiply corresponding entries directly.\n\n```scheme\n(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (dot-product-loop i n1 (vector-ref v1 i) (+ (vector-ref v2 i) 1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))", "verify_expr": "(let ()\n  (and (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32) (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "bugfix", "vec-dot"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-dot` in `lattice/linalg/vec.ss`.\nKnown issue: Dot product must multiply corresponding entries directly.\n\n```scheme\n(define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)] [n2 (vector-length v2)])\n    (if (not (= n1 n2))\n        `(error dimension-mismatch ,n1 ,n2)\n        (dot-product-loop i n1 (vector-ref v1 i) (+ (vector-ref v2 i) 1)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (vec-dot (vector 1 2 3) (vector 4 5 6)) 32))\n(let () (equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1)))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "vec_bugfix_013", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-normalize` in `lattice/linalg/vec.ss`.\nKnown issue: Zero-vector guard must check `n = 0`, not `n = 1`.\n\n```scheme\n(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n    (if (= n 1)\n        '(error zero-vector)\n        (vec-scale (/ 1 n) v))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n       (if (= n 0)\n           '(error zero-vector)\n           (vec-scale (/ 1 n) v))))", "verify_expr": "(let ()\n  (define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n  (define (vec-norm-squared v)\n  (vec-dot v v))\n  (define (vec-norm v)\n  (sqrt (vec-norm-squared v)))\n  (define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n  (define (vec-scale k v)\n  (vec-map (lambda (x) (* k x)) v))\n  (and (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)) (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))))", "tags": ["linalg", "vec", "bugfix", "vec-normalize"], "split": "train", "prompt_body": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-normalize` in `lattice/linalg/vec.ss`.\nKnown issue: Zero-vector guard must check `n = 0`, not `n = 1`.\n\n```scheme\n(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n    (if (= n 1)\n        '(error zero-vector)\n        (vec-scale (/ 1 n) v))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nRetain public contract while repairing the implementation fault."}
{"id": "vec_bugfix_014", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-normalize` in `lattice/linalg/vec.ss`.\nKnown issue: Normalization must scale by reciprocal norm.\n\n```scheme\n(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n    (if (= n 0)\n        '(error zero-vector)\n        (vec-scale n v))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Normalization must scale by reciprocal norm.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n       (if (= n 0)\n           '(error zero-vector)\n           (vec-scale (/ 1 n) v))))", "verify_expr": "(let ()\n  (define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n  (define (vec-norm-squared v)\n  (vec-dot v v))\n  (define (vec-norm v)\n  (sqrt (vec-norm-squared v)))\n  (define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n  (define (vec-scale k v)\n  (vec-map (lambda (x) (* k x)) v))\n  (and (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)) (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))))", "tags": ["linalg", "vec", "bugfix", "vec-normalize"], "split": "train", "prompt_body": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-normalize` in `lattice/linalg/vec.ss`.\nKnown issue: Normalization must scale by reciprocal norm.\n\n```scheme\n(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n    (if (= n 0)\n        '(error zero-vector)\n        (vec-scale n v))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Normalization must scale by reciprocal norm.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)))\n(let () (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector)))\n```\n\nFix root-cause behavior rather than masking symptoms."}
{"id": "vec_bugfix_015", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-approx-equal?` in `lattice/linalg/vec.ss`.\nKnown issue: Tolerance comparison direction is inverted.\n\n```scheme\n(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n    (and (= (vector-length v1) (vector-length v2))\n         (let ([n (vector-length v1)])\n           (do ([i 0 (+ i 1)]\n                [eq #t (and eq (> (abs (- (vector-ref v1 i) (vector-ref v2 i))) epsilon))])\n               ((or (= i n) (not eq)) eq))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tolerance comparison direction is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))", "verify_expr": "(let ()\n  (and (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)) (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))) (vec-approx-equal? (vector 1.0) (vector 1.05) 0.1)))", "tags": ["linalg", "vec", "bugfix", "vec-approx-equal?"], "split": "train", "prompt_body": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-approx-equal?` in `lattice/linalg/vec.ss`.\nKnown issue: Tolerance comparison direction is inverted.\n\n```scheme\n(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n    (and (= (vector-length v1) (vector-length v2))\n         (let ([n (vector-length v1)])\n           (do ([i 0 (+ i 1)]\n                [eq #t (and eq (> (abs (- (vector-ref v1 i) (vector-ref v2 i))) epsilon))])\n               ((or (= i n) (not eq)) eq))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Tolerance comparison direction is inverted.\n\nExpected behavior after patch:\n```scheme\n(let () (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault."}
{"id": "vec_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn out-of-bounds error for index 3 on a length-3 vector.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-ref (vector 1 2 3) 3)", "verify_expr": "(equal? (vec-ref (vector 1 2 3) 3) '(error out-of-bounds 3 3))", "tags": ["linalg", "vec", "composition", "vec-ref", "edge-case"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn out-of-bounds error for index 3 on a length-3 vector.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSlice #(9 8 7 6) from 1 to 3 and read index 1 of that slice.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-ref (vec-slice (vector 9 8 7 6) 1 3) 1)", "verify_expr": "(equal? (vec-ref (vec-slice (vector 9 8 7 6) 1 3) 1) 7)", "tags": ["linalg", "vec", "composition", "vec-ref", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nSlice #(9 8 7 6) from 1 to 3 and read index 1 of that slice.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff vec-ref at index 0 equals vec-first on non-empty vector.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (vec-ref (vector 11 12 13) 0) (vec-first (vector 11 12 13)))", "verify_expr": "(equal? (= (vec-ref (vector 11 12 13) 0) (vec-first (vector 11 12 13))) #t)", "tags": ["linalg", "vec", "composition", "vec-ref", "property"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn #t iff vec-ref at index 0 equals vec-first on non-empty vector.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn first element of #(3 4 5).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-first (vector 3 4 5))", "verify_expr": "(equal? (vec-first (vector 3 4 5)) 3)", "tags": ["linalg", "vec", "composition", "vec-first", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nReturn first element of #(3 4 5).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "vec_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: small integration task across module primitives.\n\nReturn empty-vector error for empty input.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-first (vector))", "verify_expr": "(equal? (vec-first (vector)) '(error empty-vector))", "tags": ["linalg", "vec", "composition", "vec-first", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn empty-vector error for empty input.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap (+ x 10) over #(1 2 3), then take vec-first.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-first (vec-map (lambda (x) (+ x 10)) (vector 1 2 3)))", "verify_expr": "(equal? (vec-first (vec-map (lambda (x) (+ x 10)) (vector 1 2 3))) 11)", "tags": ["linalg", "vec", "composition", "vec-first", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nMap (+ x 10) over #(1 2 3), then take vec-first.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nTake slice [2,5) of #(0 1 2 3 4 5) and return vec-first.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-first (vec-slice (vector 0 1 2 3 4 5) 2 5))", "verify_expr": "(equal? (vec-first (vec-slice (vector 0 1 2 3 4 5) 2 5)) 2)", "tags": ["linalg", "vec", "composition", "vec-first", "integration"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nTake slice [2,5) of #(0 1 2 3 4 5) and return vec-first.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap (+ x 1) over empty vector.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-map (lambda (x) (+ x 1)) (vector))", "verify_expr": "(equal? (vec-map (lambda (x) (+ x 1)) (vector)) (vector))", "tags": ["linalg", "vec", "composition", "vec-map", "edge-case"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nMap (+ x 1) over empty vector.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: small integration task across module primitives.\n\nMap square over #(1 2 3), then dot with #(1 1 1).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-dot (vec-map (lambda (x) (* x x)) (vector 1 2 3)) (vector 1 1 1))", "verify_expr": "(equal? (vec-dot (vec-map (lambda (x) (* x x)) (vector 1 2 3)) (vector 1 1 1)) 14)", "tags": ["linalg", "vec", "composition", "vec-map", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nMap square over #(1 2 3), then dot with #(1 1 1).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff vec-map preserves length.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (vector-length (vec-map (lambda (x) (- x 1)) (vector 3 4 5 6))) 4)", "verify_expr": "(equal? (= (vector-length (vec-map (lambda (x) (- x 1)) (vector 3 4 5 6))) 4) #t)", "tags": ["linalg", "vec", "composition", "vec-map", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff vec-map preserves length.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: small integration task across module primitives.\n\nAdd #(1 2 3) and #(4 5 6) with vec-zip-with.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-zip-with + (vector 1 2 3) (vector 4 5 6))", "verify_expr": "(equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9))", "tags": ["linalg", "vec", "composition", "vec-zip-with", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nAdd #(1 2 3) and #(4 5 6) with vec-zip-with.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: small integration task across module primitives.\n\nReturn dimension mismatch error for lengths 2 and 3.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-zip-with + (vector 1 2) (vector 9 8 7))", "verify_expr": "(equal? (vec-zip-with + (vector 1 2) (vector 9 8 7)) '(error dimension-mismatch 2 3))", "tags": ["linalg", "vec", "composition", "vec-zip-with", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn dimension mismatch error for lengths 2 and 3.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "vec_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: small integration task across module primitives.\n\nSubtract #(2 3 4) from #(10 20 30).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-zip-with - (vector 10 20 30) (vector 2 3 4))", "verify_expr": "(equal? (vec-zip-with - (vector 10 20 30) (vector 2 3 4)) (vector 8 17 26))", "tags": ["linalg", "vec", "composition", "vec-zip-with", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nSubtract #(2 3 4) from #(10 20 30).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "vec_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: small integration task across module primitives.\n\nZip-multiply two vectors and sum via vec-dot with ones.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-dot (vec-zip-with * (vector 1 2 3) (vector 4 5 6)) (vector 1 1 1))", "verify_expr": "(equal? (vec-dot (vec-zip-with * (vector 1 2 3) (vector 4 5 6)) (vector 1 1 1)) 32)", "tags": ["linalg", "vec", "composition", "vec-zip-with", "integration"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nZip-multiply two vectors and sum via vec-dot with ones.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: small integration task across module primitives.\n\nReturn invalid-range error for start=3 end=1.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-slice (vector 1 2 3 4) 3 1)", "verify_expr": "(equal? (vec-slice (vector 1 2 3 4) 3 1) '(error invalid-range 3 1))", "tags": ["linalg", "vec", "composition", "vec-slice", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn invalid-range error for start=3 end=1.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "vec_composition_019", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: compose existing APIs into one expression.\n\nTake full slice [0,3) from #(8 9 10).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-slice (vector 8 9 10) 0 3)", "verify_expr": "(equal? (vec-slice (vector 8 9 10) 0 3) (vector 8 9 10))", "tags": ["linalg", "vec", "composition", "vec-slice", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nTake full slice [0,3) from #(8 9 10).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: compose existing APIs into one expression.\n\nSlice [1,3) from #(5 6 7 8), then normalize that result.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-normalize (vec-slice (vector 5 6 7 8) 1 3))", "verify_expr": "(equal? (vec-normalize (vec-slice (vector 5 6 7 8) 1 3)) (vec-normalize (vector 6 7)))", "tags": ["linalg", "vec", "composition", "vec-slice", "integration"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nSlice [1,3) from #(5 6 7 8), then normalize that result.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: small integration task across module primitives.\n\nCompute dot product of #(1 2 3) and #(4 5 6).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-dot (vector 1 2 3) (vector 4 5 6))", "verify_expr": "(equal? (vec-dot (vector 1 2 3) (vector 4 5 6)) 32)", "tags": ["linalg", "vec", "composition", "vec-dot", "direct"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nCompute dot product of #(1 2 3) and #(4 5 6).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: small integration task across module primitives.\n\nReturn dimension mismatch error for dot of length-2 and length-1 vectors.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-dot (vector 1 2) (vector 9))", "verify_expr": "(equal? (vec-dot (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))", "tags": ["linalg", "vec", "composition", "vec-dot", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nReturn dimension mismatch error for dot of length-2 and length-1 vectors.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression."}
{"id": "vec_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute dot of orthogonal vectors #(1 0 0) and #(0 1 0).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-dot (vector 1 0 0) (vector 0 1 0))", "verify_expr": "(equal? (vec-dot (vector 1 0 0) (vector 0 1 0)) 0)", "tags": ["linalg", "vec", "composition", "vec-dot", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCompute dot of orthogonal vectors #(1 0 0) and #(0 1 0).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: compose existing APIs into one expression.\n\nNormalize unit vector #(1 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-normalize (vector 1 0 0))", "verify_expr": "(equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0))", "tags": ["linalg", "vec", "composition", "vec-normalize", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nNormalize unit vector #(1 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: small integration task across module primitives.\n\nNormalize zero vector and return the error.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-normalize (vector 0 0 0))", "verify_expr": "(equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))", "tags": ["linalg", "vec", "composition", "vec-normalize", "edge-case"], "split": "train", "prompt_body": "Task mode: small integration task across module primitives.\n\nNormalize zero vector and return the error.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff normalized #(3 4) is approximately #(0.6 0.8).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-approx-equal? (vec-normalize (vector 3 4)) (vector 0.6 0.8) 1e-12)", "verify_expr": "(equal? (vec-approx-equal? (vec-normalize (vector 3 4)) (vector 0.6 0.8) 1e-12) #t)", "tags": ["linalg", "vec", "composition", "vec-normalize", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff normalized #(3 4) is approximately #(0.6 0.8).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "vec_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff norm of normalized #(3 4) is approximately 1.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(< (abs (- (vec-dot (vec-normalize (vector 3 4)) (vec-normalize (vector 3 4))) 1.0)) 1e-12)", "verify_expr": "(equal? (< (abs (- (vec-dot (vec-normalize (vector 3 4)) (vec-normalize (vector 3 4))) 1.0)) 1e-12) #t)", "tags": ["linalg", "vec", "composition", "vec-normalize", "property"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff norm of normalized #(3 4) is approximately 1.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "vec_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck default-epsilon approximate equality for two close vectors.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0))", "verify_expr": "(equal? (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)) #t)", "tags": ["linalg", "vec", "composition", "vec-approx-equal?", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nCheck default-epsilon approximate equality for two close vectors.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation."}
{"id": "vec_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that visibly different vectors are not approximately equal.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))", "verify_expr": "(equal? (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0)) #f)", "tags": ["linalg", "vec", "composition", "vec-approx-equal?", "direct"], "split": "train", "prompt_body": "Task mode: compose existing APIs into one expression.\n\nCheck that visibly different vectors are not approximately equal.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior."}
{"id": "vec_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse custom epsilon=0.1 to compare #(1.0) and #(1.05).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-approx-equal? (vector 1.0) (vector 1.05) 0.1)", "verify_expr": "(equal? (vec-approx-equal? (vector 1.0) (vector 1.05) 0.1) #t)", "tags": ["linalg", "vec", "composition", "vec-approx-equal?", "direct"], "split": "train", "prompt_body": "Task mode: solve by expression synthesis over available functions.\n\nUse custom epsilon=0.1 to compare #(1.0) and #(1.05).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression."}
