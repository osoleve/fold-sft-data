{"id": "vec_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-first", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-first`\nSpec: Return first element of vector, or `(error empty-vector)` for empty vectors.\n\nWrite exactly one Scheme function definition for `vec-first`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (vec-first (vector 5 6 7)) 5)\n(equal? (vec-first (vector)) '(error empty-vector))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))", "verify_expr": "(let ()\n  (define (vec-first v)\n  (if (> (vector-length v) 0)\n      (vector-ref v 0)\n      '(error empty-vector)))\n  (and (= (vec-first (vector 5 6 7)) 5) (equal? (vec-first (vector)) '(error empty-vector))))", "tags": ["linalg", "vec", "spec-to-code", "vec-first"], "split": "eval"}
{"id": "vec_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-zip-with", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-zip-with`\nSpec: Zip two equal-length vectors with f, otherwise return dimension-mismatch error.\n\nWrite exactly one Scheme function definition for `vec-zip-with`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9))\n(equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))", "verify_expr": "(let ()\n  (define (vec-zip-with f v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (vec-zip-map-idx i v1 v2 (f (vector-ref v1 i) (vector-ref v2 i))))))\n  (and (equal? (vec-zip-with + (vector 1 2 3) (vector 4 5 6)) (vector 5 7 9)) (equal? (vec-zip-with + (vector 1 2) (vector 9)) '(error dimension-mismatch 2 1))))", "tags": ["linalg", "vec", "spec-to-code", "vec-zip-with"], "split": "eval"}
{"id": "vec_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-normalize", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/linalg/vec.ss\nFunction: `vec-normalize`\nSpec: Return unit-length vector in same direction, or `(error zero-vector)` if norm is zero.\n\nWrite exactly one Scheme function definition for `vec-normalize`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0))\n(equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (vec-normalize v)\n  (let ([n (vec-norm v)])\n       (if (= n 0)\n           '(error zero-vector)\n           (vec-scale (/ 1 n) v))))", "verify_expr": "(let ()\n  (define (vec-dot v1 v2)\n  (let ([n1 (vector-length v1)]\n        [n2 (vector-length v2)])\n       (if (not (= n1 n2))\n           `(error dimension-mismatch ,n1 ,n2)\n           (dot-product-loop i n1 (vector-ref v1 i) (vector-ref v2 i)))))\n  (define (vec-norm-squared v)\n  (vec-dot v v))\n  (define (vec-norm v)\n  (sqrt (vec-norm-squared v)))\n  (define (vec-map f v)\n  (vec-map-idx i v (f (vector-ref v i))))\n  (define (vec-scale k v)\n  (vec-map (lambda (x) (* k x)) v))\n  (define (vec-normalize v)\n  (let ([n (vec-norm v)])\n       (if (= n 0)\n           '(error zero-vector)\n           (vec-scale (/ 1 n) v))))\n  (and (equal? (vec-normalize (vector 1 0 0)) (vector 1 0 0)) (equal? (vec-normalize (vector 0 0 0)) '(error zero-vector))))", "tags": ["linalg", "vec", "spec-to-code", "vec-normalize"], "split": "eval"}
{"id": "vec_translation_001", "family": "translation", "category": "transpile", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-ref`\n\n```python\ndef vec_ref(v, i):\n    if 0 <= i < len(v):\n        return v[i]\n    return ['error', 'out-of-bounds', i, len(v)]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (vec-ref (vector 10 20 30) 1) 20)\n(equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))", "verify_expr": "(let ()\n  (define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))\n  (and (= (vec-ref (vector 10 20 30) 1) 20) (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3))))", "tags": ["linalg", "vec", "translation", "python", "vec-ref"], "split": "eval"}
{"id": "vec_translation_009", "family": "translation", "category": "transpile", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly, including error values.\n\nTarget function name: `vec-slice`\n\n```python\ndef vec_slice(v, start, end):\n    n = len(v)\n    if start < 0:\n        return ['error', 'out-of-bounds', start, n]\n    if end > n:\n        return ['error', 'out-of-bounds', end, n]\n    if start > end:\n        return ['error', 'invalid-range', start, end]\n    out = [0] * (end - start)\n    for i in range(end - start):\n        out[i] = v[start + i]\n    return out\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))", "verify_expr": "(let ()\n  (define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))\n  (and (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)) (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)) (equal? (vec-slice (vector 1 2 3) 0 3) (vector 1 2 3))))", "tags": ["linalg", "vec", "translation", "python", "vec-slice"], "split": "eval"}
{"id": "vec_translation_016", "family": "translation", "category": "transpile", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `vec-approx-equal?`\n\n```scheme\n(define (vapprox? a b . eps-arg)\n  (let ((eps (if (null? eps-arg) 1e-10 (car eps-arg))))\n    (and (= (vector-length a) (vector-length b))\n         (let ((n (vector-length a)))\n           (do ((i 0 (+ i 1))\n                (ok #t (and ok (< (abs (- (vector-ref a i) (vector-ref b i))) eps))))\n               ((or (= i n) (not ok)) ok))))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0))\n(not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))", "verify_expr": "(let ()\n  (define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))\n  (and (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)) (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))) (vec-approx-equal? (vector 1.0) (vector 1.05) 0.1)))", "tags": ["linalg", "vec", "translation", "chez", "vec-approx-equal?"], "split": "eval"}
{"id": "vec_bugfix_001", "family": "bugfix", "category": "repair", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-ref` in `lattice/linalg/vec.ss`.\nKnown issue: Upper-bound check is off by one; last valid index should be accepted.\n\n```scheme\n(define (vec-ref v i)\n  (if (and (>= i 0) (< i (- (vector-length v) 1)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))", "verify_expr": "(let ()\n  (define (vec-ref v i)\n  (if (and (>= i 0) (< i (vector-length v)))\n      (vector-ref v i)\n      `(error out-of-bounds ,i ,(vector-length v))))\n  (and (= (vec-ref (vector 10 20 30) 1) 20) (equal? (vec-ref (vector 10 20 30) 3) '(error out-of-bounds 3 3))))", "tags": ["linalg", "vec", "bugfix", "vec-ref"], "split": "eval"}
{"id": "vec_bugfix_009", "family": "bugfix", "category": "repair", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-slice` in `lattice/linalg/vec.ss`.\nKnown issue: Slice length should be `end - start`, not inclusive of end.\n\n```scheme\n(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n    (cond\n      [(< start 0) `(error out-of-bounds ,start ,len)]\n      [(> end len) `(error out-of-bounds ,end ,len)]\n      [else\n       (let ([new-len (+ 1 (- end start))] [src v] [offset start])\n         (vec-tabulate new-len i (vector-ref src (+ offset i))))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))", "verify_expr": "(let ()\n  (define (vec-slice v start end)\n  (let ([len (vector-length v)])\n       (cond\n        [(< start 0) `(error out-of-bounds ,start ,len)]\n        [(> end len) `(error out-of-bounds ,end ,len)]\n        [(> start end) `(error invalid-range ,start ,end)]\n        [else\n         (let ([new-len (- end start)]\n               [src v]\n               [offset start])\n              (vec-tabulate new-len i (vector-ref src (+ offset i))))])))\n  (and (equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4)) (equal? (vec-slice (vector 1 2 3) 2 1) '(error invalid-range 2 1)) (equal? (vec-slice (vector 1 2 3) 0 3) (vector 1 2 3))))", "tags": ["linalg", "vec", "bugfix", "vec-slice"], "split": "eval"}
{"id": "vec_bugfix_016", "family": "bugfix", "category": "repair", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec-approx-equal?` in `lattice/linalg/vec.ss`.\nKnown issue: Default epsilon should remain strict at 1e-10.\n\n```scheme\n(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-2 (car epsilon-arg))])\n    (and (= (vector-length v1) (vector-length v2))\n         (let ([n (vector-length v1)])\n           (do ([i 0 (+ i 1)]\n                [eq #t (and eq (< (abs (- (vector-ref v1 i) (vector-ref v2 i))) epsilon))])\n               ((or (= i n) (not eq)) eq))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0))\n(not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))", "verify_expr": "(let ()\n  (define (vec-approx-equal? v1 v2 . epsilon-arg)\n  (let ([epsilon (if (null? epsilon-arg) 1e-10 (car epsilon-arg))])\n       (and (= (vector-length v1) (vector-length v2))\n            (let ([n (vector-length v1)])\n                 (do ([i 0 (+ i 1)]\n                      [eq #t (and eq (< (abs (- (vector-ref v1 i)\n                                                (vector-ref v2 i)))\n                                        epsilon))])\n                     ((or (= i n) (not eq)) eq))))))\n  (and (vec-approx-equal? (vector 1.0 2.0) (vector 1.00000000001 2.0)) (not (vec-approx-equal? (vector 1.0 2.0) (vector 1.1 2.0))) (vec-approx-equal? (vector 1.0) (vector 1.05) 0.1)))", "tags": ["linalg", "vec", "bugfix", "vec-approx-equal?"], "split": "eval"}
{"id": "vec_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-ref", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRead index 2 from vector #(4 5 6 7).\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vec-ref (vector 4 5 6 7) 2)", "verify_expr": "(equal? (vec-ref (vector 4 5 6 7) 2) 6)", "tags": ["linalg", "vec", "composition", "vec-ref", "direct"], "split": "eval"}
{"id": "vec_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-map", "prompt": "Task mode: small integration task across module primitives.\n\nDouble every element of #(1 2 3).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-map (lambda (x) (* 2 x)) (vector 1 2 3))", "verify_expr": "(equal? (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 2 4 6))", "tags": ["linalg", "vec", "composition", "vec-map", "direct"], "split": "eval"}
{"id": "vec_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-slice", "prompt": "Task mode: compose existing APIs into one expression.\n\nTake slice [1,4) from #(1 2 3 4 5).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-slice (vector 1 2 3 4 5) 1 4)", "verify_expr": "(equal? (vec-slice (vector 1 2 3 4 5) 1 4) (vector 2 3 4))", "tags": ["linalg", "vec", "composition", "vec-slice", "direct"], "split": "eval"}
{"id": "vec_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-dot", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap (* 2 x) over #(1 2 3) and dot with #(1 1 1).\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (vec-dot (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 1 1 1)) 12)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-dot (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 1 1 1))", "verify_expr": "(equal? (vec-dot (vec-map (lambda (x) (* 2 x)) (vector 1 2 3)) (vector 1 1 1)) 12)", "tags": ["linalg", "vec", "composition", "vec-dot", "integration"], "split": "eval"}
{"id": "vec_composition_032", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/linalg/vec.ss", "source_test": "lattice/linalg/test-vec.ss", "source_function": "vec-approx-equal?", "prompt": "Task mode: small integration task across module primitives.\n\nLength mismatch should return #f.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (vec-approx-equal? (vector 1.0 2.0) (vector 1.0)) #f)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vec-approx-equal? (vector 1.0 2.0) (vector 1.0))", "verify_expr": "(equal? (vec-approx-equal? (vector 1.0 2.0) (vector 1.0)) #f)", "tags": ["linalg", "vec", "composition", "vec-approx-equal?", "edge-case"], "split": "eval"}
