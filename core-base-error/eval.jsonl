{"id": "core_error_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error?", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `error?`\nSpec: Return #t iff value is an error list with tag `error` and arity >= 4.\n\nWrite exactly one Scheme function definition for `error?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(error? '(error infer unbound-variable \"ctx\" x))\n(not (error? '(ok 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (and (error? '(error infer unbound-variable \"ctx\" x)) (not (error? '(ok 1))) (not (error? '(error short)))))", "tags": ["core", "base", "error", "spec-to-code", "error?"], "split": "eval"}
{"id": "core_error_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-phase", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `error-phase`\nSpec: Extract phase symbol from error; return #f for non-errors.\n\nWrite exactly one Scheme function definition for `error-phase`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (error-phase err)\n  (and (error? err) (cadr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval))", "tags": ["core", "base", "error", "spec-to-code", "error-phase"], "split": "eval"}
{"id": "core_error_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-code", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `error-code`\nSpec: Extract code symbol from error; return #f for non-errors.\n\nWrite exactly one Scheme function definition for `error-code`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (error-code '(error eval division-by-zero no-span 0)) 'division-by-zero)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (error-code err)\n  (and (error? err) (caddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (equal? (error-code '(error eval division-by-zero no-span 0)) 'division-by-zero))", "tags": ["core", "base", "error", "spec-to-code", "error-code"], "split": "eval"}
{"id": "core_error_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-context", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `error-context`\nSpec: Extract context payload from error; return #f for non-errors.\n\nWrite exactly one Scheme function definition for `error-context`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\")\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (error-context err)\n  (and (error? err) (cadddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\"))", "tags": ["core", "base", "error", "spec-to-code", "error-context"], "split": "eval"}
{"id": "core_error_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-details", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `error-details`\nSpec: Extract details tail from error; return #f for non-errors.\n\nWrite exactly one Scheme function definition for `error-details`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (error-details err)\n  (and (error? err) (cddddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (equal? (error-details '(error infer type-mismatch no-span Int Bool)) '(Int Bool)))", "tags": ["core", "base", "error", "spec-to-code", "error-details"], "split": "eval"}
{"id": "core_error_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-details", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `format-details`\nSpec: Format code-specific detail suffixes for diagnostics.\n\nWrite exactly one Scheme function definition for `format-details`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))", "verify_expr": "(let ()\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (and (equal? (format-details 'unbound-variable '(foo)) \": 'foo'\") (equal? (format-details 'arity-mismatch '(2 3)) \" (expected 2, got 3)\") (equal? (format-details 'type-mismatch '(Int Bool)) \"\\n  expected: Int\\n  actual:   Bool\") (equal? (format-details 'other '()) \"\")))", "tags": ["core", "base", "error", "spec-to-code", "format-details"], "split": "eval"}
{"id": "core_error_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "unbound-error", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unbound-error var span)\n  ;; TODO: construct unbound variable helper error\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unbound-error`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e (unbound-error 'foo no-span)]) (and (equal? (error-phase e) 'infer) (equal? (error-code e) 'unbound-variable) (equal? (error-details e) '(foo))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))\n  (let ([e (unbound-error 'foo no-span)]) (and (equal? (error-phase e) 'infer) (equal? (error-code e) 'unbound-variable) (equal? (error-details e) '(foo)))))", "tags": ["core", "base", "error", "skeleton-completion", "unbound-error"], "split": "eval"}
{"id": "core_error_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-phase", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `format-phase`.\nReturn only the Scheme definition.\n\n```python\ndef format_phase(phase):\n    return f'[{phase}] '\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (format-phase phase)\n  (format \"[~a] \" phase))", "verify_expr": "(let ()\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (equal? (format-phase 'parse) \"[parse] \"))", "tags": ["core", "base", "error", "python-to-scheme", "format-phase"], "split": "eval"}
{"id": "core_error_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-location", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `format-location`.\nReturn only the Scheme definition.\n\n```python\ndef format_location(ctx):\n    if is_span(ctx) and ctx.line > 0 and ctx.col > 0:\n        return f'{ctx.file}:{ctx.line}:{ctx.col}: '\n    if isinstance(ctx, str):\n        return f'{ctx}: '\n    return ''\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([s (make-span \"file.ss\" 3 9 3 12)]) (and (equal? (format-location s) \"file.ss:3:9: \") (equal? (format-location \"repl\") \"repl: \") (equal? (format-location no-span) \"\")))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))", "verify_expr": "(let ()\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (let ([s (make-span \"file.ss\" 3 9 3 12)]) (and (equal? (format-location s) \"file.ss:3:9: \") (equal? (format-location \"repl\") \"repl: \") (equal? (format-location no-span) \"\"))))", "tags": ["core", "base", "error", "python-to-scheme", "format-location"], "split": "eval"}
{"id": "core_error_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "similar-to?", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `similar-to?`.\nReturn only the Scheme definition.\n\n```python\ndef similar_to(a, b):\n    return isinstance(a, str) and isinstance(b, str) and edit_distance(a, b) <= 2\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(similar-to? 'lambda 'lamdba)\n(not (similar-to? 'lambda 'completely-different))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (and (similar-to? 'lambda 'lamdba) (not (similar-to? 'lambda 'completely-different)) (not (similar-to? \"x\" 'x))))", "tags": ["core", "base", "error", "python-to-scheme", "similar-to?"], "split": "eval"}
{"id": "core_error_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-suggestion", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `format-suggestion`.\nReturn only the Scheme definition.\n\n```python\ndef format_suggestion(phase, code, details):\n    s = get_suggestion(phase, code, details)\n    return f'\\n  hint: {s}' if s else ''\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n hint: Ensure the expression returns the expected type\")\n(equal? (format-suggestion 'infer 'unknown-code '()) \"\")\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (and (equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n  hint: Ensure the expression returns the expected type\") (equal? (format-suggestion 'infer 'unknown-code '()) \"\")))", "tags": ["core", "base", "error", "python-to-scheme", "format-suggestion"], "split": "eval"}
{"id": "core_error_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "make-error", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-error` in `core/base/error.ss`.\nKnown issue: Tag must be `error`, not `err`.\n\n```scheme\n(define (make-error phase code context . details)\n  `(err ,phase ,code ,context ,@details))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (make-error 'infer 'unbound-variable \"ctx\" 'x) '(error infer unbound-variable \"ctx\" x))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (equal? (make-error 'infer 'unbound-variable \"ctx\" 'x) '(error infer unbound-variable \"ctx\" x)))", "tags": ["core", "base", "error", "bugfix", "make-error"], "split": "eval"}
{"id": "core_error_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "lookup-error-message", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `lookup-error-message` in `core/base/error.ss`.\nKnown issue: Must select table by phase and fallback to symbol string when missing.\n\n```scheme\n(define (lookup-error-message phase code)\n  (let ([entry (assq code *infer-errors*)])\n    (and entry (cdr entry))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (lookup-error-message 'infer 'unbound-variable) \"Variable is not defined\")\n(equal? (lookup-error-message 'infer 'unknown-code) \"unknown-code\")\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))", "verify_expr": "(let ()\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (and (equal? (lookup-error-message 'infer 'unbound-variable) \"Variable is not defined\") (equal? (lookup-error-message 'infer 'unknown-code) \"unknown-code\")))", "tags": ["core", "base", "error", "bugfix", "lookup-error-message"], "split": "eval"}
{"id": "core_error_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "type-error", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `type-error` in `core/base/error.ss`.\nKnown issue: Code should be `type-mismatch`.\n\n```scheme\n(define (type-error expected actual span)\n  (make-error 'infer 'type-error span expected actual))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))\n  (let ([e (type-error 'Int 'Bool no-span)]) (and (equal? (error-code e) 'type-mismatch) (equal? (error-details e) '(Int Bool)))))", "tags": ["core", "base", "error", "bugfix", "type-error"], "split": "eval"}
{"id": "core_error_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "eval-error", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `eval-error` in `core/base/error.ss`.\nKnown issue: Helper should use eval phase.\n\n```scheme\n(define (eval-error code value span)\n  (make-error 'infer code span value))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([e (eval-error 'division-by-zero 0 no-span)]) (and (equal? (error-phase e) 'eval) (equal? (error-code e) 'division-by-zero) (equal? (error-details e) '(0))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (eval-error code value span)\n  (make-error 'eval code span value))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (eval-error code value span)\n  (make-error 'eval code span value))\n  (let ([e (eval-error 'division-by-zero 0 no-span)]) (and (equal? (error-phase e) 'eval) (equal? (error-code e) 'division-by-zero) (equal? (error-details e) '(0)))))", "tags": ["core", "base", "error", "bugfix", "eval-error"], "split": "eval"}
{"id": "core_error_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "make-error", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct an eval division-by-zero error with value 0.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (car e) 'error)\n(equal? (error-phase e) 'eval)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(make-error 'eval 'division-by-zero no-span 0)", "verify_expr": "(let ([e (make-error 'eval 'division-by-zero no-span 0)]) (and (equal? (car e) 'error) (equal? (error-phase e) 'eval) (equal? (error-code e) 'division-by-zero) (equal? (car (error-details e)) 0)))", "tags": ["core", "base", "error", "composition", "make-error", "direct"], "split": "eval"}
{"id": "core_error_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "lookup-error-message", "prompt": "Task mode: compose existing APIs into one expression.\n\nLookup unknown infer code and return fallback string.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (lookup-error-message 'infer 'not-real) \"not-real\")\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(lookup-error-message 'infer 'not-real)", "verify_expr": "(equal? (lookup-error-message 'infer 'not-real) \"not-real\")", "tags": ["core", "base", "error", "composition", "lookup-error-message", "direct"], "split": "eval"}
{"id": "core_error_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "get-suggestion", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #f for unknown suggestion code.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (get-suggestion 'infer 'no-such-code '()) #f)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(get-suggestion 'infer 'no-such-code '())", "verify_expr": "(equal? (get-suggestion 'infer 'no-such-code '()) #f)", "tags": ["core", "base", "error", "composition", "get-suggestion", "edge-case"], "split": "eval"}
{"id": "core_error_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "parse-error", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild parse error at position 11 and return `(phase code col)`.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([e (parse-error 'unexpected-char \"digit\" 11)]) (list (error-phase e) (error-code e) (span-column (error-context e)))) '(parse unexpected-char 11))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([e (parse-error 'unexpected-char \"digit\" 11)]) (list (error-phase e) (error-code e) (span-column (error-context e))))", "verify_expr": "(equal? (let ([e (parse-error 'unexpected-char \"digit\" 11)]) (list (error-phase e) (error-code e) (span-column (error-context e)))) '(parse unexpected-char 11))", "tags": ["core", "base", "error", "composition", "parse-error", "integration"], "split": "eval"}
{"id": "core_error_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-error", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFormat parse error at position 7 for expected `digit`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(format-error (parse-error 'unexpected-char \"digit\" 7))", "verify_expr": "(equal? (format-error (parse-error 'unexpected-char \"digit\" 7)) \"<input>:1:7: [parse] Unexpected character: digit\")", "tags": ["core", "base", "error", "composition", "format-error", "integration"], "split": "eval"}
