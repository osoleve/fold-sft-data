{"id": "core_error_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "make-error", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `make-error`\nSpec: Build structured error list `(error phase code context details...)`.\n\nWrite exactly one Scheme function definition for `make-error`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (equal? (make-error 'infer 'unbound-variable \"ctx\" 'x) '(error infer unbound-variable \"ctx\" x)))", "tags": ["core", "base", "error", "spec-to-code", "make-error"], "split": "train"}
{"id": "core_error_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "make-error", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-error phase code context . details)\n  ;; TODO: construct canonical error tuple\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-error`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (make-error 'infer 'unbound-variable \"ctx\" 'x) '(error infer unbound-variable \"ctx\" x))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (equal? (make-error 'infer 'unbound-variable \"ctx\" 'x) '(error infer unbound-variable \"ctx\" x)))", "tags": ["core", "base", "error", "skeleton-completion", "make-error"], "split": "train"}
{"id": "core_error_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error?", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (error? x)\n  ;; TODO: detect canonical error representation\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error?`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (and (error? '(error infer unbound-variable \"ctx\" x)) (not (error? '(ok 1))) (not (error? '(error short)))))", "tags": ["core", "base", "error", "skeleton-completion", "error?"], "split": "train"}
{"id": "core_error_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-phase", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (error-phase err)\n  ;; TODO: return phase for valid errors\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error-phase`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (error-phase err)\n  (and (error? err) (cadr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval))", "tags": ["core", "base", "error", "skeleton-completion", "error-phase"], "split": "train"}
{"id": "core_error_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-code", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (error-code err)\n  ;; TODO: return code for valid errors\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error-code`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (error-code '(error eval division-by-zero no-span 0)) 'division-by-zero)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (error-code err)\n  (and (error? err) (caddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (equal? (error-code '(error eval division-by-zero no-span 0)) 'division-by-zero))", "tags": ["core", "base", "error", "skeleton-completion", "error-code"], "split": "train"}
{"id": "core_error_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-context", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (error-context err)\n  ;; TODO: return context for valid errors\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error-context`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\")\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (error-context err)\n  (and (error? err) (cadddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\"))", "tags": ["core", "base", "error", "skeleton-completion", "error-context"], "split": "train"}
{"id": "core_error_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-details", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (error-details err)\n  ;; TODO: return details tail for valid errors\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `error-details`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (error-details '(error infer type-mismatch no-span Int Bool)) '(Int Bool))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (error-details err)\n  (and (error? err) (cddddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (equal? (error-details '(error infer type-mismatch no-span Int Bool)) '(Int Bool)))", "tags": ["core", "base", "error", "skeleton-completion", "error-details"], "split": "train"}
{"id": "core_error_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "lookup-error-message", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `lookup-error-message`\nSpec: Lookup message text by phase+code, else fallback to code symbol string.\n\nWrite exactly one Scheme function definition for `lookup-error-message`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))", "verify_expr": "(let ()\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (and (equal? (lookup-error-message 'infer 'unbound-variable) \"Variable is not defined\") (equal? (lookup-error-message 'infer 'unknown-code) \"unknown-code\")))", "tags": ["core", "base", "error", "spec-to-code", "lookup-error-message"], "split": "train"}
{"id": "core_error_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "lookup-error-message", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (lookup-error-message phase code)\n  ;; TODO: phase/code lookup with symbol->string fallback\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `lookup-error-message`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))", "verify_expr": "(let ()\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (and (equal? (lookup-error-message 'infer 'unbound-variable) \"Variable is not defined\") (equal? (lookup-error-message 'infer 'unknown-code) \"unknown-code\")))", "tags": ["core", "base", "error", "skeleton-completion", "lookup-error-message"], "split": "train"}
{"id": "core_error_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-phase", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `format-phase`\nSpec: Format phase as `[phase] `.\n\nWrite exactly one Scheme function definition for `format-phase`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (format-phase phase)\n  (format \"[~a] \" phase))", "verify_expr": "(let ()\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (equal? (format-phase 'parse) \"[parse] \"))", "tags": ["core", "base", "error", "spec-to-code", "format-phase"], "split": "train"}
{"id": "core_error_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-phase", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (format-phase phase)\n  ;; TODO: produce bracketed phase prefix\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-phase`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (format-phase phase)\n  (format \"[~a] \" phase))", "verify_expr": "(let ()\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (equal? (format-phase 'parse) \"[parse] \"))", "tags": ["core", "base", "error", "skeleton-completion", "format-phase"], "split": "train"}
{"id": "core_error_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-location", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `format-location`\nSpec: Format source context: `file:line:col: ` for spans, `name: ` for strings, else empty string.\n\nWrite exactly one Scheme function definition for `format-location`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))", "verify_expr": "(let ()\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (let ([s (make-span \"file.ss\" 3 9 3 12)]) (and (equal? (format-location s) \"file.ss:3:9: \") (equal? (format-location \"repl\") \"repl: \") (equal? (format-location no-span) \"\"))))", "tags": ["core", "base", "error", "spec-to-code", "format-location"], "split": "train"}
{"id": "core_error_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-location", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (format-location ctx)\n  ;; TODO: format span/string context into location prefix\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-location`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))", "verify_expr": "(let ()\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (let ([s (make-span \"file.ss\" 3 9 3 12)]) (and (equal? (format-location s) \"file.ss:3:9: \") (equal? (format-location \"repl\") \"repl: \") (equal? (format-location no-span) \"\"))))", "tags": ["core", "base", "error", "skeleton-completion", "format-location"], "split": "train"}
{"id": "core_error_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-details", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (format-details code details)\n  ;; TODO: format code-specific detail suffix\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-details`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (format-details 'unbound-variable '(foo)) \": 'foo'\")\n(equal? (format-details 'arity-mismatch '(2 3)) \" (expected 2, got 3)\")\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))", "verify_expr": "(let ()\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (and (equal? (format-details 'unbound-variable '(foo)) \": 'foo'\") (equal? (format-details 'arity-mismatch '(2 3)) \" (expected 2, got 3)\") (equal? (format-details 'type-mismatch '(Int Bool)) \"\\n  expected: Int\\n  actual:   Bool\") (equal? (format-details 'other '()) \"\")))", "tags": ["core", "base", "error", "skeleton-completion", "format-details"], "split": "train"}
{"id": "core_error_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "similar-to?", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `similar-to?`\nSpec: Return #t when two symbols have edit distance <= 2.\n\nWrite exactly one Scheme function definition for `similar-to?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(similar-to? 'lambda 'lamdba)\n(not (similar-to? 'lambda 'completely-different))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (and (similar-to? 'lambda 'lamdba) (not (similar-to? 'lambda 'completely-different)) (not (similar-to? \"x\" 'x))))", "tags": ["core", "base", "error", "spec-to-code", "similar-to?"], "split": "train"}
{"id": "core_error_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "similar-to?", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (similar-to? s1 s2)\n  ;; TODO: symbol typo heuristic using edit distance <= 2\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `similar-to?`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(similar-to? 'lambda 'lamdba)\n(not (similar-to? 'lambda 'completely-different))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (and (similar-to? 'lambda 'lamdba) (not (similar-to? 'lambda 'completely-different)) (not (similar-to? \"x\" 'x))))", "tags": ["core", "base", "error", "skeleton-completion", "similar-to?"], "split": "train"}
{"id": "core_error_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "get-suggestion", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `get-suggestion`\nSpec: Return targeted hint string for known error codes, else #f.\n\nWrite exactly one Scheme function definition for `get-suggestion`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (get-suggestion 'infer 'type-mismatch '()) \"Ensure the expression returns the expected type\")\n(equal? (get-suggestion 'parse 'unclosed-string '()) \"Add a closing \\\" to complete the string\")\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (and (equal? (get-suggestion 'infer 'type-mismatch '()) \"Ensure the expression returns the expected type\") (equal? (get-suggestion 'parse 'unclosed-string '()) \"Add a closing \\\" to complete the string\") (not (get-suggestion 'infer 'unknown-code '()))))", "tags": ["core", "base", "error", "spec-to-code", "get-suggestion"], "split": "train"}
{"id": "core_error_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "get-suggestion", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (get-suggestion phase code details)\n  ;; TODO: return hint string for known cases, else #f\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `get-suggestion`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (get-suggestion 'infer 'type-mismatch '()) \"Ensure the expression returns the expected type\")\n(equal? (get-suggestion 'parse 'unclosed-string '()) \"Add a closing \\\" to complete the string\")\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (and (equal? (get-suggestion 'infer 'type-mismatch '()) \"Ensure the expression returns the expected type\") (equal? (get-suggestion 'parse 'unclosed-string '()) \"Add a closing \\\" to complete the string\") (not (get-suggestion 'infer 'unknown-code '()))))", "tags": ["core", "base", "error", "skeleton-completion", "get-suggestion"], "split": "train"}
{"id": "core_error_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-suggestion", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `format-suggestion`\nSpec: Format suggestion as newline-prefixed hint, else empty string.\n\nWrite exactly one Scheme function definition for `format-suggestion`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n hint: Ensure the expression returns the expected type\")\n(equal? (format-suggestion 'infer 'unknown-code '()) \"\")\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (and (equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n  hint: Ensure the expression returns the expected type\") (equal? (format-suggestion 'infer 'unknown-code '()) \"\")))", "tags": ["core", "base", "error", "spec-to-code", "format-suggestion"], "split": "train"}
{"id": "core_error_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-suggestion", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (format-suggestion phase code details)\n  ;; TODO: prepend hint label when suggestion exists\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-suggestion`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n hint: Ensure the expression returns the expected type\")\n(equal? (format-suggestion 'infer 'unknown-code '()) \"\")\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (and (equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n  hint: Ensure the expression returns the expected type\") (equal? (format-suggestion 'infer 'unknown-code '()) \"\")))", "tags": ["core", "base", "error", "skeleton-completion", "format-suggestion"], "split": "train"}
{"id": "core_error_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-error", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `format-error`\nSpec: Render error object to user-facing string with location, phase, message, details, and hint.\n\nWrite exactly one Scheme function definition for `format-error`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n hint: Check spelling or add a binding with 'let' or 'fix'\")\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))\n  (equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n  hint: Check spelling or add a binding with 'let' or 'fix'\"))", "tags": ["core", "base", "error", "spec-to-code", "format-error"], "split": "train"}
{"id": "core_error_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-error", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (format-error err)\n  ;; TODO: render non-error as ~a; render structured errors with location/phase/message/details/hint\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `format-error`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n hint: Check spelling or add a binding with 'let' or 'fix'\")\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))\n  (equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n  hint: Check spelling or add a binding with 'let' or 'fix'\"))", "tags": ["core", "base", "error", "skeleton-completion", "format-error"], "split": "train"}
{"id": "core_error_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "unbound-error", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `unbound-error`\nSpec: Construct infer/unbound-variable error helper.\n\nWrite exactly one Scheme function definition for `unbound-error`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e (unbound-error 'foo no-span)]) (and (equal? (error-phase e) 'infer) (equal? (error-code e) 'unbound-variable) (equal? (error-details e) '(foo))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))\n  (let ([e (unbound-error 'foo no-span)]) (and (equal? (error-phase e) 'infer) (equal? (error-code e) 'unbound-variable) (equal? (error-details e) '(foo)))))", "tags": ["core", "base", "error", "spec-to-code", "unbound-error"], "split": "train"}
{"id": "core_error_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "type-error", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `type-error`\nSpec: Construct infer/type-mismatch error helper.\n\nWrite exactly one Scheme function definition for `type-error`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e (type-error 'Int 'Bool no-span)]) (and (equal? (error-code e) 'type-mismatch) (equal? (error-details e) '(Int Bool))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))\n  (let ([e (type-error 'Int 'Bool no-span)]) (and (equal? (error-code e) 'type-mismatch) (equal? (error-details e) '(Int Bool)))))", "tags": ["core", "base", "error", "spec-to-code", "type-error"], "split": "train"}
{"id": "core_error_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "type-error", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (type-error expected actual span)\n  ;; TODO: construct type mismatch helper error\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `type-error`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([e (type-error 'Int 'Bool no-span)]) (and (equal? (error-code e) 'type-mismatch) (equal? (error-details e) '(Int Bool))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))\n  (let ([e (type-error 'Int 'Bool no-span)]) (and (equal? (error-code e) 'type-mismatch) (equal? (error-details e) '(Int Bool)))))", "tags": ["core", "base", "error", "skeleton-completion", "type-error"], "split": "train"}
{"id": "core_error_spec_to_code_033", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "parse-error", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `parse-error`\nSpec: Construct parse-phase error with `<input>` span at given position.\n\nWrite exactly one Scheme function definition for `parse-error`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([e (parse-error 'unexpected-char \"digit\" 7)]) (and (equal? (error-phase e) 'parse) (equal? (error-code e) 'unexpected-char) (span? (error-context e)) (= (span-column (error-context e)) 7)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))\n  (let ([e (parse-error 'unexpected-char \"digit\" 7)]) (and (equal? (error-phase e) 'parse) (equal? (error-code e) 'unexpected-char) (span? (error-context e)) (= (span-column (error-context e)) 7))))", "tags": ["core", "base", "error", "spec-to-code", "parse-error"], "split": "train"}
{"id": "core_error_spec_to_code_034", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "parse-error", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (parse-error code expected position)\n  ;; TODO: build parse error with <input> span anchored at position\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `parse-error`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([e (parse-error 'unexpected-char \"digit\" 7)]) (and (equal? (error-phase e) 'parse) (equal? (error-code e) 'unexpected-char) (span? (error-context e)) (= (span-column (error-context e)) 7)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))\n  (let ([e (parse-error 'unexpected-char \"digit\" 7)]) (and (equal? (error-phase e) 'parse) (equal? (error-code e) 'unexpected-char) (span? (error-context e)) (= (span-column (error-context e)) 7))))", "tags": ["core", "base", "error", "skeleton-completion", "parse-error"], "split": "train"}
{"id": "core_error_spec_to_code_035", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "eval-error", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing core runtime utilities in Fold-native Scheme.\n\nTarget module: core/base/error.ss\nFunction: `eval-error`\nSpec: Construct eval-phase error helper.\n\nWrite exactly one Scheme function definition for `eval-error`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([e (eval-error 'division-by-zero 0 no-span)]) (and (equal? (error-phase e) 'eval) (equal? (error-code e) 'division-by-zero) (equal? (error-details e) '(0))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (eval-error code value span)\n  (make-error 'eval code span value))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (eval-error code value span)\n  (make-error 'eval code span value))\n  (let ([e (eval-error 'division-by-zero 0 no-span)]) (and (equal? (error-phase e) 'eval) (equal? (error-code e) 'division-by-zero) (equal? (error-details e) '(0)))))", "tags": ["core", "base", "error", "spec-to-code", "eval-error"], "split": "train"}
{"id": "core_error_spec_to_code_036", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "eval-error", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (eval-error code value span)\n  ;; TODO: construct eval helper error\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `eval-error`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (eval-error code value span)\n  (make-error 'eval code span value))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (eval-error code value span)\n  (make-error 'eval code span value))\n  (let ([e (eval-error 'division-by-zero 0 no-span)]) (and (equal? (error-phase e) 'eval) (equal? (error-code e) 'division-by-zero) (equal? (error-details e) '(0)))))", "tags": ["core", "base", "error", "skeleton-completion", "eval-error"], "split": "train"}
{"id": "core_error_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "make-error", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-error`.\nReturn only the Scheme definition.\n\n```python\ndef make_error(phase, code, context, *details):\n    return ('error', phase, code, context, *details)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (make-error 'infer 'unbound-variable \"ctx\" 'x) '(error infer unbound-variable \"ctx\" x))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (equal? (make-error 'infer 'unbound-variable \"ctx\" 'x) '(error infer unbound-variable \"ctx\" x)))", "tags": ["core", "base", "error", "python-to-scheme", "make-error"], "split": "train"}
{"id": "core_error_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `error?`.\nReturn only the Scheme definition.\n\n```python\ndef is_error(x):\n    return isinstance(x, tuple) and len(x) >= 4 and x[0] == 'error'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (and (error? '(error infer unbound-variable \"ctx\" x)) (not (error? '(ok 1))) (not (error? '(error short)))))", "tags": ["core", "base", "error", "python-to-scheme", "error?"], "split": "train"}
{"id": "core_error_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-phase", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `error-phase`.\nReturn only the Scheme definition.\n\n```python\ndef error_phase(err):\n    return err[1] if is_error(err) else None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (error-phase err)\n  (and (error? err) (cadr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval))", "tags": ["core", "base", "error", "python-to-scheme", "error-phase"], "split": "train"}
{"id": "core_error_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-code", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `error-code`.\nReturn only the Scheme definition.\n\n```python\ndef error_code(err):\n    return err[2] if is_error(err) else None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (error-code err)\n  (and (error? err) (caddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (equal? (error-code '(error eval division-by-zero no-span 0)) 'division-by-zero))", "tags": ["core", "base", "error", "python-to-scheme", "error-code"], "split": "train"}
{"id": "core_error_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-context", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `error-context`.\nReturn only the Scheme definition.\n\n```python\ndef error_context(err):\n    return err[3] if is_error(err) else None\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\")\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (error-context err)\n  (and (error? err) (cadddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\"))", "tags": ["core", "base", "error", "python-to-scheme", "error-context"], "split": "train"}
{"id": "core_error_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-details", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `error-details`.\nReturn only the Scheme definition.\n\n```python\ndef error_details(err):\n    return list(err[4:]) if is_error(err) else None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (error-details '(error infer type-mismatch no-span Int Bool)) '(Int Bool))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (error-details err)\n  (and (error? err) (cddddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (equal? (error-details '(error infer type-mismatch no-span Int Bool)) '(Int Bool)))", "tags": ["core", "base", "error", "python-to-scheme", "error-details"], "split": "train"}
{"id": "core_error_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "lookup-error-message", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `lookup-error-message`.\nReturn only the Scheme definition.\n\n```python\ndef lookup_error_message(phase, code):\n    table = PHASE_TABLES.get(phase, {})\n    return table.get(code, str(code))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (lookup-error-message 'infer 'unbound-variable) \"Variable is not defined\")\n(equal? (lookup-error-message 'infer 'unknown-code) \"unknown-code\")\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))", "verify_expr": "(let ()\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (and (equal? (lookup-error-message 'infer 'unbound-variable) \"Variable is not defined\") (equal? (lookup-error-message 'infer 'unknown-code) \"unknown-code\")))", "tags": ["core", "base", "error", "python-to-scheme", "lookup-error-message"], "split": "train"}
{"id": "core_error_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-details", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `format-details`.\nReturn only the Scheme definition.\n\n```python\ndef format_details(code, details):\n    if not details:\n        return ''\n    if code == 'unbound-variable':\n        return f\": '{details[0]}'\"\n    if code == 'type-mismatch':\n        if len(details) >= 2:\n            return f\"\\n  expected: {details[0]}\\n  actual:   {details[1]}\"\n        return ''\n    if code == 'arity-mismatch':\n        if len(details) >= 2:\n            return f' (expected {details[0]}, got {details[1]})'\n        return ''\n    if code == 'unknown-primitive':\n        return f\": '{details[0]}'\"\n    return f': {details[0]}'\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (format-details 'unbound-variable '(foo)) \": 'foo'\")\n(equal? (format-details 'arity-mismatch '(2 3)) \" (expected 2, got 3)\")\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))", "verify_expr": "(let ()\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (and (equal? (format-details 'unbound-variable '(foo)) \": 'foo'\") (equal? (format-details 'arity-mismatch '(2 3)) \" (expected 2, got 3)\") (equal? (format-details 'type-mismatch '(Int Bool)) \"\\n  expected: Int\\n  actual:   Bool\") (equal? (format-details 'other '()) \"\")))", "tags": ["core", "base", "error", "python-to-scheme", "format-details"], "split": "train"}
{"id": "core_error_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "get-suggestion", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `get-suggestion`.\nReturn only the Scheme definition.\n\n```python\ndef get_suggestion(phase, code, details):\n    if code == 'unbound-variable':\n        if details and similar_to(details[0], 'define'):\n            return \"Did you mean 'fn' for function definition?\"\n        if details and similar_to(details[0], 'lambda'):\n            return \"Use 'fn' instead of 'lambda' in The Fold\"\n        return \"Check spelling or add a binding with 'let' or 'fix'\"\n    if code == 'type-mismatch':\n        return 'Ensure the expression returns the expected type'\n    if code == 'not-a-function':\n        return 'Only closures can be called. Check that the first element is a function.'\n    if code == 'unknown-primitive':\n        if details and details[0] in ['+', '-', '*', '/']:\n            return f\"Use 'add', 'sub', 'mul', 'div' instead of {details[0]}\"\n        return \"See (help 'primitives) for available operations\"\n    if code == 'unclosed-list':\n        return 'Count your parentheses - every ( needs a matching )'\n    if code == 'unclosed-string':\n        return 'Add a closing \" to complete the string'\n    return None\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (and (equal? (get-suggestion 'infer 'type-mismatch '()) \"Ensure the expression returns the expected type\") (equal? (get-suggestion 'parse 'unclosed-string '()) \"Add a closing \\\" to complete the string\") (not (get-suggestion 'infer 'unknown-code '()))))", "tags": ["core", "base", "error", "python-to-scheme", "get-suggestion"], "split": "train"}
{"id": "core_error_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-error", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `format-error`.\nReturn only the Scheme definition.\n\n```python\ndef format_error(err):\n    if not is_error(err):\n        return str(err)\n    phase, code, ctx, *details = err[1:]\n    return format_location(ctx) + format_phase(phase) + lookup_error_message(phase, code) + format_details(code, details) + format_suggestion(phase, code, details)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n hint: Check spelling or add a binding with 'let' or 'fix'\")\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))\n  (equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n  hint: Check spelling or add a binding with 'let' or 'fix'\"))", "tags": ["core", "base", "error", "python-to-scheme", "format-error"], "split": "train"}
{"id": "core_error_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "unbound-error", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `unbound-error`.\nReturn only the Scheme definition.\n\n```python\ndef unbound_error(var, span):\n    return make_error('infer', 'unbound-variable', span, var)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([e (unbound-error 'foo no-span)]) (and (equal? (error-phase e) 'infer) (equal? (error-code e) 'unbound-variable) (equal? (error-details e) '(foo))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))\n  (let ([e (unbound-error 'foo no-span)]) (and (equal? (error-phase e) 'infer) (equal? (error-code e) 'unbound-variable) (equal? (error-details e) '(foo)))))", "tags": ["core", "base", "error", "python-to-scheme", "unbound-error"], "split": "train"}
{"id": "core_error_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "type-error", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `type-error`.\nReturn only the Scheme definition.\n\n```python\ndef type_error(expected, actual, span):\n    return make_error('infer', 'type-mismatch', span, expected, actual)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([e (type-error 'Int 'Bool no-span)]) (and (equal? (error-code e) 'type-mismatch) (equal? (error-details e) '(Int Bool))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (type-error expected actual span)\n  (make-error 'infer 'type-mismatch span expected actual))\n  (let ([e (type-error 'Int 'Bool no-span)]) (and (equal? (error-code e) 'type-mismatch) (equal? (error-details e) '(Int Bool)))))", "tags": ["core", "base", "error", "python-to-scheme", "type-error"], "split": "train"}
{"id": "core_error_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "parse-error", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `parse-error`.\nReturn only the Scheme definition.\n\n```python\ndef parse_error(code, expected, position):\n    return make_error('parse', code, make_span('<input>', 1, position, 1, position), expected)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))\n  (let ([e (parse-error 'unexpected-char \"digit\" 7)]) (and (equal? (error-phase e) 'parse) (equal? (error-code e) 'unexpected-char) (span? (error-context e)) (= (span-column (error-context e)) 7))))", "tags": ["core", "base", "error", "python-to-scheme", "parse-error"], "split": "train"}
{"id": "core_error_translation_018", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "eval-error", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `eval-error`.\nReturn only the Scheme definition.\n\n```python\ndef eval_error(code, value, span):\n    return make_error('eval', code, span, value)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (eval-error code value span)\n  (make-error 'eval code span value))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (eval-error code value span)\n  (make-error 'eval code span value))\n  (let ([e (eval-error 'division-by-zero 0 no-span)]) (and (equal? (error-phase e) 'eval) (equal? (error-code e) 'division-by-zero) (equal? (error-details e) '(0)))))", "tags": ["core", "base", "error", "python-to-scheme", "eval-error"], "split": "train"}
{"id": "core_error_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error?` in `core/base/error.ss`.\nKnown issue: Valid errors have length >= 4, not strictly greater than 4.\n\n```scheme\n(define (error? x)\n  (and (pair? x) (eq? (car x) 'error) (> (length x) 4)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (and (error? '(error infer unbound-variable \"ctx\" x)) (not (error? '(ok 1))) (not (error? '(error short)))))", "tags": ["core", "base", "error", "bugfix", "error?"], "split": "train"}
{"id": "core_error_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-phase", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error-phase` in `core/base/error.ss`.\nKnown issue: Phase is the second field, not the tag.\n\n```scheme\n(define (error-phase err)\n  (and (error? err) (car err)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (error-phase err)\n  (and (error? err) (cadr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (equal? (error-phase '(error eval division-by-zero no-span 0)) 'eval))", "tags": ["core", "base", "error", "bugfix", "error-phase"], "split": "train"}
{"id": "core_error_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-code", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error-code` in `core/base/error.ss`.\nKnown issue: Code is the third field.\n\n```scheme\n(define (error-code err)\n  (and (error? err) (cadddr err)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (error-code '(error eval division-by-zero no-span 0)) 'division-by-zero)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (error-code err)\n  (and (error? err) (caddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (equal? (error-code '(error eval division-by-zero no-span 0)) 'division-by-zero))", "tags": ["core", "base", "error", "bugfix", "error-code"], "split": "train"}
{"id": "core_error_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-context", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error-context` in `core/base/error.ss`.\nKnown issue: Context is the fourth field.\n\n```scheme\n(define (error-context err)\n  (and (error? err) (caddr err)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\")\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (error-context err)\n  (and (error? err) (cadddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (equal? (error-context '(error infer type-mismatch \"ctx\" Int Bool)) \"ctx\"))", "tags": ["core", "base", "error", "bugfix", "error-context"], "split": "train"}
{"id": "core_error_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-details", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `error-details` in `core/base/error.ss`.\nKnown issue: Details should drop the first four fields, not three.\n\n```scheme\n(define (error-details err)\n  (and (error? err) (cdddr err)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (error-details '(error infer type-mismatch no-span Int Bool)) '(Int Bool))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (error-details err)\n  (and (error? err) (cddddr err)))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (equal? (error-details '(error infer type-mismatch no-span Int Bool)) '(Int Bool)))", "tags": ["core", "base", "error", "bugfix", "error-details"], "split": "train"}
{"id": "core_error_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-phase", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-phase` in `core/base/error.ss`.\nKnown issue: Formatted phase must include square brackets.\n\n```scheme\n(define (format-phase phase)\n  (format \"~a \" phase))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (format-phase 'parse) \"[parse] \")\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (format-phase phase)\n  (format \"[~a] \" phase))", "verify_expr": "(let ()\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (equal? (format-phase 'parse) \"[parse] \"))", "tags": ["core", "base", "error", "bugfix", "format-phase"], "split": "train"}
{"id": "core_error_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-location", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-location` in `core/base/error.ss`.\nKnown issue: String locations need trailing `: `; spans must format file/line/col.\n\n```scheme\n(define (format-location ctx)\n  (if (string? ctx) ctx \"\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))", "verify_expr": "(let ()\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (let ([s (make-span \"file.ss\" 3 9 3 12)]) (and (equal? (format-location s) \"file.ss:3:9: \") (equal? (format-location \"repl\") \"repl: \") (equal? (format-location no-span) \"\"))))", "tags": ["core", "base", "error", "bugfix", "format-location"], "split": "train"}
{"id": "core_error_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-details", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-details` in `core/base/error.ss`.\nKnown issue: Details should format code-specific content, not print raw list object.\n\n```scheme\n(define (format-details code details)\n  (if (null? details) \"\" (format \": ~a\" details)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (format-details 'unbound-variable '(foo)) \": 'foo'\")\n(equal? (format-details 'arity-mismatch '(2 3)) \" (expected 2, got 3)\")\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))", "verify_expr": "(let ()\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (and (equal? (format-details 'unbound-variable '(foo)) \": 'foo'\") (equal? (format-details 'arity-mismatch '(2 3)) \" (expected 2, got 3)\") (equal? (format-details 'type-mismatch '(Int Bool)) \"\\n  expected: Int\\n  actual:   Bool\") (equal? (format-details 'other '()) \"\")))", "tags": ["core", "base", "error", "bugfix", "format-details"], "split": "train"}
{"id": "core_error_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "similar-to?", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `similar-to?` in `core/base/error.ss`.\nKnown issue: Threshold should be <= 2 edits.\n\n```scheme\n(define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2) (<= (edit-distance (symbol->string s1) (symbol->string s2)) 1)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (and (similar-to? 'lambda 'lamdba) (not (similar-to? 'lambda 'completely-different)) (not (similar-to? \"x\" 'x))))", "tags": ["core", "base", "error", "bugfix", "similar-to?"], "split": "train"}
{"id": "core_error_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "get-suggestion", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `get-suggestion` in `core/base/error.ss`.\nKnown issue: Known codes should return useful suggestions.\n\n```scheme\n(define (get-suggestion phase code details)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (get-suggestion 'infer 'type-mismatch '()) \"Ensure the expression returns the expected type\")\n(equal? (get-suggestion 'parse 'unclosed-string '()) \"Add a closing \\\" to complete the string\")\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (and (equal? (get-suggestion 'infer 'type-mismatch '()) \"Ensure the expression returns the expected type\") (equal? (get-suggestion 'parse 'unclosed-string '()) \"Add a closing \\\" to complete the string\") (not (get-suggestion 'infer 'unknown-code '()))))", "tags": ["core", "base", "error", "bugfix", "get-suggestion"], "split": "train"}
{"id": "core_error_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-suggestion", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-suggestion` in `core/base/error.ss`.\nKnown issue: When suggestion is missing, this must return empty string.\n\n```scheme\n(define (format-suggestion phase code details)\n  (format \"hint: ~a\" (get-suggestion phase code details)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n hint: Ensure the expression returns the expected type\")\n(equal? (format-suggestion 'infer 'unknown-code '()) \"\")\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))", "verify_expr": "(let ()\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (and (equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n  hint: Ensure the expression returns the expected type\") (equal? (format-suggestion 'infer 'unknown-code '()) \"\")))", "tags": ["core", "base", "error", "bugfix", "format-suggestion"], "split": "train"}
{"id": "core_error_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-error", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `format-error` in `core/base/error.ss`.\nKnown issue: Non-errors should print as `~a`, and full formatted output must include location/phase/details/suggestions.\n\n```scheme\n(define (format-error err)\n  (if (not (error? err))\n      \"error\"\n      (lookup-error-message (error-phase err) (error-code err))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))", "verify_expr": "(let ()\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define *parse-errors*\n  '((unexpected-eof    . \"Unexpected end of input\")\n    (unexpected-char   . \"Unexpected character\")\n    (unclosed-string   . \"Unclosed string literal\")\n    (unclosed-list     . \"Unclosed list - missing )\")\n    (invalid-number    . \"Invalid number format\")\n    (invalid-escape    . \"Invalid escape sequence\")))\n  (define *infer-errors*\n  '((unbound-variable  . \"Variable is not defined\")\n    (type-mismatch     . \"Types do not match\")\n    (arity-mismatch    . \"Wrong number of arguments\")\n    (not-a-function    . \"Attempting to call a non-function\")\n    (occurs-check      . \"Infinite type detected\")\n    (unknown-primitive . \"Unknown primitive operation\")\n    (if-test-not-bool  . \"If condition must be boolean\")))\n  (define *eval-errors*\n  '((unbound-variable   . \"Variable is not defined\")\n    (invalid-expression . \"Cannot evaluate this expression\")\n    (not-a-closure      . \"Attempting to call a non-function\")\n    (invalid-arguments  . \"Invalid arguments to function\")\n    (division-by-zero   . \"Division by zero\")\n    (out-of-bounds      . \"Index out of bounds\")\n    (type-error         . \"Runtime type error\")))\n  (define *block-errors*\n  '((invalid-tag       . \"Invalid block tag\")\n    (invalid-payload   . \"Invalid block payload\")\n    (invalid-refs      . \"Invalid block references\")\n    (hash-mismatch     . \"Content hash does not match\")\n    (not-found         . \"Block not found in store\")))\n  (define (lookup-error-message phase code)\n  (let* ([table (case phase\n                  [(parse) *parse-errors*]\n                  [(infer) *infer-errors*]\n                  [(eval) *eval-errors*]\n                  [(block cas) *block-errors*]\n                  [else '()])]\n         [entry (assq code table)])\n    (if entry\n        (cdr entry)\n        (symbol->string code))))\n  (define (format-location ctx)\n  (cond\n    [(span? ctx)\n     (let ([file (span-file ctx)]\n           [line (span-line ctx)]\n           [col (span-column ctx)])\n       (if (and (> line 0) (> col 0))\n           (format \"~a:~a:~a: \" file line col)\n           \"\"))]\n    [(string? ctx) (format \"~a: \" ctx)]\n    [else \"\"]))\n  (define (format-phase phase)\n  (format \"[~a] \" phase))\n  (define (format-details code details)\n  (if (null? details)\n      \"\"\n      (case code\n        [(unbound-variable)\n         (format \": '~a'\" (car details))]\n        [(type-mismatch)\n         (if (>= (length details) 2)\n             (format \"\n  expected: ~a\n  actual:   ~a\"\n                     (car details) (cadr details))\n             \"\")]\n        [(arity-mismatch)\n         (if (>= (length details) 2)\n             (format \" (expected ~a, got ~a)\"\n                     (car details) (cadr details))\n             \"\")]\n        [(unknown-primitive)\n         (format \": '~a'\" (car details))]\n        [else\n         (if (pair? details)\n             (format \": ~a\" (car details))\n             \"\")])))\n  (define (similar-to? s1 s2)\n  (and (symbol? s1) (symbol? s2)\n       (let ([str1 (symbol->string s1)]\n             [str2 (symbol->string s2)])\n         (<= (edit-distance str1 str2) 2))))\n  (define (get-suggestion phase code details)\n  (case code\n    [(unbound-variable)\n     (cond\n       [(and (pair? details) (similar-to? (car details) 'define))\n        \"Did you mean 'fn' for function definition?\"]\n       [(and (pair? details) (similar-to? (car details) 'lambda))\n        \"Use 'fn' instead of 'lambda' in The Fold\"]\n       [else\n        \"Check spelling or add a binding with 'let' or 'fix'\"])]\n    [(type-mismatch)\n     \"Ensure the expression returns the expected type\"]\n    [(not-a-function)\n     \"Only closures can be called. Check that the first element is a function.\"]\n    [(unknown-primitive)\n     (if (and (pair? details)\n              (memq (car details) '(+ - * /)))\n         (format \"Use 'add', 'sub', 'mul', 'div' instead of ~a\" (car details))\n         \"See (help 'primitives) for available operations\")]\n    [(unclosed-list)\n     \"Count your parentheses - every ( needs a matching )\"]\n    [(unclosed-string)\n     \"Add a closing \\\" to complete the string\"]\n    [else #f]))\n  (define (format-suggestion phase code details)\n  (let ([suggestion (get-suggestion phase code details)])\n    (if suggestion\n        (format \"\n  hint: ~a\" suggestion)\n        \"\")))\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (format-error err)\n  (if (not (error? err))\n      (format \"~a\" err)\n      (let* ([phase (error-phase err)]\n             [code (error-code err)]\n             [ctx (error-context err)]\n             [details (error-details err)]\n             [message (lookup-error-message phase code)]\n             [location (format-location ctx)])\n        (string-append\n          location\n          (format-phase phase)\n          message\n          (format-details code details)\n          (format-suggestion phase code details)))))\n  (equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n  hint: Check spelling or add a binding with 'let' or 'fix'\"))", "tags": ["core", "base", "error", "bugfix", "format-error"], "split": "train"}
{"id": "core_error_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "unbound-error", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unbound-error` in `core/base/error.ss`.\nKnown issue: Helper should use infer phase.\n\n```scheme\n(define (unbound-error var span)\n  (make-error 'parse 'unbound-variable span var))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-details err)\n  (and (error? err) (cddddr err)))\n  (define (unbound-error var span)\n  (make-error 'infer 'unbound-variable span var))\n  (let ([e (unbound-error 'foo no-span)]) (and (equal? (error-phase e) 'infer) (equal? (error-code e) 'unbound-variable) (equal? (error-details e) '(foo)))))", "tags": ["core", "base", "error", "bugfix", "unbound-error"], "split": "train"}
{"id": "core_error_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "parse-error", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `parse-error` in `core/base/error.ss`.\nKnown issue: Parse error should include `<input>` span at the given position.\n\n```scheme\n(define (parse-error code expected position)\n  (make-error 'parse code no-span expected))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([e (parse-error 'unexpected-char \"digit\" 7)]) (and (equal? (error-phase e) 'parse) (equal? (error-code e) 'unexpected-char) (span? (error-context e)) (= (span-column (error-context e)) 7)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))", "verify_expr": "(let ()\n  (define (make-error phase code context . details)\n  `(error ,phase ,code ,context ,@details))\n  (define (error? x)\n  (and (pair? x)\n       (eq? (car x) 'error)\n       (>= (length x) 4)))\n  (define (error-phase err)\n  (and (error? err) (cadr err)))\n  (define (error-code err)\n  (and (error? err) (caddr err)))\n  (define (error-context err)\n  (and (error? err) (cadddr err)))\n  (define (parse-error code expected position)\n  (make-error 'parse code (make-span \"<input>\" 1 position 1 position) expected))\n  (let ([e (parse-error 'unexpected-char \"digit\" 7)]) (and (equal? (error-phase e) 'parse) (equal? (error-code e) 'unexpected-char) (span? (error-context e)) (= (span-column (error-context e)) 7))))", "tags": ["core", "base", "error", "bugfix", "parse-error"], "split": "train"}
{"id": "core_error_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error?", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether `(make-error 'infer 'unbound-variable no-span 'x)` is an error.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (error? (make-error 'infer 'unbound-variable no-span 'x)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(error? (make-error 'infer 'unbound-variable no-span 'x))", "verify_expr": "(equal? (error? (make-error 'infer 'unbound-variable no-span 'x)) #t)", "tags": ["core", "base", "error", "composition", "error?", "direct"], "split": "train"}
{"id": "core_error_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-phase", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract phase from `(make-error 'parse 'unexpected-eof no-span)`.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(error-phase (make-error 'parse 'unexpected-eof no-span))", "verify_expr": "(equal? (error-phase (make-error 'parse 'unexpected-eof no-span)) 'parse)", "tags": ["core", "base", "error", "composition", "error-phase", "direct"], "split": "train"}
{"id": "core_error_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-code", "prompt": "Task mode: small integration task across module primitives.\n\nExtract code from `(make-error 'eval 'division-by-zero no-span 0)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(error-code (make-error 'eval 'division-by-zero no-span 0))", "verify_expr": "(equal? (error-code (make-error 'eval 'division-by-zero no-span 0)) 'division-by-zero)", "tags": ["core", "base", "error", "composition", "error-code", "direct"], "split": "train"}
{"id": "core_error_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-context", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract context from `(make-error 'infer 'type-mismatch \"ctx\" 'Int 'Bool)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (error-context (make-error 'infer 'type-mismatch \"ctx\" 'Int 'Bool)) \"ctx\")\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(error-context (make-error 'infer 'type-mismatch \"ctx\" 'Int 'Bool))", "verify_expr": "(equal? (error-context (make-error 'infer 'type-mismatch \"ctx\" 'Int 'Bool)) \"ctx\")", "tags": ["core", "base", "error", "composition", "error-context", "direct"], "split": "train"}
{"id": "core_error_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-details", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract details from `(make-error 'infer 'type-mismatch no-span 'Int 'Bool)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (error-details (make-error 'infer 'type-mismatch no-span 'Int 'Bool)) '(Int Bool))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(error-details (make-error 'infer 'type-mismatch no-span 'Int 'Bool))", "verify_expr": "(equal? (error-details (make-error 'infer 'type-mismatch no-span 'Int 'Bool)) '(Int Bool))", "tags": ["core", "base", "error", "composition", "error-details", "direct"], "split": "train"}
{"id": "core_error_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "lookup-error-message", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nLookup infer message for `unbound-variable`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(lookup-error-message 'infer 'unbound-variable)", "verify_expr": "(equal? (lookup-error-message 'infer 'unbound-variable) \"Variable is not defined\")", "tags": ["core", "base", "error", "composition", "lookup-error-message", "direct"], "split": "train"}
{"id": "core_error_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-phase", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFormat phase symbol `infer`.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (format-phase 'infer) \"[infer] \")\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(format-phase 'infer)", "verify_expr": "(equal? (format-phase 'infer) \"[infer] \")", "tags": ["core", "base", "error", "composition", "format-phase", "direct"], "split": "train"}
{"id": "core_error_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-location", "prompt": "Task mode: small integration task across module primitives.\n\nFormat span location for `core.ss:2:7`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(format-location (make-span \"core.ss\" 2 7 2 9))", "verify_expr": "(equal? (format-location (make-span \"core.ss\" 2 7 2 9)) \"core.ss:2:7: \")", "tags": ["core", "base", "error", "composition", "format-location", "direct"], "split": "train"}
{"id": "core_error_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-details", "prompt": "Task mode: small integration task across module primitives.\n\nFormat details for `unbound-variable` with symbol `foo`.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (format-details 'unbound-variable '(foo)) \": 'foo'\")\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(format-details 'unbound-variable '(foo))", "verify_expr": "(equal? (format-details 'unbound-variable '(foo)) \": 'foo'\")", "tags": ["core", "base", "error", "composition", "format-details", "direct"], "split": "train"}
{"id": "core_error_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-details", "prompt": "Task mode: compose existing APIs into one expression.\n\nFormat arity mismatch details `(2 5)`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (format-details 'arity-mismatch '(2 5)) \" (expected 2, got 5)\")\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(format-details 'arity-mismatch '(2 5))", "verify_expr": "(equal? (format-details 'arity-mismatch '(2 5)) \" (expected 2, got 5)\")", "tags": ["core", "base", "error", "composition", "format-details", "direct"], "split": "train"}
{"id": "core_error_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "similar-to?", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck if `lambda` and `lamdba` are considered similar.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (similar-to? 'lambda 'lamdba) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(similar-to? 'lambda 'lamdba)", "verify_expr": "(equal? (similar-to? 'lambda 'lamdba) #t)", "tags": ["core", "base", "error", "composition", "similar-to?", "property"], "split": "train"}
{"id": "core_error_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "get-suggestion", "prompt": "Task mode: compose existing APIs into one expression.\n\nGet suggestion for unknown primitive `+`.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(get-suggestion 'infer 'unknown-primitive '(+))", "verify_expr": "(equal? (get-suggestion 'infer 'unknown-primitive '(+)) \"Use 'add', 'sub', 'mul', 'div' instead of +\")", "tags": ["core", "base", "error", "composition", "get-suggestion", "direct"], "split": "train"}
{"id": "core_error_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-suggestion", "prompt": "Task mode: small integration task across module primitives.\n\nFormat suggestion for type mismatch.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n hint: Ensure the expression returns the expected type\")\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(format-suggestion 'infer 'type-mismatch '())", "verify_expr": "(equal? (format-suggestion 'infer 'type-mismatch '()) \"\\n  hint: Ensure the expression returns the expected type\")", "tags": ["core", "base", "error", "composition", "format-suggestion", "direct"], "split": "train"}
{"id": "core_error_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-suggestion", "prompt": "Task mode: compose existing APIs into one expression.\n\nFormat suggestion for unknown code (should be empty).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (format-suggestion 'infer 'nope '()) \"\")\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(format-suggestion 'infer 'nope '())", "verify_expr": "(equal? (format-suggestion 'infer 'nope '()) \"\")", "tags": ["core", "base", "error", "composition", "format-suggestion", "edge-case"], "split": "train"}
{"id": "core_error_composition_018", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-error", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFormat a canonical unbound-variable error for symbol `x`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n hint: Check spelling or add a binding with 'let' or 'fix'\")\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(format-error (make-error 'infer 'unbound-variable no-span 'x))", "verify_expr": "(equal? (format-error (make-error 'infer 'unbound-variable no-span 'x)) \"[infer] Variable is not defined: 'x'\\n  hint: Check spelling or add a binding with 'let' or 'fix'\")", "tags": ["core", "base", "error", "composition", "format-error", "integration"], "split": "train"}
{"id": "core_error_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "unbound-error", "prompt": "Task mode: small integration task across module primitives.\n\nBuild `unbound-error` for `foo` and return its `(phase code details)`.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([e (unbound-error 'foo no-span)]) (list (error-phase e) (error-code e) (error-details e))) '(infer unbound-variable (foo)))\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([e (unbound-error 'foo no-span)]) (list (error-phase e) (error-code e) (error-details e)))", "verify_expr": "(equal? (let ([e (unbound-error 'foo no-span)]) (list (error-phase e) (error-code e) (error-details e))) '(infer unbound-variable (foo)))", "tags": ["core", "base", "error", "composition", "unbound-error", "integration"], "split": "train"}
{"id": "core_error_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "type-error", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild `type-error` and return details tuple.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([e (type-error 'Int 'Bool no-span)]) (list (error-phase e) (error-code e) (error-details e)))", "verify_expr": "(equal? (let ([e (type-error 'Int 'Bool no-span)]) (list (error-phase e) (error-code e) (error-details e))) '(infer type-mismatch (Int Bool)))", "tags": ["core", "base", "error", "composition", "type-error", "integration"], "split": "train"}
{"id": "core_error_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "eval-error", "prompt": "Task mode: small integration task across module primitives.\n\nBuild eval error and return `(phase code detail)`.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([e (eval-error 'division-by-zero 0 no-span)]) (list (error-phase e) (error-code e) (car (error-details e))))", "verify_expr": "(equal? (let ([e (eval-error 'division-by-zero 0 no-span)]) (list (error-phase e) (error-code e) (car (error-details e)))) '(eval division-by-zero 0))", "tags": ["core", "base", "error", "composition", "eval-error", "integration"], "split": "train"}
{"id": "core_error_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-code", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap `error-code` over three helper errors.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (map error-code (list (unbound-error 'x no-span) (type-error 'Int 'Bool no-span) (eval-error 'division-by-zero 0 no-span))) '(unbound-variable type-mismatch division-by-zero))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map error-code (list (unbound-error 'x no-span) (type-error 'Int 'Bool no-span) (eval-error 'division-by-zero 0 no-span)))", "verify_expr": "(equal? (map error-code (list (unbound-error 'x no-span) (type-error 'Int 'Bool no-span) (eval-error 'division-by-zero 0 no-span))) '(unbound-variable type-mismatch division-by-zero))", "tags": ["core", "base", "error", "composition", "error-code", "list"], "split": "train"}
{"id": "core_error_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "error-phase", "prompt": "Task mode: small integration task across module primitives.\n\nCount parse-phase errors in a list of mixed errors.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (fold-left (lambda (n e) (if (eq? (error-phase e) 'parse) (+ n 1) n)) 0 (list (parse-error 'unexpected-eof \"x\" 1) (eval-error 'type-error 'bad no-span) (parse-error 'unclosed-list \"list\" 5))) 2)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(fold-left (lambda (n e) (if (eq? (error-phase e) 'parse) (+ n 1) n)) 0 (list (parse-error 'unexpected-eof \"x\" 1) (eval-error 'type-error 'bad no-span) (parse-error 'unclosed-list \"list\" 5)))", "verify_expr": "(equal? (fold-left (lambda (n e) (if (eq? (error-phase e) 'parse) (+ n 1) n)) 0 (list (parse-error 'unexpected-eof \"x\" 1) (eval-error 'type-error 'bad no-span) (parse-error 'unclosed-list \"list\" 5))) 2)", "tags": ["core", "base", "error", "composition", "error-phase", "fold"], "split": "train"}
{"id": "core_error_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "lookup-error-message", "prompt": "Task mode: small integration task across module primitives.\n\nMap lookup over infer codes `(unbound-variable type-mismatch unknown-code)`.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(map (lambda (c) (lookup-error-message 'infer c)) '(unbound-variable type-mismatch unknown-code))", "verify_expr": "(equal? (map (lambda (c) (lookup-error-message 'infer c)) '(unbound-variable type-mismatch unknown-code)) '(\"Variable is not defined\" \"Types do not match\" \"unknown-code\"))", "tags": ["core", "base", "error", "composition", "lookup-error-message", "list"], "split": "train"}
{"id": "core_error_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-location", "prompt": "Task mode: small integration task across module primitives.\n\nMap `format-location` over contexts `[no-span, \"repl\", span]`.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(list (format-location no-span) (format-location \"repl\") (format-location (make-span \"f.ss\" 1 2 1 4)))", "verify_expr": "(equal? (list (format-location no-span) (format-location \"repl\") (format-location (make-span \"f.ss\" 1 2 1 4))) '(\"\" \"repl: \" \"f.ss:1:2: \"))", "tags": ["core", "base", "error", "composition", "format-location", "list"], "split": "train"}
{"id": "core_error_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "core/base/error.ss", "source_test": "core/base/test-error.ss", "source_function": "format-details", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff type mismatch detail formatting matches multiline layout.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (format-details 'type-mismatch '(Int Bool)) \"\\n expected: Int\\n actual: Bool\")\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (format-details 'type-mismatch '(Int Bool)) \"\\n  expected: Int\\n  actual:   Bool\")", "verify_expr": "(equal? (format-details 'type-mismatch '(Int Bool)) \"\\n  expected: Int\\n  actual:   Bool\")", "tags": ["core", "base", "error", "composition", "format-details", "property"], "split": "train"}
