{"id": "query_aho_corasick_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (build-trie patterns)\n  ;; TODO: pre-allocate mutable states, insert patterns, and return used prefix\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `build-trie`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"ab\" \"ac\"))] [root (vector-ref states 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [ac (dict-lookup #\\c (ac-state-trans (vector-ref states a)))]) (and (set-member? \"ab\" (ac-state-output (vector-ref states ab))) (set-member? \"ac\" (ac-state-output (vector-ref states ac))))) #t)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (equal? (let* ([states (build-trie '(\"ab\" \"ac\"))] [root (vector-ref states 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [ac (dict-lookup #\\c (ac-state-trans (vector-ref states a)))]) (and (set-member? \"ab\" (ac-state-output (vector-ref states ab))) (set-member? \"ac\" (ac-state-output (vector-ref states ac))))) #t))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "build-trie"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `build-trie` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Build a compact mutable trie vector from pattern strings and return only the used prefix.\n\nRequirements:\n1. Keep the exact function name/signature for `build-trie`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "build-trie"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `insert-pattern-mut!`\nSpec: Insert one pattern into mutable trie state, creating nodes and terminal outputs as needed.\n\nWrite exactly one Scheme function definition for `insert-pattern-mut!`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([states (make-vector 16 #f)] [size 1]) (let* ([next-id (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (new-size) (set! size new-size)) 1)] [root (vector-ref states 0)] [s1 (dict-lookup #\\a (ac-state-trans root))] [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))]) (and (= next-id 3) (= size 3) s1 s2 (set-member? \"ab\" (ac-state-output (vector-ref states s2))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)) 3)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)) 3))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  ;; TODO: mutate trie for one pattern and return next available state id\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `insert-pattern-mut!`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([states (make-vector 16 #f)] [size 1]) (let* ([next-id (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (new-size) (set! size new-size)) 1)] [root (vector-ref states 0)] [s1 (dict-lookup #\\a (ac-state-trans root))] [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))]) (and (= next-id 3) (= size 3) s1 s2 (set-member? \"ab\" (ac-state-output (vector-ref states s2))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size)) 4)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size)) 4))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `insert-pattern-mut!` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Insert one pattern into mutable trie state, creating nodes and terminal outputs as needed.\n\nRequirements:\n1. Keep the exact function name/signature for `insert-pattern-mut!`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([states (make-vector 16 #f)] [size 1]) (let* ([next-id (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (new-size) (set! size new-size)) 1)] [root (vector-ref states 0)] [s1 (dict-lookup #\\a (ac-state-trans root))] [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))]) (and (= next-id 3) (= size 3) s1 s2 (set-member? \"ab\" (ac-state-output (vector-ref states s2))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `compute-failures`\nSpec: Compute failure links and output unions over trie states via BFS traversal.\n\nWrite exactly one Scheme function definition for `compute-failures`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(and h s he sh she she-state (= (ac-state-fail she-state) he) (set-member? \"she\" (ac-state-output she-state)) (set-member? \"he\" (ac-state-output she-state)))\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t)\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "compute-failures"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compute-failures states)\n  ;; TODO: seed BFS queue from root children and run bfs-mut!\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compute-failures`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he))\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he)))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "compute-failures"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `bfs-mut!`\nSpec: Run in-place BFS over queued states, filling child failure links and inherited output sets.\n\nWrite exactly one Scheme function definition for `bfs-mut!`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she))))) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she))))) #t))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (bfs-mut! states queue)\n  ;; TODO: BFS through transitions, assign fail links, and union outputs\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `bfs-mut!`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n)) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n)) #t))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `bfs-mut!` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Run in-place BFS over queued states, filling child failure links and inherited output sets.\n\nRequirements:\n1. Keep the exact function name/signature for `bfs-mut!`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"ab\" \"bc\"))] [root (vector-ref states 0)] [kids (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty kids)]) (bfs-mut! states q) (let* ([a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref states b)))]) (= (get-next states ab #\\c) bc))) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"ab\" \"bc\"))] [root (vector-ref states 0)] [kids (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty kids)]) (bfs-mut! states q) (let* ([a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref states b)))]) (= (get-next states ab #\\c) bc))) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `find-fail`\nSpec: Resolve fallback transition target for a char from a state's failure chain.\n\nWrite exactly one Scheme function definition for `find-fail`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) he)\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) sh)\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\e) he))\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\e) he)))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "find-fail"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (find-fail states sid ch)\n  ;; TODO: walk failure chain to locate transition for ch\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `find-fail`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) he)\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) sh)\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\x) 0)) #t)\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "find-fail"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `find-fail` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Resolve fallback transition target for a char from a state's failure chain.\n\nRequirements:\n1. Keep the exact function name/signature for `find-fail`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (find-fail a ab #\\c) bc)) #t)\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (find-fail a ab #\\c) bc)) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "find-fail"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (get-next automaton sid ch)\n  ;; TODO: transition on ch with recursive fallback to failure links\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `get-next`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "get-next"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `get-next` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Advance automaton state for one character using transitions plus recursive failure fallback.\n\nRequirements:\n1. Keep the exact function name/signature for `get-next`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "get-next"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `make-automaton`\nSpec: Construct complete Aho-Corasick automaton by combining trie build and failure-link pass.\n\nWrite exactly one Scheme function definition for `make-automaton`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) h)\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) s)\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-automaton patterns)\n  ;; TODO: build trie then compute failure links\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-automaton`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `make-automaton` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Construct complete Aho-Corasick automaton by combining trie build and failure-link pass.\n\nRequirements:\n1. Keep the exact function name/signature for `make-automaton`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m)) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m)) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `search`\nSpec: Scan text with automaton and return all (start-index . matched-pattern) results.\n\nWrite exactly one Scheme function definition for `search`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (length m) 9))\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "search"], "split": "train"}
{"id": "query_aho_corasick_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (search automaton text)\n  ;; TODO: scan text and emit (start-index . pattern) matches\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `search`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (length m) 9))\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "search"], "split": "train"}
{"id": "query_aho_corasick_translation_002", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `build-trie`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (build-trie* patterns)\n  (let* ([total (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [cap (max 64 (+ total 1))]\n         [states (make-vector cap #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop ([ps patterns] [next 1])\n      (if (null? ps)\n          (vector-copy states 0 size)\n          (let ([n2 (insert-pattern-mut! (car ps) states\n                                         (lambda () size)\n                                         (lambda (v) (set! size v))\n                                         next)])\n            (loop (cdr ps) n2))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) (= (vector-length states) 6))\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) h)\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"ab\" \"ac\"))] [root (vector-ref states 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [ac (dict-lookup #\\c (ac-state-trans (vector-ref states a)))]) (and (set-member? \"ab\" (ac-state-output (vector-ref states ab))) (set-member? \"ac\" (ac-state-output (vector-ref states ac))))) #t)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (equal? (let* ([states (build-trie '(\"ab\" \"ac\"))] [root (vector-ref states 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [ac (dict-lookup #\\c (ac-state-trans (vector-ref states a)))]) (and (set-member? \"ab\" (ac-state-output (vector-ref states ab))) (set-member? \"ac\" (ac-state-output (vector-ref states ac))))) #t))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "build-trie"], "split": "train"}
{"id": "query_aho_corasick_translation_003", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `build-trie`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `build-trie`.\nReturn only the final Scheme definition.\n\n```python\ndef build_trie(patterns):\n    total_chars = sum(len(p) for p in patterns)\n    capacity = max(64, total_chars + 1)\n    states = [None] * capacity\n    size = 1\n    states[0] = make_state(0)\n    next_id = 1\n    for pat in patterns:\n        next_id = insert_pattern_mut(pat, states, lambda: size, lambda n: set_size(n), next_id)\n    return states[:size]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) (= (vector-length states) 6))\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) h)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "build-trie"], "split": "train"}
{"id": "query_aho_corasick_translation_004", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `insert-pattern-mut!`.\nReturn only the Scheme definition.\n\n```python\ndef insert_pattern_mut(pattern, states, get_size, set_size, next_id):\n    sid = 0\n    for ch in pattern:\n        state = states[sid]\n        nxt = dict_lookup(ch, state.trans)\n        if nxt is not None:\n            sid = nxt\n            continue\n        states[next_id] = make_state(next_id)\n        new_trans = dict_assoc(ch, next_id, state.trans)\n        states[sid] = make_ac_state(sid, new_trans, state.output, state.fail)\n        set_size(get_size() + 1)\n        sid = next_id\n        next_id += 1\n    st = states[sid]\n    states[sid] = make_ac_state(sid, st.trans, set_add(pattern, st.output), st.fail)\n    return next_id\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([states (make-vector 16 #f)] [size 1]) (let* ([next-id (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (new-size) (set! size new-size)) 1)] [root (vector-ref states 0)] [s1 (dict-lookup #\\a (ac-state-trans root))] [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))]) (and (= next-id 3) (= size 3) s1 s2 (set-member? \"ab\" (ac-state-output (vector-ref states s2))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)) 3)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)) 3))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `insert-pattern-mut!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (insert-pattern-mut!* pattern states get-size set-size! next-id)\n  (let loop ([chars (string->list pattern)] [sid 0] [nid next-id])\n    (if (null? chars)\n        (let* ([st (vector-ref states sid)]\n               [out (set-add pattern (ac-state-output st))])\n          (vector-set! states sid (make-ac-state sid (ac-state-trans st) out (ac-state-fail st)))\n          nid)\n        (let* ([ch (car chars)]\n               [st (vector-ref states sid)]\n               [next (dict-lookup ch (ac-state-trans st))])\n          (if next\n              (loop (cdr chars) next nid)\n              (let* ([new (make-state nid)]\n                     [trans2 (dict-assoc ch nid (ac-state-trans st))])\n                (vector-set! states nid new)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid (make-ac-state sid trans2 (ac-state-output st) (ac-state-fail st)))\n                (loop (cdr chars) nid (+ nid 1))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size)) 4)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size)) 4))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `insert-pattern-mut!`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `insert-pattern-mut!`.\nReturn only the final Scheme definition.\n\n```python\ndef insert_pattern_mut(pattern, states, get_size, set_size, next_id):\n    sid = 0\n    for ch in pattern:\n        state = states[sid]\n        nxt = dict_lookup(ch, state.trans)\n        if nxt is not None:\n            sid = nxt\n            continue\n        states[next_id] = make_state(next_id)\n        new_trans = dict_assoc(ch, next_id, state.trans)\n        states[sid] = make_ac_state(sid, new_trans, state.output, state.fail)\n        set_size(get_size() + 1)\n        sid = next_id\n        next_id += 1\n    st = states[sid]\n    states[sid] = make_ac_state(sid, st.trans, set_add(pattern, st.output), st.fail)\n    return next_id\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([states (make-vector 16 #f)] [size 1]) (let* ([next-id (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (new-size) (set! size new-size)) 1)] [root (vector-ref states 0)] [s1 (dict-lookup #\\a (ac-state-trans root))] [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))]) (and (= next-id 3) (= size 3) s1 s2 (set-member? \"ab\" (ac-state-output (vector-ref states s2))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `compute-failures`.\nReturn only the Scheme definition.\n\n```python\ndef compute_failures(states):\n    root = states[0]\n    q = queue_empty\n    for child in dict_values(root.trans):\n        q = queue_enqueue(child, q)\n    bfs_mut(states, q)\n    return states\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(and h s he sh she she-state (= (ac-state-fail she-state) he) (set-member? \"she\" (ac-state-output she-state)) (set-member? \"he\" (ac-state-output she-state)))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t)\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "compute-failures"], "split": "train"}
{"id": "query_aho_corasick_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `compute-failures`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (compute-failures* states)\n  (let* ([root (vector-ref states 0)]\n         [kids (dict-values (ac-state-trans root))]\n         [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty kids)])\n    (bfs-mut! states q)\n    states))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(and h s he sh she she-state (= (ac-state-fail she-state) he) (set-member? \"she\" (ac-state-output she-state)) (set-member? \"he\" (ac-state-output she-state)))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he))\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he)))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "compute-failures"], "split": "train"}
{"id": "query_aho_corasick_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `bfs-mut!`.\nReturn only the Scheme definition.\n\n```python\ndef bfs_mut(states, queue):\n    while not queue_empty_q(queue):\n        queue, sid = queue_dequeue(queue)\n        trans = states[sid].trans\n        for ch in dict_keys(trans):\n            child_id = dict_lookup(ch, trans)\n            fail_id = find_fail(states, sid, ch)\n            child = states[child_id]\n            fail_state = states[fail_id]\n            merged = set_union(child.output, fail_state.output)\n            states[child_id] = make_ac_state(child_id, child.trans, merged, fail_id)\n            queue = queue_enqueue(child_id, queue)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she))))) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she))))) #t))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `bfs-mut!`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (bfs-mut!* states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let loop ([keys (dict-keys (ac-state-trans (vector-ref states sid)))] [q q2])\n          (if (null? keys)\n              (bfs-mut!* states q)\n              (let* ([ch (car keys)]\n                     [child-id (dict-lookup ch (ac-state-trans (vector-ref states sid)))]\n                     [fail-id (find-fail states sid ch)]\n                     [child (vector-ref states child-id)]\n                     [fail-state (vector-ref states fail-id)]\n                     [merged (set-union (ac-state-output child) (ac-state-output fail-state))])\n                (vector-set! states child-id\n                  (make-ac-state child-id (ac-state-trans child) merged fail-id))\n                (loop (cdr keys) (queue-enqueue child-id q))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n)) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n)) #t))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `bfs-mut!`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `bfs-mut!`.\nReturn only the final Scheme definition.\n\n```python\ndef bfs_mut(states, queue):\n    while not queue_empty_q(queue):\n        queue, sid = queue_dequeue(queue)\n        trans = states[sid].trans\n        for ch in dict_keys(trans):\n            child_id = dict_lookup(ch, trans)\n            fail_id = find_fail(states, sid, ch)\n            child = states[child_id]\n            fail_state = states[fail_id]\n            merged = set_union(child.output, fail_state.output)\n            states[child_id] = make_ac_state(child_id, child.trans, merged, fail_id)\n            queue = queue_enqueue(child_id, queue)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"ab\" \"bc\"))] [root (vector-ref states 0)] [kids (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty kids)]) (bfs-mut! states q) (let* ([a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref states b)))]) (= (get-next states ab #\\c) bc))) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"ab\" \"bc\"))] [root (vector-ref states 0)] [kids (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty kids)]) (bfs-mut! states q) (let* ([a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref states b)))]) (= (get-next states ab #\\c) bc))) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `find-fail`.\nReturn only the Scheme definition.\n\n```python\ndef find_fail(states, sid, ch):\n    fail_id = states[sid].fail\n    if fail_id == 0:\n        nxt = dict_lookup(ch, states[0].trans)\n        return nxt if nxt is not None else 0\n    nxt = dict_lookup(ch, states[fail_id].trans)\n    if nxt is not None:\n        return nxt\n    return find_fail(states, fail_id, ch)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\e) he))\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\e) he)))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "find-fail"], "split": "train"}
{"id": "query_aho_corasick_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `find-fail`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (find-fail* states sid ch)\n  (let ([fid (ac-state-fail (vector-ref states sid))])\n    (if (= fid 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fid)))])\n          (if next next (find-fail* states fid ch))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) he)\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) sh)\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\x) 0)) #t)\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "find-fail"], "split": "train"}
{"id": "query_aho_corasick_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `find-fail`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `find-fail`.\nReturn only the final Scheme definition.\n\n```python\ndef find_fail(states, sid, ch):\n    fail_id = states[sid].fail\n    if fail_id == 0:\n        nxt = dict_lookup(ch, states[0].trans)\n        return nxt if nxt is not None else 0\n    nxt = dict_lookup(ch, states[fail_id].trans)\n    if nxt is not None:\n        return nxt\n    return find_fail(states, fail_id, ch)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) he)\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) sh)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (find-fail a ab #\\c) bc)) #t)\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (find-fail a ab #\\c) bc)) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "find-fail"], "split": "train"}
{"id": "query_aho_corasick_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `get-next`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (get-next* automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next* automaton (ac-state-fail (vector-ref automaton sid)) ch)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "get-next"], "split": "train"}
{"id": "query_aho_corasick_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `get-next`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `get-next`.\nReturn only the final Scheme definition.\n\n```python\ndef get_next(automaton, sid, ch):\n    nxt = dict_lookup(ch, automaton[sid].trans)\n    if nxt is not None:\n        return nxt\n    if sid == 0:\n        return 0\n    return get_next(automaton, automaton[sid].fail, ch)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "get-next"], "split": "train"}
{"id": "query_aho_corasick_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `make-automaton`.\nReturn only the Scheme definition.\n\n```python\ndef make_automaton(patterns):\n    return compute_failures(build_trie(patterns))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) h)\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) s)\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-automaton`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (make-automaton* patterns)\n  (compute-failures (build-trie patterns)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) h)\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) s)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `make-automaton`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `make-automaton`.\nReturn only the final Scheme definition.\n\n```python\ndef make_automaton(patterns):\n    return compute_failures(build_trie(patterns))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m)) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m)) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `search`.\nReturn only the Scheme definition.\n\n```python\ndef search(automaton, text):\n    sid = 0\n    matches = []\n    for pos, ch in enumerate(text):\n        sid = get_next(automaton, sid, ch)\n        outputs = set_to_list(automaton[sid].output)\n        for pat in outputs:\n            start = (pos + 1) - len(pat)\n            matches.append((start, pat))\n    return matches\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "search"], "split": "train"}
{"id": "query_aho_corasick_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `search`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (search* automaton text)\n  (let loop ([chars (string->list text)] [pos 0] [sid 0] [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [sid2 (get-next automaton sid ch)]\n               [outs (set->list (ac-state-output (vector-ref automaton sid2)))])\n          (loop (cdr chars)\n                (+ pos 1)\n                sid2\n                (append (map (lambda (p) (cons (- (+ pos 1) (string-length p)) p)) outs)\n                        matches))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (length m) 9))\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "search"], "split": "train"}
{"id": "query_aho_corasick_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-trie` in `lattice/query/aho-corasick.ss`.\nKnown issue: Trie size tracking must include root node; starting from zero truncates the resulting state vector.\n\n```scheme\n(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 0])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Trie size tracking must include root node; starting from zero truncates the resulting state vector.\n\nExpected behavior after patch:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) (= (vector-length states) 6))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (vector-length (build-trie '(\"he\" \"she\"))) 6)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (= (vector-length (build-trie '(\"he\" \"she\"))) 6))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "build-trie"], "split": "train"}
{"id": "query_aho_corasick_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insert-pattern-mut!` in `lattice/query/aho-corasick.ss`.\nKnown issue: Terminal states must record matched pattern strings in output sets.\n\n```scheme\n(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        next-id\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Terminal states must record matched pattern strings in output sets.\n\nExpected behavior after patch:\n```scheme\n(let* ([states (make-vector 16 #f)] [size 1]) (let* ([next-id (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (new-size) (set! size new-size)) 1)] [root (vector-ref states 0)] [s1 (dict-lookup #\\a (ac-state-trans root))] [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))]) (and (= next-id 3) (= size 3) s1 s2 (set-member? \"ab\" (ac-state-output (vector-ref states s2))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size)) 4)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size)) 4))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `insert-pattern-mut!` in `lattice/query/aho-corasick.ss`.\nKnown issue: Insertion must update externally tracked trie size when allocating new states.\n\n```scheme\n(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Insertion must update externally tracked trie size when allocating new states.\n\nExpected behavior after patch:\n```scheme\n(let* ([states (make-vector 16 #f)] [size 1]) (let* ([next-id (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (new-size) (set! size new-size)) 1)] [root (vector-ref states 0)] [s1 (dict-lookup #\\a (ac-state-trans root))] [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))]) (and (= next-id 3) (= size 3) s1 s2 (set-member? \"ab\" (ac-state-output (vector-ref states s2))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t)\n```", "ground_truth": "(define (insert-pattern-mut! pattern states get-size set-size! next-id)\n  (let loop-chars ([chars (string->list pattern)]\n                   [sid 0]\n                   [next-id next-id])\n    (if (null? chars)\n        (let* ([state (vector-ref states sid)]\n               [new-output (set-add pattern (ac-state-output state))]\n               [new-state (make-ac-state sid\n                                         (ac-state-trans state)\n                                         new-output\n                                         (ac-state-fail state))])\n          (vector-set! states sid new-state)\n          next-id)\n        (let* ([ch (car chars)]\n               [state (vector-ref states sid)]\n               [trans (ac-state-trans state)]\n               [next (dict-lookup ch trans)])\n          (if next\n              (loop-chars (cdr chars) next next-id)\n              (let* ([new-state (make-state next-id)]\n                     [new-trans (dict-assoc ch next-id trans)]\n                     [updated-parent (make-ac-state sid\n                                                    new-trans\n                                                    (ac-state-output state)\n                                                    (ac-state-fail state))])\n                (vector-set! states next-id new-state)\n                (set-size! (+ (get-size) 1))\n                (vector-set! states sid updated-parent)\n                (loop-chars (cdr chars) next-id (+ next-id 1))))))))", "verify_expr": "(and (let* ([states (make-vector 16 #f)]\n       [size 1])\n  (vector-set! states 0 (make-state 0))\n  (let* ([next-id (insert-pattern-mut! \"ab\" states\n                                       (lambda () size)\n                                       (lambda (new-size) (set! size new-size))\n                                       1)]\n         [root (vector-ref states 0)]\n         [s1 (dict-lookup #\\a (ac-state-trans root))]\n         [s2 (and s1 (dict-lookup #\\b (ac-state-trans (vector-ref states s1))))])\n    (and (= next-id 3)\n         (= size 3)\n         s1 s2\n         (set-member? \"ab\" (ac-state-output (vector-ref states s2)))))) (equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "insert-pattern-mut!"], "split": "train"}
{"id": "query_aho_corasick_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compute-failures` in `lattice/query/aho-corasick.ss`.\nKnown issue: Failure-link computation must run BFS; returning trie unchanged leaves fail links unset.\n\n```scheme\n(define (compute-failures states)\n  states)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Failure-link computation must run BFS; returning trie unchanged leaves fail links unset.\n\nExpected behavior after patch:\n```scheme\n(and h s he sh she she-state (= (ac-state-fail she-state) he) (set-member? \"she\" (ac-state-output she-state)) (set-member? \"he\" (ac-state-output she-state)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t)\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "compute-failures"], "split": "train"}
{"id": "query_aho_corasick_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compute-failures` in `lattice/query/aho-corasick.ss`.\nKnown issue: BFS must be seeded with root children; empty seed queue skips all failure propagation.\n\n```scheme\n(define (compute-failures states)\n  (bfs-mut! states queue-empty)\n  states)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: BFS must be seeded with root children; empty seed queue skips all failure propagation.\n\nExpected behavior after patch:\n```scheme\n(and h s he sh she she-state (= (ac-state-fail she-state) he) (set-member? \"she\" (ac-state-output she-state)) (set-member? \"he\" (ac-state-output she-state)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he))\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he)))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "compute-failures"], "split": "train"}
{"id": "query_aho_corasick_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `bfs-mut!` in `lattice/query/aho-corasick.ss`.\nKnown issue: BFS propagation must union child outputs with fail-state outputs.\n\n```scheme\n(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 (ac-state-output child)\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she))))) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she))))) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `bfs-mut!` in `lattice/query/aho-corasick.ss`.\nKnown issue: BFS must compute real failure links from find-fail rather than forcing all fails to root.\n\n```scheme\n(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [child (vector-ref states child-id)]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 (ac-state-output child)\n                                                 0)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n)) #t)\n```", "ground_truth": "(define (bfs-mut! states queue)\n  (if (queue-empty? queue)\n      (void)\n      (let-values ([(q2 sid) (queue-dequeue queue)])\n        (let* ([state (vector-ref states sid)]\n               [trans (ac-state-trans state)])\n          (let loop-trans ([keys (dict-keys trans)]\n                           [q q2])\n            (if (null? keys)\n                (bfs-mut! states q)\n                (let* ([ch (car keys)]\n                       [child-id (dict-lookup ch trans)]\n                       [fail-id (find-fail states sid ch)]\n                       [child (vector-ref states child-id)]\n                       [fail-state (vector-ref states fail-id)]\n                       [new-output (set-union (ac-state-output child)\n                                              (ac-state-output fail-state))]\n                       [new-child (make-ac-state child-id\n                                                 (ac-state-trans child)\n                                                 new-output\n                                                 fail-id)])\n                  (vector-set! states child-id new-child)\n                  (loop-trans (cdr keys)\n                              (queue-enqueue child-id q)))))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [children (dict-values (ac-state-trans root))]\n       [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)])\n  (bfs-mut! states q)\n  (let* ([h (dict-lookup #\\h (ac-state-trans root))]\n         [s (dict-lookup #\\s (ac-state-trans root))]\n         [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n         [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n         [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]\n         [she-state (and she (vector-ref states she))])\n    (and h s he sh she she-state\n         (= (ac-state-fail she-state) he)\n         (set-member? \"she\" (ac-state-output she-state))\n         (set-member? \"he\" (ac-state-output she-state))))) (equal? (let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "bfs-mut!"], "split": "train"}
{"id": "query_aho_corasick_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `find-fail` in `lattice/query/aho-corasick.ss`.\nKnown issue: If fail state lacks transition, search must continue recursively up the failure chain.\n\n```scheme\n(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              fail-id)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0)) #t)\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (equal? (let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "find-fail"], "split": "train"}
{"id": "query_aho_corasick_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `get-next` in `lattice/query/aho-corasick.ss`.\nKnown issue: Single-step transition must recursively follow failure links, not jump directly to root.\n\n```scheme\n(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "get-next"], "split": "train"}
{"id": "query_aho_corasick_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `get-next` in `lattice/query/aho-corasick.ss`.\nKnown issue: Fallback must recurse until a valid transition is found, not return immediate fail-id as next state.\n\n```scheme\n(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (ac-state-fail (vector-ref automaton sid))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "get-next"], "split": "train"}
{"id": "query_aho_corasick_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-automaton` in `lattice/query/aho-corasick.ss`.\nKnown issue: Automaton construction must include failure-link computation after trie build.\n\n```scheme\n(define (make-automaton patterns)\n  (build-trie patterns))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Automaton construction must include failure-link computation after trie build.\n\nExpected behavior after patch:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) h)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-automaton` in `lattice/query/aho-corasick.ss`.\nKnown issue: Automaton must include all patterns; dropping head pattern changes recognized matches.\n\n```scheme\n(define (make-automaton patterns)\n  (compute-failures (build-trie (cdr patterns))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) h)\n(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))] [matches (search a \"ushers\")]) s)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m)) #t)\n```", "ground_truth": "(define (make-automaton patterns)\n  (compute-failures (build-trie patterns)))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref a sh))))]\n       [matches (search a \"ushers\")])\n  (and h s he sh she\n       (= (ac-state-fail (vector-ref a she)) he)\n       (= (length matches) 3)\n       (if (member '(1 . \"she\") matches) #t #f)\n       (if (member '(2 . \"he\") matches) #t #f)\n       (if (member '(2 . \"hers\") matches) #t #f))) (equal? (let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "make-automaton"], "split": "train"}
{"id": "query_aho_corasick_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `search` in `lattice/query/aho-corasick.ss`.\nKnown issue: Search should return matches in scan order; accumulated list must be reversed before returning.\n\n```scheme\n(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        matches\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (length m) 9))\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "search"], "split": "train"}
{"id": "query_aho_corasick_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild trie for ('a' 'aa') and return whether root has transition on #\\a.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([states (build-trie '(\"a\" \"aa\"))] [root (vector-ref states 0)]) (if (dict-lookup #\\a (ac-state-trans root)) #t #f)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([states (build-trie '(\"a\" \"aa\"))] [root (vector-ref states 0)]) (if (dict-lookup #\\a (ac-state-trans root)) #t #f))", "verify_expr": "(equal? (let* ([states (build-trie '(\"a\" \"aa\"))] [root (vector-ref states 0)]) (if (dict-lookup #\\a (ac-state-trans root)) #t #f)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "build-trie", "root-transition"], "split": "train"}
{"id": "query_aho_corasick_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild trie for ('ab' 'ac') and return whether both terminal outputs are present.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([states (build-trie '(\"ab\" \"ac\"))] [root (vector-ref states 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [ac (dict-lookup #\\c (ac-state-trans (vector-ref states a)))]) (and (set-member? \"ab\" (ac-state-output (vector-ref states ab))) (set-member? \"ac\" (ac-state-output (vector-ref states ac))))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([states (build-trie '(\"ab\" \"ac\"))] [root (vector-ref states 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [ac (dict-lookup #\\c (ac-state-trans (vector-ref states a)))]) (and (set-member? \"ab\" (ac-state-output (vector-ref states ab))) (set-member? \"ac\" (ac-state-output (vector-ref states ac)))))", "verify_expr": "(equal? (let* ([states (build-trie '(\"ab\" \"ac\"))] [root (vector-ref states 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [ac (dict-lookup #\\c (ac-state-trans (vector-ref states a)))]) (and (set-member? \"ab\" (ac-state-output (vector-ref states ab))) (set-member? \"ac\" (ac-state-output (vector-ref states ac))))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "build-trie", "terminal-output"], "split": "train"}
{"id": "query_aho_corasick_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild trie for empty pattern list and return whether only root state exists.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([states (build-trie '())]) (= (vector-length states) 1))", "verify_expr": "(equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "build-trie", "empty"], "split": "train"}
{"id": "query_aho_corasick_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert pattern 'ab' into fresh mutable trie and return next-id.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1))", "verify_expr": "(= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)) 3)", "tags": ["tier1", "query", "aho-corasick", "composition", "insert-pattern-mut!", "next-id"], "split": "train"}
{"id": "query_aho_corasick_composition_006", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: small integration task across module primitives.\n\nInsert 'ab' then 'ac' and return resulting mutable trie size.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size))", "verify_expr": "(= (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)]) (insert-pattern-mut! \"ac\" states (lambda () size) (lambda (n) (set! size n)) id2) size)) 4)", "tags": ["tier1", "query", "aho-corasick", "composition", "insert-pattern-mut!", "size-update"], "split": "train"}
{"id": "query_aho_corasick_composition_008", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert 'ab' twice and return whether second insert keeps next-id unchanged.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let* ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)] [id3 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) id2)]) (= id2 id3)))", "verify_expr": "(equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (let* ([id2 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) 1)] [id3 (insert-pattern-mut! \"ab\" states (lambda () size) (lambda (n) (set! size n)) id2)]) (= id2 id3))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "insert-pattern-mut!", "idempotent-path"], "split": "train"}
{"id": "query_aho_corasick_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute failures for trie ('he' 'she') and return fail id of state 'she'.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compute-failures`\n- `build-trie`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nTarget properties for your expression:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (ac-state-fail (vector-ref done she)))", "verify_expr": "(let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref done h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (= (ac-state-fail (vector-ref done she)) he))", "tags": ["tier1", "query", "aho-corasick", "composition", "compute-failures", "fail-link"], "split": "train"}
{"id": "query_aho_corasick_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: small integration task across module primitives.\n\nAfter compute-failures on ('he' 'she'), return whether she-state output includes inherited 'he'.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (set-member? \"he\" (ac-state-output (vector-ref done she))))", "verify_expr": "(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (set-member? \"he\" (ac-state-output (vector-ref done she)))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "compute-failures", "output-union"], "split": "train"}
{"id": "query_aho_corasick_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute failures for empty trie and return whether result remains a single root state.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `compute-failures`\n- `build-trie`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([done (compute-failures (build-trie '()))]) (= (vector-length done) 1)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([done (compute-failures (build-trie '()))]) (= (vector-length done) 1))", "verify_expr": "(equal? (let ([done (compute-failures (build-trie '()))]) (= (vector-length done) 1)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "compute-failures", "empty"], "split": "train"}
{"id": "query_aho_corasick_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun compute-failures for ('ab' 'bc') and return whether fail of state 'ab' points to state 'b'.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b))", "verify_expr": "(equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "compute-failures", "cross-prefix"], "split": "train"}
{"id": "query_aho_corasick_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun bfs-mut! and return whether she output set contains inherited he after propagation.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `bfs-mut!`\n- `build-trie`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she)))))", "verify_expr": "(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"he\" (ac-state-output (vector-ref states she))))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "bfs-mut!", "output-propagation"], "split": "train"}
{"id": "query_aho_corasick_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun bfs-mut! on empty queue and return whether automaton states remain unchanged in count.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `bfs-mut!`\n- `build-trie`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n))", "verify_expr": "(equal? (let* ([states (build-trie '(\"a\"))] [n (vector-length states)]) (bfs-mut! states queue-empty) (= (vector-length states) n)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "bfs-mut!", "empty-queue"], "split": "train"}
{"id": "query_aho_corasick_composition_016", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild trie ('ab' 'bc'), run bfs-mut!, and return whether get-next can bridge from state 'ab' with char c.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `bfs-mut!`\n- `build-trie`\n- `get-next`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([states (build-trie '(\"ab\" \"bc\"))] [root (vector-ref states 0)] [kids (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty kids)]) (bfs-mut! states q) (let* ([a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref states b)))]) (= (get-next states ab #\\c) bc)))", "verify_expr": "(equal? (let* ([states (build-trie '(\"ab\" \"bc\"))] [root (vector-ref states 0)] [kids (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty kids)]) (bfs-mut! states q) (let* ([a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref states a)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref states b)))]) (= (get-next states ab #\\c) bc))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "bfs-mut!", "fallback-bridge"], "split": "train"}
{"id": "query_aho_corasick_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn find-fail result for state 'sh' with char e in automaton ('he' 'she').\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `find-fail`\n- `make-automaton`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\e) he))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (find-fail a sh #\\e))", "verify_expr": "(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\e) he))", "tags": ["tier1", "query", "aho-corasick", "composition", "find-fail", "match-fallback"], "split": "train"}
{"id": "query_aho_corasick_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether find-fail from state 'sh' on char x returns root fallback 0.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\x) 0)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\x) 0))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))]) (= (find-fail a sh #\\x) 0)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "find-fail", "root-fallback"], "split": "train"}
{"id": "query_aho_corasick_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: small integration task across module primitives.\n\nOn automaton ('ab' 'bc'), return whether find-fail from state 'ab' on c lands at state 'bc'.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `find-fail`\n- `make-automaton`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (find-fail a ab #\\c) bc)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (find-fail a ab #\\c) bc))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (find-fail a ab #\\c) bc)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "find-fail", "chain-fallback"], "split": "train"}
{"id": "query_aho_corasick_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: small integration task across module primitives.\n\nReturn get-next from root on char h in automaton ('he' 'she').\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `get-next`\n- `make-automaton`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\"))]) (get-next a 0 #\\h))", "verify_expr": "(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))", "tags": ["tier1", "query", "aho-corasick", "composition", "get-next", "direct"], "split": "train"}
{"id": "query_aho_corasick_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether get-next from root on unknown char x returns 0.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "get-next", "missing-root"], "split": "train"}
{"id": "query_aho_corasick_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFor automaton ('ab' 'bc'), return whether get-next from state 'ab' with c reaches state 'bc'.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `get-next`\n- `make-automaton`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "get-next", "recursive-fallback"], "split": "train"}
{"id": "query_aho_corasick_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: small integration task across module primitives.\n\nFor automaton ('ab' 'bc'), return whether get-next from state 'ab' with x falls back to 0.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "get-next", "dead-transition"], "split": "train"}
{"id": "query_aho_corasick_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild automaton for ('he' 'she') and return state count.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(vector-length (make-automaton '(\"he\" \"she\")))", "verify_expr": "(= (vector-length (make-automaton '(\"he\" \"she\"))) 6)", "tags": ["tier1", "query", "aho-corasick", "composition", "make-automaton", "size"], "split": "train"}
{"id": "query_aho_corasick_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: small integration task across module primitives.\n\nBuild automaton for ('he' 'she' 'his' 'hers') and return whether searching 'ushers' yields three expected matches.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f)))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (= (length m) 3) (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "make-automaton", "search-integrated"], "split": "train"}
{"id": "query_aho_corasick_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild automaton for empty pattern list and return whether searching any text returns empty list.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `make-automaton`\n- `search`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m))", "verify_expr": "(equal? (let* ([a (make-automaton '())] [m (search a \"anything\")]) (null? m)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "make-automaton", "empty-patterns"], "split": "train"}
{"id": "query_aho_corasick_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: compose existing APIs into one expression.\n\nSearch automaton ('he' 'she' 'his' 'hers') on 'ushers' and return whether key matches exist.\n\nSolve with an expression that can be evaluated directly.\n\nAvailable functions you may compose:\n- `search`\n- `make-automaton`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f)))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\" \"she\" \"his\" \"hers\"))] [m (search a \"ushers\")]) (and (if (member '(1 . \"she\") m) #t #f) (if (member '(2 . \"he\") m) #t #f) (if (member '(2 . \"hers\") m) #t #f))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "search", "classic-example"], "split": "train"}
{"id": "query_aho_corasick_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: small integration task across module primitives.\n\nSearch automaton ('a' 'aa' 'aaa') on 'aaaa' and return match count.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `search`\n- `make-automaton`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m))", "verify_expr": "(= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9)", "tags": ["tier1", "query", "aho-corasick", "composition", "search", "overlap-count"], "split": "train"}
{"id": "query_aho_corasick_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSearch automaton ('a' 'aa' 'aaa') on 'aaaa' and return whether earliest match position is 0.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "search", "ordering"], "split": "train"}
