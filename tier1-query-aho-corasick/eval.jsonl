{"id": "query_aho_corasick_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `build-trie`\nSpec: Build a compact mutable trie vector from pattern strings and return only the used prefix.\n\nWrite exactly one Scheme function definition for `build-trie`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) (= (vector-length states) 6))\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) h)\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"a\" \"aa\"))] [root (vector-ref states 0)]) (if (dict-lookup #\\a (ac-state-trans root)) #t #f)) #t)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (equal? (let* ([states (build-trie '(\"a\" \"aa\"))] [root (vector-ref states 0)]) (if (dict-lookup #\\a (ac-state-trans root)) #t #f)) #t))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "build-trie"], "split": "eval"}
{"id": "query_aho_corasick_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `compute-failures` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Compute failure links and output unions over trie states via BFS traversal.\n\nRequirements:\n1. Keep the exact function name/signature for `compute-failures`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(and h s he sh she she-state (= (ac-state-fail she-state) he) (set-member? \"she\" (ac-state-output she-state)) (set-member? \"he\" (ac-state-output she-state)))\n```\n\nKeep the implementation idiomatic and dependency-aware.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (set-member? \"he\" (ac-state-output (vector-ref done she)))) #t)\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (equal? (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (set-member? \"he\" (ac-state-output (vector-ref done she)))) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "compute-failures"], "split": "eval"}
{"id": "query_aho_corasick_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `get-next`\nSpec: Advance automaton state for one character using transitions plus recursive failure fallback.\n\nWrite exactly one Scheme function definition for `get-next`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `search` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Scan text with automaton and return all (start-index . matched-pattern) results.\n\nRequirements:\n1. Keep the exact function name/signature for `search`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0)) #t)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (equal? (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "search"], "split": "eval"}
{"id": "query_aho_corasick_translation_001", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `build-trie`.\nReturn only the Scheme definition.\n\n```python\ndef build_trie(patterns):\n    total_chars = sum(len(p) for p in patterns)\n    capacity = max(64, total_chars + 1)\n    states = [None] * capacity\n    size = 1\n    states[0] = make_state(0)\n    next_id = 1\n    for pat in patterns:\n        next_id = insert_pattern_mut(pat, states, lambda: size, lambda n: set_size(n), next_id)\n    return states[:size]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) (= (vector-length states) 6))\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) h)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"a\" \"aa\"))] [root (vector-ref states 0)]) (if (dict-lookup #\\a (ac-state-trans root)) #t #f)) #t)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (equal? (let* ([states (build-trie '(\"a\" \"aa\"))] [root (vector-ref states 0)]) (if (dict-lookup #\\a (ac-state-trans root)) #t #f)) #t))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "build-trie"], "split": "eval"}
{"id": "query_aho_corasick_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `compute-failures`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `compute-failures`.\nReturn only the final Scheme definition.\n\n```python\ndef compute_failures(states):\n    root = states[0]\n    q = queue_empty\n    for child in dict_values(root.trans):\n        q = queue_enqueue(child, q)\n    bfs_mut(states, q)\n    return states\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(and h s he sh she she-state (= (ac-state-fail she-state) he) (set-member? \"she\" (ac-state-output she-state)) (set-member? \"he\" (ac-state-output she-state)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (set-member? \"he\" (ac-state-output (vector-ref done she)))) #t)\n```", "ground_truth": "(define (compute-failures states)\n  (let* ([root (vector-ref states 0)]\n         [children (dict-values (ac-state-trans root))]\n         [init-q (fold-left (lambda (q child) (queue-enqueue child q))\n                            queue-empty\n                            children)])\n    (bfs-mut! states init-q)\n    states))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\" \"his\" \"hers\"))]\n       [done (compute-failures states)]\n       [root (vector-ref done 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref done h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref done s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref done sh))))]\n       [she-state (and she (vector-ref done she))])\n  (and h s he sh she she-state\n       (= (ac-state-fail she-state) he)\n       (set-member? \"she\" (ac-state-output she-state))\n       (set-member? \"he\" (ac-state-output she-state)))) (equal? (let* ([states (build-trie '(\"he\" \"she\"))] [done (compute-failures states)] [root (vector-ref done 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref done s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref done sh)))]) (set-member? \"he\" (ac-state-output (vector-ref done she)))) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "compute-failures"], "split": "eval"}
{"id": "query_aho_corasick_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `get-next`.\nReturn only the Scheme definition.\n\n```python\ndef get_next(automaton, sid, ch):\n    nxt = dict_lookup(ch, automaton[sid].trans)\n    if nxt is not None:\n        return nxt\n    if sid == 0:\n        return 0\n    return get_next(automaton, automaton[sid].fail, ch)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this reference implementation into canonical Fold Scheme for `search`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `search`.\nReturn only the final Scheme definition.\n\n```python\ndef search(automaton, text):\n    sid = 0\n    matches = []\n    for pos, ch in enumerate(text):\n        sid = get_next(automaton, sid, ch)\n        outputs = set_to_list(automaton[sid].output)\n        for pat in outputs:\n            start = (pos + 1) - len(pat)\n            matches.append((start, pat))\n    return matches\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (length m) 9))\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0)) #t)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (equal? (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "search"], "split": "eval"}
{"id": "query_aho_corasick_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `build-trie` in `lattice/query/aho-corasick.ss`.\nKnown issue: Trie builder must return only the used vector prefix, not the full preallocated capacity.\n\n```scheme\n(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          states\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Trie builder must return only the used vector prefix, not the full preallocated capacity.\n\nExpected behavior after patch:\n```scheme\n(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))] [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))]) (= (vector-length states) 6))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t)\n```", "ground_truth": "(define (build-trie patterns)\n  (let* ([total-chars (fold-left (lambda (acc p) (+ acc (string-length p))) 0 patterns)]\n         [capacity (max 64 (+ total-chars 1))]\n         [states (make-vector capacity #f)]\n         [size 1])\n    (vector-set! states 0 (make-state 0))\n    (let loop-patterns ([patterns patterns]\n                        [next-id 1])\n      (if (null? patterns)\n          (vector-copy states 0 size)\n          (let ([new-id (insert-pattern-mut! (car patterns) states\n                                             (lambda () size)\n                                             (lambda (new-size) (set! size new-size))\n                                             next-id)])\n            (loop-patterns (cdr patterns) new-id))))))", "verify_expr": "(and (let* ([states (build-trie '(\"he\" \"she\"))]\n       [root (vector-ref states 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref states h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref states s))))]\n       [she (and sh (dict-lookup #\\e (ac-state-trans (vector-ref states sh))))])\n  (and (= (vector-length states) 6)\n       h s he she\n       (set-member? \"he\" (ac-state-output (vector-ref states he)))\n       (set-member? \"she\" (ac-state-output (vector-ref states she)))\n       (not (set-member? \"he\" (ac-state-output root))))) (equal? (let ([states (build-trie '())]) (= (vector-length states) 1)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "build-trie"], "split": "eval"}
{"id": "query_aho_corasick_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `find-fail` in `lattice/query/aho-corasick.ss`.\nKnown issue: At root fallback, find-fail must still check root transitions before returning 0.\n\n```scheme\n(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        0\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) he)\n(let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [s (dict-lookup #\\s (ac-state-trans root))] [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))] [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))] [ff1 (and sh (find-fail a sh #\\e))] [ff2 (and sh (find-fail a sh #\\x))] [ff3 (find-fail a 0 #\\h)]) sh)\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0)) #t)\n```", "ground_truth": "(define (find-fail states sid ch)\n  (let* ([state (vector-ref states sid)]\n         [fail-id (ac-state-fail state)])\n    (if (= fail-id 0)\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states 0)))])\n          (if next next 0))\n        (let ([next (dict-lookup ch (ac-state-trans (vector-ref states fail-id)))])\n          (if next\n              next\n              (find-fail states fail-id ch))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"he\" \"she\" \"hers\"))]\n       [root (vector-ref a 0)]\n       [h (dict-lookup #\\h (ac-state-trans root))]\n       [s (dict-lookup #\\s (ac-state-trans root))]\n       [he (and h (dict-lookup #\\e (ac-state-trans (vector-ref a h))))]\n       [sh (and s (dict-lookup #\\h (ac-state-trans (vector-ref a s))))]\n       [ff1 (and sh (find-fail a sh #\\e))]\n       [ff2 (and sh (find-fail a sh #\\x))]\n       [ff3 (find-fail a 0 #\\h)])\n  (and he sh ff1 ff2\n       (= ff1 he)\n       (= ff2 0)\n       (= ff3 h))) (equal? (let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "find-fail"], "split": "eval"}
{"id": "query_aho_corasick_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `search` in `lattice/query/aho-corasick.ss`.\nKnown issue: Match offsets must subtract pattern length to emit start indices, not end positions.\n\n```scheme\n(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (+ pos 1) p))\n                             outputs)\n                        matches))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (length m) 9))\n(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))\n```\n\nRetain public contract while repairing the implementation fault.\n\nIndependent behavior check to satisfy:\n```scheme\n(= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9)\n```", "ground_truth": "(define (search automaton text)\n  (let loop ([chars (string->list text)]\n             [pos 0]\n             [sid 0]\n             [matches '()])\n    (if (null? chars)\n        (reverse matches)\n        (let* ([ch (car chars)]\n               [next-sid (get-next automaton sid ch)]\n               [state (vector-ref automaton next-sid)]\n               [outputs (set->list (ac-state-output state))])\n          (loop (cdr chars)\n                (+ pos 1)\n                next-sid\n                (append (map (lambda (p)\n                               (cons (- (+ pos 1) (string-length p)) p))\n                             outputs)\n                        matches))))))", "verify_expr": "(and (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))]\n       [m (search a \"aaaa\")])\n  (and (= (length m) 9)\n       (= (car (car m)) 0)\n       (if (member '(0 . \"aaa\") m) #t #f)\n       (if (member '(1 . \"aaa\") m) #t #f)\n       (if (member '(3 . \"a\") m) #t #f))) (= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "search"], "split": "eval"}
{"id": "query_aho_corasick_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild trie for ('he' 'she') and return state count.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(= (vector-length (build-trie '(\"he\" \"she\"))) 6)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vector-length (build-trie '(\"he\" \"she\")))", "verify_expr": "(= (vector-length (build-trie '(\"he\" \"she\"))) 6)", "tags": ["tier1", "query", "aho-corasick", "composition", "build-trie", "size"], "split": "eval"}
{"id": "query_aho_corasick_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert pattern 'she' into fresh trie and return whether terminal state output contains 'she'.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she)))))", "verify_expr": "(equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "insert-pattern-mut!", "terminal"], "split": "eval"}
{"id": "query_aho_corasick_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun bfs-mut! over trie ('he' 'she') and return whether she fail-link points to he.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `bfs-mut!`\n- `build-trie`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref states h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (= (ac-state-fail (vector-ref states she)) he)))", "verify_expr": "(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref states h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (= (ac-state-fail (vector-ref states she)) he))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "bfs-mut!", "fail-link"], "split": "eval"}
{"id": "query_aho_corasick_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether root-state find-fail on unknown char z is 0.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0)) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "find-fail", "root-case"], "split": "eval"}
{"id": "query_aho_corasick_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: small integration task across module primitives.\n\nBuild automaton for ('he' 'she') and return whether she state fail-link points to he.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref a sh)))]) (= (ac-state-fail (vector-ref a she)) he)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref a sh)))]) (= (ac-state-fail (vector-ref a she)) he))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref a sh)))]) (= (ac-state-fail (vector-ref a she)) he)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "make-automaton", "fail-link"], "split": "eval"}
{"id": "query_aho_corasick_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: compose existing APIs into one expression.\n\nSearch automaton ('ATG' 'TGA' 'TAG' 'TAA') on 'AAATGATAG' and return whether start/stop codon matches are present.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ATG\" \"TGA\" \"TAG\" \"TAA\"))] [m (search a \"AAATGATAG\")]) (and (if (member '(2 . \"ATG\") m) #t #f) (if (member '(3 . \"TGA\") m) #t #f) (if (member '(6 . \"TAG\") m) #t #f))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (make-automaton '(\"ATG\" \"TGA\" \"TAG\" \"TAA\"))] [m (search a \"AAATGATAG\")]) (and (if (member '(2 . \"ATG\") m) #t #f) (if (member '(3 . \"TGA\") m) #t #f) (if (member '(6 . \"TAG\") m) #t #f)))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"ATG\" \"TGA\" \"TAG\" \"TAA\"))] [m (search a \"AAATGATAG\")]) (and (if (member '(2 . \"ATG\") m) #t #f) (if (member '(3 . \"TGA\") m) #t #f) (if (member '(6 . \"TAG\") m) #t #f))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "search", "dna"], "split": "eval"}
