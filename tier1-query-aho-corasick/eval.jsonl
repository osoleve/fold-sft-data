{"id": "query_aho_corasick_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this Aho-Corasick function in Fold-native Scheme.\n\nTarget module: lattice/query/aho-corasick.ss\nFunction: `get-next`\nSpec: Advance automaton state for one character using transitions plus recursive failure fallback.\n\nWrite exactly one Scheme function definition for `get-next`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nEnsure the definition is production-ready for module integration.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)))", "tags": ["tier1", "query", "aho-corasick", "spec-to-code", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (get-next automaton sid ch)\n  ;; TODO: transition on ch with recursive fallback to failure links\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `get-next`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "skeleton-completion", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `get-next` from this Aho-Corasick contract.\n\nModule: `lattice/query/aho-corasick.ss`\nContract focus: Advance automaton state for one character using transitions plus recursive failure fallback.\n\nRequirements:\n1. Keep the exact function name/signature for `get-next`.\n2. Preserve trie/failure/output semantics.\n3. Return only one complete function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nPrioritize edge-case behavior when specified by the contract.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc)) #t))", "tags": ["tier1", "query", "aho-corasick", "contract-implementation", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_translation_016", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `get-next`.\nReturn only the Scheme definition.\n\n```python\ndef get_next(automaton, sid, ch):\n    nxt = dict_lookup(ch, automaton[sid].trans)\n    if nxt is not None:\n        return nxt\n    if sid == 0:\n        return 0\n    return get_next(automaton, automaton[sid].fail, ch)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))]) (= (get-next a ab #\\x) 0)) #t) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)))", "tags": ["tier1", "query", "aho-corasick", "python-to-scheme", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `get-next`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (get-next* automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next* automaton (ac-state-fail (vector-ref automaton sid)) ch)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nSemantic equivalence is more important than token-level similarity.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc)) #t))", "tags": ["tier1", "query", "aho-corasick", "chez-to-fold", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_translation_018", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this reference implementation into canonical Fold Scheme for `get-next`.\n\nPreserve observable matching behavior exactly.\nKeep the target function name/signature as `get-next`.\nReturn only the final Scheme definition.\n\n```python\ndef get_next(automaton, sid, ch):\n    nxt = dict_lookup(ch, automaton[sid].trans)\n    if nxt is not None:\n        return nxt\n    if sid == 0:\n        return 0\n    return get_next(automaton, automaton[sid].fail, ch)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t) (equal? (let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [a1 (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref a a1)))] [b (dict-lookup #\\b (ac-state-trans root))] [bc (dict-lookup #\\c (ac-state-trans (vector-ref a b)))]) (= (get-next a ab #\\c) bc)) #t))", "tags": ["tier1", "query", "aho-corasick", "reference-translation", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `get-next` in `lattice/query/aho-corasick.ss`.\nKnown issue: Single-step transition must recursively follow failure links, not jump directly to root.\n\n```scheme\n(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        0)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```\n\nCheck 2:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "get-next", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `get-next` in `lattice/query/aho-corasick.ss`.\nKnown issue: Fallback must recurse until a valid transition is found, not return immediate fail-id as next state.\n\n```scheme\n(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (ac-state-fail (vector-ref automaton sid))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sab)\n(let* ([a (make-automaton '(\"ab\" \"bc\"))] [root (vector-ref a 0)] [sa (dict-lookup #\\a (ac-state-trans root))] [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))] [sb (dict-lookup #\\b (ac-state-trans root))] [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))] [n1 (and sab (get-next a sab #\\c))] [n2 (and sab (get-next a sab #\\x))]) sbc)\n```\n\nFix root-cause behavior rather than masking symptoms.\n\nIndependent behavior checks to satisfy:\nCheck 1:\n```scheme\n(equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t)\n```\n\nCheck 2:\n```scheme\n(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h))\n```", "ground_truth": "(define (get-next automaton sid ch)\n  (let ([next (dict-lookup ch (ac-state-trans (vector-ref automaton sid)))])\n    (if next\n        next\n        (if (= sid 0)\n            0\n            (get-next automaton (ac-state-fail (vector-ref automaton sid)) ch)))))", "verify_expr": "(and (let* ([a (make-automaton '(\"ab\" \"bc\"))]\n       [root (vector-ref a 0)]\n       [sa (dict-lookup #\\a (ac-state-trans root))]\n       [sab (and sa (dict-lookup #\\b (ac-state-trans (vector-ref a sa))))]\n       [sb (dict-lookup #\\b (ac-state-trans root))]\n       [sbc (and sb (dict-lookup #\\c (ac-state-trans (vector-ref a sb))))]\n       [n1 (and sab (get-next a sab #\\c))]\n       [n2 (and sab (get-next a sab #\\x))])\n  (and sab sbc n1 n2\n       (= n1 sbc)\n       (= n2 0))) (equal? (let* ([a (make-automaton '(\"he\" \"she\"))]) (= (get-next a 0 #\\x) 0)) #t) (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))]) (= (get-next a 0 #\\h) h)))", "tags": ["tier1", "query", "aho-corasick", "bugfix", "get-next"], "split": "eval"}
{"id": "query_aho_corasick_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "build-trie", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild trie for ('he' 'she') and return state count.\n\nEnsure `build-trie` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(vector-length (build-trie '(\"he\" \"she\")))", "verify_expr": "(= (vector-length (build-trie '(\"he\" \"she\"))) 6)", "tags": ["tier1", "query", "aho-corasick", "composition", "build-trie", "size"], "split": "eval"}
{"id": "query_aho_corasick_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "insert-pattern-mut!", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert pattern 'she' into fresh trie and return whether terminal state output contains 'she'.\n\nEnsure `insert-pattern-mut!` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she)))))", "verify_expr": "(equal? (let* ([states (make-vector 16 #f)] [size 1]) (vector-set! states 0 (make-state 0)) (insert-pattern-mut! \"she\" states (lambda () size) (lambda (n) (set! size n)) 1) (let* ([root (vector-ref states 0)] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (set-member? \"she\" (ac-state-output (vector-ref states she))))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "insert-pattern-mut!", "terminal"], "split": "eval"}
{"id": "query_aho_corasick_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "compute-failures", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun compute-failures for ('ab' 'bc') and return whether fail of state 'ab' points to state 'b'.\n\nEnsure `compute-failures` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b))", "verify_expr": "(equal? (let* ([done (compute-failures (build-trie '(\"ab\" \"bc\")))] [root (vector-ref done 0)] [a (dict-lookup #\\a (ac-state-trans root))] [ab (dict-lookup #\\b (ac-state-trans (vector-ref done a)))] [b (dict-lookup #\\b (ac-state-trans root))]) (= (ac-state-fail (vector-ref done ab)) b)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "compute-failures", "cross-prefix"], "split": "eval"}
{"id": "query_aho_corasick_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "bfs-mut!", "prompt": "Task mode: compose existing APIs into one expression.\n\nRun bfs-mut! over trie ('he' 'she') and return whether she fail-link points to he.\n\nEnsure `bfs-mut!` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `bfs-mut!`\n- `build-trie`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref states h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (= (ac-state-fail (vector-ref states she)) he)))", "verify_expr": "(equal? (let* ([states (build-trie '(\"he\" \"she\"))] [root (vector-ref states 0)] [children (dict-values (ac-state-trans root))] [q (fold-left (lambda (qq child) (queue-enqueue child qq)) queue-empty children)]) (bfs-mut! states q) (let* ([h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref states h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref states s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref states sh)))]) (= (ac-state-fail (vector-ref states she)) he))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "bfs-mut!", "fail-link"], "split": "eval"}
{"id": "query_aho_corasick_composition_020", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "find-fail", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether root-state find-fail on unknown char z is 0.\n\nEnsure `find-fail` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\"))]) (= (find-fail a 0 #\\z) 0)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "find-fail", "root-case"], "split": "eval"}
{"id": "query_aho_corasick_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "make-automaton", "prompt": "Task mode: small integration task across module primitives.\n\nBuild automaton for ('he' 'she') and return whether she state fail-link points to he.\n\nEnsure `make-automaton` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref a sh)))]) (= (ac-state-fail (vector-ref a she)) he))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"he\" \"she\"))] [root (vector-ref a 0)] [h (dict-lookup #\\h (ac-state-trans root))] [he (dict-lookup #\\e (ac-state-trans (vector-ref a h)))] [s (dict-lookup #\\s (ac-state-trans root))] [sh (dict-lookup #\\h (ac-state-trans (vector-ref a s)))] [she (dict-lookup #\\e (ac-state-trans (vector-ref a sh)))]) (= (ac-state-fail (vector-ref a she)) he)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "make-automaton", "fail-link"], "split": "eval"}
{"id": "query_aho_corasick_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: small integration task across module primitives.\n\nSearch automaton ('a' 'aa' 'aaa') on 'aaaa' and return match count.\n\nEnsure `search` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nAvailable functions you may compose:\n- `search`\n- `make-automaton`\n\nPrefer using this API inventory directly instead of re-implementing behavior.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m))", "verify_expr": "(= (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (length m)) 9)", "tags": ["tier1", "query", "aho-corasick", "composition", "search", "overlap-count"], "split": "eval"}
{"id": "query_aho_corasick_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nSearch automaton ('a' 'aa' 'aaa') on 'aaaa' and return whether earliest match position is 0.\n\nEnsure `search` is part of the composed solution.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"a\" \"aa\" \"aaa\"))] [m (search a \"aaaa\")]) (= (car (car m)) 0)) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "search", "ordering"], "split": "eval"}
{"id": "query_aho_corasick_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/query/aho-corasick.ss", "source_test": "lattice/query/test-aho-corasick.ss", "source_function": "search", "prompt": "Task mode: compose existing APIs into one expression.\n\nSearch automaton ('ATG' 'TGA' 'TAG' 'TAA') on 'AAATGATAG' and return whether start/stop codon matches are present.\n\nEnsure `search` is part of the composed solution.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (make-automaton '(\"ATG\" \"TGA\" \"TAG\" \"TAA\"))] [m (search a \"AAATGATAG\")]) (and (if (member '(2 . \"ATG\") m) #t #f) (if (member '(3 . \"TGA\") m) #t #f) (if (member '(6 . \"TAG\") m) #t #f)))", "verify_expr": "(equal? (let* ([a (make-automaton '(\"ATG\" \"TGA\" \"TAG\" \"TAA\"))] [m (search a \"AAATGATAG\")]) (and (if (member '(2 . \"ATG\") m) #t #f) (if (member '(3 . \"TGA\") m) #t #f) (if (member '(6 . \"TAG\") m) #t #f))) #t)", "tags": ["tier1", "query", "aho-corasick", "composition", "search", "dna"], "split": "eval"}
