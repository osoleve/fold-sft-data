{"id": "heap_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-empty?`\nSpec: Return #t iff heap is the empty-heap sentinel.\n\nWrite exactly one Scheme function definition for `heap-empty?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(heap-empty? heap-empty)\n(not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-empty?"], "split": "train"}
{"id": "heap_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-empty? heap)\n  ;; TODO: check empty-heap sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(heap-empty? heap-empty)\n(not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-empty?"], "split": "train"}
{"id": "heap_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `make-heap-node`\nSpec: Construct a node while enforcing leftist rank ordering (larger rank subtree on the left).\n\nWrite exactly one Scheme function definition for `make-heap-node`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "spec-to-code", "make-heap-node"], "split": "train"}
{"id": "heap_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-heap-node value left right)\n  ;; TODO: enforce leftist rank invariant when building a node\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-heap-node`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "make-heap-node"], "split": "train"}
{"id": "heap_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-merge`\nSpec: Merge two min-heaps preserving heap ordering and leftist property.\n\nWrite exactly one Scheme function definition for `heap-merge`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-merge"], "split": "train"}
{"id": "heap_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-merge h1 h2)\n  ;; TODO: merge two min-heaps recursively\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-merge`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-merge"], "split": "train"}
{"id": "heap_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-insert elem heap)\n  ;; TODO: insert by merging a singleton node with heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-insert`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-insert"], "split": "train"}
{"id": "heap_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-min`\nSpec: Remove minimum element from non-empty heap; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-min`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5))\n(guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-delete-min"], "split": "train"}
{"id": "heap_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-min heap)\n  ;; TODO: remove root and merge children; error on empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-min`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5))\n(guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-delete-min"], "split": "train"}
{"id": "heap_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-pop heap)\n  ;; TODO: return (values new-heap min-value)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-pop`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5)))))\n(guard (ex [else #t]) (begin (heap-pop heap-empty) #f))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-pop"], "split": "train"}
{"id": "heap_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-size heap)\n  ;; TODO: count nodes recursively\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-size`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (heap-size heap-empty) 0)\n(= (heap-size (list->heap '(9 2 7 1))) 4)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-size"], "split": "train"}
{"id": "heap_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap->list`\nSpec: Extract all heap elements in ascending order.\n\nWrite exactly one Scheme function definition for `heap->list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap->list"], "split": "train"}
{"id": "heap_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap->list heap)\n  ;; TODO: repeatedly extract min to produce sorted list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap->list`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap->list"], "split": "train"}
{"id": "heap_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? h)\n  (eq? h 'heap-empty))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-empty?"], "split": "train"}
{"id": "heap_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-heap-node`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-node v l r)\n  (let ((rl (heap-rank l))\n        (rr (heap-rank r)))\n    (if (>= rl rr)\n        (heap-node (+ rr 1) v l r)\n        (heap-node (+ rl 1) v r l))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "make-heap-node"], "split": "train"}
{"id": "heap_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-merge`.\nReturn only the Scheme definition.\n\n```python\ndef heap_merge(h1, h2):\n    if heap_empty(h1):\n        return h2\n    if heap_empty(h2):\n        return h1\n    v1 = heap_value(h1)\n    v2 = heap_value(h2)\n    if v1 <= v2:\n        return make_heap_node(v1, heap_left(h1), heap_merge(heap_right(h1), h2))\n    return make_heap_node(v2, heap_left(h2), heap_merge(h1, heap_right(h2)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-merge"], "split": "train"}
{"id": "heap_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-merge`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge0 a b)\n  (cond\n    ((heap-empty? a) b)\n    ((heap-empty? b) a)\n    (else\n      (let ((va (heap-value a))\n            (vb (heap-value b)))\n        (if (<= va vb)\n            (make-heap-node va (heap-left a) (merge0 (heap-right a) b))\n            (make-heap-node vb (heap-left b) (merge0 a (heap-right b))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-merge"], "split": "train"}
{"id": "heap_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-insert`.\nReturn only the Scheme definition.\n\n```python\ndef heap_insert(elem, heap):\n    return heap_merge(heap_node(1, elem, heap_empty_const, heap_empty_const), heap)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-insert"], "split": "train"}
{"id": "heap_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-insert`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (insert0 x h)\n  (heap-merge (heap-node 1 x heap-empty heap-empty) h))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-insert"], "split": "train"}
{"id": "heap_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-delete-min`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 h)\n  (if (heap-empty? h)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left h) (heap-right h))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-delete-min"], "split": "train"}
{"id": "heap_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-pop`.\nReturn only the Scheme definition.\n\n```python\ndef heap_pop(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot pop from empty heap')\n    return (heap_merge(heap_left(heap), heap_right(heap)), heap_value(heap))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5)))))\n(guard (ex [else #t]) (begin (heap-pop heap-empty) #f))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-pop"], "split": "train"}
{"id": "heap_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-pop`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (pop0 h)\n  (if (heap-empty? h)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left h) (heap-right h))\n              (heap-value h))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-pop"], "split": "train"}
{"id": "heap_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-size`.\nReturn only the Scheme definition.\n\n```python\ndef heap_size(heap):\n    if heap_empty(heap):\n        return 0\n    return 1 + heap_size(heap_left(heap)) + heap_size(heap_right(heap))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-size"], "split": "train"}
{"id": "heap_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (size0 h)\n  (if (heap-empty? h)\n      0\n      (+ 1 (size0 (heap-left h)) (size0 (heap-right h)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-size"], "split": "train"}
{"id": "heap_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap->list`.\nReturn only the Scheme definition.\n\n```python\ndef heap_to_list(heap):\n    if heap_empty(heap):\n        return []\n    return [heap_min(heap)] + heap_to_list(heap_delete_min(heap))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9))\n(equal? (heap->list heap-empty) '())\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap->list"], "split": "train"}
{"id": "heap_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap->list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (to-list h)\n  (if (heap-empty? h)\n      '()\n      (cons (heap-min h) (to-list (heap-delete-min h)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9))\n(equal? (heap->list heap-empty) '())\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap->list"], "split": "train"}
{"id": "heap_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Must return #t for heap-empty.\n\n```scheme\n(define (heap-empty? heap)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(heap-empty? heap-empty)\n(not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "train"}
{"id": "heap_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-heap-node` in `lattice/data/heap.ss`.\nKnown issue: Must swap children when right rank exceeds left rank.\n\n```scheme\n(define (make-heap-node value left right)\n  (heap-node (+ 1 (heap-rank right)) value left right))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "bugfix", "make-heap-node"], "split": "train"}
{"id": "heap_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-heap-node` in `lattice/data/heap.ss`.\nKnown issue: Node rank should be based on the right subtree rank after ordering.\n\n```scheme\n(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-l) value left right)\n        (heap-node (+ 1 rank-r) value right left))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "bugfix", "make-heap-node"], "split": "train"}
{"id": "heap_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-merge` in `lattice/data/heap.ss`.\nKnown issue: Merge must handle both non-empty heaps recursively.\n\n```scheme\n(define (heap-merge h1 h2)\n  (if (heap-empty? h1) h2 h1))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-merge"], "split": "train"}
{"id": "heap_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-merge` in `lattice/data/heap.ss`.\nKnown issue: Min-heap merge must keep the smaller root, not the larger one.\n\n```scheme\n(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n      (let ([v1 (heap-value h1)]\n            [v2 (heap-value h2)])\n        (if (>= v1 v2)\n            (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n            (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-merge"], "split": "train"}
{"id": "heap_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-insert` in `lattice/data/heap.ss`.\nKnown issue: Insert must add the new element.\n\n```scheme\n(define (heap-insert elem heap)\n  heap)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-insert"], "split": "train"}
{"id": "heap_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-insert` in `lattice/data/heap.ss`.\nKnown issue: Insert must add elem for non-empty heaps too.\n\n```scheme\n(define (heap-insert elem heap)\n  (if (heap-empty? heap)\n      (heap-node 1 elem heap-empty heap-empty)\n      heap))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-insert"], "split": "train"}
{"id": "heap_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Empty input should raise an error, not silently return heap-empty.\n\n```scheme\n(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (heap-merge (heap-left heap) (heap-right heap))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5))\n(guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-delete-min"], "split": "train"}
{"id": "heap_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-pop` in `lattice/data/heap.ss`.\nKnown issue: Returned heap must remove the top element.\n\n```scheme\n(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values heap (heap-value heap))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5)))))\n(guard (ex [else #t]) (begin (heap-pop heap-empty) #f))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-pop"], "split": "train"}
{"id": "heap_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-pop` in `lattice/data/heap.ss`.\nKnown issue: On empty heap this function must raise an error and preserve return arity.\n\n```scheme\n(define (heap-pop heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-pop"], "split": "train"}
{"id": "heap_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-size` in `lattice/data/heap.ss`.\nKnown issue: Base case for empty heap must be 0 and node count must include current root.\n\n```scheme\n(define (heap-size heap)\n  (if (heap-empty? heap)\n      1\n      (+ (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (heap-size heap-empty) 0)\n(= (heap-size (list->heap '(9 2 7 1))) 4)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-size"], "split": "train"}
{"id": "heap_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-size` in `lattice/data/heap.ss`.\nKnown issue: Size must include both subtrees.\n\n```scheme\n(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-size"], "split": "train"}
{"id": "heap_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap->list` in `lattice/data/heap.ss`.\nKnown issue: Extraction must repeatedly delete min; traversing only right subtree drops elements.\n\n```scheme\n(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-right heap)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "bugfix", "heap->list"], "split": "train"}
{"id": "heap_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether a singleton heap is empty.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (heap-empty? (heap-node 1 9 heap-empty heap-empty)) #f)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap-empty? (heap-node 1 9 heap-empty heap-empty))", "verify_expr": "(equal? (heap-empty? (heap-node 1 9 heap-empty heap-empty)) #f)", "tags": ["tier0", "data", "heap", "composition", "heap-empty?", "direct"], "split": "train"}
{"id": "heap_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate a heap node with children ranked 2 and 1, then return whether left rank is >= right rank.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([l (heap-node 2 10 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [r (heap-node 1 12 heap-empty heap-empty)] [n (make-heap-node 5 l r)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([l (heap-node 2 10 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [r (heap-node 1 12 heap-empty heap-empty)] [n (make-heap-node 5 l r)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))", "verify_expr": "(equal? (let* ([l (heap-node 2 10 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [r (heap-node 1 12 heap-empty heap-empty)] [n (make-heap-node 5 l r)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "direct"], "split": "train"}
{"id": "heap_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild make-heap-node with swapped-rank inputs and return root value.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap-value (make-heap-node 4 (heap-node 1 7 heap-empty heap-empty) (heap-node 2 8 (heap-node 1 9 heap-empty heap-empty) heap-empty)))", "verify_expr": "(equal? (heap-value (make-heap-node 4 (heap-node 1 7 heap-empty heap-empty) (heap-node 2 8 (heap-node 1 9 heap-empty heap-empty) heap-empty))) 4)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "direct"], "split": "train"}
{"id": "heap_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge heaps built from '(1 5 9) and '(2 4 8), then return sorted extraction.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (heap->list (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8)))) '(1 2 4 5 8 9))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap->list (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8))))", "verify_expr": "(equal? (heap->list (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8)))) '(1 2 4 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "direct"], "split": "train"}
{"id": "heap_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: small integration task across module primitives.\n\nMerge heap-empty with a non-empty heap and return heap->list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap->list (heap-merge heap-empty (list->heap '(3 1 2))))", "verify_expr": "(equal? (heap->list (heap-merge heap-empty (list->heap '(3 1 2)))) '(1 2 3))", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "edge-case"], "split": "train"}
{"id": "heap_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: small integration task across module primitives.\n\nInsert 3 into heap from '(7 2 9) and return heap minimum.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (heap-min (heap-insert 3 (list->heap '(7 2 9)))) 2)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap-min (heap-insert 3 (list->heap '(7 2 9))))", "verify_expr": "(equal? (heap-min (heap-insert 3 (list->heap '(7 2 9)))) 2)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "direct"], "split": "train"}
{"id": "heap_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert 6 into heap from '(7 2 9) and return resulting sorted list.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap->list (heap-insert 6 (list->heap '(7 2 9))))", "verify_expr": "(equal? (heap->list (heap-insert 6 (list->heap '(7 2 9)))) '(2 6 7 9))", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "direct"], "split": "train"}
{"id": "heap_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff heap-delete-min on empty heap raises an error.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "edge-case"], "split": "train"}
{"id": "heap_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: small integration task across module primitives.\n\nPop heap from '(10 2 7 5) and return (list popped remaining-list).\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (call-with-values (lambda () (heap-pop (list->heap '(10 2 7 5)))) (lambda (h x) (list x (heap->list h)))) '(2 (5 7 10)))\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (heap-pop (list->heap '(10 2 7 5)))) (lambda (h x) (list x (heap->list h))))", "verify_expr": "(equal? (call-with-values (lambda () (heap-pop (list->heap '(10 2 7 5)))) (lambda (h x) (list x (heap->list h)))) '(2 (5 7 10)))", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "direct"], "split": "train"}
{"id": "heap_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff heap-pop on empty heap raises an error.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (guard (ex [else #t]) (begin (heap-pop heap-empty) #f)) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else #t]) (begin (heap-pop heap-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (heap-pop heap-empty) #f)) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "edge-case"], "split": "train"}
{"id": "heap_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: small integration task across module primitives.\n\nReturn size of heap-empty.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (heap-size heap-empty) 0)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap-size heap-empty)", "verify_expr": "(equal? (heap-size heap-empty) 0)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "direct"], "split": "train"}
{"id": "heap_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn size of heap built from '(9 2 7 1).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap-size (list->heap '(9 2 7 1)))", "verify_expr": "(equal? (heap-size (list->heap '(9 2 7 1))) 4)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "direct"], "split": "train"}
{"id": "heap_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert heap from '(5 2 8 1 9 3) to sorted list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap->list (list->heap '(5 2 8 1 9 3)))", "verify_expr": "(equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap->list", "direct"], "split": "train"}
{"id": "heap_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert heap-empty to list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap->list heap-empty)", "verify_expr": "(equal? (heap->list heap-empty) '())", "tags": ["tier0", "data", "heap", "composition", "heap->list", "direct"], "split": "train"}
{"id": "heap_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that merge minimum equals min of both input minima.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (= (heap-min (heap-merge (list->heap '(4 7 9)) (list->heap '(2 5 8)))) (min (heap-min (list->heap '(4 7 9))) (heap-min (list->heap '(2 5 8))))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (heap-min (heap-merge (list->heap '(4 7 9)) (list->heap '(2 5 8)))) (min (heap-min (list->heap '(4 7 9))) (heap-min (list->heap '(2 5 8)))))", "verify_expr": "(equal? (= (heap-min (heap-merge (list->heap '(4 7 9)) (list->heap '(2 5 8)))) (min (heap-min (list->heap '(4 7 9))) (heap-min (list->heap '(2 5 8))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "property"], "split": "train"}
{"id": "heap_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-insert increases size by one.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (= (heap-size (heap-insert 6 (list->heap '(7 2 9)))) (+ 1 (heap-size (list->heap '(7 2 9))))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (heap-size (heap-insert 6 (list->heap '(7 2 9)))) (+ 1 (heap-size (list->heap '(7 2 9)))))", "verify_expr": "(equal? (= (heap-size (heap-insert 6 (list->heap '(7 2 9)))) (+ 1 (heap-size (list->heap '(7 2 9))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "property"], "split": "train"}
{"id": "heap_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that inserting a smaller element updates heap-min.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (= (heap-min (heap-insert 1 (list->heap '(7 2 9)))) 1) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (heap-min (heap-insert 1 (list->heap '(7 2 9)))) 1)", "verify_expr": "(equal? (= (heap-min (heap-insert 1 (list->heap '(7 2 9)))) 1) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "property"], "split": "train"}
{"id": "heap_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that deleting min decreases size by one for non-empty heap.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([h (list->heap '(6 1 4 2))]) (= (heap-size (heap-delete-min h)) (- (heap-size h) 1))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([h (list->heap '(6 1 4 2))]) (= (heap-size (heap-delete-min h)) (- (heap-size h) 1)))", "verify_expr": "(equal? (let ([h (list->heap '(6 1 4 2))]) (= (heap-size (heap-delete-min h)) (- (heap-size h) 1))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "property"], "split": "train"}
{"id": "heap_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-pop returns heap-min as the popped value.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([h (list->heap '(6 1 4 2))]) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (= x (heap-min h))))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([h (list->heap '(6 1 4 2))]) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (= x (heap-min h)))))", "verify_expr": "(equal? (let ([h (list->heap '(6 1 4 2))]) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (= x (heap-min h))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "property"], "split": "train"}
{"id": "heap_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-size equals length of heap->list.\n\nCompose from existing module functions where appropriate.\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([h (list->heap '(8 3 5 1 9))]) (= (heap-size h) (length (heap->list h)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([h (list->heap '(8 3 5 1 9))]) (= (heap-size h) (length (heap->list h))))", "verify_expr": "(equal? (let ([h (list->heap '(8 3 5 1 9))]) (= (heap-size h) (length (heap->list h)))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "property"], "split": "train"}
{"id": "heap_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild a heap with fold-left inserts from '(5 2 8 1 9 3), then return heap->list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([h (fold-left (lambda (acc x) (heap-insert x acc)) heap-empty '(5 2 8 1 9 3))]) (heap->list h)) '(1 2 3 5 8 9))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([h (fold-left (lambda (acc x) (heap-insert x acc)) heap-empty '(5 2 8 1 9 3))]) (heap->list h))", "verify_expr": "(equal? (let ([h (fold-left (lambda (acc x) (heap-insert x acc)) heap-empty '(5 2 8 1 9 3))]) (heap->list h)) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "fold"], "split": "train"}
{"id": "heap_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: compose existing APIs into one expression.\n\nPop repeatedly from heap '(5 2 8 1 9 3) and collect values.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (let loop ([h (list->heap '(5 2 8 1 9 3))] [acc '()]) (if (heap-empty? h) (reverse acc) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (cons x acc)))))) '(1 2 3 5 8 9))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([h (list->heap '(5 2 8 1 9 3))] [acc '()]) (if (heap-empty? h) (reverse acc) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (cons x acc))))))", "verify_expr": "(equal? (let loop ([h (list->heap '(5 2 8 1 9 3))] [acc '()]) (if (heap-empty? h) (reverse acc) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (cons x acc)))))) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "loop"], "split": "train"}
{"id": "heap_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge two heaps then pop two values and return them as a list.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (heap-merge (list->heap '(7 3 9)) (list->heap '(6 2 8)))]) (call-with-values (lambda () (heap-pop m)) (lambda (h1 a) (call-with-values (lambda () (heap-pop h1)) (lambda (h2 b) (list a b))))))", "verify_expr": "(equal? (let ([m (heap-merge (list->heap '(7 3 9)) (list->heap '(6 2 8)))]) (call-with-values (lambda () (heap-pop m)) (lambda (h1 a) (call-with-values (lambda () (heap-pop h1)) (lambda (h2 b) (list a b)))))) '(2 3))", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "integration"], "split": "train"}
{"id": "heap_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert 0 then delete min; result should match sorted original values.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (heap->list (heap-delete-min (heap-insert 0 (list->heap '(4 2 6 8))))) '(2 4 6 8))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (heap-delete-min (heap-insert 0 (list->heap '(4 2 6 8)))))", "verify_expr": "(equal? (heap->list (heap-delete-min (heap-insert 0 (list->heap '(4 2 6 8))))) '(2 4 6 8))", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "integration"], "split": "train"}
{"id": "heap_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCount how many pops are needed to empty heap '(4 1 3 2).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let loop ([h (list->heap '(4 1 3 2))] [n 0]) (if (heap-empty? h) n (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (+ n 1)))))) 4)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let loop ([h (list->heap '(4 1 3 2))] [n 0]) (if (heap-empty? h) n (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (+ n 1))))))", "verify_expr": "(equal? (let loop ([h (list->heap '(4 1 3 2))] [n 0]) (if (heap-empty? h) n (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (+ n 1)))))) 4)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "loop"], "split": "train"}
{"id": "heap_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that merged heap size matches length of its extracted list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([m (heap-merge (list->heap '(1 4 7)) (list->heap '(2 5 8 9)))]) (= (heap-size m) (length (heap->list m)))) #t)\n```\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (heap-merge (list->heap '(1 4 7)) (list->heap '(2 5 8 9)))]) (= (heap-size m) (length (heap->list m))))", "verify_expr": "(equal? (let ([m (heap-merge (list->heap '(1 4 7)) (list->heap '(2 5 8 9)))]) (= (heap-size m) (length (heap->list m)))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "integration"], "split": "train"}
{"id": "heap_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff make-heap-node output satisfies leftist rank ordering.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))", "verify_expr": "(equal? (let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "property"], "split": "train"}
