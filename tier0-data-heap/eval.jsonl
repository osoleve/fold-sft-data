{"id": "heap_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-insert`\nSpec: Insert elem by merging heap with singleton node.\n\nWrite exactly one Scheme function definition for `heap-insert`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-insert"], "split": "eval"}
{"id": "heap_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-pop`\nSpec: Return two values (new-heap, min-value); raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-pop`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5)))))\n(guard (ex [else #t]) (begin (heap-pop heap-empty) #f))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-pop"], "split": "eval"}
{"id": "heap_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-size`\nSpec: Return the number of nodes in the heap tree.\n\nWrite exactly one Scheme function definition for `heap-size`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(= (heap-size heap-empty) 0)\n(= (heap-size (list->heap '(9 2 7 1))) 4)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-size"], "split": "eval"}
{"id": "heap_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef heap_empty(heap):\n    return heap == 'heap-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-empty?"], "split": "eval"}
{"id": "heap_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-heap-node`.\nReturn only the Scheme definition.\n\n```python\ndef make_heap_node(value, left, right):\n    rank_l = heap_rank(left)\n    rank_r = heap_rank(right)\n    if rank_l >= rank_r:\n        return heap_node(1 + rank_r, value, left, right)\n    return heap_node(1 + rank_l, value, right, left)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "make-heap-node"], "split": "eval"}
{"id": "heap_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-delete-min`.\nReturn only the Scheme definition.\n\n```python\ndef heap_delete_min(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot delete from empty heap')\n    return heap_merge(heap_left(heap), heap_right(heap))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5))\n(guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-delete-min"], "split": "eval"}
{"id": "heap_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Empty heap is represented by the sentinel symbol, not the empty list.\n\n```scheme\n(define (heap-empty? heap)\n  (null? heap))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "eval"}
{"id": "heap_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Deleting min must merge left and right sub-heaps.\n\n```scheme\n(define (heap-delete-min heap)\n  (heap-right heap))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-delete-min"], "split": "eval"}
{"id": "heap_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap->list` in `lattice/data/heap.ss`.\nKnown issue: Non-empty heaps must produce all elements in ascending order.\n\n```scheme\n(define (heap->list heap)\n  '())\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9))\n(equal? (heap->list heap-empty) '())\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "bugfix", "heap->list"], "split": "eval"}
{"id": "heap_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether heap-empty is empty.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap-empty? heap-empty)", "verify_expr": "(equal? (heap-empty? heap-empty) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-empty?", "direct"], "split": "eval"}
{"id": "heap_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt": "Task mode: compose existing APIs into one expression.\n\nDelete minimum from heap built from '(5 1 4 3) and return heap->list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5))\n```\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (heap-delete-min (list->heap '(5 1 4 3))))", "verify_expr": "(equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5))", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "direct"], "split": "eval"}
{"id": "heap_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that merge size equals the sum of input sizes.\n\nSolve with an expression that can be evaluated directly.\n\nTarget properties for your expression:\n```scheme\n(equal? (= (heap-size (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8 10)))) (+ (heap-size (list->heap '(1 5 9))) (heap-size (list->heap '(2 4 8 10))))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (heap-size (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8 10)))) (+ (heap-size (list->heap '(1 5 9))) (heap-size (list->heap '(2 4 8 10)))))", "verify_expr": "(equal? (= (heap-size (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8 10)))) (+ (heap-size (list->heap '(1 5 9))) (heap-size (list->heap '(2 4 8 10))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "property"], "split": "eval"}
{"id": "heap_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that heap->list output is sorted for '(8 3 5 1 9).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nTarget properties for your expression:\n```scheme\n(equal? (let ([xs (heap->list (list->heap '(8 3 5 1 9)))]) (or (null? xs) (null? (cdr xs)) (let loop ([rest (cdr xs)] [prev (car xs)]) (if (null? rest) #t (and (<= prev (car rest)) (loop (cdr rest) (car rest))))))) #t)\n```\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([xs (heap->list (list->heap '(8 3 5 1 9)))]) (or (null? xs) (null? (cdr xs)) (let loop ([rest (cdr xs)] [prev (car xs)]) (if (null? rest) #t (and (<= prev (car rest)) (loop (cdr rest) (car rest)))))))", "verify_expr": "(equal? (let ([xs (heap->list (list->heap '(8 3 5 1 9)))]) (or (null? xs) (null? (cdr xs)) (let loop ([rest (cdr xs)] [prev (car xs)]) (if (null? rest) #t (and (<= prev (car rest)) (loop (cdr rest) (car rest))))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap->list", "property"], "split": "eval"}
{"id": "heap_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt": "Task mode: small integration task across module primitives.\n\nSort '(9 1 5 3 7) by going through list->heap and heap->list.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (list->heap '(9 1 5 3 7)))", "verify_expr": "(equal? (heap->list (list->heap '(9 1 5 3 7))) '(1 3 5 7 9))", "tags": ["tier0", "data", "heap", "composition", "heap->list", "integration"], "split": "eval"}
