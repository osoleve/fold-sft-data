{"id": "heap_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-empty?`\nSpec: Return #t iff heap is the empty-heap sentinel.\n\nWrite exactly one Scheme function definition for `heap-empty?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-empty?`\nSpec: Return #t iff heap is the empty-heap sentinel.\n\nWrite exactly one Scheme function definition for `heap-empty?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-empty?"], "split": "eval"}
{"id": "heap_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-empty? heap)\n  ;; TODO: check empty-heap sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-empty?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-empty? heap)\n  ;; TODO: check empty-heap sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-empty?"], "split": "eval"}
{"id": "heap_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort-by`\nSpec: Sort a list using comparator ordering via custom heap operations.\n\nWrite exactly one Scheme function definition for `heapsort-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort-by`\nSpec: Sort a list using comparator ordering via custom heap operations.\n\nWrite exactly one Scheme function definition for `heapsort-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heapsort-by"], "split": "eval"}
{"id": "heap_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort-by cmp lst)\n  ;; TODO: sort using custom comparator heap pipeline\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort-by cmp lst)\n  ;; TODO: sort using custom comparator heap pipeline\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heapsort-by"], "split": "eval"}
{"id": "heap_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef heap_empty(heap):\n    return heap == 'heap-empty'\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef heap_empty(heap):\n    return heap == 'heap-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-empty?"], "split": "eval"}
{"id": "heap_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? h)\n  (eq? h 'heap-empty))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? h)\n  (eq? h 'heap-empty))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-empty?"], "split": "eval"}
{"id": "heap_translation_031", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heapsort-by`.\nReturn only the Scheme definition.\n\n```python\ndef heapsort_by(cmp, xs):\n    h = list_to_heap_by(cmp, xs)\n    acc = []\n    while not heap_empty(h):\n        acc.append(heap_value(h))\n        h = heap_delete_top_by(cmp, h)\n    return acc\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heapsort-by`.\nReturn only the Scheme definition.\n\n```python\ndef heapsort_by(cmp, xs):\n    h = list_to_heap_by(cmp, xs)\n    acc = []\n    while not heap_empty(h):\n        acc.append(heap_value(h))\n        h = heap_delete_top_by(cmp, h)\n    return acc\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heapsort-by"], "split": "eval"}
{"id": "heap_translation_032", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heapsort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (heapsort-by0 cmp xs)\n  (let loop ((h (list->heap-by cmp xs)) (acc '()))\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h)\n              (cons (heap-value h) acc)))))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heapsort-by`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (heapsort-by0 cmp xs)\n  (let loop ((h (list->heap-by cmp xs)) (acc '()))\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h)\n              (cons (heap-value h) acc)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heapsort-by"], "split": "eval"}
{"id": "heap_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Empty heap is represented by the sentinel symbol, not the empty list.\n\n```scheme\n(define (heap-empty? heap)\n  (null? heap))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Empty heap is represented by the sentinel symbol, not the empty list.\n\n```scheme\n(define (heap-empty? heap)\n  (null? heap))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty heap is represented by the sentinel symbol, not the empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (heap-empty? heap-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "eval"}
{"id": "heap_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Must return #t for heap-empty.\n\n```scheme\n(define (heap-empty? heap)\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Must return #t for heap-empty.\n\n```scheme\n(define (heap-empty? heap)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must return #t for heap-empty.\n\nExpected behavior after patch:\n```scheme\n(let () (heap-empty? heap-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "eval"}
{"id": "heap_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heapsort-by` in `lattice/data/heap.ss`.\nKnown issue: Comparator-based sort must use comparator-aware heap operations.\n\n```scheme\n(define (heapsort-by cmp lst)\n  (heap->list (list->heap lst)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heapsort-by` in `lattice/data/heap.ss`.\nKnown issue: Comparator-based sort must use comparator-aware heap operations.\n\n```scheme\n(define (heapsort-by cmp lst)\n  (heap->list (list->heap lst)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "bugfix", "heapsort-by"], "split": "eval"}
{"id": "heap_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Return whether heap-empty is empty.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether heap-empty is empty.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap-empty? heap-empty)", "verify_expr": "(equal? (heap-empty? heap-empty) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-empty?", "direct"], "split": "eval"}
{"id": "heap_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Insert 3 into heap from '(7 2 9) and return heap minimum.", "prompt": "Task mode: small integration task across module primitives.\n\nInsert 3 into heap from '(7 2 9) and return heap minimum.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap-min (heap-insert 3 (list->heap '(7 2 9))))", "verify_expr": "(equal? (heap-min (heap-insert 3 (list->heap '(7 2 9)))) 2)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "direct"], "split": "eval"}
{"id": "heap_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Return #t iff heap-pop on empty heap raises an error.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff heap-pop on empty heap raises an error.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else #t]) (begin (heap-pop heap-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (heap-pop heap-empty) #f)) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "edge-case"], "split": "eval"}
{"id": "heap_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Check that merge minimum equals min of both input minima.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that merge minimum equals min of both input minima.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (heap-min (heap-merge (list->heap '(4 7 9)) (list->heap '(2 5 8)))) (min (heap-min (list->heap '(4 7 9))) (heap-min (list->heap '(2 5 8)))))", "verify_expr": "(equal? (= (heap-min (heap-merge (list->heap '(4 7 9)) (list->heap '(2 5 8)))) (min (heap-min (list->heap '(4 7 9))) (heap-min (list->heap '(2 5 8))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "property"], "split": "eval"}
{"id": "heap_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Check that heap-size equals length of heap->list.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-size equals length of heap->list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([h (list->heap '(8 3 5 1 9))]) (= (heap-size h) (length (heap->list h))))", "verify_expr": "(equal? (let ([h (list->heap '(8 3 5 1 9))]) (= (heap-size h) (length (heap->list h)))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "property"], "split": "eval"}
{"id": "heap_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Insert 0 then delete min; result should match sorted original values.", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert 0 then delete min; result should match sorted original values.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (heap-delete-min (heap-insert 0 (list->heap '(4 2 6 8)))))", "verify_expr": "(equal? (heap->list (heap-delete-min (heap-insert 0 (list->heap '(4 2 6 8))))) '(2 4 6 8))", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "integration"], "split": "eval"}
{"id": "heap_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Return #t iff make-heap-node output satisfies leftist rank ordering.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff make-heap-node output satisfies leftist rank ordering.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))", "verify_expr": "(equal? (let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "property"], "split": "eval"}
{"id": "heap_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Sort '(9 1 5 3 7) by going through list->heap and heap->list.", "prompt": "Task mode: small integration task across module primitives.\n\nSort '(9 1 5 3 7) by going through list->heap and heap->list.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (list->heap '(9 1 5 3 7)))", "verify_expr": "(equal? (heap->list (list->heap '(9 1 5 3 7))) '(1 3 5 7 9))", "tags": ["tier0", "data", "heap", "composition", "heap->list", "integration"], "split": "eval"}
{"id": "heap_composition_033", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-min", "prompt_body": "Read minimum element from a non-empty heap.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRead minimum element from a non-empty heap.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap-min (list->heap '(5 2 8 1)))", "verify_expr": "(equal? (heap-min (list->heap '(5 2 8 1))) 1)", "tags": ["tier0", "data", "heap", "composition", "heap-min", "direct"], "split": "eval"}
{"id": "heap_composition_034", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge-by", "prompt_body": "Merge two max-heaps with comparator > and pop in order.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge two max-heaps with comparator > and pop in order.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([h (heap-merge-by > (list->heap-by > '(7 3)) (list->heap-by > '(6 2)))] [acc '()]) (if (heap-empty? h) (reverse acc) (loop (heap-delete-top-by > h) (cons (heap-value h) acc))))", "verify_expr": "(equal? (let loop ([h (heap-merge-by > (list->heap-by > '(7 3)) (list->heap-by > '(6 2)))] [acc '()]) (if (heap-empty? h) (reverse acc) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))) '(7 6 3 2))", "tags": ["tier0", "data", "heap", "composition", "heap-merge-by", "comparator"], "split": "eval"}
{"id": "heap_composition_035", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert-by", "prompt_body": "Insert with comparator > and check top value.", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert with comparator > and check top value.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap-value (heap-insert-by > 9 (list->heap-by > '(5 7 2))))", "verify_expr": "(equal? (heap-value (heap-insert-by > 9 (list->heap-by > '(5 7 2)))) 9)", "tags": ["tier0", "data", "heap", "composition", "heap-insert-by", "comparator"], "split": "eval"}
{"id": "heap_composition_036", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-top-by", "prompt_body": "Delete top element with comparator > and inspect next top.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDelete top element with comparator > and inspect next top.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (list (heap-value h) (heap-value h2) (heap-size h2)))", "verify_expr": "(equal? (let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (list (heap-value h) (heap-value h2) (heap-size h2))) '(7 4 3))", "tags": ["tier0", "data", "heap", "composition", "heap-delete-top-by", "comparator"], "split": "eval"}
{"id": "heap_composition_037", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-fold", "prompt_body": "Fold heap values into a sum.", "prompt": "Task mode: small integration task across module primitives.\n\nFold heap values into a sum.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap-fold (lambda (acc x) (+ acc x)) 0 (list->heap '(5 1 4 3)))", "verify_expr": "(equal? (heap-fold (lambda (acc x) (+ acc x)) 0 (list->heap '(5 1 4 3))) 13)", "tags": ["tier0", "data", "heap", "composition", "heap-fold", "direct"], "split": "eval"}
{"id": "heap_composition_038", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "list->heap-by", "prompt_body": "Build comparator heap and extract descending order.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild comparator heap and extract descending order.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (reverse acc) (loop (heap-delete-top-by > h) (cons (heap-value h) acc))))", "verify_expr": "(equal? (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (reverse acc) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))) '(7 6 4 3))", "tags": ["tier0", "data", "heap", "composition", "list->heap-by", "comparator"], "split": "eval"}
{"id": "heap_composition_039", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort", "prompt_body": "Sort list with heapsort.", "prompt": "Task mode: compose existing APIs into one expression.\n\nSort list with heapsort.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heapsort '(9 1 5 3 7))", "verify_expr": "(equal? (heapsort '(9 1 5 3 7)) '(1 3 5 7 9))", "tags": ["tier0", "data", "heap", "composition", "heapsort", "direct"], "split": "eval"}
