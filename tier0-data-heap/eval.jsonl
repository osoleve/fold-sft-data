{"id": "heap_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-empty?`\nSpec: Return #t iff heap is the empty-heap sentinel.\n\nWrite exactly one Scheme function definition for `heap-empty?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-empty?`\nSpec: Return #t iff heap is the empty-heap sentinel.\n\nWrite exactly one Scheme function definition for `heap-empty?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-empty?"], "split": "eval"}
{"id": "heap_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-empty? heap)\n  ;; TODO: check empty-heap sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-empty?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-empty? heap)\n  ;; TODO: check empty-heap sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-empty?"], "split": "eval"}
{"id": "heap_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-min", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-min`\nSpec: Return minimum element at root; raise an error for empty heap.\n\nWrite exactly one Scheme function definition for `heap-min`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-min`\nSpec: Return minimum element at root; raise an error for empty heap.\n\nWrite exactly one Scheme function definition for `heap-min`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define heap-empty 'heap-empty)\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (and (= (heap-min (list->heap '(5 1 4))) 1) (guard (ex [else #t]) (begin (heap-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-min"], "split": "eval"}
{"id": "heap_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-min", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-min heap)\n  ;; TODO: return root value and error on empty heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-min`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-min heap)\n  ;; TODO: return root value and error on empty heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-min`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (heap-min (list->heap '(5 1 4))) 1))\n(let () (guard (ex [else #t]) (begin (heap-min heap-empty) #f)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define heap-empty 'heap-empty)\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (and (= (heap-min (list->heap '(5 1 4))) 1) (guard (ex [else #t]) (begin (heap-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-min"], "split": "eval"}
{"id": "heap_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-min`\nSpec: Remove minimum element from non-empty heap; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-min`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-min`\nSpec: Remove minimum element from non-empty heap; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-min`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-delete-min"], "split": "eval"}
{"id": "heap_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-min heap)\n  ;; TODO: remove root and merge children; error on empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-min`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-min heap)\n  ;; TODO: remove root and merge children; error on empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-min`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-delete-min"], "split": "eval"}
{"id": "heap_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-merge-by`\nSpec: Merge two heaps using comparator `(cmp a b)` deciding which root wins.\n\nWrite exactly one Scheme function definition for `heap-merge-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-merge-by`\nSpec: Merge two heaps using comparator `(cmp a b)` deciding which root wins.\n\nWrite exactly one Scheme function definition for `heap-merge-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-merge-by"], "split": "eval"}
{"id": "heap_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-merge-by cmp h1 h2)\n  ;; TODO: merge with custom comparator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-merge-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-merge-by cmp h1 h2)\n  ;; TODO: merge with custom comparator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-merge-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-merge-by"], "split": "eval"}
{"id": "heap_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-insert-by`\nSpec: Insert with custom comparator by merging a singleton heap.\n\nWrite exactly one Scheme function definition for `heap-insert-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-insert-by`\nSpec: Insert with custom comparator by merging a singleton heap.\n\nWrite exactly one Scheme function definition for `heap-insert-by`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-insert-by"], "split": "eval"}
{"id": "heap_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-insert-by cmp elem heap)\n  ;; TODO: insert using heap-merge-by\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-insert-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-insert-by cmp elem heap)\n  ;; TODO: insert using heap-merge-by\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-insert-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-insert-by"], "split": "eval"}
{"id": "heap_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-top-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-top-by`\nSpec: Delete comparator-defined top element; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-top-by`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-top-by`\nSpec: Delete comparator-defined top element; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-top-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (and (= (heap-value h) 7) (= (heap-value h2) 4) (= (heap-size h2) 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (and (= (heap-value h) 7) (= (heap-value h2) 4) (= (heap-size h2) 3))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-delete-top-by"], "split": "eval"}
{"id": "heap_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-top-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-top-by cmp heap)\n  ;; TODO: delete comparator-defined top element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-top-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-top-by cmp heap)\n  ;; TODO: delete comparator-defined top element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-top-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (and (= (heap-value h) 7) (= (heap-value h2) 4) (= (heap-size h2) 3))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-delete-top-by"], "split": "eval"}
{"id": "heap_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-fold", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-fold`\nSpec: Fold all heap values with an accumulator function.\n\nWrite exactly one Scheme function definition for `heap-fold`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-fold`\nSpec: Fold all heap values with an accumulator function.\n\nWrite exactly one Scheme function definition for `heap-fold`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))\n  (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-fold"], "split": "eval"}
{"id": "heap_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-fold", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-fold fn init heap)\n  ;; TODO: fold all heap elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-fold`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-fold fn init heap)\n  ;; TODO: fold all heap elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-fold`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))\n  (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-fold"], "split": "eval"}
{"id": "heap_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "list->heap-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `list->heap-by`\nSpec: Build a heap from list using a custom comparator.\n\nWrite exactly one Scheme function definition for `list->heap-by`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `list->heap-by`\nSpec: Build a heap from list using a custom comparator.\n\nWrite exactly one Scheme function definition for `list->heap-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "list->heap-by"], "split": "eval"}
{"id": "heap_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "list->heap-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (list->heap-by cmp lst)\n  ;; TODO: build heap with comparator-aware inserts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `list->heap-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (list->heap-by cmp lst)\n  ;; TODO: build heap with comparator-aware inserts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `list->heap-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "list->heap-by"], "split": "eval"}
{"id": "heap_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort`\nSpec: Sort a list in ascending order via heap extraction.\n\nWrite exactly one Scheme function definition for `heapsort`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort`\nSpec: Sort a list in ascending order via heap extraction.\n\nWrite exactly one Scheme function definition for `heapsort`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heapsort lst)\n  (heap->list (list->heap lst)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heapsort lst)\n  (heap->list (list->heap lst)))\n  (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heapsort"], "split": "eval"}
{"id": "heap_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort lst)\n  ;; TODO: sort ascending using heap->list and list->heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort lst)\n  ;; TODO: sort ascending using heap->list and list->heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heapsort lst)\n  (heap->list (list->heap lst)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heapsort lst)\n  (heap->list (list->heap lst)))\n  (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heapsort"], "split": "eval"}
{"id": "heap_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort-by`\nSpec: Sort a list using comparator ordering via custom heap operations.\n\nWrite exactly one Scheme function definition for `heapsort-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort-by`\nSpec: Sort a list using comparator ordering via custom heap operations.\n\nWrite exactly one Scheme function definition for `heapsort-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heapsort-by"], "split": "eval"}
{"id": "heap_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort-by cmp lst)\n  ;; TODO: sort using custom comparator heap pipeline\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort-by cmp lst)\n  ;; TODO: sort using custom comparator heap pipeline\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heapsort-by"], "split": "eval"}
{"id": "heap_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef heap_empty(heap):\n    return heap == 'heap-empty'\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef heap_empty(heap):\n    return heap == 'heap-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-empty?"], "split": "eval"}
{"id": "heap_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? h)\n  (eq? h 'heap-empty))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? h)\n  (eq? h 'heap-empty))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-empty?"], "split": "eval"}
{"id": "heap_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-delete-min`.\nReturn only the Scheme definition.\n\n```python\ndef heap_delete_min(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot delete from empty heap')\n    return heap_merge(heap_left(heap), heap_right(heap))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-delete-min`.\nReturn only the Scheme definition.\n\n```python\ndef heap_delete_min(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot delete from empty heap')\n    return heap_merge(heap_left(heap), heap_right(heap))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-delete-min"], "split": "eval"}
{"id": "heap_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-delete-min`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 h)\n  (if (heap-empty? h)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left h) (heap-right h))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-delete-min`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 h)\n  (if (heap-empty? h)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left h) (heap-right h))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-delete-min"], "split": "eval"}
{"id": "heap_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Empty heap is represented by the sentinel symbol, not the empty list.\n\n```scheme\n(define (heap-empty? heap)\n  (null? heap))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Empty heap is represented by the sentinel symbol, not the empty list.\n\n```scheme\n(define (heap-empty? heap)\n  (null? heap))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty heap is represented by the sentinel symbol, not the empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (heap-empty? heap-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "eval"}
{"id": "heap_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Must return #t for heap-empty.\n\n```scheme\n(define (heap-empty? heap)\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Must return #t for heap-empty.\n\n```scheme\n(define (heap-empty? heap)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must return #t for heap-empty.\n\nExpected behavior after patch:\n```scheme\n(let () (heap-empty? heap-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "eval"}
{"id": "heap_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Deleting min must merge left and right sub-heaps.\n\n```scheme\n(define (heap-delete-min heap)\n  (heap-right heap))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Deleting min must merge left and right sub-heaps.\n\n```scheme\n(define (heap-delete-min heap)\n  (heap-right heap))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-delete-min"], "split": "eval"}
{"id": "heap_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Empty input should raise an error, not silently return heap-empty.\n\n```scheme\n(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (heap-merge (heap-left heap) (heap-right heap))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Empty input should raise an error, not silently return heap-empty.\n\n```scheme\n(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (heap-merge (heap-left heap) (heap-right heap))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Empty input should raise an error, not silently return heap-empty.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-delete-min"], "split": "eval"}
{"id": "heap_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Insert 3 into heap from '(7 2 9) and return heap minimum.", "prompt": "Task mode: small integration task across module primitives.\n\nInsert 3 into heap from '(7 2 9) and return heap minimum.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap-min (heap-insert 3 (list->heap '(7 2 9))))", "verify_expr": "(equal? (heap-min (heap-insert 3 (list->heap '(7 2 9)))) 2)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "direct"], "split": "eval"}
{"id": "heap_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Return size of heap-empty.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn size of heap-empty.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap-size heap-empty)", "verify_expr": "(equal? (heap-size heap-empty) 0)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "direct"], "split": "eval"}
{"id": "heap_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Pop repeatedly from heap '(5 2 8 1 9 3) and collect values.", "prompt": "Task mode: compose existing APIs into one expression.\n\nPop repeatedly from heap '(5 2 8 1 9 3) and collect values.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([h (list->heap '(5 2 8 1 9 3))] [acc '()]) (if (heap-empty? h) (reverse acc) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (cons x acc))))))", "verify_expr": "(equal? (let loop ([h (list->heap '(5 2 8 1 9 3))] [acc '()]) (if (heap-empty? h) (reverse acc) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (cons x acc)))))) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "loop"], "split": "eval"}
{"id": "heap_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Merge two heaps then pop two values and return them as a list.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge two heaps then pop two values and return them as a list.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (heap-merge (list->heap '(7 3 9)) (list->heap '(6 2 8)))]) (call-with-values (lambda () (heap-pop m)) (lambda (h1 a) (call-with-values (lambda () (heap-pop h1)) (lambda (h2 b) (list a b))))))", "verify_expr": "(equal? (let ([m (heap-merge (list->heap '(7 3 9)) (list->heap '(6 2 8)))]) (call-with-values (lambda () (heap-pop m)) (lambda (h1 a) (call-with-values (lambda () (heap-pop h1)) (lambda (h2 b) (list a b)))))) '(2 3))", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "integration"], "split": "eval"}
{"id": "heap_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Return #t iff make-heap-node output satisfies leftist rank ordering.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff make-heap-node output satisfies leftist rank ordering.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))", "verify_expr": "(equal? (let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "property"], "split": "eval"}
{"id": "heap_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Sort '(9 1 5 3 7) by going through list->heap and heap->list.", "prompt": "Task mode: small integration task across module primitives.\n\nSort '(9 1 5 3 7) by going through list->heap and heap->list.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (list->heap '(9 1 5 3 7)))", "verify_expr": "(equal? (heap->list (list->heap '(9 1 5 3 7))) '(1 3 5 7 9))", "tags": ["tier0", "data", "heap", "composition", "heap->list", "integration"], "split": "eval"}
