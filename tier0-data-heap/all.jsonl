{"id": "heap_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-empty?`\nSpec: Return #t iff heap is the empty-heap sentinel.\n\nWrite exactly one Scheme function definition for `heap-empty?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-empty?`\nSpec: Return #t iff heap is the empty-heap sentinel.\n\nWrite exactly one Scheme function definition for `heap-empty?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-empty?"], "split": "eval"}
{"id": "heap_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-empty? heap)\n  ;; TODO: check empty-heap sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-empty?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-empty? heap)\n  ;; TODO: check empty-heap sentinel\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-empty?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-empty?"], "split": "eval"}
{"id": "heap_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `make-heap-node`\nSpec: Construct a node while enforcing leftist rank ordering (larger rank subtree on the left).\n\nWrite exactly one Scheme function definition for `make-heap-node`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `make-heap-node`\nSpec: Construct a node while enforcing leftist rank ordering (larger rank subtree on the left).\n\nWrite exactly one Scheme function definition for `make-heap-node`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "spec-to-code", "make-heap-node"], "split": "train"}
{"id": "heap_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-heap-node value left right)\n  ;; TODO: enforce leftist rank invariant when building a node\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-heap-node`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-heap-node value left right)\n  ;; TODO: enforce leftist rank invariant when building a node\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-heap-node`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "make-heap-node"], "split": "train"}
{"id": "heap_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-merge`\nSpec: Merge two min-heaps preserving heap ordering and leftist property.\n\nWrite exactly one Scheme function definition for `heap-merge`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-merge`\nSpec: Merge two min-heaps preserving heap ordering and leftist property.\n\nWrite exactly one Scheme function definition for `heap-merge`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-merge"], "split": "train"}
{"id": "heap_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-merge h1 h2)\n  ;; TODO: merge two min-heaps recursively\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-merge`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-merge h1 h2)\n  ;; TODO: merge two min-heaps recursively\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-merge`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-merge"], "split": "train"}
{"id": "heap_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-insert`\nSpec: Insert elem by merging heap with singleton node.\n\nWrite exactly one Scheme function definition for `heap-insert`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-insert`\nSpec: Insert elem by merging heap with singleton node.\n\nWrite exactly one Scheme function definition for `heap-insert`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-insert"], "split": "train"}
{"id": "heap_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-insert elem heap)\n  ;; TODO: insert by merging a singleton node with heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-insert`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-insert elem heap)\n  ;; TODO: insert by merging a singleton node with heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-insert`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-insert"], "split": "train"}
{"id": "heap_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-min", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-min`\nSpec: Return minimum element at root; raise an error for empty heap.\n\nWrite exactly one Scheme function definition for `heap-min`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-min`\nSpec: Return minimum element at root; raise an error for empty heap.\n\nWrite exactly one Scheme function definition for `heap-min`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define heap-empty 'heap-empty)\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (and (= (heap-min (list->heap '(5 1 4))) 1) (guard (ex [else #t]) (begin (heap-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-min"], "split": "eval"}
{"id": "heap_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-min", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-min heap)\n  ;; TODO: return root value and error on empty heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-min`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-min heap)\n  ;; TODO: return root value and error on empty heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-min`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (heap-min (list->heap '(5 1 4))) 1))\n(let () (guard (ex [else #t]) (begin (heap-min heap-empty) #f)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define heap-empty 'heap-empty)\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (and (= (heap-min (list->heap '(5 1 4))) 1) (guard (ex [else #t]) (begin (heap-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-min"], "split": "eval"}
{"id": "heap_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-min`\nSpec: Remove minimum element from non-empty heap; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-min`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-min`\nSpec: Remove minimum element from non-empty heap; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-min`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-delete-min"], "split": "eval"}
{"id": "heap_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-min heap)\n  ;; TODO: remove root and merge children; error on empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-min`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-min heap)\n  ;; TODO: remove root and merge children; error on empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-min`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-delete-min"], "split": "eval"}
{"id": "heap_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-pop`\nSpec: Return two values (new-heap, min-value); raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-pop`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-pop`\nSpec: Return two values (new-heap, min-value); raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-pop`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-pop"], "split": "train"}
{"id": "heap_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-pop heap)\n  ;; TODO: return (values new-heap min-value)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-pop`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-pop heap)\n  ;; TODO: return (values new-heap min-value)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-pop`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))))\n(let () (guard (ex [else #t]) (begin (heap-pop heap-empty) #f)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-pop"], "split": "train"}
{"id": "heap_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-size`\nSpec: Return the number of nodes in the heap tree.\n\nWrite exactly one Scheme function definition for `heap-size`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-size`\nSpec: Return the number of nodes in the heap tree.\n\nWrite exactly one Scheme function definition for `heap-size`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (heap-size heap-empty) 0))\n(let () (= (heap-size (list->heap '(9 2 7 1))) 4))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-size"], "split": "train"}
{"id": "heap_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-size heap)\n  ;; TODO: count nodes recursively\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-size`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-size heap)\n  ;; TODO: count nodes recursively\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-size`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (heap-size heap-empty) 0))\n(let () (= (heap-size (list->heap '(9 2 7 1))) 4))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-size"], "split": "train"}
{"id": "heap_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-merge-by`\nSpec: Merge two heaps using comparator `(cmp a b)` deciding which root wins.\n\nWrite exactly one Scheme function definition for `heap-merge-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-merge-by`\nSpec: Merge two heaps using comparator `(cmp a b)` deciding which root wins.\n\nWrite exactly one Scheme function definition for `heap-merge-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-merge-by"], "split": "eval"}
{"id": "heap_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-merge-by cmp h1 h2)\n  ;; TODO: merge with custom comparator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-merge-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-merge-by cmp h1 h2)\n  ;; TODO: merge with custom comparator\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-merge-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (let loop ([h (heap-merge-by > (list->heap-by > '(3 7)) (list->heap-by > '(4 6)))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-merge-by"], "split": "eval"}
{"id": "heap_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-insert-by`\nSpec: Insert with custom comparator by merging a singleton heap.\n\nWrite exactly one Scheme function definition for `heap-insert-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-insert-by`\nSpec: Insert with custom comparator by merging a singleton heap.\n\nWrite exactly one Scheme function definition for `heap-insert-by`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-insert-by"], "split": "eval"}
{"id": "heap_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-insert-by cmp elem heap)\n  ;; TODO: insert using heap-merge-by\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-insert-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-insert-by cmp elem heap)\n  ;; TODO: insert using heap-merge-by\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-insert-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert-by > 9 (list->heap-by > '(3 7 4)))]) (and (= (heap-value h) 9) (= (heap-size h) 4))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-insert-by"], "split": "eval"}
{"id": "heap_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-top-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-top-by`\nSpec: Delete comparator-defined top element; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-top-by`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-delete-top-by`\nSpec: Delete comparator-defined top element; raise an error on empty heap.\n\nWrite exactly one Scheme function definition for `heap-delete-top-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (and (= (heap-value h) 7) (= (heap-value h2) 4) (= (heap-size h2) 3))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (and (= (heap-value h) 7) (= (heap-value h2) 4) (= (heap-size h2) 3))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-delete-top-by"], "split": "eval"}
{"id": "heap_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-top-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-top-by cmp heap)\n  ;; TODO: delete comparator-defined top element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-top-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-delete-top-by cmp heap)\n  ;; TODO: delete comparator-defined top element\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-delete-top-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (let* ([h (list->heap-by > '(4 1 7 3))] [h2 (heap-delete-top-by > h)]) (and (= (heap-value h) 7) (= (heap-value h2) 4) (= (heap-size h2) 3))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-delete-top-by"], "split": "eval"}
{"id": "heap_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-fold", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-fold`\nSpec: Fold all heap values with an accumulator function.\n\nWrite exactly one Scheme function definition for `heap-fold`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap-fold`\nSpec: Fold all heap values with an accumulator function.\n\nWrite exactly one Scheme function definition for `heap-fold`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))\n  (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap-fold"], "split": "eval"}
{"id": "heap_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-fold", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-fold fn init heap)\n  ;; TODO: fold all heap elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-fold`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap-fold fn init heap)\n  ;; TODO: fold all heap elements\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap-fold`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-fold fn init heap)\n  (if (heap-empty? heap)\n      init\n      (let* ([acc (fn init (heap-value heap))]\n             [acc-right (heap-fold fn acc (heap-right heap))])\n        (heap-fold fn acc-right (heap-left heap)))))\n  (let ([h (list->heap '(5 1 4 3))]) (and (= (heap-fold (lambda (acc x) (+ acc x)) 0 h) 13) (= (heap-fold (lambda (acc x) (+ acc 1)) 0 h) 4))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap-fold"], "split": "eval"}
{"id": "heap_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "list->heap-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `list->heap-by`\nSpec: Build a heap from list using a custom comparator.\n\nWrite exactly one Scheme function definition for `list->heap-by`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `list->heap-by`\nSpec: Build a heap from list using a custom comparator.\n\nWrite exactly one Scheme function definition for `list->heap-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "spec-to-code", "list->heap-by"], "split": "eval"}
{"id": "heap_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "list->heap-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (list->heap-by cmp lst)\n  ;; TODO: build heap with comparator-aware inserts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `list->heap-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (list->heap-by cmp lst)\n  ;; TODO: build heap with comparator-aware inserts\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `list->heap-by`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (let loop ([h (list->heap-by > '(3 7 4 6))] [acc '()]) (if (heap-empty? h) (equal? (reverse acc) '(7 6 4 3)) (loop (heap-delete-top-by > h) (cons (heap-value h) acc)))))", "tags": ["tier0", "data", "heap", "skeleton-completion", "list->heap-by"], "split": "eval"}
{"id": "heap_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap->list`\nSpec: Extract all heap elements in ascending order.\n\nWrite exactly one Scheme function definition for `heap->list`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heap->list`\nSpec: Extract all heap elements in ascending order.\n\nWrite exactly one Scheme function definition for `heap->list`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)))\n(let () (equal? (heap->list heap-empty) '()))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "spec-to-code", "heap->list"], "split": "train"}
{"id": "heap_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heap->list heap)\n  ;; TODO: repeatedly extract min to produce sorted list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap->list`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heap->list heap)\n  ;; TODO: repeatedly extract min to produce sorted list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heap->list`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)))\n(let () (equal? (heap->list heap-empty) '()))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heap->list"], "split": "train"}
{"id": "heap_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort`\nSpec: Sort a list in ascending order via heap extraction.\n\nWrite exactly one Scheme function definition for `heapsort`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort`\nSpec: Sort a list in ascending order via heap extraction.\n\nWrite exactly one Scheme function definition for `heapsort`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heapsort lst)\n  (heap->list (list->heap lst)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heapsort lst)\n  (heap->list (list->heap lst)))\n  (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heapsort"], "split": "eval"}
{"id": "heap_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort lst)\n  ;; TODO: sort ascending using heap->list and list->heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort lst)\n  ;; TODO: sort ascending using heap->list and list->heap\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heapsort lst)\n  (heap->list (list->heap lst)))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heapsort lst)\n  (heap->list (list->heap lst)))\n  (equal? (heapsort '(5 2 8 1 2)) '(1 2 2 5 8)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heapsort"], "split": "eval"}
{"id": "heap_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "You are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort-by`\nSpec: Sort a list using comparator ordering via custom heap operations.\n\nWrite exactly one Scheme function definition for `heapsort-by`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nYou are implementing Tier-0 heap code in Fold-native Scheme.\n\nTarget module: lattice/data/heap.ss\nFunction: `heapsort-by`\nSpec: Sort a list using comparator ordering via custom heap operations.\n\nWrite exactly one Scheme function definition for `heapsort-by`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "spec-to-code", "heapsort-by"], "split": "eval"}
{"id": "heap_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heapsort-by", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort-by cmp lst)\n  ;; TODO: sort using custom comparator heap pipeline\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort-by`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (heapsort-by cmp lst)\n  ;; TODO: sort using custom comparator heap pipeline\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `heapsort-by`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge-by cmp h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (cmp v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge-by cmp (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge-by cmp h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert-by cmp elem heap)\n  (heap-merge-by cmp (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap-by cmp lst)\n  (fold-left (lambda (h x) (heap-insert-by cmp x h)) heap-empty lst))\n  (define (heap-delete-top-by cmp heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-top-by \"Cannot delete from empty heap\")\n      (heap-merge-by cmp (heap-left heap) (heap-right heap))))\n  (define (heapsort-by cmp lst)\n  (let loop ([h (list->heap-by cmp lst)] [acc '()])\n    (if (heap-empty? h)\n        (reverse acc)\n        (loop (heap-delete-top-by cmp h) (cons (heap-value h) acc)))))\n  (equal? (heapsort-by > '(5 2 8 1 2)) '(8 5 2 2 1)))", "tags": ["tier0", "data", "heap", "skeleton-completion", "heapsort-by"], "split": "eval"}
{"id": "heap_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef heap_empty(heap):\n    return heap == 'heap-empty'\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-empty?`.\nReturn only the Scheme definition.\n\n```python\ndef heap_empty(heap):\n    return heap == 'heap-empty'\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-empty?"], "split": "eval"}
{"id": "heap_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? h)\n  (eq? h 'heap-empty))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-empty?`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (empty? h)\n  (eq? h 'heap-empty))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-empty?"], "split": "eval"}
{"id": "heap_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-heap-node`.\nReturn only the Scheme definition.\n\n```python\ndef make_heap_node(value, left, right):\n    rank_l = heap_rank(left)\n    rank_r = heap_rank(right)\n    if rank_l >= rank_r:\n        return heap_node(1 + rank_r, value, left, right)\n    return heap_node(1 + rank_l, value, right, left)\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `make-heap-node`.\nReturn only the Scheme definition.\n\n```python\ndef make_heap_node(value, left, right):\n    rank_l = heap_rank(left)\n    rank_r = heap_rank(right)\n    if rank_l >= rank_r:\n        return heap_node(1 + rank_r, value, left, right)\n    return heap_node(1 + rank_l, value, right, left)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "make-heap-node"], "split": "train"}
{"id": "heap_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-heap-node`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-node v l r)\n  (let ((rl (heap-rank l))\n        (rr (heap-rank r)))\n    (if (>= rl rr)\n        (heap-node (+ rr 1) v l r)\n        (heap-node (+ rl 1) v r l))))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `make-heap-node`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (mk-node v l r)\n  (let ((rl (heap-rank l))\n        (rr (heap-rank r)))\n    (if (>= rl rr)\n        (heap-node (+ rr 1) v l r)\n        (heap-node (+ rl 1) v r l))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "make-heap-node"], "split": "train"}
{"id": "heap_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-merge`.\nReturn only the Scheme definition.\n\n```python\ndef heap_merge(h1, h2):\n    if heap_empty(h1):\n        return h2\n    if heap_empty(h2):\n        return h1\n    v1 = heap_value(h1)\n    v2 = heap_value(h2)\n    if v1 <= v2:\n        return make_heap_node(v1, heap_left(h1), heap_merge(heap_right(h1), h2))\n    return make_heap_node(v2, heap_left(h2), heap_merge(h1, heap_right(h2)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-merge`.\nReturn only the Scheme definition.\n\n```python\ndef heap_merge(h1, h2):\n    if heap_empty(h1):\n        return h2\n    if heap_empty(h2):\n        return h1\n    v1 = heap_value(h1)\n    v2 = heap_value(h2)\n    if v1 <= v2:\n        return make_heap_node(v1, heap_left(h1), heap_merge(heap_right(h1), h2))\n    return make_heap_node(v2, heap_left(h2), heap_merge(h1, heap_right(h2)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-merge"], "split": "train"}
{"id": "heap_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-merge`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge0 a b)\n  (cond\n    ((heap-empty? a) b)\n    ((heap-empty? b) a)\n    (else\n      (let ((va (heap-value a))\n            (vb (heap-value b)))\n        (if (<= va vb)\n            (make-heap-node va (heap-left a) (merge0 (heap-right a) b))\n            (make-heap-node vb (heap-left b) (merge0 a (heap-right b))))))))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-merge`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (merge0 a b)\n  (cond\n    ((heap-empty? a) b)\n    ((heap-empty? b) a)\n    (else\n      (let ((va (heap-value a))\n            (vb (heap-value b)))\n        (if (<= va vb)\n            (make-heap-node va (heap-left a) (merge0 (heap-right a) b))\n            (make-heap-node vb (heap-left b) (merge0 a (heap-right b))))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-merge"], "split": "train"}
{"id": "heap_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-insert`.\nReturn only the Scheme definition.\n\n```python\ndef heap_insert(elem, heap):\n    return heap_merge(heap_node(1, elem, heap_empty_const, heap_empty_const), heap)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-insert`.\nReturn only the Scheme definition.\n\n```python\ndef heap_insert(elem, heap):\n    return heap_merge(heap_node(1, elem, heap_empty_const, heap_empty_const), heap)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-insert"], "split": "train"}
{"id": "heap_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-insert`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (insert0 x h)\n  (heap-merge (heap-node 1 x heap-empty heap-empty) h))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-insert`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (insert0 x h)\n  (heap-merge (heap-node 1 x heap-empty heap-empty) h))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-insert"], "split": "train"}
{"id": "heap_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-delete-min`.\nReturn only the Scheme definition.\n\n```python\ndef heap_delete_min(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot delete from empty heap')\n    return heap_merge(heap_left(heap), heap_right(heap))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-delete-min`.\nReturn only the Scheme definition.\n\n```python\ndef heap_delete_min(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot delete from empty heap')\n    return heap_merge(heap_left(heap), heap_right(heap))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-delete-min"], "split": "eval"}
{"id": "heap_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-delete-min`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 h)\n  (if (heap-empty? h)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left h) (heap-right h))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-delete-min`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (delete-min0 h)\n  (if (heap-empty? h)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left h) (heap-right h))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-delete-min"], "split": "eval"}
{"id": "heap_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-pop`.\nReturn only the Scheme definition.\n\n```python\ndef heap_pop(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot pop from empty heap')\n    return (heap_merge(heap_left(heap), heap_right(heap)), heap_value(heap))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-pop`.\nReturn only the Scheme definition.\n\n```python\ndef heap_pop(heap):\n    if heap_empty(heap):\n        raise ValueError('Cannot pop from empty heap')\n    return (heap_merge(heap_left(heap), heap_right(heap)), heap_value(heap))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))))\n(let () (guard (ex [else #t]) (begin (heap-pop heap-empty) #f)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-pop"], "split": "train"}
{"id": "heap_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-pop`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (pop0 h)\n  (if (heap-empty? h)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left h) (heap-right h))\n              (heap-value h))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-pop`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (pop0 h)\n  (if (heap-empty? h)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left h) (heap-right h))\n              (heap-value h))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-pop"], "split": "train"}
{"id": "heap_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-size`.\nReturn only the Scheme definition.\n\n```python\ndef heap_size(heap):\n    if heap_empty(heap):\n        return 0\n    return 1 + heap_size(heap_left(heap)) + heap_size(heap_right(heap))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap-size`.\nReturn only the Scheme definition.\n\n```python\ndef heap_size(heap):\n    if heap_empty(heap):\n        return 0\n    return 1 + heap_size(heap_left(heap)) + heap_size(heap_right(heap))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap-size"], "split": "train"}
{"id": "heap_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (size0 h)\n  (if (heap-empty? h)\n      0\n      (+ 1 (size0 (heap-left h)) (size0 (heap-right h)))))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap-size`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (size0 h)\n  (if (heap-empty? h)\n      0\n      (+ 1 (size0 (heap-left h)) (size0 (heap-right h)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap-size"], "split": "train"}
{"id": "heap_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap->list`.\nReturn only the Scheme definition.\n\n```python\ndef heap_to_list(heap):\n    if heap_empty(heap):\n        return []\n    return [heap_min(heap)] + heap_to_list(heap_delete_min(heap))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use the target function name `heap->list`.\nReturn only the Scheme definition.\n\n```python\ndef heap_to_list(heap):\n    if heap_empty(heap):\n        return []\n    return [heap_min(heap)] + heap_to_list(heap_delete_min(heap))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)))\n(let () (equal? (heap->list heap-empty) '()))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "python-to-scheme", "heap->list"], "split": "train"}
{"id": "heap_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap->list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (to-list h)\n  (if (heap-empty? h)\n      '()\n      (cons (heap-min h) (to-list (heap-delete-min h)))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `heap->list`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (to-list h)\n  (if (heap-empty? h)\n      '()\n      (cons (heap-min h) (to-list (heap-delete-min h)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)))\n(let () (equal? (heap->list heap-empty) '()))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "chez-to-fold", "heap->list"], "split": "train"}
{"id": "heap_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Empty heap is represented by the sentinel symbol, not the empty list.\n\n```scheme\n(define (heap-empty? heap)\n  (null? heap))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Empty heap is represented by the sentinel symbol, not the empty list.\n\n```scheme\n(define (heap-empty? heap)\n  (null? heap))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Empty heap is represented by the sentinel symbol, not the empty list.\n\nExpected behavior after patch:\n```scheme\n(let () (heap-empty? heap-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "eval"}
{"id": "heap_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Must return #t for heap-empty.\n\n```scheme\n(define (heap-empty? heap)\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-empty?` in `lattice/data/heap.ss`.\nKnown issue: Must return #t for heap-empty.\n\n```scheme\n(define (heap-empty? heap)\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must return #t for heap-empty.\n\nExpected behavior after patch:\n```scheme\n(let () (heap-empty? heap-empty))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (heap-empty? heap-empty))\n(let () (not (heap-empty? (heap-node 1 5 heap-empty heap-empty))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-empty? heap)\n  (eq? heap 'heap-empty))", "verify_expr": "(let ()\n  (define heap-empty 'heap-empty)\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (and (heap-empty? heap-empty) (not (heap-empty? (heap-node 1 5 heap-empty heap-empty)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-empty?"], "split": "eval"}
{"id": "heap_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-heap-node` in `lattice/data/heap.ss`.\nKnown issue: Must swap children when right rank exceeds left rank.\n\n```scheme\n(define (make-heap-node value left right)\n  (heap-node (+ 1 (heap-rank right)) value left right))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-heap-node` in `lattice/data/heap.ss`.\nKnown issue: Must swap children when right rank exceeds left rank.\n\n```scheme\n(define (make-heap-node value left right)\n  (heap-node (+ 1 (heap-rank right)) value left right))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Must swap children when right rank exceeds left rank.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "bugfix", "make-heap-node"], "split": "train"}
{"id": "heap_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-heap-node` in `lattice/data/heap.ss`.\nKnown issue: Node rank should be based on the right subtree rank after ordering.\n\n```scheme\n(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-l) value left right)\n        (heap-node (+ 1 rank-r) value right left))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-heap-node` in `lattice/data/heap.ss`.\nKnown issue: Node rank should be based on the right subtree rank after ordering.\n\n```scheme\n(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-l) value left right)\n        (heap-node (+ 1 rank-r) value right left))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Node rank should be based on the right subtree rank after ordering.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define heap-empty 'heap-empty)\n  (define (heap-node? x)\n  (and (pair? x)\n       (eq? (car x) 'heap-node)))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (let* ([l (heap-node 2 4 (heap-node 1 6 heap-empty heap-empty) heap-empty)] [r (heap-node 1 5 heap-empty heap-empty)] [n (make-heap-node 3 l r)]) (and (heap-node? n) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))))", "tags": ["tier0", "data", "heap", "bugfix", "make-heap-node"], "split": "train"}
{"id": "heap_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-merge` in `lattice/data/heap.ss`.\nKnown issue: Merge must handle both non-empty heaps recursively.\n\n```scheme\n(define (heap-merge h1 h2)\n  (if (heap-empty? h1) h2 h1))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-merge` in `lattice/data/heap.ss`.\nKnown issue: Merge must handle both non-empty heaps recursively.\n\n```scheme\n(define (heap-merge h1 h2)\n  (if (heap-empty? h1) h2 h1))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Merge must handle both non-empty heaps recursively.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-merge"], "split": "train"}
{"id": "heap_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-merge` in `lattice/data/heap.ss`.\nKnown issue: Min-heap merge must keep the smaller root, not the larger one.\n\n```scheme\n(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n      (let ([v1 (heap-value h1)]\n            [v2 (heap-value h2)])\n        (if (>= v1 v2)\n            (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n            (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-merge` in `lattice/data/heap.ss`.\nKnown issue: Min-heap merge must keep the smaller root, not the larger one.\n\n```scheme\n(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n      (let ([v1 (heap-value h1)]\n            [v2 (heap-value h2)])\n        (if (>= v1 v2)\n            (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n            (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (equal? (heap->list (heap-merge (list->heap '(5 1 9)) (list->heap '(4 2 8)))) '(1 2 4 5 8 9)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-merge"], "split": "train"}
{"id": "heap_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-insert` in `lattice/data/heap.ss`.\nKnown issue: Insert must add the new element.\n\n```scheme\n(define (heap-insert elem heap)\n  heap)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-insert` in `lattice/data/heap.ss`.\nKnown issue: Insert must add the new element.\n\n```scheme\n(define (heap-insert elem heap)\n  heap)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: Insert must add the new element.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-insert"], "split": "train"}
{"id": "heap_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-insert` in `lattice/data/heap.ss`.\nKnown issue: Insert must add elem for non-empty heaps too.\n\n```scheme\n(define (heap-insert elem heap)\n  (if (heap-empty? heap)\n      (heap-node 1 elem heap-empty heap-empty)\n      heap))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-insert` in `lattice/data/heap.ss`.\nKnown issue: Insert must add elem for non-empty heaps too.\n\n```scheme\n(define (heap-insert elem heap)\n  (if (heap-empty? heap)\n      (heap-node 1 elem heap-empty heap-empty)\n      heap))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Insert must add elem for non-empty heaps too.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define heap-empty 'heap-empty)\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (let ([h (heap-insert 3 (list->heap '(7 2 9)))]) (and (= (heap-min h) 2) (= (heap-size h) 4) (equal? (heap->list h) '(2 3 7 9)))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-insert"], "split": "train"}
{"id": "heap_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Deleting min must merge left and right sub-heaps.\n\n```scheme\n(define (heap-delete-min heap)\n  (heap-right heap))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Deleting min must merge left and right sub-heaps.\n\n```scheme\n(define (heap-delete-min heap)\n  (heap-right heap))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-delete-min"], "split": "eval"}
{"id": "heap_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Empty input should raise an error, not silently return heap-empty.\n\n```scheme\n(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (heap-merge (heap-left heap) (heap-right heap))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-delete-min` in `lattice/data/heap.ss`.\nKnown issue: Empty input should raise an error, not silently return heap-empty.\n\n```scheme\n(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (heap-merge (heap-left heap) (heap-right heap))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Empty input should raise an error, not silently return heap-empty.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)))\n(let () (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (and (equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5)) (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-delete-min"], "split": "eval"}
{"id": "heap_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-pop` in `lattice/data/heap.ss`.\nKnown issue: Returned heap must remove the top element.\n\n```scheme\n(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values heap (heap-value heap))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-pop` in `lattice/data/heap.ss`.\nKnown issue: Returned heap must remove the top element.\n\n```scheme\n(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values heap (heap-value heap))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))))\n(let () (guard (ex [else #t]) (begin (heap-pop heap-empty) #f)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-pop"], "split": "train"}
{"id": "heap_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-pop` in `lattice/data/heap.ss`.\nKnown issue: On empty heap this function must raise an error and preserve return arity.\n\n```scheme\n(define (heap-pop heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-pop` in `lattice/data/heap.ss`.\nKnown issue: On empty heap this function must raise an error and preserve return arity.\n\n```scheme\n(define (heap-pop heap)\n  (if (heap-empty? heap)\n      heap-empty\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-pop heap)\n  (if (heap-empty? heap)\n      (error 'heap-pop \"Cannot pop from empty heap\")\n      (values (heap-merge (heap-left heap) (heap-right heap))\n              (heap-value heap))))\n  (and (call-with-values (lambda () (heap-pop (list->heap '(5 1 4 3)))) (lambda (h x) (and (= x 1) (equal? (heap->list h) '(3 4 5))))) (guard (ex [else #t]) (begin (heap-pop heap-empty) #f))))", "tags": ["tier0", "data", "heap", "bugfix", "heap-pop"], "split": "train"}
{"id": "heap_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-size` in `lattice/data/heap.ss`.\nKnown issue: Base case for empty heap must be 0 and node count must include current root.\n\n```scheme\n(define (heap-size heap)\n  (if (heap-empty? heap)\n      1\n      (+ (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-size` in `lattice/data/heap.ss`.\nKnown issue: Base case for empty heap must be 0 and node count must include current root.\n\n```scheme\n(define (heap-size heap)\n  (if (heap-empty? heap)\n      1\n      (+ (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (heap-size heap-empty) 0))\n(let () (= (heap-size (list->heap '(9 2 7 1))) 4))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-size"], "split": "train"}
{"id": "heap_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-size` in `lattice/data/heap.ss`.\nKnown issue: Size must include both subtrees.\n\n```scheme\n(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap-size` in `lattice/data/heap.ss`.\nKnown issue: Size must include both subtrees.\n\n```scheme\n(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define heap-empty 'heap-empty)\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap-size heap)\n  (if (heap-empty? heap)\n      0\n      (+ 1 (heap-size (heap-left heap)) (heap-size (heap-right heap)))))\n  (and (= (heap-size heap-empty) 0) (= (heap-size (list->heap '(9 2 7 1))) 4)))", "tags": ["tier0", "data", "heap", "bugfix", "heap-size"], "split": "train"}
{"id": "heap_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap->list` in `lattice/data/heap.ss`.\nKnown issue: Extraction must repeatedly delete min; traversing only right subtree drops elements.\n\n```scheme\n(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-right heap)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap->list` in `lattice/data/heap.ss`.\nKnown issue: Extraction must repeatedly delete min; traversing only right subtree drops elements.\n\n```scheme\n(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-right heap)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Extraction must repeatedly delete min; traversing only right subtree drops elements.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "bugfix", "heap->list"], "split": "train"}
{"id": "heap_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap->list` in `lattice/data/heap.ss`.\nKnown issue: Non-empty heaps must produce all elements in ascending order.\n\n```scheme\n(define (heap->list heap)\n  '())\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `heap->list` in `lattice/data/heap.ss`.\nKnown issue: Non-empty heaps must produce all elements in ascending order.\n\n```scheme\n(define (heap->list heap)\n  '())\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Non-empty heaps must produce all elements in ascending order.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)))\n(let () (equal? (heap->list heap-empty) '()))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))", "verify_expr": "(let ()\n  (define (heap-empty? heap)\n  (eq? heap 'heap-empty))\n  (define (heap-value h)\n  (caddr h))\n  (define (heap-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-min \"Cannot get min of empty heap\")\n      (heap-value heap)))\n  (define (heap-rank h)\n  (if (heap-empty? h) 0 (cadr h)))\n  (define (heap-node rank value left right)\n  (list 'heap-node rank value left right))\n  (define (make-heap-node value left right)\n  (let ([rank-l (heap-rank left)]\n        [rank-r (heap-rank right)])\n    (if (>= rank-l rank-r)\n        (heap-node (+ 1 rank-r) value left right)\n        (heap-node (+ 1 rank-l) value right left))))\n  (define (heap-left h)\n  (cadddr h))\n  (define (heap-right h)\n  (car (cddddr h)))\n  (define (heap-merge h1 h2)\n  (cond\n    [(heap-empty? h1) h2]\n    [(heap-empty? h2) h1]\n    [else\n     (let ([v1 (heap-value h1)]\n           [v2 (heap-value h2)])\n       (if (<= v1 v2)\n           (make-heap-node v1 (heap-left h1) (heap-merge (heap-right h1) h2))\n           (make-heap-node v2 (heap-left h2) (heap-merge h1 (heap-right h2)))))]))\n  (define (heap-delete-min heap)\n  (if (heap-empty? heap)\n      (error 'heap-delete-min \"Cannot delete from empty heap\")\n      (heap-merge (heap-left heap) (heap-right heap))))\n  (define heap-empty 'heap-empty)\n  (define (heap-insert elem heap)\n  (heap-merge (heap-node 1 elem heap-empty heap-empty) heap))\n  (define (list->heap lst)\n  (fold-left (lambda (h x) (heap-insert x h)) heap-empty lst))\n  (define (heap->list heap)\n  (if (heap-empty? heap)\n      '()\n      (cons (heap-min heap)\n            (heap->list (heap-delete-min heap)))))\n  (and (equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9)) (equal? (heap->list heap-empty) '())))", "tags": ["tier0", "data", "heap", "bugfix", "heap->list"], "split": "train"}
{"id": "heap_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Return whether heap-empty is empty.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether heap-empty is empty.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap-empty? heap-empty)", "verify_expr": "(equal? (heap-empty? heap-empty) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-empty?", "direct"], "split": "train"}
{"id": "heap_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-empty?", "prompt_body": "Return whether a singleton heap is empty.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether a singleton heap is empty.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap-empty? (heap-node 1 9 heap-empty heap-empty))", "verify_expr": "(equal? (heap-empty? (heap-node 1 9 heap-empty heap-empty)) #f)", "tags": ["tier0", "data", "heap", "composition", "heap-empty?", "direct"], "split": "train"}
{"id": "heap_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Create a heap node with children ranked 2 and 1, then return whether left rank is >= right rank.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate a heap node with children ranked 2 and 1, then return whether left rank is >= right rank.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([l (heap-node 2 10 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [r (heap-node 1 12 heap-empty heap-empty)] [n (make-heap-node 5 l r)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))", "verify_expr": "(equal? (let* ([l (heap-node 2 10 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [r (heap-node 1 12 heap-empty heap-empty)] [n (make-heap-node 5 l r)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "direct"], "split": "train"}
{"id": "heap_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Build make-heap-node with swapped-rank inputs and return root value.", "prompt": "Task mode: compose existing APIs into one expression.\n\nBuild make-heap-node with swapped-rank inputs and return root value.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap-value (make-heap-node 4 (heap-node 1 7 heap-empty heap-empty) (heap-node 2 8 (heap-node 1 9 heap-empty heap-empty) heap-empty)))", "verify_expr": "(equal? (heap-value (make-heap-node 4 (heap-node 1 7 heap-empty heap-empty) (heap-node 2 8 (heap-node 1 9 heap-empty heap-empty) heap-empty))) 4)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "direct"], "split": "train"}
{"id": "heap_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Merge heaps built from '(1 5 9) and '(2 4 8), then return sorted extraction.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge heaps built from '(1 5 9) and '(2 4 8), then return sorted extraction.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap->list (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8))))", "verify_expr": "(equal? (heap->list (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8)))) '(1 2 4 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "direct"], "split": "train"}
{"id": "heap_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Merge heap-empty with a non-empty heap and return heap->list.", "prompt": "Task mode: small integration task across module primitives.\n\nMerge heap-empty with a non-empty heap and return heap->list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap->list (heap-merge heap-empty (list->heap '(3 1 2))))", "verify_expr": "(equal? (heap->list (heap-merge heap-empty (list->heap '(3 1 2)))) '(1 2 3))", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "edge-case"], "split": "train"}
{"id": "heap_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Insert 3 into heap from '(7 2 9) and return heap minimum.", "prompt": "Task mode: small integration task across module primitives.\n\nInsert 3 into heap from '(7 2 9) and return heap minimum.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap-min (heap-insert 3 (list->heap '(7 2 9))))", "verify_expr": "(equal? (heap-min (heap-insert 3 (list->heap '(7 2 9)))) 2)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "direct"], "split": "eval"}
{"id": "heap_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Insert 6 into heap from '(7 2 9) and return resulting sorted list.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nInsert 6 into heap from '(7 2 9) and return resulting sorted list.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap->list (heap-insert 6 (list->heap '(7 2 9))))", "verify_expr": "(equal? (heap->list (heap-insert 6 (list->heap '(7 2 9)))) '(2 6 7 9))", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "direct"], "split": "train"}
{"id": "heap_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Delete minimum from heap built from '(5 1 4 3) and return heap->list.", "prompt": "Task mode: compose existing APIs into one expression.\n\nDelete minimum from heap built from '(5 1 4 3) and return heap->list.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (heap-delete-min (list->heap '(5 1 4 3))))", "verify_expr": "(equal? (heap->list (heap-delete-min (list->heap '(5 1 4 3)))) '(3 4 5))", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "direct"], "split": "train"}
{"id": "heap_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Return #t iff heap-delete-min on empty heap raises an error.", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff heap-delete-min on empty heap raises an error.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (heap-delete-min heap-empty) #f)) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "edge-case"], "split": "train"}
{"id": "heap_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Pop heap from '(10 2 7 5) and return (list popped remaining-list).", "prompt": "Task mode: small integration task across module primitives.\n\nPop heap from '(10 2 7 5) and return (list popped remaining-list).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(call-with-values (lambda () (heap-pop (list->heap '(10 2 7 5)))) (lambda (h x) (list x (heap->list h))))", "verify_expr": "(equal? (call-with-values (lambda () (heap-pop (list->heap '(10 2 7 5)))) (lambda (h x) (list x (heap->list h)))) '(2 (5 7 10)))", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "direct"], "split": "train"}
{"id": "heap_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Return #t iff heap-pop on empty heap raises an error.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff heap-pop on empty heap raises an error.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(guard (ex [else #t]) (begin (heap-pop heap-empty) #f))", "verify_expr": "(equal? (guard (ex [else #t]) (begin (heap-pop heap-empty) #f)) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "edge-case"], "split": "train"}
{"id": "heap_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Return size of heap-empty.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn size of heap-empty.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap-size heap-empty)", "verify_expr": "(equal? (heap-size heap-empty) 0)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "direct"], "split": "eval"}
{"id": "heap_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Return size of heap built from '(9 2 7 1).", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn size of heap built from '(9 2 7 1).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(heap-size (list->heap '(9 2 7 1)))", "verify_expr": "(equal? (heap-size (list->heap '(9 2 7 1))) 4)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "direct"], "split": "train"}
{"id": "heap_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Convert heap from '(5 2 8 1 9 3) to sorted list.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert heap from '(5 2 8 1 9 3) to sorted list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap->list (list->heap '(5 2 8 1 9 3)))", "verify_expr": "(equal? (heap->list (list->heap '(5 2 8 1 9 3))) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap->list", "direct"], "split": "train"}
{"id": "heap_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Convert heap-empty to list.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nConvert heap-empty to list.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(heap->list heap-empty)", "verify_expr": "(equal? (heap->list heap-empty) '())", "tags": ["tier0", "data", "heap", "composition", "heap->list", "direct"], "split": "train"}
{"id": "heap_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Check that merge size equals the sum of input sizes.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that merge size equals the sum of input sizes.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (heap-size (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8 10)))) (+ (heap-size (list->heap '(1 5 9))) (heap-size (list->heap '(2 4 8 10)))))", "verify_expr": "(equal? (= (heap-size (heap-merge (list->heap '(1 5 9)) (list->heap '(2 4 8 10)))) (+ (heap-size (list->heap '(1 5 9))) (heap-size (list->heap '(2 4 8 10))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "property"], "split": "train"}
{"id": "heap_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Check that merge minimum equals min of both input minima.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that merge minimum equals min of both input minima.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (heap-min (heap-merge (list->heap '(4 7 9)) (list->heap '(2 5 8)))) (min (heap-min (list->heap '(4 7 9))) (heap-min (list->heap '(2 5 8)))))", "verify_expr": "(equal? (= (heap-min (heap-merge (list->heap '(4 7 9)) (list->heap '(2 5 8)))) (min (heap-min (list->heap '(4 7 9))) (heap-min (list->heap '(2 5 8))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "property"], "split": "train"}
{"id": "heap_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Check that heap-insert increases size by one.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-insert increases size by one.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (heap-size (heap-insert 6 (list->heap '(7 2 9)))) (+ 1 (heap-size (list->heap '(7 2 9)))))", "verify_expr": "(equal? (= (heap-size (heap-insert 6 (list->heap '(7 2 9)))) (+ 1 (heap-size (list->heap '(7 2 9))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "property"], "split": "train"}
{"id": "heap_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Check that inserting a smaller element updates heap-min.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that inserting a smaller element updates heap-min.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (heap-min (heap-insert 1 (list->heap '(7 2 9)))) 1)", "verify_expr": "(equal? (= (heap-min (heap-insert 1 (list->heap '(7 2 9)))) 1) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "property"], "split": "train"}
{"id": "heap_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Check that deleting min decreases size by one for non-empty heap.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that deleting min decreases size by one for non-empty heap.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([h (list->heap '(6 1 4 2))]) (= (heap-size (heap-delete-min h)) (- (heap-size h) 1)))", "verify_expr": "(equal? (let ([h (list->heap '(6 1 4 2))]) (= (heap-size (heap-delete-min h)) (- (heap-size h) 1))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "property"], "split": "train"}
{"id": "heap_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Check that heap-pop returns heap-min as the popped value.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-pop returns heap-min as the popped value.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([h (list->heap '(6 1 4 2))]) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (= x (heap-min h)))))", "verify_expr": "(equal? (let ([h (list->heap '(6 1 4 2))]) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (= x (heap-min h))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "property"], "split": "train"}
{"id": "heap_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Check that heap-size equals length of heap->list.", "prompt": "Task mode: small integration task across module primitives.\n\nCheck that heap-size equals length of heap->list.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([h (list->heap '(8 3 5 1 9))]) (= (heap-size h) (length (heap->list h))))", "verify_expr": "(equal? (let ([h (list->heap '(8 3 5 1 9))]) (= (heap-size h) (length (heap->list h)))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "property"], "split": "train"}
{"id": "heap_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Check that heap->list output is sorted for '(8 3 5 1 9).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that heap->list output is sorted for '(8 3 5 1 9).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([xs (heap->list (list->heap '(8 3 5 1 9)))]) (or (null? xs) (null? (cdr xs)) (let loop ([rest (cdr xs)] [prev (car xs)]) (if (null? rest) #t (and (<= prev (car rest)) (loop (cdr rest) (car rest)))))))", "verify_expr": "(equal? (let ([xs (heap->list (list->heap '(8 3 5 1 9)))]) (or (null? xs) (null? (cdr xs)) (let loop ([rest (cdr xs)] [prev (car xs)]) (if (null? rest) #t (and (<= prev (car rest)) (loop (cdr rest) (car rest))))))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap->list", "property"], "split": "train"}
{"id": "heap_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-insert", "prompt_body": "Build a heap with fold-left inserts from '(5 2 8 1 9 3), then return heap->list.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild a heap with fold-left inserts from '(5 2 8 1 9 3), then return heap->list.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([h (fold-left (lambda (acc x) (heap-insert x acc)) heap-empty '(5 2 8 1 9 3))]) (heap->list h))", "verify_expr": "(equal? (let ([h (fold-left (lambda (acc x) (heap-insert x acc)) heap-empty '(5 2 8 1 9 3))]) (heap->list h)) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap-insert", "fold"], "split": "train"}
{"id": "heap_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-pop", "prompt_body": "Pop repeatedly from heap '(5 2 8 1 9 3) and collect values.", "prompt": "Task mode: compose existing APIs into one expression.\n\nPop repeatedly from heap '(5 2 8 1 9 3) and collect values.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let loop ([h (list->heap '(5 2 8 1 9 3))] [acc '()]) (if (heap-empty? h) (reverse acc) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (cons x acc))))))", "verify_expr": "(equal? (let loop ([h (list->heap '(5 2 8 1 9 3))] [acc '()]) (if (heap-empty? h) (reverse acc) (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (cons x acc)))))) '(1 2 3 5 8 9))", "tags": ["tier0", "data", "heap", "composition", "heap-pop", "loop"], "split": "eval"}
{"id": "heap_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-merge", "prompt_body": "Merge two heaps then pop two values and return them as a list.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMerge two heaps then pop two values and return them as a list.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (heap-merge (list->heap '(7 3 9)) (list->heap '(6 2 8)))]) (call-with-values (lambda () (heap-pop m)) (lambda (h1 a) (call-with-values (lambda () (heap-pop h1)) (lambda (h2 b) (list a b))))))", "verify_expr": "(equal? (let ([m (heap-merge (list->heap '(7 3 9)) (list->heap '(6 2 8)))]) (call-with-values (lambda () (heap-pop m)) (lambda (h1 a) (call-with-values (lambda () (heap-pop h1)) (lambda (h2 b) (list a b)))))) '(2 3))", "tags": ["tier0", "data", "heap", "composition", "heap-merge", "integration"], "split": "eval"}
{"id": "heap_composition_028", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-delete-min", "prompt_body": "Insert 0 then delete min; result should match sorted original values.", "prompt": "Task mode: compose existing APIs into one expression.\n\nInsert 0 then delete min; result should match sorted original values.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (heap-delete-min (heap-insert 0 (list->heap '(4 2 6 8)))))", "verify_expr": "(equal? (heap->list (heap-delete-min (heap-insert 0 (list->heap '(4 2 6 8))))) '(2 4 6 8))", "tags": ["tier0", "data", "heap", "composition", "heap-delete-min", "integration"], "split": "train"}
{"id": "heap_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Count how many pops are needed to empty heap '(4 1 3 2).", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCount how many pops are needed to empty heap '(4 1 3 2).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let loop ([h (list->heap '(4 1 3 2))] [n 0]) (if (heap-empty? h) n (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (+ n 1))))))", "verify_expr": "(equal? (let loop ([h (list->heap '(4 1 3 2))] [n 0]) (if (heap-empty? h) n (call-with-values (lambda () (heap-pop h)) (lambda (h2 x) (loop h2 (+ n 1)))))) 4)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "loop"], "split": "train"}
{"id": "heap_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap-size", "prompt_body": "Check that merged heap size matches length of its extracted list.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that merged heap size matches length of its extracted list.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([m (heap-merge (list->heap '(1 4 7)) (list->heap '(2 5 8 9)))]) (= (heap-size m) (length (heap->list m))))", "verify_expr": "(equal? (let ([m (heap-merge (list->heap '(1 4 7)) (list->heap '(2 5 8 9)))]) (= (heap-size m) (length (heap->list m)))) #t)", "tags": ["tier0", "data", "heap", "composition", "heap-size", "integration"], "split": "train"}
{"id": "heap_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "make-heap-node", "prompt_body": "Return #t iff make-heap-node output satisfies leftist rank ordering.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff make-heap-node output satisfies leftist rank ordering.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n))))", "verify_expr": "(equal? (let* ([a (heap-node 1 8 heap-empty heap-empty)] [b (heap-node 2 9 (heap-node 1 11 heap-empty heap-empty) heap-empty)] [n (make-heap-node 7 a b)]) (>= (heap-rank (heap-left n)) (heap-rank (heap-right n)))) #t)", "tags": ["tier0", "data", "heap", "composition", "make-heap-node", "property"], "split": "eval"}
{"id": "heap_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/data/heap.ss", "source_test": "lattice/data/test-heap.ss", "source_function": "heap->list", "prompt_body": "Sort '(9 1 5 3 7) by going through list->heap and heap->list.", "prompt": "Task mode: small integration task across module primitives.\n\nSort '(9 1 5 3 7) by going through list->heap and heap->list.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(heap->list (list->heap '(9 1 5 3 7)))", "verify_expr": "(equal? (heap->list (list->heap '(9 1 5 3 7))) '(1 3 5 7 9))", "tags": ["tier0", "data", "heap", "composition", "heap->list", "integration"], "split": "eval"}
