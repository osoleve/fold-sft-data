{"id": "optics_core_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `prism-over`\nSpec: Apply a function through prism focus only when preview succeeds.\n\nWrite exactly one Scheme definition for `prism-over`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `prism-over`\nSpec: Apply a function through prism focus only when preview succeeds.\n\nWrite exactly one Scheme definition for `prism-over`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "spec-to-code", "prism-over"], "split": "eval"}
{"id": "optics_core_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (prism-over prism f s)\n  ;; TODO: modify only when preview produces a focus\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `prism-over`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (prism-over prism f s)\n  ;; TODO: modify only when preview produces a focus\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `prism-over`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "skeleton-completion", "prism-over"], "split": "eval"}
{"id": "optics_core_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Implement `prism-over` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Apply a function through prism focus only when preview succeeds.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `prism-over` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Apply a function through prism focus only when preview succeeds.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "contract-implementation", "prism-over"], "split": "eval"}
{"id": "optics_core_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `optic-compose`\nSpec: Dispatch optic composition to the most specific compatible optic type.\n\nWrite exactly one Scheme definition for `optic-compose`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `optic-compose`\nSpec: Dispatch optic composition to the most specific compatible optic type.\n\nWrite exactly one Scheme definition for `optic-compose`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "spec-to-code", "optic-compose"], "split": "eval"}
{"id": "optics_core_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (optic-compose outer inner)\n  ;; TODO: dispatch by optic-type and return the most specific composed optic\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optic-compose`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (optic-compose outer inner)\n  ;; TODO: dispatch by optic-type and return the most specific composed optic\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optic-compose`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "skeleton-completion", "optic-compose"], "split": "eval"}
{"id": "optics_core_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Implement `optic-compose` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Dispatch optic composition to the most specific compatible optic type.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `optic-compose` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Dispatch optic composition to the most specific compatible optic type.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "contract-implementation", "optic-compose"], "split": "eval"}
{"id": "optics_core_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `prism-over`.\nReturn only the Scheme definition.\n\n```python\ndef prism_over(prism, fn, s):\n    maybe_a = preview(prism, s)\n    if maybe_a is nothing:\n        return s\n    return review(prism, fn(from_just(maybe_a)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `prism-over`.\nReturn only the Scheme definition.\n\n```python\ndef prism_over(prism, fn, s):\n    maybe_a = preview(prism, s)\n    if maybe_a is nothing:\n        return s\n    return review(prism, fn(from_just(maybe_a)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "python-to-scheme", "prism-over"], "split": "eval"}
{"id": "optics_core_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `prism-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define (prism-over prism fn s)\n  (let ([hit (preview prism s)])\n    (cond\n      [(nothing? hit) s]\n      [else (review prism (fn (from-just hit)))])))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `prism-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define (prism-over prism fn s)\n  (let ([hit (preview prism s)])\n    (cond\n      [(nothing? hit) s]\n      [else (review prism (fn (from-just hit)))])))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "chez-to-fold", "prism-over"], "split": "eval"}
{"id": "optics_core_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `prism-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'prism)\n\n(define (local-helper x) x)\n\n  (define (prism-over prism fn s)\n    (let ([hit (preview prism s)])\n      (cond\n        [(nothing? hit) s]\n        [else (review prism (fn (from-just hit)))])))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `prism-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'prism)\n\n(define (local-helper x) x)\n\n  (define (prism-over prism fn s)\n    (let ([hit (preview prism s)])\n      (cond\n        [(nothing? hit) s]\n        [else (review prism (fn (from-just hit)))])))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (prism-over prism f s)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "prism-over"], "split": "eval"}
{"id": "optics_core_translation_022", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optic-compose`.\nReturn only the Scheme definition.\n\n```python\ndef optic_compose(outer, inner):\n    t1 = optic_type(outer)\n    t2 = optic_type(inner)\n\n    if t1 == \"lens\" and t2 == \"lens\":\n        return lens_compose(outer, inner)\n    if t1 == \"prism\" and t2 == \"prism\":\n        return prism_compose(outer, inner)\n    if t1 == \"lens\" and t2 == \"prism\":\n        return affine_compose(lens_to_affine(outer), prism_to_affine(inner))\n\n    return traversal_compose(to_traversal(outer), to_traversal(inner))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optic-compose`.\nReturn only the Scheme definition.\n\n```python\ndef optic_compose(outer, inner):\n    t1 = optic_type(outer)\n    t2 = optic_type(inner)\n\n    if t1 == \"lens\" and t2 == \"lens\":\n        return lens_compose(outer, inner)\n    if t1 == \"prism\" and t2 == \"prism\":\n        return prism_compose(outer, inner)\n    if t1 == \"lens\" and t2 == \"prism\":\n        return affine_compose(lens_to_affine(outer), prism_to_affine(inner))\n\n    return traversal_compose(to_traversal(outer), to_traversal(inner))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "python-to-scheme", "optic-compose"], "split": "eval"}
{"id": "optics_core_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optic-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optic-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "chez-to-fold", "optic-compose"], "split": "eval"}
{"id": "optics_core_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optic-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'unified)\n\n(define (local-helper x) x)\n\n  (define (optic-compose outer inner)\n    (let ([t1 (optic-type outer)]\n          [t2 (optic-type inner)])\n      (cond\n        [(and (eq? t1 'lens) (eq? t2 'lens))\n         (lens-compose outer inner)]\n        [(and (eq? t1 'prism) (eq? t2 'prism))\n         (prism-compose outer inner)]\n        [(and (eq? t1 'lens) (eq? t2 'prism))\n         (affine-compose (lens->affine outer) (prism->affine inner))]\n        [else\n         (traversal-compose (->traversal outer) (->traversal inner))])))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optic-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'unified)\n\n(define (local-helper x) x)\n\n  (define (optic-compose outer inner)\n    (let ([t1 (optic-type outer)]\n          [t2 (optic-type inner)])\n      (cond\n        [(and (eq? t1 'lens) (eq? t2 'lens))\n         (lens-compose outer inner)]\n        [(and (eq? t1 'prism) (eq? t2 'prism))\n         (prism-compose outer inner)]\n        [(and (eq? t1 'lens) (eq? t2 'prism))\n         (affine-compose (lens->affine outer) (prism->affine inner))]\n        [else\n         (traversal-compose (->traversal outer) (->traversal inner))])))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "optic-compose"], "split": "eval"}
{"id": "optics_core_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prism-over` in `lattice/optics/optics.ss`.\nKnown issue: Must preserve the source when preview fails.\n\n```scheme\n(define (prism-over prism f s)\n  (review prism (f (from-just (preview prism s)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prism-over` in `lattice/optics/optics.ss`.\nKnown issue: Must preserve the source when preview fails.\n\n```scheme\n(define (prism-over prism f s)\n  (review prism (f (from-just (preview prism s)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "bugfix", "prism-over"], "split": "eval"}
{"id": "optics_core_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prism-over` in `lattice/optics/optics.ss`.\nKnown issue: Transformation function f is ignored on successful matches.\n\n```scheme\n(define (prism-over prism f s)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (from-just maybe-a)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prism-over` in `lattice/optics/optics.ss`.\nKnown issue: Transformation function f is ignored on successful matches.\n\n```scheme\n(define (prism-over prism f s)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (from-just maybe-a)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) (just 4))\n  (just 5))\n(equal?\n  (prism-over prism-just (lambda (x) (+ x 1)) nothing)\n  nothing)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "bugfix", "prism-over"], "split": "eval"}
{"id": "optics_core_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optic-compose` in `lattice/optics/optics.ss`.\nKnown issue: optic-compose must preserve specific optic kinds (lens/prism/affine/fold/setter), not always return traversal.\n\n```scheme\n(define (optic-compose outer inner)\n  (traversal-compose (->traversal outer) (->traversal inner)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optic-compose` in `lattice/optics/optics.ss`.\nKnown issue: optic-compose must preserve specific optic kinds (lens/prism/affine/fold/setter), not always return traversal.\n\n```scheme\n(define (optic-compose outer inner)\n  (traversal-compose (->traversal outer) (->traversal inner)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "bugfix", "optic-compose"], "split": "eval"}
{"id": "optics_core_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optic-compose` in `lattice/optics/optics.ss`.\nKnown issue: lens+prism composition should produce affine behavior focused through both optics.\n\n```scheme\n(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (prism-compose inner prism-id)]\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optic-compose` in `lattice/optics/optics.ss`.\nKnown issue: lens+prism composition should produce affine behavior focused through both optics.\n\n```scheme\n(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (prism-compose inner prism-id)]\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(affine? lp)\n(lens? ll)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) — before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions — before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions — before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions — after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "bugfix", "optic-compose"], "split": "eval"}
{"id": "optics_core_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Create an identity iso via make-iso and return its tag symbol.\n\nEnsure `make-iso` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCreate an identity iso via make-iso and return its tag symbol.\n\nEnsure `make-iso` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(car (make-iso identity identity))", "verify_expr": "(equal? (car (make-iso identity identity)) 'iso)", "tags": ["tier1", "optics", "core", "composition", "make-iso", "record"], "split": "eval"}
{"id": "optics_core_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Apply iso-over via iso-reversed to append 0 to list '(1 2 3).\n\nEnsure `iso-over` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nApply iso-over via iso-reversed to append 0 to list '(1 2 3).\n\nEnsure `iso-over` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3))", "verify_expr": "(equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))", "tags": ["tier1", "optics", "core", "composition", "iso-over", "reversed"], "split": "eval"}
{"id": "optics_core_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Compose iso-id with iso-reversed and view '(1 2 3).\n\nEnsure `iso-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose iso-id with iso-reversed and view '(1 2 3).\n\nEnsure `iso-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([c (iso-compose iso-id iso-reversed)]) (iso-view c '(1 2 3)))", "verify_expr": "(equal? (let ([c (iso-compose iso-id iso-reversed)]) (iso-view c '(1 2 3))) '(3 2 1))", "tags": ["tier1", "optics", "core", "composition", "iso-compose", "identity-compose"], "split": "eval"}
{"id": "optics_core_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Compose two affine-nth optics to preview the nested focus in '((10 11) (20 21) (30 31)).\n\nEnsure `affine-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose two affine-nth optics to preview the nested focus in '((10 11) (20 21) (30 31)).\n\nEnsure `affine-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-preview a s))", "verify_expr": "(equal? (let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-preview a s)) (just 20))", "tags": ["tier1", "optics", "core", "composition", "affine-compose", "preview"], "split": "eval"}
{"id": "optics_core_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Compose traversal-each with traversal-each and increment all nested numeric targets.\n\nEnsure `traversal-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose traversal-each with traversal-each and increment all nested numeric targets.\n\nEnsure `traversal-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-over t (lambda (x) (+ x 1)) s))", "verify_expr": "(equal? (let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-over t (lambda (x) (+ x 1)) s)) '((2 3) (4 5)))", "tags": ["tier1", "optics", "core", "composition", "traversal-compose", "over"], "split": "eval"}
{"id": "optics_core_composition_033", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Preview first even element through fold-filtered even? on mixed input.\n\nEnsure `fold-preview` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nPreview first even element through fold-filtered even? on mixed input.\n\nEnsure `fold-preview` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(fold-preview (fold-filtered even?) '(1 3 4 6))", "verify_expr": "(equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4))", "tags": ["tier1", "optics", "core", "composition", "fold-preview", "filtered"], "split": "eval"}
{"id": "optics_core_composition_040", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Compose getter-fst with lens-fst and collect the resulting read-only fold output.\n\nEnsure `optic-compose` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose getter-fst with lens-fst and collect the resulting read-only fold output.\n\nEnsure `optic-compose` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([o (optic-compose getter-fst lens-fst)]) (fold-to-list o '((1 . 2) . z)))", "verify_expr": "(equal? (let* ([o (optic-compose getter-fst lens-fst)]) (fold-to-list o '((1 . 2) . z))) '(1))", "tags": ["tier1", "optics", "core", "composition", "optic-compose", "getter-fold"], "split": "eval"}
