{"id": "optics_core_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `make-iso`\nSpec: Construct an iso record tagged 'iso with forward/backward functions in order.\n\nWrite exactly one Scheme definition for `make-iso`.\nReturn only code, no explanation.", "ground_truth": "(define (make-iso forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> (-> s a) (-> b t) (Iso s t a b)))\n  (doc 'description \"For simple isos, s=t and a=b, so: (s \u2192 a) \u00d7 (a \u2192 s)\")\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "spec-to-code", "make-iso"], "split": "train"}
{"id": "optics_core_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-iso forward backward)\n  ;; TODO: construct an iso record with the canonical tag and slots\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-iso`.", "ground_truth": "(define (make-iso forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> (-> s a) (-> b t) (Iso s t a b)))\n  (doc 'description \"For simple isos, s=t and a=b, so: (s \u2192 a) \u00d7 (a \u2192 s)\")\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "skeleton-completion", "make-iso"], "split": "train"}
{"id": "optics_core_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Implement `make-iso` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Construct an iso record tagged 'iso with forward/backward functions in order.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (make-iso forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> (-> s a) (-> b t) (Iso s t a b)))\n  (doc 'description \"For simple isos, s=t and a=b, so: (s \u2192 a) \u00d7 (a \u2192 s)\")\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "contract-implementation", "make-iso"], "split": "train"}
{"id": "optics_core_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `iso-over`\nSpec: Map over an isomorphic view: forward, transform, then backward.\n\nWrite exactly one Scheme definition for `iso-over`.\nReturn only code, no explanation.", "ground_truth": "(define (iso-over iso f s)\n  (doc 'export #t)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "spec-to-code", "iso-over"], "split": "train"}
{"id": "optics_core_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (iso-over iso f s)\n  ;; TODO: transform via forward view and rebuild via backward direction\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `iso-over`.", "ground_truth": "(define (iso-over iso f s)\n  (doc 'export #t)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "skeleton-completion", "iso-over"], "split": "train"}
{"id": "optics_core_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Implement `iso-over` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Map over an isomorphic view: forward, transform, then backward.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (iso-over iso f s)\n  (doc 'export #t)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "contract-implementation", "iso-over"], "split": "train"}
{"id": "optics_core_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `iso-compose`\nSpec: Compose two isos preserving forward/backward directionality.\n\nWrite exactly one Scheme definition for `iso-compose`.\nReturn only code, no explanation.", "ground_truth": "(define (iso-compose outer inner)\n  (doc 'export #t)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "spec-to-code", "iso-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (iso-compose outer inner)\n  ;; TODO: compose forward/backward paths with correct directionality\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `iso-compose`.", "ground_truth": "(define (iso-compose outer inner)\n  (doc 'export #t)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "skeleton-completion", "iso-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Implement `iso-compose` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Compose two isos preserving forward/backward directionality.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (iso-compose outer inner)\n  (doc 'export #t)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "contract-implementation", "iso-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `prism-over`\nSpec: Apply a function through prism focus only when preview succeeds.\n\nWrite exactly one Scheme definition for `prism-over`.\nReturn only code, no explanation.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "spec-to-code", "prism-over"], "split": "eval"}
{"id": "optics_core_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (prism-over prism f s)\n  ;; TODO: modify only when preview produces a focus\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `prism-over`.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "skeleton-completion", "prism-over"], "split": "eval"}
{"id": "optics_core_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Implement `prism-over` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Apply a function through prism focus only when preview succeeds.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "contract-implementation", "prism-over"], "split": "eval"}
{"id": "optics_core_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `affine-compose`\nSpec: Compose two affines by chaining Maybe-aware getter/setter behavior.\n\nWrite exactly one Scheme definition for `affine-compose`.\nReturn only code, no explanation.", "ground_truth": "(define (affine-compose outer inner)\n  (doc 'export #t)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "spec-to-code", "affine-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (affine-compose outer inner)\n  ;; TODO: compose affine getter/setter while preserving missing-focus behavior\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `affine-compose`.", "ground_truth": "(define (affine-compose outer inner)\n  (doc 'export #t)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "skeleton-completion", "affine-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Implement `affine-compose` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Compose two affines by chaining Maybe-aware getter/setter behavior.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (affine-compose outer inner)\n  (doc 'export #t)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "contract-implementation", "affine-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `traversal-compose`\nSpec: Compose traversals by nesting traverse semantics and flattening folded targets.\n\nWrite exactly one Scheme definition for `traversal-compose`.\nReturn only code, no explanation.", "ground_truth": "(define (traversal-compose outer inner)\n  (doc 'export #t)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "spec-to-code", "traversal-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (traversal-compose outer inner)\n  ;; TODO: compose traversal traverse/fold behaviors\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `traversal-compose`.", "ground_truth": "(define (traversal-compose outer inner)\n  (doc 'export #t)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "skeleton-completion", "traversal-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Implement `traversal-compose` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Compose traversals by nesting traverse semantics and flattening folded targets.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (traversal-compose outer inner)\n  (doc 'export #t)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "contract-implementation", "traversal-compose"], "split": "train"}
{"id": "optics_core_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `fold-preview`\nSpec: Return the first fold target as Just, or nothing when no targets exist.\n\nWrite exactly one Scheme definition for `fold-preview`.\nReturn only code, no explanation.", "ground_truth": "(define (fold-preview fold s)\n  (doc 'export #t)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "spec-to-code", "fold-preview"], "split": "train"}
{"id": "optics_core_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (fold-preview fold s)\n  ;; TODO: return Just first target or nothing if empty\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `fold-preview`.", "ground_truth": "(define (fold-preview fold s)\n  (doc 'export #t)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "skeleton-completion", "fold-preview"], "split": "train"}
{"id": "optics_core_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Implement `fold-preview` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Return the first fold target as Just, or nothing when no targets exist.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (fold-preview fold s)\n  (doc 'export #t)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "contract-implementation", "fold-preview"], "split": "train"}
{"id": "optics_core_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Implement this optics function in Fold-native Scheme.\n\nTarget module: lattice/optics/optics.ss\nFunction: `optic-compose`\nSpec: Dispatch optic composition to the most specific compatible optic type.\n\nWrite exactly one Scheme definition for `optic-compose`.\nReturn only code, no explanation.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "spec-to-code", "optic-compose"], "split": "eval"}
{"id": "optics_core_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (optic-compose outer inner)\n  ;; TODO: dispatch by optic-type and return the most specific composed optic\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optic-compose`.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "skeleton-completion", "optic-compose"], "split": "eval"}
{"id": "optics_core_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Implement `optic-compose` from this contract.\n\nModule: `lattice/optics/optics.ss`\nContract focus: Dispatch optic composition to the most specific compatible optic type.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve semantics for optic laws and edge cases.\n3. Return only one production-ready definition.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "contract-implementation", "optic-compose"], "split": "eval"}
{"id": "optics_core_translation_001", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-iso`.\nReturn only the Scheme definition.\n\n```python\ndef make_iso(forward, backward):\n    return [\"iso\", forward, backward]\n```", "ground_truth": "(define (make-iso forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> (-> s a) (-> b t) (Iso s t a b)))\n  (doc 'description \"For simple isos, s=t and a=b, so: (s \u2192 a) \u00d7 (a \u2192 s)\")\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "python-to-scheme", "make-iso"], "split": "train"}
{"id": "optics_core_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-iso`.\nReturn only the final Fold definition.\n\n```scheme\n(define (build-iso fwd bwd)\n  (list 'iso fwd bwd))\n```", "ground_truth": "(define (make-iso forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> (-> s a) (-> b t) (Iso s t a b)))\n  (doc 'description \"For simple isos, s=t and a=b, so: (s \u2192 a) \u00d7 (a \u2192 s)\")\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "chez-to-fold", "make-iso"], "split": "train"}
{"id": "optics_core_translation_003", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-iso`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'iso)\n\n(define (local-helper x) x)\n\n  (define (build-iso fwd bwd)\n    (list 'iso fwd bwd))\n\n```", "ground_truth": "(define (make-iso forward backward)\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "make-iso"], "split": "train"}
{"id": "optics_core_translation_004", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `iso-over`.\nReturn only the Scheme definition.\n\n```python\ndef iso_over(iso_obj, fn, s):\n    forward = iso_obj[1]\n    backward = iso_obj[2]\n    return backward(fn(forward(s)))\n```", "ground_truth": "(define (iso-over iso f s)\n  (doc 'export #t)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "python-to-scheme", "iso-over"], "split": "train"}
{"id": "optics_core_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `iso-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define (iso-over iso fn s)\n  (let* ([fw (iso-forward iso)]\n         [bw (iso-backward iso)]\n         [a (fw s)])\n    (bw (fn a))))\n```", "ground_truth": "(define (iso-over iso f s)\n  (doc 'export #t)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "chez-to-fold", "iso-over"], "split": "train"}
{"id": "optics_core_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `iso-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'iso)\n\n(define (local-helper x) x)\n\n  (define (iso-over iso fn s)\n    (let* ([fw (iso-forward iso)]\n           [bw (iso-backward iso)]\n           [a (fw s)])\n      (bw (fn a))))\n\n```", "ground_truth": "(define (iso-over iso f s)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "iso-over"], "split": "train"}
{"id": "optics_core_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `iso-compose`.\nReturn only the Scheme definition.\n\n```python\ndef iso_compose(outer, inner):\n    f = lambda s: inner[1](outer[1](s))\n    b = lambda d: outer[2](inner[2](d))\n    return [\"iso\", f, b]\n```", "ground_truth": "(define (iso-compose outer inner)\n  (doc 'export #t)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "python-to-scheme", "iso-compose"], "split": "train"}
{"id": "optics_core_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `iso-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (iso-compose outer inner)\n  (let ([fw (compose2 (iso-forward inner) (iso-forward outer))]\n        [bw (compose2 (iso-backward outer) (iso-backward inner))])\n    (make-iso fw bw)))\n```", "ground_truth": "(define (iso-compose outer inner)\n  (doc 'export #t)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "chez-to-fold", "iso-compose"], "split": "train"}
{"id": "optics_core_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `iso-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'iso)\n\n(define (local-helper x) x)\n\n  (define (iso-compose outer inner)\n    (let ([fw (compose2 (iso-forward inner) (iso-forward outer))]\n          [bw (compose2 (iso-backward outer) (iso-backward inner))])\n      (make-iso fw bw)))\n\n```", "ground_truth": "(define (iso-compose outer inner)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "iso-compose"], "split": "train"}
{"id": "optics_core_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `prism-over`.\nReturn only the Scheme definition.\n\n```python\ndef prism_over(prism, fn, s):\n    maybe_a = preview(prism, s)\n    if maybe_a is nothing:\n        return s\n    return review(prism, fn(from_just(maybe_a)))\n```", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "python-to-scheme", "prism-over"], "split": "eval"}
{"id": "optics_core_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `prism-over`.\nReturn only the final Fold definition.\n\n```scheme\n(define (prism-over prism fn s)\n  (let ([hit (preview prism s)])\n    (cond\n      [(nothing? hit) s]\n      [else (review prism (fn (from-just hit)))])))\n```", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "chez-to-fold", "prism-over"], "split": "eval"}
{"id": "optics_core_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `prism-over`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'prism)\n\n(define (local-helper x) x)\n\n  (define (prism-over prism fn s)\n    (let ([hit (preview prism s)])\n      (cond\n        [(nothing? hit) s]\n        [else (review prism (fn (from-just hit)))])))\n\n```", "ground_truth": "(define (prism-over prism f s)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "prism-over"], "split": "eval"}
{"id": "optics_core_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `affine-compose`.\nReturn only the Scheme definition.\n\n```python\ndef affine_compose(outer, inner):\n    def get(s):\n        ma = affine_preview(outer, s)\n        if ma is nothing:\n            return nothing\n        return affine_preview(inner, from_just(ma))\n\n    def set_(d, s):\n        ma = affine_preview(outer, s)\n        if ma is nothing:\n            return s\n        return affine_set(outer, affine_set(inner, d, from_just(ma)), s)\n\n    return make_affine(get, set_)\n```", "ground_truth": "(define (affine-compose outer inner)\n  (doc 'export #t)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "python-to-scheme", "affine-compose"], "split": "train"}
{"id": "optics_core_translation_014", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `affine-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (affine-compose outer inner)\n  (make-affine\n   (lambda (s)\n     (let ([oa (affine-preview outer s)])\n       (if (nothing? oa)\n           nothing\n           (affine-preview inner (from-just oa)))))\n   (lambda (d s)\n     (let ([oa (affine-preview outer s)])\n       (if (nothing? oa)\n           s\n           (affine-set outer\n                       (affine-set inner d (from-just oa))\n                       s))))))\n```", "ground_truth": "(define (affine-compose outer inner)\n  (doc 'export #t)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "chez-to-fold", "affine-compose"], "split": "train"}
{"id": "optics_core_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `affine-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'affine)\n\n(define (local-helper x) x)\n\n  (define (affine-compose outer inner)\n    (make-affine\n     (lambda (s)\n       (let ([oa (affine-preview outer s)])\n         (if (nothing? oa)\n             nothing\n             (affine-preview inner (from-just oa)))))\n     (lambda (d s)\n       (let ([oa (affine-preview outer s)])\n         (if (nothing? oa)\n             s\n             (affine-set outer\n                         (affine-set inner d (from-just oa))\n                         s))))))\n\n```", "ground_truth": "(define (affine-compose outer inner)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "affine-compose"], "split": "train"}
{"id": "optics_core_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `traversal-compose`.\nReturn only the Scheme definition.\n\n```python\ndef traversal_compose(outer, inner):\n    def traverse(f, s):\n        return traversal_traverse(outer)(lambda a: traversal_traverse(inner)(f, a), s)\n\n    def fold(s):\n        return append_map(traversal_fold(inner), traversal_fold(outer)(s))\n\n    return make_traversal(traverse, fold)\n```", "ground_truth": "(define (traversal-compose outer inner)\n  (doc 'export #t)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "python-to-scheme", "traversal-compose"], "split": "train"}
{"id": "optics_core_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `traversal-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (traversal-compose outer inner)\n  (make-traversal\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a)\n        ((traversal-traverse inner) f a))\n      s))\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))\n```", "ground_truth": "(define (traversal-compose outer inner)\n  (doc 'export #t)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "chez-to-fold", "traversal-compose"], "split": "train"}
{"id": "optics_core_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `traversal-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'traversal)\n\n(define (local-helper x) x)\n\n  (define (traversal-compose outer inner)\n    (make-traversal\n     (lambda (f s)\n       ((traversal-traverse outer)\n        (lambda (a)\n          ((traversal-traverse inner) f a))\n        s))\n     (lambda (s)\n       (append-map (traversal-fold inner)\n                   ((traversal-fold outer) s)))))\n\n```", "ground_truth": "(define (traversal-compose outer inner)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "traversal-compose"], "split": "train"}
{"id": "optics_core_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `fold-preview`.\nReturn only the Scheme definition.\n\n```python\ndef fold_preview(fold_obj, s):\n    targets = fold_optic_fn(fold_obj)(s)\n    if len(targets) == 0:\n        return nothing\n    return just(targets[0])\n```", "ground_truth": "(define (fold-preview fold s)\n  (doc 'export #t)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "python-to-scheme", "fold-preview"], "split": "train"}
{"id": "optics_core_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `fold-preview`.\nReturn only the final Fold definition.\n\n```scheme\n(define (fold-preview fold s)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (pair? targets)\n        (just (car targets))\n        nothing)))\n```", "ground_truth": "(define (fold-preview fold s)\n  (doc 'export #t)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "chez-to-fold", "fold-preview"], "split": "train"}
{"id": "optics_core_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `fold-preview`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'fold)\n\n(define (local-helper x) x)\n\n  (define (fold-preview fold s)\n    (let ([targets ((fold-optic-fn fold) s)])\n      (if (pair? targets)\n          (just (car targets))\n          nothing)))\n\n```", "ground_truth": "(define (fold-preview fold s)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "fold-preview"], "split": "train"}
{"id": "optics_core_translation_022", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optic-compose`.\nReturn only the Scheme definition.\n\n```python\ndef optic_compose(outer, inner):\n    t1 = optic_type(outer)\n    t2 = optic_type(inner)\n\n    if t1 == \"lens\" and t2 == \"lens\":\n        return lens_compose(outer, inner)\n    if t1 == \"prism\" and t2 == \"prism\":\n        return prism_compose(outer, inner)\n    if t1 == \"lens\" and t2 == \"prism\":\n        return affine_compose(lens_to_affine(outer), prism_to_affine(inner))\n\n    return traversal_compose(to_traversal(outer), to_traversal(inner))\n```", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "python-to-scheme", "optic-compose"], "split": "eval"}
{"id": "optics_core_translation_023", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optic-compose`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))\n```", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "chez-to-fold", "optic-compose"], "split": "eval"}
{"id": "optics_core_translation_024", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optic-compose`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/optics/optics.ss excerpt\n(require 'prelude)\n(require 'combinators)\n(require 'templates)\n\n(doc 'module 'optics)\n(doc 'section 'unified)\n\n(define (local-helper x) x)\n\n  (define (optic-compose outer inner)\n    (let ([t1 (optic-type outer)]\n          [t2 (optic-type inner)])\n      (cond\n        [(and (eq? t1 'lens) (eq? t2 'lens))\n         (lens-compose outer inner)]\n        [(and (eq? t1 'prism) (eq? t2 'prism))\n         (prism-compose outer inner)]\n        [(and (eq? t1 'lens) (eq? t2 'prism))\n         (affine-compose (lens->affine outer) (prism->affine inner))]\n        [else\n         (traversal-compose (->traversal outer) (->traversal inner))])))\n\n```", "ground_truth": "(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "source-excerpt-to-fold", "doc-free-target", "optic-compose"], "split": "eval"}
{"id": "optics_core_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-iso` in `lattice/optics/optics.ss`.\nKnown issue: Iso records must use the canonical 'iso tag.\n\n```scheme\n(define (make-iso forward backward)\n  (list 'is0 forward backward))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (make-iso forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> (-> s a) (-> b t) (Iso s t a b)))\n  (doc 'description \"For simple isos, s=t and a=b, so: (s \u2192 a) \u00d7 (a \u2192 s)\")\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "bugfix", "make-iso"], "split": "train"}
{"id": "optics_core_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-iso` in `lattice/optics/optics.ss`.\nKnown issue: Forward/backward slots are swapped.\n\n```scheme\n(define (make-iso forward backward)\n  (list 'iso backward forward))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (make-iso forward backward)\n  (doc 'export #t)\n  (doc 'type '(-> (-> s a) (-> b t) (Iso s t a b)))\n  (doc 'description \"For simple isos, s=t and a=b, so: (s \u2192 a) \u00d7 (a \u2192 s)\")\n  (list 'iso forward backward))", "verify_expr": "(let* ([i (make-iso cdr (lambda (x) (cons 'k x)))])\n  (and (iso? i)\n       (= (iso-view i '(a . 7)) 7)\n       (equal? (iso-review i 9) '(k . 9))))", "tags": ["tier1", "optics", "core", "bugfix", "make-iso"], "split": "train"}
{"id": "optics_core_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iso-over` in `lattice/optics/optics.ss`.\nKnown issue: Result must be reconstructed with iso-backward.\n\n```scheme\n(define (iso-over iso f s)\n  (f ((iso-forward iso) s)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (iso-over iso f s)\n  (doc 'export #t)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "bugfix", "iso-over"], "split": "train"}
{"id": "optics_core_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iso-over` in `lattice/optics/optics.ss`.\nKnown issue: Input should be transformed through iso-forward, not iso-backward.\n\n```scheme\n(define (iso-over iso f s)\n  ((iso-backward iso) (f ((iso-backward iso) s))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (iso-over iso f s)\n  (doc 'export #t)\n  ((iso-backward iso) (f ((iso-forward iso) s))))", "verify_expr": "(and (= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)\n     (equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))\n     (equal? (iso-over iso-swapped\n                       (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1)))\n                       '(1 . 2))\n             '(2 . 3))\n     (equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))])\n               (iso-over i (lambda (n) (* n 3)) '(4 . tail)))\n             '(12 . ignored)))", "tags": ["tier1", "optics", "core", "bugfix", "iso-over"], "split": "train"}
{"id": "optics_core_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iso-compose` in `lattice/optics/optics.ss`.\nKnown issue: Composition order is reversed for both directions.\n\n```scheme\n(define (iso-compose outer inner)\n  (make-iso\n   (compose2 (iso-forward outer) (iso-forward inner))\n   (compose2 (iso-backward inner) (iso-backward outer))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (iso-compose outer inner)\n  (doc 'export #t)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "bugfix", "iso-compose"], "split": "train"}
{"id": "optics_core_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `iso-compose` in `lattice/optics/optics.ss`.\nKnown issue: Backward path must use inner backward then outer backward.\n\n```scheme\n(define (iso-compose outer inner)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward outer))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (iso-compose outer inner)\n  (doc 'export #t)\n  (make-iso\n   (compose2 (iso-forward inner) (iso-forward outer))\n   (compose2 (iso-backward outer) (iso-backward inner))))", "verify_expr": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))]\n       [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))]\n       [c (iso-compose a b)]\n       [swap2 (iso-compose iso-swapped iso-swapped)])\n  (and (= (iso-view c 3) 8)\n       (= (iso-review c 8) 3)\n       (equal? (iso-view swap2 '(1 . 2)) '(1 . 2))))", "tags": ["tier1", "optics", "core", "bugfix", "iso-compose"], "split": "train"}
{"id": "optics_core_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prism-over` in `lattice/optics/optics.ss`.\nKnown issue: Must preserve the source when preview fails.\n\n```scheme\n(define (prism-over prism f s)\n  (review prism (f (from-just (preview prism s)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "bugfix", "prism-over"], "split": "eval"}
{"id": "optics_core_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `prism-over` in `lattice/optics/optics.ss`.\nKnown issue: Transformation function f is ignored on successful matches.\n\n```scheme\n(define (prism-over prism f s)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (from-just maybe-a)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (prism-over prism f s)\n  (doc 'export #t)\n  (let ([maybe-a (preview prism s)])\n    (if (nothing? maybe-a)\n        s\n        (review prism (f (from-just maybe-a))))))", "verify_expr": "(and (equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))\n     (equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))\n     (equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9)))", "tags": ["tier1", "optics", "core", "bugfix", "prism-over"], "split": "eval"}
{"id": "optics_core_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `affine-compose` in `lattice/optics/optics.ss`.\nKnown issue: Setter path must update nested focus, not always return original source.\n\n```scheme\n(define (affine-compose outer inner)\n  (make-affine\n   (lambda (s)\n     (let ([oa (affine-preview outer s)])\n       (if (nothing? oa)\n           nothing\n           (affine-preview inner (from-just oa)))))\n   (lambda (_d s) s)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (affine-compose outer inner)\n  (doc 'export #t)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "bugfix", "affine-compose"], "split": "train"}
{"id": "optics_core_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `affine-compose` in `lattice/optics/optics.ss`.\nKnown issue: Composed affine getter/setter must route through both optics.\n\n```scheme\n(define (affine-compose outer inner)\n  (make-affine\n   (lambda (s) ((affine-getter outer) s))\n   (lambda (d s) ((affine-setter outer) d s))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (affine-compose outer inner)\n  (doc 'export #t)\n  (make-affine\n   ;; getter: s \u2192 Maybe c\n   (lambda (s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           nothing\n           ((affine-getter inner) (from-just maybe-a)))))\n   ;; setter: d \u2192 s \u2192 t\n   (lambda (d s)\n     (let ([maybe-a ((affine-getter outer) s)])\n       (if (nothing? maybe-a)\n           s\n           ((affine-setter outer)\n            ((affine-setter inner) d (from-just maybe-a))\n            s))))))", "verify_expr": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]\n       [s '((10 11) (20 21) (30 31))])\n  (and (equal? (affine-preview a s) (just 20))\n       (equal? (affine-set a 99 s) '((10 11) (99 21) (30 31)))\n       (equal? (affine-preview a '((1 2))) nothing)))", "tags": ["tier1", "optics", "core", "bugfix", "affine-compose"], "split": "train"}
{"id": "optics_core_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `traversal-compose` in `lattice/optics/optics.ss`.\nKnown issue: Traverse path must apply inner traversal to each outer focus.\n\n```scheme\n(define (traversal-compose outer inner)\n  (make-traversal\n   (lambda (f s)\n     ((traversal-traverse outer) f s))\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (traversal-compose outer inner)\n  (doc 'export #t)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "bugfix", "traversal-compose"], "split": "train"}
{"id": "optics_core_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `traversal-compose` in `lattice/optics/optics.ss`.\nKnown issue: Fold path must flatten inner folds, and traverse path must not ignore f.\n\n```scheme\n(define (traversal-compose outer inner)\n  (make-traversal\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) a)\n      s))\n   (lambda (s)\n     ((traversal-fold outer) s))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (traversal-compose outer inner)\n  (doc 'export #t)\n  (make-traversal\n   ;; traverse: (c \u2192 F d) \u2192 s \u2192 F t\n   (lambda (f s)\n     ((traversal-traverse outer)\n      (lambda (a) ((traversal-traverse inner) f a))\n      s))\n   ;; fold: s \u2192 List c\n   (lambda (s)\n     (append-map (traversal-fold inner)\n                 ((traversal-fold outer) s)))))", "verify_expr": "(let* ([t (traversal-compose traversal-each traversal-each)]\n       [s '((1 2) (3 4))])\n  (and (equal? (traversal-to-list t s) '(1 2 3 4))\n       (equal? (traversal-over t (lambda (x) (+ x 1)) s) '((2 3) (4 5)))\n       (equal? (traversal-set t 0 s) '((0 0) (0 0)))))", "tags": ["tier1", "optics", "core", "bugfix", "traversal-compose"], "split": "train"}
{"id": "optics_core_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-preview` in `lattice/optics/optics.ss`.\nKnown issue: fold-preview must return a Maybe value, not a raw target.\n\n```scheme\n(define (fold-preview fold s)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (car targets))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (fold-preview fold s)\n  (doc 'export #t)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "bugfix", "fold-preview"], "split": "train"}
{"id": "optics_core_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `fold-preview` in `lattice/optics/optics.ss`.\nKnown issue: fold-preview should return the first target, not the last.\n\n```scheme\n(define (fold-preview fold s)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets)\n        nothing\n        (let loop ([xs targets])\n          (if (null? (cdr xs))\n              (just (car xs))\n              (loop (cdr xs)))))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (fold-preview fold s)\n  (doc 'export #t)\n  (let ([targets ((fold-optic-fn fold) s)])\n    (if (null? targets) nothing (just (car targets)))))", "verify_expr": "(and (equal? (fold-preview fold-each '(1 2 3)) (just 1))\n     (equal? (fold-preview fold-each '()) nothing)\n     (equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4)))", "tags": ["tier1", "optics", "core", "bugfix", "fold-preview"], "split": "train"}
{"id": "optics_core_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optic-compose` in `lattice/optics/optics.ss`.\nKnown issue: optic-compose must preserve specific optic kinds (lens/prism/affine/fold/setter), not always return traversal.\n\n```scheme\n(define (optic-compose outer inner)\n  (traversal-compose (->traversal outer) (->traversal inner)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "bugfix", "optic-compose"], "split": "eval"}
{"id": "optics_core_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optic-compose` in `lattice/optics/optics.ss`.\nKnown issue: lens+prism composition should produce affine behavior focused through both optics.\n\n```scheme\n(define (optic-compose outer inner)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (prism-compose inner prism-id)]\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (optic-compose outer inner)\n  (doc 'export #t)\n  (let ([t1 (optic-type outer)]\n        [t2 (optic-type inner)])\n    (cond\n      ;; Iso compositions\n      [(and (eq? t1 'iso) (eq? t2 'iso))\n       (iso-compose outer inner)]\n      [(and (eq? t1 'iso) (eq? t2 'lens))\n       (lens-compose (iso->lens outer) inner)]\n      [(and (eq? t1 'lens) (eq? t2 'iso))\n       (lens-compose outer (iso->lens inner))]\n      [(and (eq? t1 'iso) (eq? t2 'prism))\n       (prism-compose (iso->prism outer) inner)]\n      [(and (eq? t1 'prism) (eq? t2 'iso))\n       (prism-compose outer (iso->prism inner))]\n      [(and (eq? t1 'iso) (eq? t2 'grate))\n       (grate-compose (iso->grate outer) inner)]\n      [(and (eq? t1 'grate) (eq? t2 'iso))\n       (grate-compose outer (iso->grate inner))]\n\n      ;; Grate compositions\n      [(and (eq? t1 'grate) (eq? t2 'grate))\n       (grate-compose outer inner)]\n\n      ;; Lens compositions\n      [(and (eq? t1 'lens) (eq? t2 'lens))\n       (lens-compose outer inner)]\n      [(and (eq? t1 'lens) (eq? t2 'prism))\n       (affine-compose (lens->affine outer) (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'lens))\n       (affine-compose (prism->affine outer) (lens->affine inner))]\n\n      ;; Prism compositions\n      [(and (eq? t1 'prism) (eq? t2 'prism))\n       (prism-compose outer inner)]\n\n      ;; Affine compositions\n      [(and (eq? t1 'affine) (eq? t2 'affine))\n       (affine-compose outer inner)]\n      [(and (eq? t1 'affine) (eq? t2 'lens))\n       (affine-compose outer (lens->affine inner))]\n      [(and (eq? t1 'lens) (eq? t2 'affine))\n       (affine-compose (lens->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'prism))\n       (affine-compose outer (prism->affine inner))]\n      [(and (eq? t1 'prism) (eq? t2 'affine))\n       (affine-compose (prism->affine outer) inner)]\n      [(and (eq? t1 'affine) (eq? t2 'iso))\n       (affine-compose outer (lens->affine (iso->lens inner)))]\n      [(and (eq? t1 'iso) (eq? t2 'affine))\n       (affine-compose (lens->affine (iso->lens outer)) inner)]\n\n      ;; Fold compositions (read-only) \u2014 before traversal to catch traversal+getter etc.\n      [(or (eq? t1 'fold) (eq? t2 'fold))\n       (fold-compose (->fold outer) (->fold inner))]\n\n      ;; Getter compositions \u2014 before traversal (getter is read-only, meet is fold)\n      [(and (eq? t1 'getter) (eq? t2 'getter))\n       (getter-compose outer inner)]\n      [(eq? t1 'getter)\n       (fold-compose (getter->fold outer) (->fold inner))]\n      [(eq? t2 'getter)\n       (fold-compose (->fold outer) (getter->fold inner))]\n\n      ;; Setter compositions \u2014 before traversal (setter is write-only, meet is setter)\n      [(and (eq? t1 'setter) (eq? t2 'setter))\n       (setter-compose outer inner)]\n      [(eq? t1 'setter)\n       (setter-compose outer (->setter inner))]\n      [(eq? t2 'setter)\n       (setter-compose (->setter outer) inner)]\n\n      ;; Grate + Setter = Setter\n      [(and (eq? t1 'grate) (eq? t2 'setter))\n       (setter-compose (grate->setter outer) inner)]\n      [(and (eq? t1 'setter) (eq? t2 'grate))\n       (setter-compose outer (grate->setter inner))]\n\n      ;; Traversal compositions \u2014 after fold/getter/setter so read/write-only optics\n      ;; find their correct meet type instead of failing on ->traversal conversion\n      [(or (eq? t1 'traversal) (eq? t2 'traversal))\n       (traversal-compose (->traversal outer) (->traversal inner))]\n\n      ;; Default: convert to traversals\n      [else\n       (traversal-compose (->traversal outer) (->traversal inner))])))", "verify_expr": "(let* ([lp (optic-compose lens-fst prism-just)]\n       [ll (optic-compose lens-fst lens-fst)]\n       [gg (optic-compose getter-fst lens-fst)])\n  (and (affine? lp)\n       (lens? ll)\n       (fold-optic? gg)\n       (equal? (affine-preview lp (cons (just 7) 'tail)) (just 7))\n       (equal? (set-lens ll 99 '((1 . 2) . (3 . 4))) '((99 . 2) . (3 . 4)))\n       (equal? (fold-to-list gg '((1 . 2) . z)) '(1))))", "tags": ["tier1", "optics", "core", "bugfix", "optic-compose"], "split": "eval"}
{"id": "optics_core_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Create an identity iso via make-iso and return its tag symbol.\n\nEnsure `make-iso` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(car (make-iso identity identity))", "verify_expr": "(equal? (car (make-iso identity identity)) 'iso)", "tags": ["tier1", "optics", "core", "composition", "make-iso", "record"], "split": "eval"}
{"id": "optics_core_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Build an iso from pair tail to scalar and read from '(a . 7).\n\nEnsure `make-iso` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(iso-view (make-iso cdr (lambda (x) (cons 'k x))) '(a . 7))", "verify_expr": "(= (iso-view (make-iso cdr (lambda (x) (cons 'k x))) '(a . 7)) 7)", "tags": ["tier1", "optics", "core", "composition", "make-iso", "view"], "split": "train"}
{"id": "optics_core_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Build the same pair-tail iso and review value 9 back into a pair.\n\nEnsure `make-iso` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(iso-review (make-iso cdr (lambda (x) (cons 'k x))) 9)", "verify_expr": "(equal? (iso-review (make-iso cdr (lambda (x) (cons 'k x))) 9) '(k . 9))", "tags": ["tier1", "optics", "core", "composition", "make-iso", "review"], "split": "train"}
{"id": "optics_core_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Compose iso-view and iso-review through a custom numeric iso and return the roundtrip result for 5.\n\nEnsure `make-iso` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([i (make-iso (lambda (x) (+ x 10)) (lambda (y) (- y 10)))]) (iso-review i (iso-view i 5)))", "verify_expr": "(= (let* ([i (make-iso (lambda (x) (+ x 10)) (lambda (y) (- y 10)))]) (iso-review i (iso-view i 5))) 5)", "tags": ["tier1", "optics", "core", "composition", "make-iso", "roundtrip"], "split": "train"}
{"id": "optics_core_composition_005", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "make-iso", "prompt_body": "Use make-iso with reverse/reverse and append 0 through iso-over on '(1 2 3).\n\nEnsure `make-iso` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(iso-over (make-iso reverse reverse) (lambda (xs) (cons 0 xs)) '(1 2 3))", "verify_expr": "(equal? (iso-over (make-iso reverse reverse) (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))", "tags": ["tier1", "optics", "core", "composition", "make-iso", "iso-over"], "split": "train"}
{"id": "optics_core_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Increment through iso-id with iso-over on 4.\n\nEnsure `iso-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(iso-over iso-id (lambda (x) (+ x 1)) 4)", "verify_expr": "(= (iso-over iso-id (lambda (x) (+ x 1)) 4) 5)", "tags": ["tier1", "optics", "core", "composition", "iso-over", "identity"], "split": "train"}
{"id": "optics_core_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Apply iso-over via iso-reversed to append 0 to list '(1 2 3).\n\nEnsure `iso-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3))", "verify_expr": "(equal? (iso-over iso-reversed (lambda (xs) (cons 0 xs)) '(1 2 3)) '(1 2 3 0))", "tags": ["tier1", "optics", "core", "composition", "iso-over", "reversed"], "split": "eval"}
{"id": "optics_core_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Modify both pair components through iso-swapped and return the reconstructed pair.\n\nEnsure `iso-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(iso-over iso-swapped (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1))) '(1 . 2))", "verify_expr": "(equal? (iso-over iso-swapped (lambda (p) (cons (+ (car p) 1) (+ (cdr p) 1))) '(1 . 2)) '(2 . 3))", "tags": ["tier1", "optics", "core", "composition", "iso-over", "swapped"], "split": "train"}
{"id": "optics_core_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Apply iso-over on iso-id to append ! to the string \"ok\".\n\nEnsure `iso-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(iso-over iso-id (lambda (s) (string-append s \"!\")) \"ok\")", "verify_expr": "(equal? (iso-over iso-id (lambda (s) (string-append s \"!\")) \"ok\") \"ok!\")", "tags": ["tier1", "optics", "core", "composition", "iso-over", "string"], "split": "train"}
{"id": "optics_core_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-over", "prompt_body": "Run iso-over with a custom car/cons iso and triple the focused numeric component.\n\nEnsure `iso-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let ([i (make-iso car (lambda (x) (cons x 'ignored)))]) (iso-over i (lambda (n) (* n 3)) '(4 . tail)))", "verify_expr": "(equal? (let ([i (make-iso car (lambda (x) (cons x 'ignored)))]) (iso-over i (lambda (n) (* n 3)) '(4 . tail))) '(12 . ignored))", "tags": ["tier1", "optics", "core", "composition", "iso-over", "custom-iso"], "split": "train"}
{"id": "optics_core_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Compose iso-swapped with itself and view pair '(1 . 2).\n\nEnsure `iso-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let ([c (iso-compose iso-swapped iso-swapped)]) (iso-view c '(1 . 2)))", "verify_expr": "(equal? (let ([c (iso-compose iso-swapped iso-swapped)]) (iso-view c '(1 . 2))) '(1 . 2))", "tags": ["tier1", "optics", "core", "composition", "iso-compose", "self-inverse"], "split": "train"}
{"id": "optics_core_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Compose numeric add-then-double isos and evaluate composed view at 3.\n\nEnsure `iso-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))] [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))] [c (iso-compose a b)]) (iso-view c 3))", "verify_expr": "(= (let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))] [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))] [c (iso-compose a b)]) (iso-view c 3)) 8)", "tags": ["tier1", "optics", "core", "composition", "iso-compose", "numeric"], "split": "train"}
{"id": "optics_core_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Using the same composed iso, review value 8 back to source space.\n\nEnsure `iso-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))] [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))] [c (iso-compose a b)]) (iso-review c 8))", "verify_expr": "(= (let* ([a (make-iso (lambda (x) (+ x 1)) (lambda (y) (- y 1)))] [b (make-iso (lambda (x) (* x 2)) (lambda (y) (/ y 2)))] [c (iso-compose a b)]) (iso-review c 8)) 3)", "tags": ["tier1", "optics", "core", "composition", "iso-compose", "numeric"], "split": "train"}
{"id": "optics_core_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Compose iso-id with iso-reversed and view '(1 2 3).\n\nEnsure `iso-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let ([c (iso-compose iso-id iso-reversed)]) (iso-view c '(1 2 3)))", "verify_expr": "(equal? (let ([c (iso-compose iso-id iso-reversed)]) (iso-view c '(1 2 3))) '(3 2 1))", "tags": ["tier1", "optics", "core", "composition", "iso-compose", "identity-compose"], "split": "eval"}
{"id": "optics_core_composition_015", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "iso-compose", "prompt_body": "Compose iso-reversed with iso-id and review '(3 2 1).\n\nEnsure `iso-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let ([c (iso-compose iso-reversed iso-id)]) (iso-review c '(3 2 1)))", "verify_expr": "(equal? (let ([c (iso-compose iso-reversed iso-id)]) (iso-review c '(3 2 1))) '(1 2 3))", "tags": ["tier1", "optics", "core", "composition", "iso-compose", "identity-compose"], "split": "train"}
{"id": "optics_core_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Increment a Just value through prism-over prism-just.\n\nEnsure `prism-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(prism-over prism-just (lambda (x) (+ x 1)) (just 4))", "verify_expr": "(equal? (prism-over prism-just (lambda (x) (+ x 1)) (just 4)) (just 5))", "tags": ["tier1", "optics", "core", "composition", "prism-over", "just"], "split": "train"}
{"id": "optics_core_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Apply the same prism-over transformation to nothing and keep it unchanged.\n\nEnsure `prism-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(prism-over prism-just (lambda (x) (+ x 1)) nothing)", "verify_expr": "(equal? (prism-over prism-just (lambda (x) (+ x 1)) nothing) nothing)", "tags": ["tier1", "optics", "core", "composition", "prism-over", "nothing"], "split": "train"}
{"id": "optics_core_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Modify Left payload text through prism-left using string-append.\n\nEnsure `prism-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\"))", "verify_expr": "(equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (left \"err\")) (left \"err!\"))", "tags": ["tier1", "optics", "core", "composition", "prism-over", "either-left"], "split": "train"}
{"id": "optics_core_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Run prism-over prism-left on a Right value and preserve the original value.\n\nEnsure `prism-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9))", "verify_expr": "(equal? (prism-over prism-left (lambda (s) (string-append s \"!\")) (right 9)) (right 9))", "tags": ["tier1", "optics", "core", "composition", "prism-over", "either-right"], "split": "train"}
{"id": "optics_core_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "prism-over", "prompt_body": "Compose prism-just with itself and increment nested Just payload.\n\nEnsure `prism-over` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(prism-over (prism-compose prism-just prism-just) (lambda (x) (+ x 1)) (just (just 4)))", "verify_expr": "(equal? (prism-over (prism-compose prism-just prism-just) (lambda (x) (+ x 1)) (just (just 4))) (just (just 5)))", "tags": ["tier1", "optics", "core", "composition", "prism-over", "composed-prism"], "split": "train"}
{"id": "optics_core_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Compose two affine-nth optics to preview the nested focus in '((10 11) (20 21) (30 31)).\n\nEnsure `affine-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-preview a s))", "verify_expr": "(equal? (let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-preview a s)) (just 20))", "tags": ["tier1", "optics", "core", "composition", "affine-compose", "preview"], "split": "eval"}
{"id": "optics_core_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Set the same composed affine focus to 99 in nested list data.\n\nEnsure `affine-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-set a 99 s))", "verify_expr": "(equal? (let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-set a 99 s)) '((10 11) (99 21) (30 31)))", "tags": ["tier1", "optics", "core", "composition", "affine-compose", "set"], "split": "train"}
{"id": "optics_core_composition_023", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Check that the composed affine returns nothing when outer focus is missing.\n\nEnsure `affine-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]) (affine-preview a '((1 2))))", "verify_expr": "(equal? (let* ([a (affine-compose (affine-nth 1) (affine-nth 0))]) (affine-preview a '((1 2)))) nothing)", "tags": ["tier1", "optics", "core", "composition", "affine-compose", "missing"], "split": "train"}
{"id": "optics_core_composition_024", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Compose affine-id with affine-nth 0 and preview from '(5 6).\n\nEnsure `affine-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (affine-compose affine-id (affine-nth 0))]) (affine-preview a '(5 6)))", "verify_expr": "(equal? (let* ([a (affine-compose affine-id (affine-nth 0))]) (affine-preview a '(5 6))) (just 5))", "tags": ["tier1", "optics", "core", "composition", "affine-compose", "identity"], "split": "train"}
{"id": "optics_core_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "affine-compose", "prompt_body": "Use affine-over through composed affine to add 10 to the nested focus.\n\nEnsure `affine-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-over a (lambda (x) (+ x 10)) s))", "verify_expr": "(equal? (let* ([a (affine-compose (affine-nth 1) (affine-nth 0))] [s '((10 11) (20 21) (30 31))]) (affine-over a (lambda (x) (+ x 10)) s)) '((10 11) (30 21) (30 31)))", "tags": ["tier1", "optics", "core", "composition", "affine-compose", "over"], "split": "train"}
{"id": "optics_core_composition_026", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Compose traversal-each with traversal-each and collect flattened targets from nested list input.\n\nEnsure `traversal-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-to-list t s))", "verify_expr": "(equal? (let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-to-list t s)) '(1 2 3 4))", "tags": ["tier1", "optics", "core", "composition", "traversal-compose", "to-list"], "split": "train"}
{"id": "optics_core_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Compose traversal-each with traversal-each and increment all nested numeric targets.\n\nEnsure `traversal-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-over t (lambda (x) (+ x 1)) s))", "verify_expr": "(equal? (let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-over t (lambda (x) (+ x 1)) s)) '((2 3) (4 5)))", "tags": ["tier1", "optics", "core", "composition", "traversal-compose", "over"], "split": "eval"}
{"id": "optics_core_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Use traversal-set through composed traversal to zero all nested values.\n\nEnsure `traversal-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-set t 0 s))", "verify_expr": "(equal? (let* ([t (traversal-compose traversal-each traversal-each)] [s '((1 2) (3 4))]) (traversal-set t 0 s)) '((0 0) (0 0)))", "tags": ["tier1", "optics", "core", "composition", "traversal-compose", "set"], "split": "train"}
{"id": "optics_core_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Compose traversal-each with filtered odd? and scale focused values by 10.\n\nEnsure `traversal-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([t (traversal-compose traversal-each (filtered odd?))]) (traversal-over t (lambda (x) (* x 10)) '(1 2 3 4)))", "verify_expr": "(equal? (let* ([t (traversal-compose traversal-each (filtered odd?))]) (traversal-over t (lambda (x) (* x 10)) '(1 2 3 4))) '(10 2 30 4))", "tags": ["tier1", "optics", "core", "composition", "traversal-compose", "filtered"], "split": "train"}
{"id": "optics_core_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "traversal-compose", "prompt_body": "Compose traversal-each with traversal-just and collect present Maybe payloads.\n\nEnsure `traversal-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([t (traversal-compose traversal-each traversal-just)]) (traversal-to-list t (list (just 1) nothing (just 3))))", "verify_expr": "(equal? (let* ([t (traversal-compose traversal-each traversal-just)]) (traversal-to-list t (list (just 1) nothing (just 3)))) '(1 3))", "tags": ["tier1", "optics", "core", "composition", "traversal-compose", "maybe"], "split": "train"}
{"id": "optics_core_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Preview the first element through fold-each on '(1 2 3).\n\nEnsure `fold-preview` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(fold-preview fold-each '(1 2 3))", "verify_expr": "(equal? (fold-preview fold-each '(1 2 3)) (just 1))", "tags": ["tier1", "optics", "core", "composition", "fold-preview", "first"], "split": "train"}
{"id": "optics_core_composition_032", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Preview through fold-each on an empty list and confirm nothing.\n\nEnsure `fold-preview` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(fold-preview fold-each '())", "verify_expr": "(equal? (fold-preview fold-each '()) nothing)", "tags": ["tier1", "optics", "core", "composition", "fold-preview", "empty"], "split": "train"}
{"id": "optics_core_composition_033", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Preview first even element through fold-filtered even? on mixed input.\n\nEnsure `fold-preview` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(fold-preview (fold-filtered even?) '(1 3 4 6))", "verify_expr": "(equal? (fold-preview (fold-filtered even?) '(1 3 4 6)) (just 4))", "tags": ["tier1", "optics", "core", "composition", "fold-preview", "filtered"], "split": "eval"}
{"id": "optics_core_composition_034", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Compose fold-each with fold-filtered odd? over nested lists and preview the first odd value.\n\nEnsure `fold-preview` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([f (fold-compose fold-each (fold-filtered odd?))]) (fold-preview f '((1 2) (4 6) (7 8))))", "verify_expr": "(equal? (let* ([f (fold-compose fold-each (fold-filtered odd?))]) (fold-preview f '((1 2) (4 6) (7 8)))) (just 1))", "tags": ["tier1", "optics", "core", "composition", "fold-preview", "composed-fold"], "split": "train"}
{"id": "optics_core_composition_035", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "fold-preview", "prompt_body": "Use lens->fold lens-fst and preview from pair '(9 . 2).\n\nEnsure `fold-preview` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(fold-preview (lens->fold lens-fst) '(9 . 2))", "verify_expr": "(equal? (fold-preview (lens->fold lens-fst) '(9 . 2)) (just 9))", "tags": ["tier1", "optics", "core", "composition", "fold-preview", "lens-fold"], "split": "train"}
{"id": "optics_core_composition_036", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Compose lens-fst with lens-fst and set nested pair focus to 99.\n\nEnsure `optic-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([o (optic-compose lens-fst lens-fst)]) (set-lens o 99 '((1 . 2) . (3 . 4))))", "verify_expr": "(equal? (let* ([o (optic-compose lens-fst lens-fst)]) (set-lens o 99 '((1 . 2) . (3 . 4)))) '((99 . 2) . (3 . 4)))", "tags": ["tier1", "optics", "core", "composition", "optic-compose", "lens-lens"], "split": "train"}
{"id": "optics_core_composition_037", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Compose lens-fst with prism-just and preview the focused payload from (cons (just 7) 'tail).\n\nEnsure `optic-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([o (optic-compose lens-fst prism-just)]) (affine-preview o (cons (just 7) 'tail)))", "verify_expr": "(equal? (let* ([o (optic-compose lens-fst prism-just)]) (affine-preview o (cons (just 7) 'tail))) (just 7))", "tags": ["tier1", "optics", "core", "composition", "optic-compose", "lens-prism"], "split": "train"}
{"id": "optics_core_composition_038", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Compose prism-just with prism-just and preview nested maybe focus.\n\nEnsure `optic-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([o (optic-compose prism-just prism-just)]) (preview o (just (just 5))))", "verify_expr": "(equal? (let* ([o (optic-compose prism-just prism-just)]) (preview o (just (just 5)))) (just 5))", "tags": ["tier1", "optics", "core", "composition", "optic-compose", "prism-prism"], "split": "train"}
{"id": "optics_core_composition_039", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Compose iso-swapped with lens-fst and view pair '(1 . 2).\n\nEnsure `optic-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([o (optic-compose iso-swapped lens-fst)]) (view o '(1 . 2)))", "verify_expr": "(= (let* ([o (optic-compose iso-swapped lens-fst)]) (view o '(1 . 2))) 2)", "tags": ["tier1", "optics", "core", "composition", "optic-compose", "iso-lens"], "split": "train"}
{"id": "optics_core_composition_040", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/optics/optics.ss", "source_test": "lattice/optics/test-optics.ss", "source_function": "optic-compose", "prompt_body": "Compose getter-fst with lens-fst and collect the resulting read-only fold output.\n\nEnsure `optic-compose` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([o (optic-compose getter-fst lens-fst)]) (fold-to-list o '((1 . 2) . z)))", "verify_expr": "(equal? (let* ([o (optic-compose getter-fst lens-fst)]) (fold-to-list o '((1 . 2) . z))) '(1))", "tags": ["tier1", "optics", "core", "composition", "optic-compose", "getter-fold"], "split": "eval"}
