{"id": "egraph_extract_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `optimize`\nSpec: Run saturation with rules using default config, then extract optimal term from the original root.\n\nWrite exactly one Scheme definition for `optimize`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `optimize`\nSpec: Run saturation with rules using default config, then extract optimal term from the original root.\n\nWrite exactly one Scheme definition for `optimize`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "optimize"], "split": "eval"}
{"id": "egraph_extract_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (optimize term rules cost-model)\n  ;; TODO: saturate then extract from the original root\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optimize`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (optimize term rules cost-model)\n  ;; TODO: saturate then extract from the original root\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optimize`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "optimize"], "split": "eval"}
{"id": "egraph_extract_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Implement `optimize` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Run saturation with rules using default config, then extract optimal term from the original root.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `optimize` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Run saturation with rules using default config, then extract optimal term from the original root.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "optimize"], "split": "eval"}
{"id": "egraph_extract_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optimize`.\nReturn only the Scheme definition.\n\n```python\ndef optimize(term, rules, cost_model):\n    eg = make_egraph()\n    root = egraph_add_term(eg, term)\n    saturate_simple(eg, rules)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, root)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optimize`.\nReturn only the Scheme definition.\n\n```python\ndef optimize(term, rules, cost_model):\n    eg = make_egraph()\n    root = egraph_add_term(eg, term)\n    saturate_simple(eg, rules)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, root)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "optimize"], "split": "eval"}
{"id": "egraph_extract_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optimize`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let* ([eg (make-egraph)]\n         [root (egraph-add-term! eg term)]\n         [_ (saturate-simple eg rules)])\n    (extract (make-extraction-state eg cost-model) root))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optimize`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let* ([eg (make-egraph)]\n         [root (egraph-add-term! eg term)]\n         [_ (saturate-simple eg rules)])\n    (extract (make-extraction-state eg cost-model) root))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "optimize"], "split": "eval"}
{"id": "egraph_extract_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optimize`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'convenience)\n\n(define (local-helper x) x)\n\n  (define (optimize term rules cost-model)\n    (let* ([eg (make-egraph)]\n           [root (egraph-add-term! eg term)]\n           [_ (saturate-simple eg rules)])\n      (extract (make-extraction-state eg cost-model) root))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optimize`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'convenience)\n\n(define (local-helper x) x)\n\n  (define (optimize term rules cost-model)\n    (let* ([eg (make-egraph)]\n           [root (egraph-add-term! eg term)]\n           [_ (saturate-simple eg rules)])\n      (extract (make-extraction-state eg cost-model) root))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "optimize"], "split": "eval"}
{"id": "egraph_extract_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: optimize must run saturation before extraction.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: optimize must run saturation before extraction.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "optimize"], "split": "eval"}
{"id": "egraph_extract_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: After saturation, optimize must extract the best equivalent term instead of returning input term.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg term)\n    (saturate-simple eg rules)\n    term))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: After saturation, optimize must extract the best equivalent term instead of returning input term.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg term)\n    (saturate-simple eg rules)\n    term))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "optimize"], "split": "eval"}
{"id": "egraph_extract_composition_001", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Build a merged class for `x` and `(+ x 0)`, create state, and extract the representative.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild a merged class for `x` and `(+ x 0)`, create state, and extract the representative.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))] [_m (egraph-merge! eg x-id sum-id)] [_r (egraph-rebuild! eg)] [st (make-extraction-state eg ast-size-cost)]) (extract st sum-id))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))] [_m (egraph-merge! eg x-id sum-id)] [_r (egraph-rebuild! eg)] [st (make-extraction-state eg ast-size-cost)]) (extract st sum-id)) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "make-extraction-state", "multi-fn", "equivalence"], "split": "eval"}
{"id": "egraph_extract_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Count how many values in a mixed list satisfy `extraction-state?`.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCount how many values in a mixed list satisfy `extraction-state?`.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [_x (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)] [vals (list st '#(wrong-tag 1 2 3 4) 42)]) (length (filter extraction-state? vals)))", "verify_expr": "(= (let* ([eg (make-egraph)] [_x (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)] [vals (list st '#(wrong-tag 1 2 3 4) 42)]) (length (filter extraction-state? vals))) 1)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extraction-state?", "collection", "multi-fn"], "split": "eval"}
{"id": "egraph_extract_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Extract a shared-subexpression form `(+ x x)` and verify exact structure.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract a shared-subexpression form `(+ x x)` and verify exact structure.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x x))] [st (make-extraction-state eg ast-size-cost)]) (extract st id))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x x))] [st (make-extraction-state eg ast-size-cost)]) (extract st id)) '(+ x x))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract", "shared", "multi-fn"], "split": "eval"}
{"id": "egraph_extract_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Run `extract-term` on `(+ a b)` in a fresh egraph.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun `extract-term` on `(+ a b)` in a fresh egraph.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (extract-term eg '(+ a b) ast-size-cost))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (extract-term eg '(+ a b) ast-size-cost)) '(+ a b))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-term", "fresh-egraph"], "split": "eval"}
{"id": "egraph_extract_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Collect extracted terms from `extract-all` and verify expected symbol membership.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCollect extracted terms from `extract-all` and verify expected symbol membership.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (let* ([st (make-extraction-state eg ast-size-cost)] [terms (map cdr (extract-all st))]) (and (not (not (member 'x terms))) (not (not (member 'y terms))))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (let* ([st (make-extraction-state eg ast-size-cost)] [terms (map cdr (extract-all st))]) (and (not (not (member 'x terms))) (not (not (member 'y terms)))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-all", "projection", "multi-fn"], "split": "eval"}
{"id": "egraph_extract_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Use config-driven optimization on `(* x 1)` and verify simplification.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse config-driven optimization on `(* x 1)` and verify simplification.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([cfg (make-saturation-config 2 10000 0)]) (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg))", "verify_expr": "(equal? (let ([cfg (make-saturation-config 2 10000 0)]) (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize-with-config", "identity"], "split": "eval"}
{"id": "egraph_extract_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Compare model outputs and verify both extracted terms equal the only available term.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompare model outputs and verify both extracted terms equal the only available term.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (equal? (cadr (car results)) '(+ x y)) (equal? (cadr (cadr results)) '(+ x y)))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (equal? (cadr (car results)) '(+ x y)) (equal? (cadr (cadr results)) '(+ x y))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "compare-extractions", "term-equality"], "split": "eval"}
{"id": "egraph_extract_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Verify compare-extractions returns triples with model, term, and numeric cost fields.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify compare-extractions returns triples with model, term, and numeric cost fields.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))] [r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (number? (caddr r1)) (cost-model? (car r2)) (number? (caddr r2)))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))] [r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (number? (caddr r1)) (cost-model? (car r2)) (number? (caddr r2))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "compare-extractions", "shape-check"], "split": "eval"}
{"id": "egraph_extract_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Return whether model names in compare-extractions are ast-size then ast-depth for the given list order.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether model names in compare-extractions are ast-size then ast-depth for the given list order.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (eq? (cost-model-name (car (car results))) 'ast-size) (eq? (cost-model-name (car (cadr results))) 'ast-depth))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (eq? (cost-model-name (car (car results))) 'ast-size) (eq? (cost-model-name (car (cadr results))) 'ast-depth)))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "compare-extractions", "ordering"], "split": "eval"}
