{"id": "egraph_extract_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `make-extraction-state`\nSpec: Compute class costs and choose minimum-cost enode for each root e-class.\n\nWrite exactly one Scheme definition for `make-extraction-state`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `make-extraction-state`\nSpec: Compute class costs and choose minimum-cost enode for each root e-class.\n\nWrite exactly one Scheme definition for `make-extraction-state`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (doc 'type (-> EGraph CostModel ExtractionState))\n  (doc 'description \"Create extraction state with precomputed best nodes.\")\n  (doc 'export #t)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  ;; TODO: compute costs and choose best enode per root class\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-extraction-state`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  ;; TODO: compute costs and choose best enode per root class\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-extraction-state`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (doc 'type (-> EGraph CostModel ExtractionState))\n  (doc 'description \"Create extraction state with precomputed best nodes.\")\n  (doc 'export #t)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Implement `make-extraction-state` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Compute class costs and choose minimum-cost enode for each root e-class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `make-extraction-state` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Compute class costs and choose minimum-cost enode for each root e-class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (doc 'type (-> EGraph CostModel ExtractionState))\n  (doc 'description \"Create extraction state with precomputed best nodes.\")\n  (doc 'export #t)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extraction-state?`\nSpec: Return #t only for extraction-state vectors tagged with extraction-state-tag and arity >= 4.\n\nWrite exactly one Scheme definition for `extraction-state?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extraction-state?`\nSpec: Return #t only for extraction-state vectors tagged with extraction-state-tag and arity >= 4.\n\nWrite exactly one Scheme definition for `extraction-state?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (extraction-state? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is an extraction state.\")\n  (doc 'export #t)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (extraction-state? x)\n  ;; TODO: validate extraction-state tag and structural shape\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extraction-state?`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (extraction-state? x)\n  ;; TODO: validate extraction-state tag and structural shape\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extraction-state?`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (extraction-state? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is an extraction state.\")\n  (doc 'export #t)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Implement `extraction-state?` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Return #t only for extraction-state vectors tagged with extraction-state-tag and arity >= 4.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `extraction-state?` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Return #t only for extraction-state vectors tagged with extraction-state-tag and arity >= 4.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (extraction-state? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is an extraction state.\")\n  (doc 'export #t)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extract`\nSpec: Extract the minimum-cost term for a class by following selected enodes recursively.\n\nWrite exactly one Scheme definition for `extract`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extract`\nSpec: Extract the minimum-cost term for a class by following selected enodes recursively.\n\nWrite exactly one Scheme definition for `extract`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (extract state class-id)\n  (doc 'type (-> ExtractionState ClassId Term))\n  (doc 'description \"Extract minimum-cost term from e-class.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "extract"], "split": "train"}
{"id": "egraph_extract_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (extract state class-id)\n  ;; TODO: lookup best node for class and recursively rebuild term\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (extract state class-id)\n  ;; TODO: lookup best node for class and recursively rebuild term\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (extract state class-id)\n  (doc 'type (-> ExtractionState ClassId Term))\n  (doc 'description \"Extract minimum-cost term from e-class.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "extract"], "split": "train"}
{"id": "egraph_extract_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Implement `extract` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Extract the minimum-cost term for a class by following selected enodes recursively.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `extract` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Extract the minimum-cost term for a class by following selected enodes recursively.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (extract state class-id)\n  (doc 'type (-> ExtractionState ClassId Term))\n  (doc 'description \"Extract minimum-cost term from e-class.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "extract"], "split": "train"}
{"id": "egraph_extract_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extract-term`\nSpec: Insert a term into an egraph, build extraction state, then extract optimal equivalent.\n\nWrite exactly one Scheme definition for `extract-term`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extract-term`\nSpec: Insert a term into an egraph, build extraction state, then extract optimal equivalent.\n\nWrite exactly one Scheme definition for `extract-term`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (extract-term eg term cost-model)\n  (doc 'type (-> EGraph Term CostModel Term))\n  (doc 'description \"Add term to e-graph and extract optimal equivalent.\")\n  (doc 'export #t)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "extract-term"], "split": "train"}
{"id": "egraph_extract_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (extract-term eg term cost-model)\n  ;; TODO: add term, make extraction state, extract best equivalent\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract-term`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (extract-term eg term cost-model)\n  ;; TODO: add term, make extraction state, extract best equivalent\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract-term`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (extract-term eg term cost-model)\n  (doc 'type (-> EGraph Term CostModel Term))\n  (doc 'description \"Add term to e-graph and extract optimal equivalent.\")\n  (doc 'export #t)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "extract-term"], "split": "train"}
{"id": "egraph_extract_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Implement `extract-term` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Insert a term into an egraph, build extraction state, then extract optimal equivalent.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `extract-term` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Insert a term into an egraph, build extraction state, then extract optimal equivalent.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (extract-term eg term cost-model)\n  (doc 'type (-> EGraph Term CostModel Term))\n  (doc 'description \"Add term to e-graph and extract optimal equivalent.\")\n  (doc 'export #t)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "extract-term"], "split": "train"}
{"id": "egraph_extract_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extract-all`\nSpec: Return (root . extracted-term) for every root e-class in the state's egraph.\n\nWrite exactly one Scheme definition for `extract-all`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `extract-all`\nSpec: Return (root . extracted-term) for every root e-class in the state's egraph.\n\nWrite exactly one Scheme definition for `extract-all`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (extract-all state)\n  (doc 'type (-> ExtractionState (List (Pair ClassId Term))))\n  (doc 'description \"Extract optimal terms for all root e-classes.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "extract-all"], "split": "train"}
{"id": "egraph_extract_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (extract-all state)\n  ;; TODO: extract one optimal term for each root class\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract-all`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (extract-all state)\n  ;; TODO: extract one optimal term for each root class\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `extract-all`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (extract-all state)\n  (doc 'type (-> ExtractionState (List (Pair ClassId Term))))\n  (doc 'description \"Extract optimal terms for all root e-classes.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "extract-all"], "split": "train"}
{"id": "egraph_extract_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Implement `extract-all` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Return (root . extracted-term) for every root e-class in the state's egraph.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement `extract-all` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Return (root . extracted-term) for every root e-class in the state's egraph.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (extract-all state)\n  (doc 'type (-> ExtractionState (List (Pair ClassId Term))))\n  (doc 'description \"Extract optimal terms for all root e-classes.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "extract-all"], "split": "train"}
{"id": "egraph_extract_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `optimize`\nSpec: Run saturation with rules using default config, then extract optimal term from the original root.\n\nWrite exactly one Scheme definition for `optimize`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `optimize`\nSpec: Run saturation with rules using default config, then extract optimal term from the original root.\n\nWrite exactly one Scheme definition for `optimize`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "optimize"], "split": "eval"}
{"id": "egraph_extract_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (optimize term rules cost-model)\n  ;; TODO: saturate then extract from the original root\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optimize`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (optimize term rules cost-model)\n  ;; TODO: saturate then extract from the original root\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optimize`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "optimize"], "split": "eval"}
{"id": "egraph_extract_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Implement `optimize` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Run saturation with rules using default config, then extract optimal term from the original root.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement `optimize` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Run saturation with rules using default config, then extract optimal term from the original root.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "optimize"], "split": "eval"}
{"id": "egraph_extract_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `optimize-with-config`\nSpec: Same as optimize, but use caller-provided saturation config.\n\nWrite exactly one Scheme definition for `optimize-with-config`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `optimize-with-config`\nSpec: Same as optimize, but use caller-provided saturation config.\n\nWrite exactly one Scheme definition for `optimize-with-config`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? r1 'x)\n(equal? r2 'x)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (doc 'type (-> Term (List Rule) CostModel SaturationConfig Term))\n  (doc 'description \"Optimize with custom saturation config.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  ;; TODO: saturate with config then extract from the original root\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optimize-with-config`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  ;; TODO: saturate with config then extract from the original root\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `optimize-with-config`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? r1 'x)\n(equal? r2 'x)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (doc 'type (-> Term (List Rule) CostModel SaturationConfig Term))\n  (doc 'description \"Optimize with custom saturation config.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Implement `optimize-with-config` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Same as optimize, but use caller-provided saturation config.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `optimize-with-config` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: Same as optimize, but use caller-provided saturation config.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? r1 'x)\n(equal? r2 'x)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (doc 'type (-> Term (List Rule) CostModel SaturationConfig Term))\n  (doc 'description \"Optimize with custom saturation config.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Implement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `compare-extractions`\nSpec: For each cost model, return (cost-model extracted-term class-cost) for the target class.\n\nWrite exactly one Scheme definition for `compare-extractions`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this e-graph extraction utility in Fold-native Scheme.\n\nTarget module: lattice/egraph/extract.ss\nFunction: `compare-extractions`\nSpec: For each cost model, return (cost-model extracted-term class-cost) for the target class.\n\nWrite exactly one Scheme definition for `compare-extractions`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (doc 'type (-> EGraph ClassId (List CostModel) (List (Triple CostModel Term Nat))))\n  (doc 'description \"Compare extractions across different cost models.\")\n  (doc 'export #t)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "spec-to-code", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  ;; TODO: run extraction under each cost model and report (model term cost)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compare-extractions`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  ;; TODO: run extraction under each cost model and report (model term cost)\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `compare-extractions`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (doc 'type (-> EGraph ClassId (List CostModel) (List (Triple CostModel Term Nat))))\n  (doc 'description \"Compare extractions across different cost models.\")\n  (doc 'export #t)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "skeleton-completion", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Implement `compare-extractions` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: For each cost model, return (cost-model extracted-term class-cost) for the target class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement `compare-extractions` from this contract.\n\nModule: `lattice/egraph/extract.ss`\nContract focus: For each cost model, return (cost-model extracted-term class-cost) for the target class.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve extraction semantics and edge behavior.\n3. Return only one production-ready definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (doc 'type (-> EGraph ClassId (List CostModel) (List (Triple CostModel Term Nat))))\n  (doc 'description \"Compare extractions across different cost models.\")\n  (doc 'export #t)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "contract-implementation", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_translation_001", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-extraction-state`.\nReturn only the Scheme definition.\n\n```python\ndef make_extraction_state(eg, cost_model):\n    costs = compute_costs(eg, cost_model)\n    best_nodes = {}\n    node_cost = cost_model.fn\n    for root in uf_roots(egraph_uf(eg)):\n        best_node = None\n        best_cost = float('inf')\n        for node in eclass_nodes(egraph_classes(eg), root):\n            c = compute_node_cost(node, costs, node_cost)\n            if c < best_cost:\n                best_node = node\n                best_cost = c\n        if best_node is not None:\n            best_nodes[root] = best_node\n    return ('extraction-state', eg, costs, best_nodes)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-extraction-state`.\nReturn only the Scheme definition.\n\n```python\ndef make_extraction_state(eg, cost_model):\n    costs = compute_costs(eg, cost_model)\n    best_nodes = {}\n    node_cost = cost_model.fn\n    for root in uf_roots(egraph_uf(eg)):\n        best_node = None\n        best_cost = float('inf')\n        for node in eclass_nodes(egraph_classes(eg), root):\n            c = compute_node_cost(node, costs, node_cost)\n            if c < best_cost:\n                best_node = node\n                best_cost = c\n        if best_node is not None:\n            best_nodes[root] = best_node\n    return ('extraction-state', eg, costs, best_nodes)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (doc 'type (-> EGraph CostModel ExtractionState))\n  (doc 'description \"Create extraction state with precomputed best nodes.\")\n  (doc 'export #t)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_translation_002", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-extraction-state`.\nReturn only the final Fold definition.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  (let* ([costs (compute-costs eg cost-model)]\n         [uf (egraph-uf eg)]\n         [store (egraph-classes eg)]\n         [node-cost-fn (cost-model-fn cost-model)])\n    (define (best-node-for root)\n      (let pick ([nodes (eclass-get-nodes store root)]\n                 [best #f]\n                 [best-cost +inf.0])\n        (if (null? nodes)\n            best\n            (let* ([node (car nodes)]\n                   [c (compute-node-cost node costs node-cost-fn)])\n              (if (< c best-cost)\n                  (pick (cdr nodes) node c)\n                  (pick (cdr nodes) best best-cost))))))\n    (let loop-roots ([roots (uf-roots uf)]\n                     [best-nodes hamt-empty])\n      (if (null? roots)\n          (vector extraction-state-tag eg costs best-nodes)\n          (let* ([root (car roots)]\n                 [best (best-node-for root)]\n                 [next (if best (hamt-assoc root best best-nodes) best-nodes)])\n            (loop-roots (cdr roots) next)))))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-extraction-state`.\nReturn only the final Fold definition.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  (let* ([costs (compute-costs eg cost-model)]\n         [uf (egraph-uf eg)]\n         [store (egraph-classes eg)]\n         [node-cost-fn (cost-model-fn cost-model)])\n    (define (best-node-for root)\n      (let pick ([nodes (eclass-get-nodes store root)]\n                 [best #f]\n                 [best-cost +inf.0])\n        (if (null? nodes)\n            best\n            (let* ([node (car nodes)]\n                   [c (compute-node-cost node costs node-cost-fn)])\n              (if (< c best-cost)\n                  (pick (cdr nodes) node c)\n                  (pick (cdr nodes) best best-cost))))))\n    (let loop-roots ([roots (uf-roots uf)]\n                     [best-nodes hamt-empty])\n      (if (null? roots)\n          (vector extraction-state-tag eg costs best-nodes)\n          (let* ([root (car roots)]\n                 [best (best-node-for root)]\n                 [next (if best (hamt-assoc root best best-nodes) best-nodes)])\n            (loop-roots (cdr roots) next)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (doc 'type (-> EGraph CostModel ExtractionState))\n  (doc 'description \"Create extraction state with precomputed best nodes.\")\n  (doc 'export #t)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_translation_003", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-extraction-state`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'state)\n\n(define (local-helper x) x)\n\n  (define (make-extraction-state eg cost-model)\n    (let* ([costs (compute-costs eg cost-model)]\n           [uf (egraph-uf eg)]\n           [store (egraph-classes eg)]\n           [node-cost-fn (cost-model-fn cost-model)])\n      (define (best-node-for root)\n        (let pick ([nodes (eclass-get-nodes store root)]\n                   [best #f]\n                   [best-cost +inf.0])\n          (if (null? nodes)\n              best\n              (let* ([node (car nodes)]\n                     [c (compute-node-cost node costs node-cost-fn)])\n                (if (< c best-cost)\n                    (pick (cdr nodes) node c)\n                    (pick (cdr nodes) best best-cost))))))\n      (let loop-roots ([roots (uf-roots uf)]\n                       [best-nodes hamt-empty])\n        (if (null? roots)\n            (vector extraction-state-tag eg costs best-nodes)\n            (let* ([root (car roots)]\n                   [best (best-node-for root)]\n                   [next (if best (hamt-assoc root best best-nodes) best-nodes)])\n              (loop-roots (cdr roots) next)))))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-extraction-state`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'state)\n\n(define (local-helper x) x)\n\n  (define (make-extraction-state eg cost-model)\n    (let* ([costs (compute-costs eg cost-model)]\n           [uf (egraph-uf eg)]\n           [store (egraph-classes eg)]\n           [node-cost-fn (cost-model-fn cost-model)])\n      (define (best-node-for root)\n        (let pick ([nodes (eclass-get-nodes store root)]\n                   [best #f]\n                   [best-cost +inf.0])\n          (if (null? nodes)\n              best\n              (let* ([node (car nodes)]\n                     [c (compute-node-cost node costs node-cost-fn)])\n                (if (< c best-cost)\n                    (pick (cdr nodes) node c)\n                    (pick (cdr nodes) best best-cost))))))\n      (let loop-roots ([roots (uf-roots uf)]\n                       [best-nodes hamt-empty])\n        (if (null? roots)\n            (vector extraction-state-tag eg costs best-nodes)\n            (let* ([root (car roots)]\n                   [best (best-node-for root)]\n                   [next (if best (hamt-assoc root best best-nodes) best-nodes)])\n              (loop-roots (cdr roots) next)))))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extraction-state?`.\nReturn only the Scheme definition.\n\n```python\ndef extraction_state_p(x):\n    return (isinstance(x, tuple)\n            and len(x) >= 4\n            and x[0] == 'extraction-state')\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extraction-state?`.\nReturn only the Scheme definition.\n\n```python\ndef extraction_state_p(x):\n    return (isinstance(x, tuple)\n            and len(x) >= 4\n            and x[0] == 'extraction-state')\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (extraction-state? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is an extraction state.\")\n  (doc 'export #t)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extraction-state?`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extraction-state? x)\n  (if (vector? x)\n      (let ([n (vector-length x)])\n        (if (>= n 4)\n            (eq? (vector-ref x 0) extraction-state-tag)\n            #f))\n      #f))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extraction-state?`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extraction-state? x)\n  (if (vector? x)\n      (let ([n (vector-length x)])\n        (if (>= n 4)\n            (eq? (vector-ref x 0) extraction-state-tag)\n            #f))\n      #f))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (extraction-state? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is an extraction state.\")\n  (doc 'export #t)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extraction-state?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'state)\n\n(define (local-helper x) x)\n\n  (define (extraction-state? x)\n    (if (vector? x)\n        (let ([n (vector-length x)])\n          (if (>= n 4)\n              (eq? (vector-ref x 0) extraction-state-tag)\n              #f))\n        #f))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extraction-state?`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'state)\n\n(define (local-helper x) x)\n\n  (define (extraction-state? x)\n    (if (vector? x)\n        (let ([n (vector-length x)])\n          (if (>= n 4)\n              (eq? (vector-ref x 0) extraction-state-tag)\n              #f))\n        #f))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (extraction-state? x)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extract`.\nReturn only the Scheme definition.\n\n```python\ndef extract(state, class_id):\n    eg = state_egraph(state)\n    root = egraph_find(eg, class_id)\n    best = state_best_nodes(state).get(root)\n    if best is None:\n        raise ValueError('no best node for class')\n    if len(best.children) == 0:\n        return best.op\n    return [best.op] + [extract(state, cid) for cid in best.children]\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extract`.\nReturn only the Scheme definition.\n\n```python\ndef extract(state, class_id):\n    eg = state_egraph(state)\n    root = egraph_find(eg, class_id)\n    best = state_best_nodes(state).get(root)\n    if best is None:\n        raise ValueError('no best node for class')\n    if len(best.children) == 0:\n        return best.op\n    return [best.op] + [extract(state, cid) for cid in best.children]\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (extract state class-id)\n  (doc 'type (-> ExtractionState ClassId Term))\n  (doc 'description \"Extract minimum-cost term from e-class.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "extract"], "split": "train"}
{"id": "egraph_extract_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extract`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extract state class-id)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best (hamt-lookup root (state-best-nodes state))])\n    (if (not best)\n        (error 'extract \"no best node for class\" root)\n        (let ([children (enode-children best)])\n          (if (zero? (vector-length children))\n              (enode-op best)\n              (cons (enode-op best)\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extract`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extract state class-id)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best (hamt-lookup root (state-best-nodes state))])\n    (if (not best)\n        (error 'extract \"no best node for class\" root)\n        (let ([children (enode-children best)])\n          (if (zero? (vector-length children))\n              (enode-op best)\n              (cons (enode-op best)\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (extract state class-id)\n  (doc 'type (-> ExtractionState ClassId Term))\n  (doc 'description \"Extract minimum-cost term from e-class.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "extract"], "split": "train"}
{"id": "egraph_extract_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extract`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'extract)\n\n(define (local-helper x) x)\n\n  (define (extract state class-id)\n    (let* ([eg (state-egraph state)]\n           [root (egraph-find eg class-id)]\n           [best (hamt-lookup root (state-best-nodes state))])\n      (if (not best)\n          (error 'extract \"no best node for class\" root)\n          (let ([children (enode-children best)])\n            (if (zero? (vector-length children))\n                (enode-op best)\n                (cons (enode-op best)\n                      (map (lambda (i)\n                             (extract state (vector-ref children i)))\n                           (iota (vector-length children)))))))))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extract`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'extract)\n\n(define (local-helper x) x)\n\n  (define (extract state class-id)\n    (let* ([eg (state-egraph state)]\n           [root (egraph-find eg class-id)]\n           [best (hamt-lookup root (state-best-nodes state))])\n      (if (not best)\n          (error 'extract \"no best node for class\" root)\n          (let ([children (enode-children best)])\n            (if (zero? (vector-length children))\n                (enode-op best)\n                (cons (enode-op best)\n                      (map (lambda (i)\n                             (extract state (vector-ref children i)))\n                           (iota (vector-length children)))))))))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (extract state class-id)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "extract"], "split": "train"}
{"id": "egraph_extract_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extract-term`.\nReturn only the Scheme definition.\n\n```python\ndef extract_term(eg, term, cost_model):\n    cid = egraph_add_term(eg, term)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, cid)\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extract-term`.\nReturn only the Scheme definition.\n\n```python\ndef extract_term(eg, term, cost_model):\n    cid = egraph_add_term(eg, term)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, cid)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (extract-term eg term cost-model)\n  (doc 'type (-> EGraph Term CostModel Term))\n  (doc 'description \"Add term to e-graph and extract optimal equivalent.\")\n  (doc 'export #t)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "extract-term"], "split": "train"}
{"id": "egraph_extract_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extract-term`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extract-term eg term cost-model)\n  (let ([class-id (egraph-add-term! eg term)])\n    (extract (make-extraction-state eg cost-model) class-id)))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extract-term`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extract-term eg term cost-model)\n  (let ([class-id (egraph-add-term! eg term)])\n    (extract (make-extraction-state eg cost-model) class-id)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (extract-term eg term cost-model)\n  (doc 'type (-> EGraph Term CostModel Term))\n  (doc 'description \"Add term to e-graph and extract optimal equivalent.\")\n  (doc 'export #t)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "extract-term"], "split": "train"}
{"id": "egraph_extract_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extract-term`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'extract)\n\n(define (local-helper x) x)\n\n  (define (extract-term eg term cost-model)\n    (let ([class-id (egraph-add-term! eg term)])\n      (extract (make-extraction-state eg cost-model) class-id)))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extract-term`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'extract)\n\n(define (local-helper x) x)\n\n  (define (extract-term eg term cost-model)\n    (let ([class-id (egraph-add-term! eg term)])\n      (extract (make-extraction-state eg cost-model) class-id)))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (extract-term eg term cost-model)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "extract-term"], "split": "train"}
{"id": "egraph_extract_translation_013", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extract-all`.\nReturn only the Scheme definition.\n\n```python\ndef extract_all(state):\n    eg = state_egraph(state)\n    return [(root, extract(state, root)) for root in uf_roots(egraph_uf(eg))]\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `extract-all`.\nReturn only the Scheme definition.\n\n```python\ndef extract_all(state):\n    eg = state_egraph(state)\n    return [(root, extract(state, root)) for root in uf_roots(egraph_uf(eg))]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (extract-all state)\n  (doc 'type (-> ExtractionState (List (Pair ClassId Term))))\n  (doc 'description \"Extract optimal terms for all root e-classes.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "extract-all"], "split": "train"}
{"id": "egraph_extract_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extract-all`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extract-all state)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (reverse\n     (fold-left\n      (lambda (acc root)\n        (cons (cons root (extract state root)) acc))\n      '()\n      (uf-roots uf)))))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `extract-all`.\nReturn only the final Fold definition.\n\n```scheme\n(define (extract-all state)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (reverse\n     (fold-left\n      (lambda (acc root)\n        (cons (cons root (extract state root)) acc))\n      '()\n      (uf-roots uf)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (extract-all state)\n  (doc 'type (-> ExtractionState (List (Pair ClassId Term))))\n  (doc 'description \"Extract optimal terms for all root e-classes.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "extract-all"], "split": "train"}
{"id": "egraph_extract_translation_015", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extract-all`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'extract)\n\n(define (local-helper x) x)\n\n  (define (extract-all state)\n    (let* ([eg (state-egraph state)]\n           [uf (egraph-uf eg)])\n      (reverse\n       (fold-left\n        (lambda (acc root)\n          (cons (cons root (extract state root)) acc))\n        '()\n        (uf-roots uf)))))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `extract-all`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'extract)\n\n(define (local-helper x) x)\n\n  (define (extract-all state)\n    (let* ([eg (state-egraph state)]\n           [uf (egraph-uf eg)])\n      (reverse\n       (fold-left\n        (lambda (acc root)\n          (cons (cons root (extract state root)) acc))\n        '()\n        (uf-roots uf)))))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (extract-all state)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "extract-all"], "split": "train"}
{"id": "egraph_extract_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optimize`.\nReturn only the Scheme definition.\n\n```python\ndef optimize(term, rules, cost_model):\n    eg = make_egraph()\n    root = egraph_add_term(eg, term)\n    saturate_simple(eg, rules)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, root)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optimize`.\nReturn only the Scheme definition.\n\n```python\ndef optimize(term, rules, cost_model):\n    eg = make_egraph()\n    root = egraph_add_term(eg, term)\n    saturate_simple(eg, rules)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, root)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "optimize"], "split": "eval"}
{"id": "egraph_extract_translation_017", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optimize`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let* ([eg (make-egraph)]\n         [root (egraph-add-term! eg term)]\n         [_ (saturate-simple eg rules)])\n    (extract (make-extraction-state eg cost-model) root))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optimize`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let* ([eg (make-egraph)]\n         [root (egraph-add-term! eg term)]\n         [_ (saturate-simple eg rules)])\n    (extract (make-extraction-state eg cost-model) root))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "optimize"], "split": "eval"}
{"id": "egraph_extract_translation_018", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optimize`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'convenience)\n\n(define (local-helper x) x)\n\n  (define (optimize term rules cost-model)\n    (let* ([eg (make-egraph)]\n           [root (egraph-add-term! eg term)]\n           [_ (saturate-simple eg rules)])\n      (extract (make-extraction-state eg cost-model) root))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optimize`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'convenience)\n\n(define (local-helper x) x)\n\n  (define (optimize term rules cost-model)\n    (let* ([eg (make-egraph)]\n           [root (egraph-add-term! eg term)]\n           [_ (saturate-simple eg rules)])\n      (extract (make-extraction-state eg cost-model) root))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "optimize"], "split": "eval"}
{"id": "egraph_extract_translation_019", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optimize-with-config`.\nReturn only the Scheme definition.\n\n```python\ndef optimize_with_config(term, rules, cost_model, config):\n    eg = make_egraph()\n    root = egraph_add_term(eg, term)\n    saturate(eg, rules, config)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, root)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `optimize-with-config`.\nReturn only the Scheme definition.\n\n```python\ndef optimize_with_config(term, rules, cost_model, config):\n    eg = make_egraph()\n    root = egraph_add_term(eg, term)\n    saturate(eg, rules, config)\n    state = make_extraction_state(eg, cost_model)\n    return extract(state, root)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? r1 'x)\n(equal? r2 'x)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (doc 'type (-> Term (List Rule) CostModel SaturationConfig Term))\n  (doc 'description \"Optimize with custom saturation config.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_translation_020", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optimize-with-config`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  (let* ([eg (make-egraph)]\n         [root (egraph-add-term! eg term)]\n         [_ (saturate eg rules config)])\n    (extract (make-extraction-state eg cost-model) root))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `optimize-with-config`.\nReturn only the final Fold definition.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  (let* ([eg (make-egraph)]\n         [root (egraph-add-term! eg term)]\n         [_ (saturate eg rules config)])\n    (extract (make-extraction-state eg cost-model) root))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? r1 'x)\n(equal? r2 'x)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (doc 'type (-> Term (List Rule) CostModel SaturationConfig Term))\n  (doc 'description \"Optimize with custom saturation config.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_translation_021", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optimize-with-config`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'convenience)\n\n(define (local-helper x) x)\n\n  (define (optimize-with-config term rules cost-model config)\n    (let* ([eg (make-egraph)]\n           [root (egraph-add-term! eg term)]\n           [_ (saturate eg rules config)])\n      (extract (make-extraction-state eg cost-model) root))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `optimize-with-config`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'convenience)\n\n(define (local-helper x) x)\n\n  (define (optimize-with-config term rules cost-model config)\n    (let* ([eg (make-egraph)]\n           [root (egraph-add-term! eg term)]\n           [_ (saturate eg rules config)])\n      (extract (make-extraction-state eg cost-model) root))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_translation_022", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `compare-extractions`.\nReturn only the Scheme definition.\n\n```python\ndef compare_extractions(eg, class_id, models):\n    out = []\n    for cm in models:\n        state = make_extraction_state(eg, cm)\n        term = extract(state, class_id)\n        cost = class_cost(state_costs(state), egraph_find(eg, class_id))\n        out.append((cm, term, cost))\n    return out\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `compare-extractions`.\nReturn only the Scheme definition.\n\n```python\ndef compare_extractions(eg, class_id, models):\n    out = []\n    for cm in models:\n        state = make_extraction_state(eg, cm)\n        term = extract(state, class_id)\n        cost = class_cost(state_costs(state), egraph_find(eg, class_id))\n        out.append((cm, term, cost))\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (doc 'type (-> EGraph ClassId (List CostModel) (List (Triple CostModel Term Nat))))\n  (doc 'description \"Compare extractions across different cost models.\")\n  (doc 'export #t)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "python-to-scheme", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_translation_023", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `compare-extractions`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  (fold-right\n   (lambda (cm acc)\n     (let* ([state (make-extraction-state eg cm)]\n            [term (extract state class-id)]\n            [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n       (cons (list cm term cost) acc)))\n   '()\n   cost-models))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `compare-extractions`.\nReturn only the final Fold definition.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  (fold-right\n   (lambda (cm acc)\n     (let* ([state (make-extraction-state eg cm)]\n            [term (extract state class-id)]\n            [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n       (cons (list cm term cost) acc)))\n   '()\n   cost-models))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (doc 'type (-> EGraph ClassId (List CostModel) (List (Triple CostModel Term Nat))))\n  (doc 'description \"Compare extractions across different cost models.\")\n  (doc 'export #t)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "chez-to-fold", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_translation_024", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `compare-extractions`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'analysis)\n\n(define (local-helper x) x)\n\n  (define (compare-extractions eg class-id cost-models)\n    (fold-right\n     (lambda (cm acc)\n       (let* ([state (make-extraction-state eg cm)]\n              [term (extract state class-id)]\n              [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n         (cons (list cm term cost) acc)))\n     '()\n     cost-models))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `compare-extractions`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/egraph/extract.ss excerpt\n(require 'prelude)\n(require 'hamt)\n(require 'egraph/cost)\n(require 'egraph/saturation)\n\n(doc 'module 'egraph/extract)\n(doc 'section 'analysis)\n\n(define (local-helper x) x)\n\n  (define (compare-extractions eg class-id cost-models)\n    (fold-right\n     (lambda (cm acc)\n       (let* ([state (make-extraction-state eg cm)]\n              [term (extract state class-id)]\n              [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n         (cons (list cm term cost) acc)))\n     '()\n     cost-models))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "source-excerpt-to-fold", "doc-free-target", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-extraction-state` in `lattice/egraph/extract.ss`.\nKnown issue: State must include best-node selections for each root class; leaving table empty breaks extraction.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)])\n    (vector extraction-state-tag eg costs hamt-empty)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-extraction-state` in `lattice/egraph/extract.ss`.\nKnown issue: State must include best-node selections for each root class; leaving table empty breaks extraction.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)])\n    (vector extraction-state-tag eg costs hamt-empty)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (doc 'type (-> EGraph CostModel ExtractionState))\n  (doc 'description \"Create extraction state with precomputed best nodes.\")\n  (doc 'export #t)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-extraction-state` in `lattice/egraph/extract.ss`.\nKnown issue: The state must preserve computed costs; replacing them with an empty table breaks extraction analytics.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)])\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let ([nodes (eclass-get-nodes store root)])\n                (if (null? nodes)\n                    bn\n                    (hamt-assoc root (car nodes) bn))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg hamt-empty best-nodes))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-extraction-state` in `lattice/egraph/extract.ss`.\nKnown issue: The state must preserve computed costs; replacing them with an empty table breaks extraction analytics.\n\n```scheme\n(define (make-extraction-state eg cost-model)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)])\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let ([nodes (eclass-get-nodes store root)])\n                (if (null? nodes)\n                    bn\n                    (hamt-assoc root (car nodes) bn))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg hamt-empty best-nodes))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-extraction-state eg cost-model)\n  (doc 'type (-> EGraph CostModel ExtractionState))\n  (doc 'description \"Create extraction state with precomputed best nodes.\")\n  (doc 'export #t)\n  (let ([costs (compute-costs eg cost-model)]\n        [uf (egraph-uf eg)]\n        [store (egraph-classes eg)]\n        [node-cost-fn (cost-model-fn cost-model)])\n    ;; Find best node for each class\n    (let ([best-nodes\n           (fold-left\n            (lambda (bn root)\n              (let find-best ([nodes (eclass-get-nodes store root)]\n                              [best-node #f]\n                              [best-cost +inf.0])\n                (if (null? nodes)\n                    (if best-node (hamt-assoc root best-node bn) bn)\n                    (let ([c (compute-node-cost (car nodes) costs node-cost-fn)])\n                      (if (< c best-cost)\n                          (find-best (cdr nodes) (car nodes) c)\n                          (find-best (cdr nodes) best-node best-cost))))))\n            hamt-empty\n            (uf-roots uf))])\n      (vector extraction-state-tag eg costs best-nodes))))", "verify_expr": "(let* ([eg (make-egraph)] [exp-id (egraph-add-term! eg '(+ (+ x 0) 0))] [x-id (egraph-add-term! eg 'x)]) (egraph-merge! eg exp-id x-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg exp-id)] [best (hamt-lookup root (state-best-nodes st))]) (and (extraction-state? st) (eq? (state-egraph st) eg) (not (hamt-empty? (state-costs st))) best (equal? (extract st exp-id) 'x) (eq? (enode-op best) 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "make-extraction-state"], "split": "train"}
{"id": "egraph_extract_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extraction-state?` in `lattice/egraph/extract.ss`.\nKnown issue: Predicate must validate extraction-state-tag, not just vector shape.\n\n```scheme\n(define (extraction-state? x)\n  (and (vector? x)\n       (>= (vector-length x) 4)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extraction-state?` in `lattice/egraph/extract.ss`.\nKnown issue: Predicate must validate extraction-state-tag, not just vector shape.\n\n```scheme\n(define (extraction-state? x)\n  (and (vector? x)\n       (>= (vector-length x) 4)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (extraction-state? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is an extraction state.\")\n  (doc 'export #t)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extraction-state?` in `lattice/egraph/extract.ss`.\nKnown issue: Valid extraction states have length 4; requiring > 4 rejects correct values.\n\n```scheme\n(define (extraction-state? x)\n  (and (vector? x)\n       (> (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extraction-state?` in `lattice/egraph/extract.ss`.\nKnown issue: Valid extraction states have length 4; requiring > 4 rejects correct values.\n\n```scheme\n(define (extraction-state? x)\n  (and (vector? x)\n       (> (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (extraction-state? x)\n  (doc 'type (-> Any Boolean))\n  (doc 'description \"Check if x is an extraction state.\")\n  (doc 'export #t)\n  (and (vector? x)\n       (>= (vector-length x) 4)\n       (eq? (vector-ref x 0) extraction-state-tag)))", "verify_expr": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (let ([st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (extraction-state? '#(extraction-state 1 2))) (not (extraction-state? '#(wrong-tag 1 2 3 4))) (not (extraction-state? 42)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extraction-state?"], "split": "train"}
{"id": "egraph_extract_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract` in `lattice/egraph/extract.ss`.\nKnown issue: Must canonicalize class-id with egraph-find before best-node lookup.\n\n```scheme\n(define (extract state class-id)\n  (let* ([best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup class-id best-nodes)])\n    (if (not best-node)\n        (error 'extract \"no best node for class\" class-id)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              op\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract` in `lattice/egraph/extract.ss`.\nKnown issue: Must canonicalize class-id with egraph-find before best-node lookup.\n\n```scheme\n(define (extract state class-id)\n  (let* ([best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup class-id best-nodes)])\n    (if (not best-node)\n        (error 'extract \"no best node for class\" class-id)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              op\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (extract state class-id)\n  (doc 'type (-> ExtractionState ClassId Term))\n  (doc 'description \"Extract minimum-cost term from e-class.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extract"], "split": "train"}
{"id": "egraph_extract_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract` in `lattice/egraph/extract.ss`.\nKnown issue: Compound nodes must recurse into children; returning only the operator loses structure.\n\n```scheme\n(define (extract state class-id)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-node (hamt-lookup root (state-best-nodes state))])\n    (if (not best-node)\n        (error 'extract \"no best node for class\" root)\n        (enode-op best-node))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract` in `lattice/egraph/extract.ss`.\nKnown issue: Compound nodes must recurse into children; returning only the operator loses structure.\n\n```scheme\n(define (extract state class-id)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-node (hamt-lookup root (state-best-nodes state))])\n    (if (not best-node)\n        (error 'extract \"no best node for class\" root)\n        (enode-op best-node))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (extract state class-id)\n  (doc 'type (-> ExtractionState ClassId Term))\n  (doc 'description \"Extract minimum-cost term from e-class.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [root (egraph-find eg class-id)]\n         [best-nodes (state-best-nodes state)]\n         [best-node (hamt-lookup root best-nodes)])\n    (if (not best-node)\n        ;; Shouldn't happen in a well-formed e-graph\n        (error 'extract \"no best node for class\" root)\n        (let ([op (enode-op best-node)]\n              [children (enode-children best-node)])\n          (if (zero? (vector-length children))\n              ;; Leaf: return the operator as-is\n              op\n              ;; Compound: recursively extract children\n              (cons op\n                    (map (lambda (i)\n                           (extract state (vector-ref children i)))\n                         (iota (vector-length children)))))))))", "verify_expr": "(let* ([eg (make-egraph)] [id1 (egraph-add-term! eg '(+ a b))] [id2 (egraph-add-term! eg '(* (+ a b) c))] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x-id sum-id) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [t1 (extract st id1)] [t2 (extract st id2)] [t3 (extract st sum-id)]) (and (equal? t1 '(+ a b)) (equal? t2 '(* (+ a b) c)) (equal? t3 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extract"], "split": "train"}
{"id": "egraph_extract_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-term` in `lattice/egraph/extract.ss`.\nKnown issue: extract-term must run extraction, not return the input term directly.\n\n```scheme\n(define (extract-term eg term cost-model)\n  (egraph-add-term! eg term)\n  term)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-term` in `lattice/egraph/extract.ss`.\nKnown issue: extract-term must run extraction, not return the input term directly.\n\n```scheme\n(define (extract-term eg term cost-model)\n  (egraph-add-term! eg term)\n  term)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (extract-term eg term cost-model)\n  (doc 'type (-> EGraph Term CostModel Term))\n  (doc 'description \"Add term to e-graph and extract optimal equivalent.\")\n  (doc 'export #t)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extract-term"], "split": "train"}
{"id": "egraph_extract_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-term` in `lattice/egraph/extract.ss`.\nKnown issue: State must be built after inserting the term so best-node tables include the new class.\n\n```scheme\n(define (extract-term eg term cost-model)\n  (let* ([state (make-extraction-state eg cost-model)]\n         [class-id (egraph-add-term! eg term)])\n    (extract state class-id)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-term` in `lattice/egraph/extract.ss`.\nKnown issue: State must be built after inserting the term so best-node tables include the new class.\n\n```scheme\n(define (extract-term eg term cost-model)\n  (let* ([state (make-extraction-state eg cost-model)]\n         [class-id (egraph-add-term! eg term)])\n    (extract state class-id)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (extract-term eg term cost-model)\n  (doc 'type (-> EGraph Term CostModel Term))\n  (doc 'description \"Add term to e-graph and extract optimal equivalent.\")\n  (doc 'export #t)\n  (let* ([class-id (egraph-add-term! eg term)]\n         [state (make-extraction-state eg cost-model)])\n    (extract state class-id)))", "verify_expr": "(let* ([eg1 (make-egraph)] [t1 (extract-term eg1 '(+ a b) ast-size-cost)] [eg2 (make-egraph)] [x (egraph-add-term! eg2 'x)] [sum (egraph-add-term! eg2 '(+ x 0))]) (egraph-merge! eg2 x sum) (egraph-rebuild! eg2) (let ([t2 (extract-term eg2 '(+ x 0) ast-size-cost)]) (and (equal? t1 '(+ a b)) (equal? t2 'x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extract-term"], "split": "train"}
{"id": "egraph_extract_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-all` in `lattice/egraph/extract.ss`.\nKnown issue: extract-all must return (root . term) pairs, not bare terms.\n\n```scheme\n(define (extract-all state)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (extract state root))\n         (uf-roots uf))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-all` in `lattice/egraph/extract.ss`.\nKnown issue: extract-all must return (root . term) pairs, not bare terms.\n\n```scheme\n(define (extract-all state)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (extract state root))\n         (uf-roots uf))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (extract-all state)\n  (doc 'type (-> ExtractionState (List (Pair ClassId Term))))\n  (doc 'description \"Extract optimal terms for all root e-classes.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extract-all"], "split": "train"}
{"id": "egraph_extract_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-all` in `lattice/egraph/extract.ss`.\nKnown issue: Pair values must be extracted terms, not repeated class ids.\n\n```scheme\n(define (extract-all state)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root root))\n         (uf-roots uf))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `extract-all` in `lattice/egraph/extract.ss`.\nKnown issue: Pair values must be extracted terms, not repeated class ids.\n\n```scheme\n(define (extract-all state)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root root))\n         (uf-roots uf))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (extract-all state)\n  (doc 'type (-> ExtractionState (List (Pair ClassId Term))))\n  (doc 'description \"Extract optimal terms for all root e-classes.\")\n  (doc 'export #t)\n  (let* ([eg (state-egraph state)]\n         [uf (egraph-uf eg)])\n    (map (lambda (root)\n           (cons root (extract state root)))\n         (uf-roots uf))))", "verify_expr": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [b (egraph-add-term! eg 'b)] [ab (egraph-add-term! eg '(+ a b))]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry-a (find (lambda (p) (= (car p) a)) all)]) (and (= (length all) 3) (pair? (car all)) entry-a (equal? (cdr entry-a) 'a)))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "extract-all"], "split": "train"}
{"id": "egraph_extract_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: optimize must run saturation before extraction.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: optimize must run saturation before extraction.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "optimize"], "split": "eval"}
{"id": "egraph_extract_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: After saturation, optimize must extract the best equivalent term instead of returning input term.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg term)\n    (saturate-simple eg rules)\n    term))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize` in `lattice/egraph/extract.ss`.\nKnown issue: After saturation, optimize must extract the best equivalent term instead of returning input term.\n\n```scheme\n(define (optimize term rules cost-model)\n  (let ([eg (make-egraph)])\n    (egraph-add-term! eg term)\n    (saturate-simple eg rules)\n    term))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal?\n  (optimize '(+ x 0) arith-identity-rules ast-size-cost)\n  'x)\n(equal?\n  (optimize '(* x 0) arith-identity-rules ast-size-cost)\n  '0)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (optimize term rules cost-model)\n  (doc 'type (-> Term (List Rule) CostModel Term))\n  (doc 'description \"Apply rules via equality saturation, extract optimal form.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate-simple eg rules)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(and (equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x) (equal? (optimize '(* x 0) arith-identity-rules ast-size-cost) '0) (equal? (optimize '(+ a b) '() ast-size-cost) '(+ a b)))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "optimize"], "split": "eval"}
{"id": "egraph_extract_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize-with-config` in `lattice/egraph/extract.ss`.\nKnown issue: optimize-with-config must actually run saturation with the provided config.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize-with-config` in `lattice/egraph/extract.ss`.\nKnown issue: optimize-with-config must actually run saturation with the provided config.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (doc 'type (-> Term (List Rule) CostModel SaturationConfig Term))\n  (doc 'description \"Optimize with custom saturation config.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize-with-config` in `lattice/egraph/extract.ss`.\nKnown issue: Function must return extracted optimum, not the original input term.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      term)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `optimize-with-config` in `lattice/egraph/extract.ss`.\nKnown issue: Function must return extracted optimum, not the original input term.\n\n```scheme\n(define (optimize-with-config term rules cost-model config)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      term)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? r1 'x)\n(equal? r2 'x)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(equal? r1 'x)\n(equal? r2 'x)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (optimize-with-config term rules cost-model config)\n  (doc 'type (-> Term (List Rule) CostModel SaturationConfig Term))\n  (doc 'description \"Optimize with custom saturation config.\")\n  (doc 'export #t)\n  (let ([eg (make-egraph)])\n    (let ([root (egraph-add-term! eg term)])\n      (saturate eg rules config)\n      (let ([state (make-extraction-state eg cost-model)])\n        (extract state root)))))", "verify_expr": "(let* ([cfg (make-saturation-config 1 10000 0)] [r1 (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)] [r2 (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)]) (and (equal? r1 'x) (equal? r2 'x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "optimize-with-config"], "split": "train"}
{"id": "egraph_extract_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compare-extractions` in `lattice/egraph/extract.ss`.\nKnown issue: All provided cost models must be compared, not only the first one.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  (if (null? cost-models)\n      '()\n      (let* ([cm (car cost-models)]\n             [state (make-extraction-state eg cm)]\n             [term (extract state class-id)]\n             [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n        (list (list cm term cost)))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compare-extractions` in `lattice/egraph/extract.ss`.\nKnown issue: All provided cost models must be compared, not only the first one.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  (if (null? cost-models)\n      '()\n      (let* ([cm (car cost-models)]\n             [state (make-extraction-state eg cm)]\n             [term (extract state class-id)]\n             [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n        (list (list cm term cost)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (doc 'type (-> EGraph ClassId (List CostModel) (List (Triple CostModel Term Nat))))\n  (doc 'description \"Compare extractions across different cost models.\")\n  (doc 'export #t)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compare-extractions` in `lattice/egraph/extract.ss`.\nKnown issue: Each result tuple must include the extracted term, not the numeric class id.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm class-id cost)))\n       cost-models))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `compare-extractions` in `lattice/egraph/extract.ss`.\nKnown issue: Each result tuple must include the extracted term, not the numeric class id.\n\n```scheme\n(define (compare-extractions eg class-id cost-models)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm class-id cost)))\n       cost-models))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (compare-extractions eg class-id cost-models)\n  (doc 'type (-> EGraph ClassId (List CostModel) (List (Triple CostModel Term Nat))))\n  (doc 'description \"Compare extractions across different cost models.\")\n  (doc 'export #t)\n  (map (lambda (cm)\n         (let* ([state (make-extraction-state eg cm)]\n                [term (extract state class-id)]\n                [cost (class-cost (state-costs state) (egraph-find eg class-id))])\n           (list cm term cost)))\n       cost-models))", "verify_expr": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (let ([results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (= (length results) 2) (let ([r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (equal? (cadr r1) '(+ x y)) (number? (caddr r1)) (cost-model? (car r2)) (equal? (cadr r2) '(+ x y)) (number? (caddr r2))))))))", "tags": ["tier1", "egraph", "extraction", "optimization", "bugfix", "compare-extractions"], "split": "train"}
{"id": "egraph_extract_composition_001", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Build a merged class for `x` and `(+ x 0)`, create state, and extract the representative.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild a merged class for `x` and `(+ x 0)`, create state, and extract the representative.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))] [_m (egraph-merge! eg x-id sum-id)] [_r (egraph-rebuild! eg)] [st (make-extraction-state eg ast-size-cost)]) (extract st sum-id))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [x-id (egraph-add-term! eg 'x)] [sum-id (egraph-add-term! eg '(+ x 0))] [_m (egraph-merge! eg x-id sum-id)] [_r (egraph-rebuild! eg)] [st (make-extraction-state eg ast-size-cost)]) (extract st sum-id)) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "make-extraction-state", "multi-fn", "equivalence"], "split": "eval"}
{"id": "egraph_extract_composition_002", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Create state for `(+ a b)` and check that the root class has a selected best node.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCreate state for `(+ a b)` and check that the root class has a selected best node.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg id)] [best (hamt-lookup root (state-best-nodes st))]) (and best (eq? (enode-op best) '+)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ a b))] [st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg id)] [best (hamt-lookup root (state-best-nodes st))]) (and best (eq? (enode-op best) '+))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "make-extraction-state", "best-node"], "split": "train"}
{"id": "egraph_extract_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Compute state over a leaf and return the class cost from the state.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute state over a leaf and return the class cost from the state.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg id)]) (class-cost (state-costs st) root))", "verify_expr": "(= (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)] [root (egraph-find eg id)]) (class-cost (state-costs st) root)) 1)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "make-extraction-state", "costs"], "split": "train"}
{"id": "egraph_extract_composition_004", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "make-extraction-state", "prompt_body": "Build extraction state and confirm the state tag check plus non-empty best-node table.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nBuild extraction state and confirm the state tag check plus non-empty best-node table.\n\nEnsure `make-extraction-state` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [_a (egraph-add-term! eg 'a)] [_b (egraph-add-term! eg '(id a))] [st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (hamt-empty? (state-best-nodes st)))))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [_a (egraph-add-term! eg 'a)] [_b (egraph-add-term! eg '(id a))] [st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (not (hamt-empty? (state-best-nodes st))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "make-extraction-state", "multi-fn", "state-shape"], "split": "train"}
{"id": "egraph_extract_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Construct a real extraction state and verify `extraction-state?` returns true.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nConstruct a real extraction state and verify `extraction-state?` returns true.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [_x (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)]) (extraction-state? st))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [_x (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)]) (extraction-state? st)) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extraction-state?", "predicate", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Check that a wrong-tag vector is rejected by `extraction-state?`.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCheck that a wrong-tag vector is rejected by `extraction-state?`.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(extraction-state? '#(wrong-tag 1 2 3 4))", "verify_expr": "(equal? (extraction-state? '#(wrong-tag 1 2 3 4)) #f)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extraction-state?", "negative"], "split": "train"}
{"id": "egraph_extract_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Count how many values in a mixed list satisfy `extraction-state?`.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCount how many values in a mixed list satisfy `extraction-state?`.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [_x (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)] [vals (list st '#(wrong-tag 1 2 3 4) 42)]) (length (filter extraction-state? vals)))", "verify_expr": "(= (let* ([eg (make-egraph)] [_x (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)] [vals (list st '#(wrong-tag 1 2 3 4) 42)]) (length (filter extraction-state? vals))) 1)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extraction-state?", "collection", "multi-fn"], "split": "eval"}
{"id": "egraph_extract_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extraction-state?", "prompt_body": "Use `extraction-state?` to guard extraction and verify the guarded path returns true.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nUse `extraction-state?` to guard extraction and verify the guarded path returns true.\n\nEnsure `extraction-state?` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (equal? (extract st id) 'x)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)]) (and (extraction-state? st) (equal? (extract st id) 'x))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extraction-state?", "multi-fn", "guarded-flow"], "split": "train"}
{"id": "egraph_extract_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Extract a leaf term from a one-node egraph.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract a leaf term from a one-node egraph.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)]) (extract st id))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg 'x)] [st (make-extraction-state eg ast-size-cost)]) (extract st id)) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract", "leaf", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Extract from a nested expression and preserve nested structure.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nExtract from a nested expression and preserve nested structure.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f (g x)))] [st (make-extraction-state eg ast-size-cost)]) (extract st id))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(f (g x)))] [st (make-extraction-state eg ast-size-cost)]) (extract st id)) '(f (g x)))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract", "nested", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_011", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Merge `a` with `(id a)` and verify extraction chooses `a`.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nMerge `a` with `(id a)` and verify extraction chooses `a`.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [a (egraph-add-term! eg 'a)] [ida (egraph-add-term! eg '(id a))]) (egraph-merge! eg a ida) (egraph-rebuild! eg) (let ([st (make-extraction-state eg ast-size-cost)]) (extract st ida)))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [a (egraph-add-term! eg 'a)] [ida (egraph-add-term! eg '(id a))]) (egraph-merge! eg a ida) (egraph-rebuild! eg) (let ([st (make-extraction-state eg ast-size-cost)]) (extract st ida))) 'a)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract", "equivalence", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_012", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract", "prompt_body": "Extract a shared-subexpression form `(+ x x)` and verify exact structure.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nExtract a shared-subexpression form `(+ x x)` and verify exact structure.\n\nEnsure `extract` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x x))] [st (make-extraction-state eg ast-size-cost)]) (extract st id))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [id (egraph-add-term! eg '(+ x x))] [st (make-extraction-state eg ast-size-cost)]) (extract st id)) '(+ x x))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract", "shared", "multi-fn"], "split": "eval"}
{"id": "egraph_extract_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Run `extract-term` on `(+ a b)` in a fresh egraph.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun `extract-term` on `(+ a b)` in a fresh egraph.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (extract-term eg '(+ a b) ast-size-cost))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (extract-term eg '(+ a b) ast-size-cost)) '(+ a b))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-term", "fresh-egraph"], "split": "eval"}
{"id": "egraph_extract_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Run `extract-term` on nested expression and keep shape stable.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nRun `extract-term` on nested expression and keep shape stable.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (extract-term eg '(* (+ x y) z) ast-size-cost))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (extract-term eg '(* (+ x y) z) ast-size-cost)) '(* (+ x y) z))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-term", "nested"], "split": "train"}
{"id": "egraph_extract_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Pre-merge `x` with `(+ x 0)` then call `extract-term` on `(+ x 0)` and verify simplification.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nPre-merge `x` with `(+ x 0)` then call `extract-term` on `(+ x 0)` and verify simplification.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)] [sum (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x sum) (egraph-rebuild! eg) (extract-term eg '(+ x 0) ast-size-cost))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [x (egraph-add-term! eg 'x)] [sum (egraph-add-term! eg '(+ x 0))]) (egraph-merge! eg x sum) (egraph-rebuild! eg) (extract-term eg '(+ x 0) ast-size-cost)) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-term", "multi-fn", "equivalence"], "split": "train"}
{"id": "egraph_extract_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-term", "prompt_body": "Compare `extract-term` and explicit `extract` on the same term in one egraph.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompare `extract-term` and explicit `extract` on the same term in one egraph.\n\nEnsure `extract-term` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([eg (make-egraph)] [t1 (extract-term eg '(neg x) ast-size-cost)] [id (egraph-add-term! eg '(neg x))] [st (make-extraction-state eg ast-size-cost)] [t2 (extract st id)]) (equal? t1 t2))", "verify_expr": "(equal? (let* ([eg (make-egraph)] [t1 (extract-term eg '(neg x) ast-size-cost)] [id (egraph-add-term! eg '(neg x))] [st (make-extraction-state eg ast-size-cost)] [t2 (extract st id)]) (equal? t1 t2)) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-term", "multi-fn", "consistency"], "split": "train"}
{"id": "egraph_extract_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Extract all roots from egraph containing `a`, `b`, and `(+ a b)` and return count.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nExtract all roots from egraph containing `a`, `b`, and `(+ a b)` and return count.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'a) (egraph-add-term! eg 'b) (egraph-add-term! eg '(+ a b)) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)]) (length all)))", "verify_expr": "(= (let ([eg (make-egraph)]) (egraph-add-term! eg 'a) (egraph-add-term! eg 'b) (egraph-add-term! eg '(+ a b)) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)]) (length all))) 3)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-all", "cardinality", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Find the pair for class of `x` inside `extract-all` output.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nFind the pair for class of `x` inside `extract-all` output.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg 'x)]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry (find (lambda (p) (= (car p) id)) all)]) (and entry (equal? (cdr entry) 'x)))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg 'x)]) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)] [entry (find (lambda (p) (= (car p) id)) all)]) (and entry (equal? (cdr entry) 'x))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-all", "lookup", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Merge `a` and `(id a)`, then ensure `extract-all` has one root entry.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nMerge `a` and `(id a)`, then ensure `extract-all` has one root entry.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [ida (egraph-add-term! eg '(id a))]) (egraph-merge! eg a ida) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)]) (= (length all) 1))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let ([a (egraph-add-term! eg 'a)] [ida (egraph-add-term! eg '(id a))]) (egraph-merge! eg a ida) (egraph-rebuild! eg) (let* ([st (make-extraction-state eg ast-size-cost)] [all (extract-all st)]) (= (length all) 1)))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-all", "equivalence", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "extract-all", "prompt_body": "Collect extracted terms from `extract-all` and verify expected symbol membership.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCollect extracted terms from `extract-all` and verify expected symbol membership.\n\nEnsure `extract-all` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (let* ([st (make-extraction-state eg ast-size-cost)] [terms (map cdr (extract-all st))]) (and (not (not (member 'x terms))) (not (not (member 'y terms))))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (egraph-add-term! eg 'x) (egraph-add-term! eg 'y) (let* ([st (make-extraction-state eg ast-size-cost)] [terms (map cdr (extract-all st))]) (and (not (not (member 'x terms))) (not (not (member 'y terms)))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "extract-all", "projection", "multi-fn"], "split": "eval"}
{"id": "egraph_extract_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Optimize `(+ x 0)` with identity rules.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nOptimize `(+ x 0)` with identity rules.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(optimize '(+ x 0) arith-identity-rules ast-size-cost)", "verify_expr": "(equal? (optimize '(+ x 0) arith-identity-rules ast-size-cost) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize", "identity"], "split": "train"}
{"id": "egraph_extract_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Optimize nested identity `(+ (* x 1) 0)`.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nOptimize nested identity `(+ (* x 1) 0)`.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(optimize '(+ (* x 1) 0) arith-identity-rules ast-size-cost)", "verify_expr": "(equal? (optimize '(+ (* x 1) 0) arith-identity-rules ast-size-cost) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize", "nested"], "split": "train"}
{"id": "egraph_extract_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Optimize `(+ a b)` with commutativity and verify one of canonical equivalents.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nOptimize `(+ a b)` with commutativity and verify one of canonical equivalents.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(optimize '(+ a b) arith-comm-rules ast-size-cost)", "verify_expr": "(let ([r (optimize '(+ a b) arith-comm-rules ast-size-cost)]) (or (equal? r '(+ a b)) (equal? r '(+ b a))))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize", "commutativity"], "split": "train"}
{"id": "egraph_extract_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize", "prompt_body": "Optimize `(+ (+ x 0) (* y 1))` with basic arithmetic rules.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nOptimize `(+ (+ x 0) (* y 1))` with basic arithmetic rules.\n\nEnsure `optimize` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(optimize '(+ (+ x 0) (* y 1)) basic-arith-rules ast-size-cost)", "verify_expr": "(let ([r (optimize '(+ (+ x 0) (* y 1)) basic-arith-rules ast-size-cost)]) (or (equal? r '(+ x y)) (equal? r '(+ y x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize", "basic-rules"], "split": "train"}
{"id": "egraph_extract_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Optimize `(+ x 0)` using explicit saturation config.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nOptimize `(+ x 0)` using explicit saturation config.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([cfg (make-saturation-config 1 10000 0)]) (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg))", "verify_expr": "(equal? (let ([cfg (make-saturation-config 1 10000 0)]) (optimize-with-config '(+ x 0) arith-identity-rules ast-size-cost cfg)) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize-with-config", "config"], "split": "train"}
{"id": "egraph_extract_composition_026", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Use config-driven optimization on `(* x 1)` and verify simplification.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nUse config-driven optimization on `(* x 1)` and verify simplification.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([cfg (make-saturation-config 2 10000 0)]) (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg))", "verify_expr": "(equal? (let ([cfg (make-saturation-config 2 10000 0)]) (optimize-with-config '(* x 1) arith-identity-rules ast-size-cost cfg)) 'x)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize-with-config", "identity"], "split": "eval"}
{"id": "egraph_extract_composition_027", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Optimize `(+ (+ x 0) (* y 1))` with config and verify canonical simplified form.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nOptimize `(+ (+ x 0) (* y 1))` with config and verify canonical simplified form.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([cfg (make-saturation-config 5 10000 0)]) (optimize-with-config '(+ (+ x 0) (* y 1)) basic-arith-rules ast-size-cost cfg))", "verify_expr": "(let ([r (let ([cfg (make-saturation-config 5 10000 0)]) (optimize-with-config '(+ (+ x 0) (* y 1)) basic-arith-rules ast-size-cost cfg))]) (or (equal? r '(+ x y)) (equal? r '(+ y x))))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize-with-config", "multi-rule"], "split": "train"}
{"id": "egraph_extract_composition_028", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "optimize-with-config", "prompt_body": "Run commutativity optimization with config and verify result remains in the equivalence set.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nRun commutativity optimization with config and verify result remains in the equivalence set.\n\nEnsure `optimize-with-config` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([cfg (make-saturation-config 1 10000 0)]) (optimize-with-config '(+ a b) arith-comm-rules ast-size-cost cfg))", "verify_expr": "(let ([r (let ([cfg (make-saturation-config 1 10000 0)]) (optimize-with-config '(+ a b) arith-comm-rules ast-size-cost cfg))]) (or (equal? r '(+ a b)) (equal? r '(+ b a))))", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "optimize-with-config", "commutativity"], "split": "train"}
{"id": "egraph_extract_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Compare two cost models for a single class and return number of result tuples.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompare two cost models for a single class and return number of result tuples.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (length (compare-extractions eg id (list ast-size-cost ast-depth-cost)))))", "verify_expr": "(= (let ([eg (make-egraph)]) (let ([id (egraph-add-term! eg '(+ x y))]) (length (compare-extractions eg id (list ast-size-cost ast-depth-cost))))) 2)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "compare-extractions", "cardinality", "multi-fn"], "split": "train"}
{"id": "egraph_extract_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Compare model outputs and verify both extracted terms equal the only available term.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompare model outputs and verify both extracted terms equal the only available term.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (equal? (cadr (car results)) '(+ x y)) (equal? (cadr (cadr results)) '(+ x y)))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (equal? (cadr (car results)) '(+ x y)) (equal? (cadr (cadr results)) '(+ x y))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "compare-extractions", "term-equality"], "split": "eval"}
{"id": "egraph_extract_composition_031", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Verify compare-extractions returns triples with model, term, and numeric cost fields.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nVerify compare-extractions returns triples with model, term, and numeric cost fields.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))] [r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (number? (caddr r1)) (cost-model? (car r2)) (number? (caddr r2)))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))] [r1 (car results)] [r2 (cadr results)]) (and (cost-model? (car r1)) (number? (caddr r1)) (cost-model? (car r2)) (number? (caddr r2))))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "compare-extractions", "shape-check"], "split": "eval"}
{"id": "egraph_extract_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/egraph/extract.ss", "source_test": "lattice/egraph/test-extract.ss", "source_function": "compare-extractions", "prompt_body": "Return whether model names in compare-extractions are ast-size then ast-depth for the given list order.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether model names in compare-extractions are ast-size then ast-depth for the given list order.\n\nEnsure `compare-extractions` is part of the composed solution.\nReturn only the final Fold expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (eq? (cost-model-name (car (car results))) 'ast-size) (eq? (cost-model-name (car (cadr results))) 'ast-depth))))", "verify_expr": "(equal? (let ([eg (make-egraph)]) (let* ([id (egraph-add-term! eg '(+ x y))] [results (compare-extractions eg id (list ast-size-cost ast-depth-cost))]) (and (eq? (cost-model-name (car (car results))) 'ast-size) (eq? (cost-model-name (car (cadr results))) 'ast-depth)))) #t)", "tags": ["tier1", "egraph", "extraction", "optimization", "composition", "compare-extractions", "ordering"], "split": "eval"}
