{"id": "info_partition_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-entropy`\nSpec: Compute Shannon entropy of partition proportions in bits.\n\nWrite exactly one Scheme function definition for `partition-entropy`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (< (abs (partition-entropy '#(0 0 0 0))) 1e-10))\n(let () (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (and (< (abs (partition-entropy '#(0 0 0 0))) 1e-10) (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-entropy"], "split": "eval"}
{"id": "info_partition_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-nmi`\nSpec: Compute normalized mutual information in [0,1] with explicit zero-entropy conventions.\n\nWrite exactly one Scheme function definition for `partition-nmi`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10))\n(let () (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (and (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10) (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10)))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-nmi"], "split": "eval"}
{"id": "info_partition_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `unique-labels`\nSpec: Extract and sort unique labels from a label vector.\n\nWrite exactly one Scheme function definition for `unique-labels`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "unique-labels"], "split": "eval"}
{"id": "info_partition_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-sizes`.\nReturn only the Scheme definition.\n\n```python\ndef partition_sizes(labels):\n    counts = {}\n    for lbl in labels:\n        counts[lbl] = counts.get(lbl, 0) + 1\n    return [counts[k] for k in sorted(counts.keys())]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))\n(let () (equal? (partition-sizes '#(0 0 0 0)) '(4)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-sizes"], "split": "eval"}
{"id": "info_partition_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-vi`.\nReturn only the Scheme definition.\n\n```python\ndef partition_vi(labels_a, labels_b):\n    ha = partition_entropy(labels_a)\n    hb = partition_entropy(labels_b)\n    mi = partition_mi(labels_a, labels_b)\n    return max(0, ha + hb - 2 * mi)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-vi"], "split": "eval"}
{"id": "info_partition_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `label-index-map`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (label-index-map0 labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "label-index-map"], "split": "eval"}
{"id": "info_partition_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-sizes` in `lattice/info/partition-info.ss`.\nKnown issue: Output must be deterministic and sorted by label keys, not unsorted HAMT values.\n\n```scheme\n(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (hamt-values counts)\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Output must be deterministic and sorted by label keys, not unsorted HAMT values.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-sizes"], "split": "eval"}
{"id": "info_partition_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-vi` in `lattice/info/partition-info.ss`.\nKnown issue: VI subtracts 2*MI, not adds it.\n\n```scheme\n(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (+ ha hb (* 2 mi))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: VI subtracts 2*MI, not adds it.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-vi"], "split": "eval"}
{"id": "info_partition_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `label-index-map` in `lattice/info/partition-info.ss`.\nKnown issue: Mapping direction is reversed; keys must be labels and values indices.\n\n```scheme\n(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc i (car ls) ht)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "bugfix", "label-index-map"], "split": "eval"}
{"id": "info_partition_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute partition sizes for labels '#(0 0 0 1 1 2).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(partition-sizes '#(0 0 0 1 1 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))", "tags": ["tier1", "info", "partition-info", "composition", "partition-sizes", "direct"], "split": "eval"}
{"id": "info_partition_composition_009", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute MI for identical partitions '#(0 0 1 1 2 2) and '#(0 0 1 1 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition-mi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)]) (< (abs (- mi h)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "composition", "partition-mi", "identity"], "split": "eval"}
{"id": "info_partition_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute VI for identical partitions '#(0 0 1 1).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(partition-vi '#(0 0 1 1) '#(0 0 1 1))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi", "identity"], "split": "eval"}
{"id": "info_partition_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether normalized VI preserves ordering against raw VI for the same n.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [c '#(0 0 0 1 1)]) (and (> (partition-vi a b) (partition-vi a c)) (> (partition-vi-normalized a b) (partition-vi-normalized a c))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (equal? (let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [c '#(0 0 0 1 1)]) (and (> (partition-vi a b) (partition-vi a c)) (> (partition-vi-normalized a b) (partition-vi-normalized a c)))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi-normalized", "ordering"], "split": "eval"}
{"id": "info_partition_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether composing unique-labels with label-index-map gives index range 0..k-1.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([labels (unique-labels '#(5 3 5 2 3 1))] [m (label-index-map labels)]) (and (= (hamt-lookup-or 1 m -1) 0) (= (hamt-lookup-or 2 m -1) 1) (= (hamt-lookup-or 3 m -1) 2) (= (hamt-lookup-or 5 m -1) 3)))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (let* ([labels (unique-labels '#(5 3 5 2 3 1))] [m (label-index-map labels)]) (and (= (hamt-lookup-or 1 m -1) 0) (= (hamt-lookup-or 2 m -1) 1) (= (hamt-lookup-or 3 m -1) 2) (= (hamt-lookup-or 5 m -1) 3))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "label-index-map", "integration"], "split": "eval"}
