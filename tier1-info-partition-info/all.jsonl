{"id": "info_partition_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-sizes`\nSpec: Count community sizes from a label vector and return counts ordered by sorted label value.\n\nWrite exactly one Scheme function definition for `partition-sizes`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-sizes"], "split": "train"}
{"id": "info_partition_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition-sizes labels)\n  ;; TODO: count labels and return counts ordered by sorted label keys\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition-sizes`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))\n(let () (equal? (partition-sizes '#(0 0 0 0)) '(4)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "partition-sizes"], "split": "train"}
{"id": "info_partition_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-entropy`\nSpec: Compute Shannon entropy of partition proportions in bits.\n\nWrite exactly one Scheme function definition for `partition-entropy`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (< (abs (partition-entropy '#(0 0 0 0))) 1e-10))\n(let () (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (and (< (abs (partition-entropy '#(0 0 0 0))) 1e-10) (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-entropy"], "split": "eval"}
{"id": "info_partition_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition-entropy labels)\n  ;; TODO: convert partition sizes to probabilities and compute entropy\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition-entropy`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (and (< (abs (partition-entropy '#(0 0 0 0))) 1e-10) (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "partition-entropy"], "split": "train"}
{"id": "info_partition_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-mi`\nSpec: Compute mutual information between two partitions via contingency table probabilities.\n\nWrite exactly one Scheme function definition for `partition-mi`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-mi"], "split": "train"}
{"id": "info_partition_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition-mi labels-a labels-b)\n  ;; TODO: build contingency table and compute mutual information\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition-mi`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "partition-mi"], "split": "train"}
{"id": "info_partition_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-nmi`\nSpec: Compute normalized mutual information in [0,1] with explicit zero-entropy conventions.\n\nWrite exactly one Scheme function definition for `partition-nmi`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10))\n(let () (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (and (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10) (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10)))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-nmi"], "split": "eval"}
{"id": "info_partition_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition-nmi labels-a labels-b)\n  ;; TODO: normalized mutual information with zero-entropy conventions\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition-nmi`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10))\n(let () (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (and (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10) (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10)))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "partition-nmi"], "split": "train"}
{"id": "info_partition_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-vi`\nSpec: Compute variation of information VI = H(A)+H(B)-2*I(A;B), clamped at zero.\n\nWrite exactly one Scheme function definition for `partition-vi`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-vi"], "split": "train"}
{"id": "info_partition_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition-vi labels-a labels-b)\n  ;; TODO: variation of information with non-negativity clamp\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition-vi`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "partition-vi"], "split": "train"}
{"id": "info_partition_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `partition-vi-normalized`\nSpec: Normalize VI by log2(n), returning 0 for n<=1.\n\nWrite exactly one Scheme function definition for `partition-vi-normalized`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "partition-vi-normalized"], "split": "train"}
{"id": "info_partition_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (partition-vi-normalized labels-a labels-b)\n  ;; TODO: divide VI by log2(n), returning 0 when n<=1\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `partition-vi-normalized`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "partition-vi-normalized"], "split": "train"}
{"id": "info_partition_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `unique-labels`\nSpec: Extract and sort unique labels from a label vector.\n\nWrite exactly one Scheme function definition for `unique-labels`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "unique-labels"], "split": "eval"}
{"id": "info_partition_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (unique-labels labels)\n  ;; TODO: deduplicate labels and return sorted unique label list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `unique-labels`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "unique-labels"], "split": "train"}
{"id": "info_partition_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this partition-information utility in Fold-native Scheme.\n\nTarget module: lattice/info/partition-info.ss\nFunction: `label-index-map`\nSpec: Build a HAMT mapping each label in a list to its positional index.\n\nWrite exactly one Scheme function definition for `label-index-map`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "spec-to-code", "label-index-map"], "split": "train"}
{"id": "info_partition_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (label-index-map labels-list)\n  ;; TODO: map each label to its zero-based index in labels-list\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `label-index-map`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "skeleton-completion", "label-index-map"], "split": "train"}
{"id": "info_partition_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-sizes`.\nReturn only the Scheme definition.\n\n```python\ndef partition_sizes(labels):\n    counts = {}\n    for lbl in labels:\n        counts[lbl] = counts.get(lbl, 0) + 1\n    return [counts[k] for k in sorted(counts.keys())]\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))\n(let () (equal? (partition-sizes '#(0 0 0 0)) '(4)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-sizes"], "split": "eval"}
{"id": "info_partition_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition-sizes`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition-sizes0 labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))\n(let () (equal? (partition-sizes '#(0 0 0 0)) '(4)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "partition-sizes"], "split": "train"}
{"id": "info_partition_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-entropy`.\nReturn only the Scheme definition.\n\n```python\ndef partition_entropy(labels):\n    n = len(labels)\n    sizes = partition_sizes(labels)\n    probs = [s / n for s in sizes]\n    return entropy(probs)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (< (abs (partition-entropy '#(0 0 0 0))) 1e-10))\n(let () (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (and (< (abs (partition-entropy '#(0 0 0 0))) 1e-10) (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-entropy"], "split": "train"}
{"id": "info_partition_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition-entropy`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition-entropy0 labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (< (abs (partition-entropy '#(0 0 0 0))) 1e-10))\n(let () (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (and (< (abs (partition-entropy '#(0 0 0 0))) 1e-10) (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "partition-entropy"], "split": "train"}
{"id": "info_partition_translation_005", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-mi`.\nReturn only the Scheme definition.\n\n```python\ndef partition_mi(labels_a, labels_b):\n    n = len(labels_a)\n    joint = build_contingency_table(labels_a, labels_b)\n    joint_probs = [[c / n for c in row] for row in joint]\n    marginal_a = [sum(row) for row in joint_probs]\n    num_cols = 0 if not joint_probs else len(joint_probs[0])\n    marginal_b = [] if num_cols == 0 else [sum(row[j] for row in joint_probs) for j in range(num_cols)]\n    return mutual_information(joint_probs, marginal_a, marginal_b)\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-mi"], "split": "train"}
{"id": "info_partition_translation_006", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition-mi`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition-mi0 labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row) (map (lambda (c) (/ c n)) row)) joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0 (map (lambda (row) (list-ref row j)) joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "partition-mi"], "split": "train"}
{"id": "info_partition_translation_007", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-nmi`.\nReturn only the Scheme definition.\n\n```python\ndef partition_nmi(labels_a, labels_b):\n    ha = partition_entropy(labels_a)\n    hb = partition_entropy(labels_b)\n    mi = partition_mi(labels_a, labels_b)\n    if ha <= 0 or hb <= 0:\n        return 1.0 if ha <= 0 and hb <= 0 else 0.0\n    return mi / sqrt(ha * hb)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (and (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10) (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10)))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-nmi"], "split": "train"}
{"id": "info_partition_translation_008", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition-nmi`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition-nmi0 labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10))\n(let () (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (and (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10) (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10)))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "partition-nmi"], "split": "train"}
{"id": "info_partition_translation_009", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-vi`.\nReturn only the Scheme definition.\n\n```python\ndef partition_vi(labels_a, labels_b):\n    ha = partition_entropy(labels_a)\n    hb = partition_entropy(labels_b)\n    mi = partition_mi(labels_a, labels_b)\n    return max(0, ha + hb - 2 * mi)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-vi"], "split": "eval"}
{"id": "info_partition_translation_010", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition-vi`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition-vi0 labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "partition-vi"], "split": "train"}
{"id": "info_partition_translation_011", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `partition-vi-normalized`.\nReturn only the Scheme definition.\n\n```python\ndef partition_vi_normalized(labels_a, labels_b):\n    n = len(labels_a)\n    vi = partition_vi(labels_a, labels_b)\n    if n <= 1:\n        return 0\n    return vi / log2(n)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "partition-vi-normalized"], "split": "train"}
{"id": "info_partition_translation_012", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `partition-vi-normalized`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (partition-vi-normalized0 labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "partition-vi-normalized"], "split": "train"}
{"id": "info_partition_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `unique-labels`.\nReturn only the Scheme definition.\n\n```python\ndef unique_labels(labels):\n    return sorted(set(labels))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "unique-labels"], "split": "train"}
{"id": "info_partition_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `unique-labels`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (unique-labels0 labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "unique-labels"], "split": "train"}
{"id": "info_partition_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly and use target function name `label-index-map`.\nReturn only the Scheme definition.\n\n```python\ndef label_index_map(labels_list):\n    out = {}\n    for i, label in enumerate(labels_list):\n        out[label] = i\n    return out\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "python-to-scheme", "label-index-map"], "split": "train"}
{"id": "info_partition_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nTarget function name must be `label-index-map`.\nReturn only the corrected Fold definition.\n\n```scheme\n(define (label-index-map0 labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "chez-to-fold", "label-index-map"], "split": "eval"}
{"id": "info_partition_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-sizes` in `lattice/info/partition-info.ss`.\nKnown issue: Output must be deterministic and sorted by label keys, not unsorted HAMT values.\n\n```scheme\n(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (hamt-values counts)\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Output must be deterministic and sorted by label keys, not unsorted HAMT values.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-sizes"], "split": "eval"}
{"id": "info_partition_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-sizes` in `lattice/info/partition-info.ss`.\nKnown issue: Missing labels should default to 0 during lookup, not 1.\n\n```scheme\n(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 1)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))\n(let () (equal? (partition-sizes '#(0 0 0 0)) '(4)))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (and (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)) (equal? (partition-sizes '#(0 0 0 0)) '(4))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-sizes"], "split": "train"}
{"id": "info_partition_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-entropy` in `lattice/info/partition-info.ss`.\nKnown issue: Entropy expects probabilities, not raw counts.\n\n```scheme\n(define (partition-entropy labels)\n  (let* ([sizes (partition-sizes labels)])\n    (entropy sizes)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Entropy expects probabilities, not raw counts.\n\nExpected behavior after patch:\n```scheme\n(let () (< (abs (partition-entropy '#(0 0 0 0))) 1e-10))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (< (abs (partition-entropy '#(0 0 0 0))) 1e-10))\n(let () (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (and (< (abs (partition-entropy '#(0 0 0 0))) 1e-10) (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-entropy"], "split": "train"}
{"id": "info_partition_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-entropy` in `lattice/info/partition-info.ss`.\nKnown issue: Probability conversion should be s/n, not n/s.\n\n```scheme\n(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ n s)) sizes)])\n    (entropy probs)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (and (< (abs (partition-entropy '#(0 0 0 0))) 1e-10) (< (abs (- (partition-entropy '#(0 0 1 1)) 1.0)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-entropy"], "split": "train"}
{"id": "info_partition_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-mi` in `lattice/info/partition-info.ss`.\nKnown issue: Mutual information subtracts joint entropy; it does not add it.\n\n```scheme\n(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row) (map (lambda (c) (/ c n)) row)) joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0 (map (lambda (row) (list-ref row j)) joint-probs)))\n                              (iota num-cols)))])\n    (+ (entropy marginal-a) (entropy marginal-b) (joint-entropy joint-probs))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Mutual information subtracts joint entropy; it does not add it.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-mi"], "split": "train"}
{"id": "info_partition_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-mi` in `lattice/info/partition-info.ss`.\nKnown issue: Argument order to mutual-information should be (joint, marginal-a, marginal-b).\n\n```scheme\n(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row) (map (lambda (c) (/ c n)) row)) joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0 (map (lambda (row) (list-ref row j)) joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-b marginal-a)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Argument order to mutual-information should be (joint, marginal-a, marginal-b).\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)] [a '#(0 0 1 1 0 0 1 1)] [b '#(0 1 0 1 0 1 0 1)]) (and (< (abs (- mi h)) 1e-10) (< (abs (partition-mi a b)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-mi"], "split": "train"}
{"id": "info_partition_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-nmi` in `lattice/info/partition-info.ss`.\nKnown issue: NMI denominator should be sqrt(Ha*Hb) with special zero-entropy convention.\n\n```scheme\n(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        0.0\n        (/ mi (+ ha hb)))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10))\n(let () (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (and (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10) (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10)))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-nmi"], "split": "train"}
{"id": "info_partition_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-nmi` in `lattice/info/partition-info.ss`.\nKnown issue: Zero-entropy convention is inverted: both-zero => 1.0, one-zero => 0.0.\n\n```scheme\n(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 0.0 1.0)\n        (/ mi (sqrt (* ha hb))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10))\n(let () (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (and (< (abs (- (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1.0)) 1e-10) (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10)))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-nmi"], "split": "train"}
{"id": "info_partition_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-vi` in `lattice/info/partition-info.ss`.\nKnown issue: VI subtracts 2*MI, not adds it.\n\n```scheme\n(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (+ ha hb (* 2 mi))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: VI subtracts 2*MI, not adds it.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-vi"], "split": "eval"}
{"id": "info_partition_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-vi` in `lattice/info/partition-info.ss`.\nKnown issue: VI should be clamped to non-negative values with max 0.\n\n```scheme\n(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (+ ha hb (* -2 mi))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (let* ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [vi-ab (partition-vi a b)] [vi-ba (partition-vi b a)]) (and (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10) (>= vi-ab -1e-10) (< (abs (- vi-ab vi-ba)) 1e-10))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-vi"], "split": "train"}
{"id": "info_partition_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-vi-normalized` in `lattice/info/partition-info.ss`.\nKnown issue: Normalization divisor should be log2(n), not n.\n\n```scheme\n(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi n))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-vi-normalized"], "split": "train"}
{"id": "info_partition_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `partition-vi-normalized` in `lattice/info/partition-info.ss`.\nKnown issue: Guard should be n<=1 to avoid division by log2(1)=0.\n\n```scheme\n(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (< n 1)\n        0\n        (/ vi (log2 n)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)) (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))))", "tags": ["tier1", "info", "partition-info", "bugfix", "partition-vi-normalized"], "split": "train"}
{"id": "info_partition_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-labels` in `lattice/info/partition-info.ss`.\nKnown issue: Unique labels should be returned in sorted order.\n\n```scheme\n(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        result\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "bugfix", "unique-labels"], "split": "train"}
{"id": "info_partition_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `unique-labels` in `lattice/info/partition-info.ss`.\nKnown issue: Function must skip labels already seen; this version duplicates them.\n\n```scheme\n(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Function must skip labels already seen; this version duplicates them.\n\nExpected behavior after patch:\n```scheme\n(let () (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "bugfix", "unique-labels"], "split": "train"}
{"id": "info_partition_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `label-index-map` in `lattice/info/partition-info.ss`.\nKnown issue: Indices should start at 0, not 1.\n\n```scheme\n(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 1] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: Indices should start at 0, not 1.\n\nExpected behavior after patch:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "bugfix", "label-index-map"], "split": "train"}
{"id": "info_partition_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `label-index-map` in `lattice/info/partition-info.ss`.\nKnown issue: Mapping direction is reversed; keys must be labels and values indices.\n\n```scheme\n(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc i (car ls) ht)))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (let ([m (label-index-map '(10 20 30))]) (and (= (hamt-lookup-or 10 m -1) 0) (= (hamt-lookup-or 20 m -1) 1) (= (hamt-lookup-or 30 m -1) 2))))", "tags": ["tier1", "info", "partition-info", "bugfix", "label-index-map"], "split": "eval"}
{"id": "info_partition_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute partition sizes for labels '#(0 0 0 1 1 2).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(partition-sizes '#(0 0 0 1 1 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (equal? (partition-sizes '#(0 0 0 1 1 2)) '(3 2 1)))", "tags": ["tier1", "info", "partition-info", "composition", "partition-sizes", "direct"], "split": "eval"}
{"id": "info_partition_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute partition sizes for single-community labels '#(0 0 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(partition-sizes '#(0 0 0 0))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (equal? (partition-sizes '#(0 0 0 0)) '(4)))", "tags": ["tier1", "info", "partition-info", "composition", "partition-sizes", "edge-case"], "split": "train"}
{"id": "info_partition_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether partition-size output is sorted by label for labels '#(2 2 1 1 1).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (partition-sizes '#(2 2 1 1 1)) '(3 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (equal? (equal? (partition-sizes '#(2 2 1 1 1)) '(3 2)) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-sizes", "ordering"], "split": "train"}
{"id": "info_partition_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-sizes", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether partition sizes preserve total count for labels '#(0 1 1 2 2 2).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (fold-left + 0 (partition-sizes '#(0 1 1 2 2 2))) 6)", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (equal? (= (fold-left + 0 (partition-sizes '#(0 1 1 2 2 2))) 6) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-sizes", "property"], "split": "train"}
{"id": "info_partition_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute partition entropy for uniform binary labels '#(0 0 1 1).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition-entropy '#(0 0 1 1))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (partition-entropy '#(0 0 1 1)) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-entropy", "direct"], "split": "train"}
{"id": "info_partition_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute partition entropy for single-community labels '#(0 0 0 0).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(partition-entropy '#(0 0 0 0))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (< (abs (partition-entropy '#(0 0 0 0))) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-entropy", "edge-case"], "split": "train"}
{"id": "info_partition_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether a uniform four-way partition has entropy 2 bits.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(partition-entropy '#(0 1 2 3))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 2.0 (partition-entropy '#(0 1 2 3)) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-entropy", "direct"], "split": "train"}
{"id": "info_partition_composition_008", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-entropy", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether non-uniform partition entropy lies strictly between 0 and 1 bit for '#(0 0 0 1).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([h (partition-entropy '#(0 0 0 1))]) (and (> h 0) (< h 1.0)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (equal? (let ([h (partition-entropy '#(0 0 0 1))]) (and (> h 0) (< h 1.0))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-entropy", "range"], "split": "train"}
{"id": "info_partition_composition_009", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute MI for identical partitions '#(0 0 1 1 2 2) and '#(0 0 1 1 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition-mi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (let* ([labels '#(0 0 1 1 2 2)] [mi (partition-mi labels labels)] [h (partition-entropy labels)]) (< (abs (- mi h)) 1e-10)))", "tags": ["tier1", "info", "partition-info", "composition", "partition-mi", "identity"], "split": "eval"}
{"id": "info_partition_composition_010", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute MI for independent-style partitions '#(0 0 1 1 0 0 1 1) and '#(0 1 0 1 0 1 0 1).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(partition-mi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (< (abs (partition-mi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-mi", "independence"], "split": "train"}
{"id": "info_partition_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether MI is non-negative for partitions '#(0 0 1 1 2) and '#(0 1 1 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(>= (partition-mi '#(0 0 1 1 2) '#(0 1 1 2 2)) -1e-10)", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (equal? (>= (partition-mi '#(0 0 1 1 2) '#(0 1 1 2 2)) -1e-10) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-mi", "property"], "split": "train"}
{"id": "info_partition_composition_012", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-mi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether MI is symmetric for two partitions.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)]) (approx=? (partition-mi a b) (partition-mi b a) 1e-10))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)]) (approx=? (partition-mi a b) (partition-mi b a) 1e-10)) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-mi", "symmetry"], "split": "train"}
{"id": "info_partition_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute NMI for identical partitions '#(0 0 1 1 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (partition-nmi '#(0 0 1 1 2 2) '#(0 0 1 1 2 2)) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-nmi", "identity"], "split": "train"}
{"id": "info_partition_composition_014", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute NMI for independent-style partitions '#(0 0 1 1 0 0 1 1) and '#(0 1 0 1 0 1 0 1).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (< (abs (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-nmi", "independence"], "split": "train"}
{"id": "info_partition_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether NMI is bounded in [0,1] for partitions '#(0 0 0 1 1 2 2 2) and '#(0 1 1 1 2 2 0 0).\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([nmi (partition-nmi '#(0 0 0 1 1 2 2 2) '#(0 1 1 1 2 2 0 0))]) (and (>= nmi -1e-10) (<= nmi (+ 1.0 1e-10))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (equal? (let ([nmi (partition-nmi '#(0 0 0 1 1 2 2 2) '#(0 1 1 1 2 2 0 0))]) (and (>= nmi -1e-10) (<= nmi (+ 1.0 1e-10)))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-nmi", "range"], "split": "train"}
{"id": "info_partition_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-nmi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn NMI when both partitions are single-community labels '#(0 0 0 0).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition-nmi '#(0 0 0 0) '#(0 0 0 0))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (approx=? 1.0 (partition-nmi '#(0 0 0 0) '#(0 0 0 0)) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-nmi", "zero-entropy"], "split": "train"}
{"id": "info_partition_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute VI for identical partitions '#(0 0 1 1).\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(partition-vi '#(0 0 1 1) '#(0 0 1 1))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (< (abs (partition-vi '#(0 0 1 1) '#(0 0 1 1))) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi", "identity"], "split": "eval"}
{"id": "info_partition_composition_018", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether VI is symmetric for partitions '#(0 0 1 1 2) and '#(0 1 1 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)]) (approx=? (partition-vi a b) (partition-vi b a) 1e-10))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (approx=? expected actual tol)\n  (< (abs (- expected actual)) tol))\n  (equal? (let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)]) (approx=? (partition-vi a b) (partition-vi b a) 1e-10)) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi", "symmetry"], "split": "train"}
{"id": "info_partition_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether VI is non-negative for partitions '#(0 0 1 1 2) and '#(0 1 1 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(>= (partition-vi '#(0 0 1 1 2) '#(0 1 1 2 2)) -1e-10)", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (equal? (>= (partition-vi '#(0 0 1 1 2) '#(0 1 1 2 2)) -1e-10) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi", "property"], "split": "train"}
{"id": "info_partition_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi", "prompt": "Task mode: small integration task across module primitives.\n\nReturn whether VI and NMI move in opposite directions between identical and independent partitions.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([id-nmi (partition-nmi '#(0 0 1 1) '#(0 0 1 1))] [id-vi (partition-vi '#(0 0 1 1) '#(0 0 1 1))] [ind-nmi (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))] [ind-vi (partition-vi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))]) (and (> id-nmi ind-nmi) (< id-vi ind-vi)))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-nmi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (if (or (<= ha 0) (<= hb 0))\n        (if (and (<= ha 0) (<= hb 0)) 1.0 0.0)\n        (/ mi (sqrt (* ha hb))))))\n  (equal? (let ([id-nmi (partition-nmi '#(0 0 1 1) '#(0 0 1 1))] [id-vi (partition-vi '#(0 0 1 1) '#(0 0 1 1))] [ind-nmi (partition-nmi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))] [ind-vi (partition-vi '#(0 0 1 1 0 0 1 1) '#(0 1 0 1 0 1 0 1))]) (and (> id-nmi ind-nmi) (< id-vi ind-vi))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi", "integration"], "split": "train"}
{"id": "info_partition_composition_021", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute normalized VI for partitions '#(0 0 1 1 2) and '#(0 1 1 2 2).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (let ([nvi (partition-vi-normalized '#(0 0 1 1 2) '#(0 1 1 2 2))]) (and (>= nvi -1e-10) (<= nvi (+ 1.0 1e-10)))))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi-normalized", "direct"], "split": "train"}
{"id": "info_partition_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: small integration task across module primitives.\n\nCompute normalized VI for identical partitions '#(0 0 1 1).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (< (abs (partition-vi-normalized '#(0 0 1 1) '#(0 0 1 1))) 1e-10))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi-normalized", "identity"], "split": "train"}
{"id": "info_partition_composition_023", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn normalized VI when n<=1 using '#(0) and '#(0).\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(partition-vi-normalized '#(0) '#(0))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (= (partition-vi-normalized '#(0) '#(0)) 0))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi-normalized", "edge-case"], "split": "train"}
{"id": "info_partition_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "partition-vi-normalized", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether normalized VI preserves ordering against raw VI for the same n.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [c '#(0 0 0 1 1)]) (and (> (partition-vi a b) (partition-vi a c)) (> (partition-vi-normalized a b) (partition-vi-normalized a c))))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (partition-sizes labels)\n  (let loop ([i 0] [counts hamt-empty])\n    (if (= i (vector-length labels))\n        (let* ([keys (hamt-keys counts)]\n               [sorted-keys (sort-labels keys)])\n          (map (lambda (k) (hamt-lookup-or k counts 0)) sorted-keys))\n        (let ([lbl (vector-ref labels i)])\n          (loop (+ i 1)\n                (hamt-assoc lbl (+ 1 (hamt-lookup-or lbl counts 0)) counts))))))\n  (define (partition-entropy labels)\n  (let* ([n (vector-length labels)]\n         [sizes (partition-sizes labels)]\n         [probs (map (lambda (s) (/ s n)) sizes)])\n    (entropy probs)))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (build-contingency-table labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [labels-a-unique (unique-labels labels-a)]\n         [labels-b-unique (unique-labels labels-b)]\n         [na (length labels-a-unique)]\n         [nb (length labels-b-unique)]\n         [a-index (label-index-map labels-a-unique)]\n         [b-index (label-index-map labels-b-unique)]\n         [counts (make-vector (* na nb) 0)])\n    (let loop ([i 0])\n      (if (= i n)\n          (let row-loop ([r 0] [rows '()])\n            (if (= r na)\n                (reverse rows)\n                (let col-loop ([c 0] [cols '()])\n                  (if (= c nb)\n                      (row-loop (+ r 1) (cons (reverse cols) rows))\n                      (col-loop (+ c 1)\n                                (cons (vector-ref counts (+ (* r nb) c)) cols))))))\n          (let ([ai (hamt-lookup-or (vector-ref labels-a i) a-index 0)]\n                [bi (hamt-lookup-or (vector-ref labels-b i) b-index 0)])\n            (let ([idx (+ (* ai nb) bi)])\n              (vector-set! counts idx (+ 1 (vector-ref counts idx))))\n            (loop (+ i 1)))))))\n  (define (partition-mi labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [joint (build-contingency-table labels-a labels-b)]\n         [joint-probs (map (lambda (row)\n                             (map (lambda (c) (/ c n)) row))\n                           joint)]\n         [marginal-a (map (lambda (row) (fold-left + 0 row)) joint-probs)]\n         [num-cols (if (null? joint-probs) 0 (length (car joint-probs)))]\n         [marginal-b (if (= num-cols 0)\n                         '()\n                         (map (lambda (j)\n                                (fold-left + 0\n                                           (map (lambda (row) (list-ref row j))\n                                                joint-probs)))\n                              (iota num-cols)))])\n    (mutual-information joint-probs marginal-a marginal-b)))\n  (define (partition-vi labels-a labels-b)\n  (let ([ha (partition-entropy labels-a)]\n        [hb (partition-entropy labels-b)]\n        [mi (partition-mi labels-a labels-b)])\n    (max 0 (+ ha hb (* -2 mi)))))\n  (define (partition-vi-normalized labels-a labels-b)\n  (let* ([n (vector-length labels-a)]\n         [vi (partition-vi labels-a labels-b)])\n    (if (<= n 1)\n        0\n        (/ vi (log2 n)))))\n  (equal? (let ([a '#(0 0 1 1 2)] [b '#(0 1 1 2 2)] [c '#(0 0 0 1 1)]) (and (> (partition-vi a b) (partition-vi a c)) (> (partition-vi-normalized a b) (partition-vi-normalized a c)))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "partition-vi-normalized", "ordering"], "split": "eval"}
{"id": "info_partition_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute unique sorted labels from '#(3 1 3 2 1 2).\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(unique-labels '#(3 1 3 2 1 2))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(3 1 3 2 1 2)) '(1 2 3)))", "tags": ["tier1", "info", "partition-info", "composition", "unique-labels", "direct"], "split": "train"}
{"id": "info_partition_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute unique labels from single-valued vector '#(5 5 5).\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(unique-labels '#(5 5 5))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (unique-labels '#(5 5 5)) '(5)))", "tags": ["tier1", "info", "partition-info", "composition", "unique-labels", "edge-case"], "split": "train"}
{"id": "info_partition_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether unique-label output is sorted ascending for '#(9 2 5 2 9 1).\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (unique-labels '#(9 2 5 2 9 1)) '(1 2 5 9))", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (equal? (unique-labels '#(9 2 5 2 9 1)) '(1 2 5 9)) #t))", "tags": ["tier1", "info", "partition-info", "composition", "unique-labels", "ordering"], "split": "train"}
{"id": "info_partition_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "unique-labels", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether unique-label count for '#(1 1 2 2 3 3 4) is 4.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (length (unique-labels '#(1 1 2 2 3 3 4))) 4)", "verify_expr": "(let ()\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (= (length (unique-labels '#(1 1 2 2 3 3 4))) 4) #t))", "tags": ["tier1", "info", "partition-info", "composition", "unique-labels", "count"], "split": "train"}
{"id": "info_partition_composition_029", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: small integration task across module primitives.\n\nBuild label index map for '(10 20 30) and return index for label 20.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (label-index-map '(10 20 30))]) (hamt-lookup-or 20 m -1))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (= (let ([m (label-index-map '(10 20 30))]) (hamt-lookup-or 20 m -1)) 1))", "tags": ["tier1", "info", "partition-info", "composition", "label-index-map", "direct"], "split": "train"}
{"id": "info_partition_composition_030", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nBuild label index map for '(7) and return index for label 7.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([m (label-index-map '(7))]) (hamt-lookup-or 7 m -1))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (= (let ([m (label-index-map '(7))]) (hamt-lookup-or 7 m -1)) 0))", "tags": ["tier1", "info", "partition-info", "composition", "label-index-map", "edge-case"], "split": "train"}
{"id": "info_partition_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn whether label-index-map assigns increasing indices following list order for '(3 9 4).\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([m (label-index-map '(3 9 4))]) (and (= (hamt-lookup-or 3 m -1) 0) (= (hamt-lookup-or 9 m -1) 1) (= (hamt-lookup-or 4 m -1) 2)))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (equal? (let ([m (label-index-map '(3 9 4))]) (and (= (hamt-lookup-or 3 m -1) 0) (= (hamt-lookup-or 9 m -1) 1) (= (hamt-lookup-or 4 m -1) 2))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "label-index-map", "ordering"], "split": "train"}
{"id": "info_partition_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/info/partition-info.ss", "source_test": "lattice/info/test-partition-info.ss", "source_function": "label-index-map", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn whether composing unique-labels with label-index-map gives index range 0..k-1.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([labels (unique-labels '#(5 3 5 2 3 1))] [m (label-index-map labels)]) (and (= (hamt-lookup-or 1 m -1) 0) (= (hamt-lookup-or 2 m -1) 1) (= (hamt-lookup-or 3 m -1) 2) (= (hamt-lookup-or 5 m -1) 3)))", "verify_expr": "(let ()\n  (define (label-index-map labels-list)\n  (let loop ([ls labels-list] [i 0] [ht hamt-empty])\n    (if (null? ls)\n        ht\n        (loop (cdr ls) (+ i 1) (hamt-assoc (car ls) i ht)))))\n  (define (insert-sorted x sorted)\n  (cond\n    [(null? sorted) (list x)]\n    [(< x (car sorted)) (cons x sorted)]\n    [else (cons (car sorted) (insert-sorted x (cdr sorted)))]))\n  (define (sort-labels keys)\n  (let loop ([remaining keys] [sorted '()])\n    (if (null? remaining)\n        sorted\n        (loop (cdr remaining)\n              (insert-sorted (car remaining) sorted)))))\n  (define (unique-labels labels)\n  (let loop ([i 0] [seen hamt-empty] [result '()])\n    (if (= i (vector-length labels))\n        (sort-labels result)\n        (let ([lbl (vector-ref labels i)])\n          (if (hamt-lookup lbl seen)\n              (loop (+ i 1) seen result)\n              (loop (+ i 1) (hamt-assoc lbl #t seen) (cons lbl result)))))))\n  (equal? (let* ([labels (unique-labels '#(5 3 5 2 3 1))] [m (label-index-map labels)]) (and (= (hamt-lookup-or 1 m -1) 0) (= (hamt-lookup-or 2 m -1) 1) (= (hamt-lookup-or 3 m -1) 2) (= (hamt-lookup-or 5 m -1) 3))) #t))", "tags": ["tier1", "info", "partition-info", "composition", "label-index-map", "integration"], "split": "eval"}
