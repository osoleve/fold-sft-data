{"id": "random_prng_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `u32`\nSpec: Truncate an integer to unsigned 32-bit by masking with (2^32 - 1).\n\nWrite exactly one Scheme function definition for `u32`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n(let () (= (u32 #x100000000) 0))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "spec-to-code", "u32"], "split": "train"}
{"id": "random_prng_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `u32`\nBehavior contract: Truncate an integer to unsigned 32-bit by masking with (2^32 - 1).\n\n```scheme\n(define (u32 n)\n  ;; TODO: mask to unsigned 32-bit range\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n(let () (= (u32 #x100000000) 0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "skeleton", "u32"], "split": "train"}
{"id": "random_prng_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `u64`\nBehavior contract: Truncate an integer to unsigned 64-bit by masking with (2^64 - 1).\n\n```scheme\n(define (u64 n)\n  ;; TODO: mask to unsigned 64-bit range\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF))\n(let () (= (u64 #x10000000000000000) 0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (u64 n)\n  (bitwise-and n mask-64))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF)\n  (= (u64 #x10000000000000000) 0)\n  (= (u64 -1) #xFFFFFFFFFFFFFFFF)\n  (= (u64 0) 0)))", "tags": ["tier1", "random", "prng", "skeleton", "u64"], "split": "train"}
{"id": "random_prng_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `rotl32`\nSpec: Rotate a 32-bit integer left by k bits with k reduced modulo 32.\n\nWrite exactly one Scheme function definition for `rotl32`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (= (rotl32 1 1) 2))\n(let () (= (rotl32 #x80000000 1) 1))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (and\n  (= (rotl32 1 1) 2)\n  (= (rotl32 #x80000000 1) 1)\n  (= (rotl32 #x12345678 4) #x23456781)\n  (= (rotl32 1 33) 2)))", "tags": ["tier1", "random", "prng", "spec-to-code", "rotl32"], "split": "train"}
{"id": "random_prng_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `rotl32`\nBehavior contract: Rotate a 32-bit integer left by k bits with k reduced modulo 32.\n\n```scheme\n(define (rotl32 x k)\n  ;; TODO: perform 32-bit rotate-left with modulo-32 shift\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (and\n  (= (rotl32 1 1) 2)\n  (= (rotl32 #x80000000 1) 1)\n  (= (rotl32 #x12345678 4) #x23456781)\n  (= (rotl32 1 33) 2)))", "tags": ["tier1", "random", "prng", "skeleton", "rotl32"], "split": "train"}
{"id": "random_prng_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `splitmix-next`\nBehavior contract: Advance splitmix64 state once and return (output . next-generator).\n\n```scheme\n(define (splitmix-next sm)\n  ;; TODO: apply splitmix64 mixing pipeline and return (value . next-state)\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([sm0 (make-splitmix 42)] [r1 (splitmix-next sm0)] [v1 (car r1)] [sm1 (cdr r1)] [r2 (splitmix-next sm1)] [v2 (car r2)]) (and (<= 0 v1) (< v1 (expt 2 64)) (<= 0 v2) (< v2 (expt 2 64)) (not (= v1 v2)) (= (splitmix-state sm1) (u64 (+ 42 #x9e3779b97f4a7c15))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([sm0 (make-splitmix 42)]\n       [r1 (splitmix-next sm0)]\n       [v1 (car r1)]\n       [sm1 (cdr r1)]\n       [r2 (splitmix-next sm1)]\n       [v2 (car r2)])\n  (and (<= 0 v1)\n       (< v1 (expt 2 64))\n       (<= 0 v2)\n       (< v2 (expt 2 64))\n       (not (= v1 v2))\n       (= (splitmix-state sm1)\n          (u64 (+ 42 #x9e3779b97f4a7c15))))))", "tags": ["tier1", "random", "prng", "skeleton", "splitmix-next"], "split": "train"}
{"id": "random_prng_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `make-pcg`\nSpec: Construct PCG state (pcg state inc) with odd increment derived from stream and warmed state progression.\n\nWrite exactly one Scheme function definition for `make-pcg`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p1 (make-pcg 42 7)] [p2 (make-pcg 42 7)] [p3 (make-pcg 42 8)]) (and (equal? p1 p2) (not (equal? p1 p3)) (eq? (car p1) 'pcg) (odd? (pcg-inc p1)) (< (pcg-state p1) (expt 2 64)) (< (pcg-inc p1) (expt 2 64)))))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "spec-to-code", "make-pcg"], "split": "train"}
{"id": "random_prng_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `make-pcg`\nBehavior contract: Construct PCG state (pcg state inc) with odd increment derived from stream and warmed state progression.\n\n```scheme\n(define (make-pcg seed stream)\n  ;; TODO: derive odd increment, warm state, return '(pcg state inc)\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p1 (make-pcg 42 7)] [p2 (make-pcg 42 7)] [p3 (make-pcg 42 8)]) (and (equal? p1 p2) (not (equal? p1 p3)) (eq? (car p1) 'pcg) (odd? (pcg-inc p1)) (< (pcg-state p1) (expt 2 64)) (< (pcg-inc p1) (expt 2 64)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "skeleton", "make-pcg"], "split": "train"}
{"id": "random_prng_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `pcg-next`\nSpec: Run one PCG-XSH-RR step: 32-bit output plus updated 64-bit state.\n\nWrite exactly one Scheme function definition for `pcg-next`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([p0 (make-pcg 12345 1)] [r1 (pcg-next p0)] [out1 (car r1)] [p1 (cdr r1)] [r1b (pcg-next p0)]) (and (= out1 (car r1b)) (equal? p1 (cdr r1b)) (<= 0 out1) (< out1 (expt 2 32)) (= (pcg-inc p0) (pcg-inc p1)) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (let* ([p0 (make-pcg 12345 1)]\n       [r1 (pcg-next p0)]\n       [out1 (car r1)]\n       [p1 (cdr r1)]\n       [r1b (pcg-next p0)])\n  (and (= out1 (car r1b))\n       (equal? p1 (cdr r1b))\n       (<= 0 out1)\n       (< out1 (expt 2 32))\n       (= (pcg-inc p0) (pcg-inc p1))\n       (= (pcg-state p1)\n          (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))", "tags": ["tier1", "random", "prng", "spec-to-code", "pcg-next"], "split": "train"}
{"id": "random_prng_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `pcg-next`\nBehavior contract: Run one PCG-XSH-RR step: 32-bit output plus updated 64-bit state.\n\n```scheme\n(define (pcg-next p)\n  ;; TODO: compute XSH-RR output and LCG state transition\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (let* ([p0 (make-pcg 12345 1)]\n       [r1 (pcg-next p0)]\n       [out1 (car r1)]\n       [p1 (cdr r1)]\n       [r1b (pcg-next p0)])\n  (and (= out1 (car r1b))\n       (equal? p1 (cdr r1b))\n       (<= 0 out1)\n       (< out1 (expt 2 32))\n       (= (pcg-inc p0) (pcg-inc p1))\n       (= (pcg-state p1)\n          (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))", "tags": ["tier1", "random", "prng", "skeleton", "pcg-next"], "split": "train"}
{"id": "random_prng_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `make-xorshift128`\nBehavior contract: Seed xorshift128+ from splitmix outputs and force both state words non-zero.\n\n```scheme\n(define (make-xorshift128 seed)\n  ;; TODO: seed from splitmix and enforce non-zero state words\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([xs0 (make-xorshift128 0)] [xs1 (make-xorshift128 0)] [xs2 (make-xorshift128 1)]) (and (equal? xs0 xs1) (not (equal? xs0 xs2)) (eq? (car xs0) 'xorshift128) (not (= (xorshift128-s0 xs0) 0)) (not (= (xorshift128-s1 xs0) 0)))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (let* ([xs0 (make-xorshift128 0)]\n       [xs1 (make-xorshift128 0)]\n       [xs2 (make-xorshift128 1)])\n  (and (equal? xs0 xs1)\n       (not (equal? xs0 xs2))\n       (eq? (car xs0) 'xorshift128)\n       (not (= (xorshift128-s0 xs0) 0))\n       (not (= (xorshift128-s1 xs0) 0)))))", "tags": ["tier1", "random", "prng", "skeleton", "make-xorshift128"], "split": "train"}
{"id": "random_prng_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `xorshift128-next`\nSpec: Run one xorshift128+ step and return (output . next-state).\n\nWrite exactly one Scheme function definition for `xorshift128-next`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let () (let* ([xs (make-xorshift128 42)] [r1 (xorshift128-next xs)] [v1 (car r1)] [xs1 (cdr r1)] [r1b (xorshift128-next xs)]) (and (= v1 (car r1b)) (equal? xs1 (cdr r1b)) (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs)))) (<= 0 v1) (< v1 (expt 2 64)) (eq? (car xs1) 'xorshift128))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "spec-to-code", "xorshift128-next"], "split": "train"}
{"id": "random_prng_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\nModule: lattice/random/prng.ss\nFunction target: `xorshift128-next`\nBehavior contract: Run one xorshift128+ step and return (output . next-state).\n\n```scheme\n(define (xorshift128-next xs)\n  ;; TODO: execute xorshift128+ transition and return (value . next-state)\n  <TODO>)\n```\n\nOutput only the completed function definition.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "skeleton", "xorshift128-next"], "split": "train"}
{"id": "random_prng_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `u32`\n\n```scheme\n(define (to-u32 n)\n  (bitwise-and n #xFFFFFFFF))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "translation", "chez", "u32"], "split": "train"}
{"id": "random_prng_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `u64`\n\n```python\ndef u64(n):\n    return n & ((1 << 64) - 1)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (u64 n)\n  (bitwise-and n mask-64))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF)\n  (= (u64 #x10000000000000000) 0)\n  (= (u64 -1) #xFFFFFFFFFFFFFFFF)\n  (= (u64 0) 0)))", "tags": ["tier1", "random", "prng", "translation", "python", "u64"], "split": "train"}
{"id": "random_prng_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `u64`\n\n```scheme\n(define (to-u64 n)\n  (bitwise-and n #xFFFFFFFFFFFFFFFF))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF))\n(let () (= (u64 #x10000000000000000) 0))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (u64 n)\n  (bitwise-and n mask-64))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF)\n  (= (u64 #x10000000000000000) 0)\n  (= (u64 -1) #xFFFFFFFFFFFFFFFF)\n  (= (u64 0) 0)))", "tags": ["tier1", "random", "prng", "translation", "chez", "u64"], "split": "train"}
{"id": "random_prng_translation_005", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `rotl32`\n\n```python\ndef rotl32(x, k):\n    x = u32(x)\n    k %= 32\n    return u32((x << k) | (x >> (32 - k)))\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (and\n  (= (rotl32 1 1) 2)\n  (= (rotl32 #x80000000 1) 1)\n  (= (rotl32 #x12345678 4) #x23456781)\n  (= (rotl32 1 33) 2)))", "tags": ["tier1", "random", "prng", "translation", "python", "rotl32"], "split": "train"}
{"id": "random_prng_translation_006", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `rotl32`\n\n```scheme\n(define (rotate-left32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (= (rotl32 1 1) 2))\n(let () (= (rotl32 #x80000000 1) 1))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (and\n  (= (rotl32 1 1) 2)\n  (= (rotl32 #x80000000 1) 1)\n  (= (rotl32 #x12345678 4) #x23456781)\n  (= (rotl32 1 33) 2)))", "tags": ["tier1", "random", "prng", "translation", "chez", "rotl32"], "split": "train"}
{"id": "random_prng_translation_007", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `splitmix-next`\n\n```python\ndef splitmix_next(sm):\n    s = u64(splitmix_state(sm) + 0x9E3779B97F4A7C15)\n    z = u64((s ^ (s >> 30)) * 0xBF58476D1CE4E5B9)\n    z = u64((z ^ (z >> 27)) * 0x94D049BB133111EB)\n    z = z ^ (z >> 31)\n    return z, make_splitmix(s)\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([sm0 (make-splitmix 42)] [r1 (splitmix-next sm0)] [v1 (car r1)] [sm1 (cdr r1)] [r2 (splitmix-next sm1)] [v2 (car r2)]) (and (<= 0 v1) (< v1 (expt 2 64)) (<= 0 v2) (< v2 (expt 2 64)) (not (= v1 v2)) (= (splitmix-state sm1) (u64 (+ 42 #x9e3779b97f4a7c15))))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([sm0 (make-splitmix 42)]\n       [r1 (splitmix-next sm0)]\n       [v1 (car r1)]\n       [sm1 (cdr r1)]\n       [r2 (splitmix-next sm1)]\n       [v2 (car r2)])\n  (and (<= 0 v1)\n       (< v1 (expt 2 64))\n       (<= 0 v2)\n       (< v2 (expt 2 64))\n       (not (= v1 v2))\n       (= (splitmix-state sm1)\n          (u64 (+ 42 #x9e3779b97f4a7c15))))))", "tags": ["tier1", "random", "prng", "translation", "python", "splitmix-next"], "split": "train"}
{"id": "random_prng_translation_008", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `splitmix-next`\n\n```scheme\n(define (splitmix-step sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30)) #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27)) #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([sm0 (make-splitmix 42)] [r1 (splitmix-next sm0)] [v1 (car r1)] [sm1 (cdr r1)] [r2 (splitmix-next sm1)] [v2 (car r2)]) (and (<= 0 v1) (< v1 (expt 2 64)) (<= 0 v2) (< v2 (expt 2 64)) (not (= v1 v2)) (= (splitmix-state sm1) (u64 (+ 42 #x9e3779b97f4a7c15))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([sm0 (make-splitmix 42)]\n       [r1 (splitmix-next sm0)]\n       [v1 (car r1)]\n       [sm1 (cdr r1)]\n       [r2 (splitmix-next sm1)]\n       [v2 (car r2)])\n  (and (<= 0 v1)\n       (< v1 (expt 2 64))\n       (<= 0 v2)\n       (< v2 (expt 2 64))\n       (not (= v1 v2))\n       (= (splitmix-state sm1)\n          (u64 (+ 42 #x9e3779b97f4a7c15))))))", "tags": ["tier1", "random", "prng", "translation", "chez", "splitmix-next"], "split": "train"}
{"id": "random_prng_translation_010", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `make-pcg`\n\n```scheme\n(define (pcg-init seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "translation", "chez", "make-pcg"], "split": "train"}
{"id": "random_prng_translation_011", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `pcg-next`\n\n```python\ndef pcg_next(p):\n    state = pcg_state(p)\n    inc = pcg_inc(p)\n    xorshifted = u32(((state >> 18) ^ state) >> 27)\n    rot = state >> 59\n    output = rotr32(xorshifted, rot)\n    new_state = u64(state * 0x5851F42D4C957F2D + inc)\n    return output, [\"pcg\", new_state, inc]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p0 (make-pcg 12345 1)] [r1 (pcg-next p0)] [out1 (car r1)] [p1 (cdr r1)] [r1b (pcg-next p0)]) (and (= out1 (car r1b)) (equal? p1 (cdr r1b)) (<= 0 out1) (< out1 (expt 2 32)) (= (pcg-inc p0) (pcg-inc p1)) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (let* ([p0 (make-pcg 12345 1)]\n       [r1 (pcg-next p0)]\n       [out1 (car r1)]\n       [p1 (cdr r1)]\n       [r1b (pcg-next p0)])\n  (and (= out1 (car r1b))\n       (equal? p1 (cdr r1b))\n       (<= 0 out1)\n       (< out1 (expt 2 32))\n       (= (pcg-inc p0) (pcg-inc p1))\n       (= (pcg-state p1)\n          (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))", "tags": ["tier1", "random", "prng", "translation", "python", "pcg-next"], "split": "train"}
{"id": "random_prng_translation_012", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `pcg-next`\n\n```scheme\n(define (pcg-step p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash (bitwise-xor (ash state -18) state) -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let () (let* ([p0 (make-pcg 12345 1)] [r1 (pcg-next p0)] [out1 (car r1)] [p1 (cdr r1)] [r1b (pcg-next p0)]) (and (= out1 (car r1b)) (equal? p1 (cdr r1b)) (<= 0 out1) (< out1 (expt 2 32)) (= (pcg-inc p0) (pcg-inc p1)) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (let* ([p0 (make-pcg 12345 1)]\n       [r1 (pcg-next p0)]\n       [out1 (car r1)]\n       [p1 (cdr r1)]\n       [r1b (pcg-next p0)])\n  (and (= out1 (car r1b))\n       (equal? p1 (cdr r1b))\n       (<= 0 out1)\n       (< out1 (expt 2 32))\n       (= (pcg-inc p0) (pcg-inc p1))\n       (= (pcg-state p1)\n          (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))", "tags": ["tier1", "random", "prng", "translation", "chez", "pcg-next"], "split": "train"}
{"id": "random_prng_translation_013", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `make-xorshift128`\n\n```python\ndef make_xorshift128(seed):\n    sm0 = make_splitmix(seed)\n    r1 = splitmix_next(sm0)\n    s0 = r1[0]\n    sm1 = r1[1]\n    r2 = splitmix_next(sm1)\n    s1 = r2[0]\n    return [\"xorshift128\", 1 if s0 == 0 else s0, 1 if s1 == 0 else s1]\n```\n\nReturn only the Scheme definition.\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (let* ([xs0 (make-xorshift128 0)]\n       [xs1 (make-xorshift128 0)]\n       [xs2 (make-xorshift128 1)])\n  (and (equal? xs0 xs1)\n       (not (equal? xs0 xs2))\n       (eq? (car xs0) 'xorshift128)\n       (not (= (xorshift128-s0 xs0) 0))\n       (not (= (xorshift128-s1 xs0) 0)))))", "tags": ["tier1", "random", "prng", "translation", "python", "make-xorshift128"], "split": "train"}
{"id": "random_prng_translation_014", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `make-xorshift128`\n\n```scheme\n(define (xorshift-init seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n```\n\nReturn only Fold code.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (let* ([xs0 (make-xorshift128 0)]\n       [xs1 (make-xorshift128 0)]\n       [xs2 (make-xorshift128 1)])\n  (and (equal? xs0 xs1)\n       (not (equal? xs0 xs2))\n       (eq? (car xs0) 'xorshift128)\n       (not (= (xorshift128-s0 xs0) 0))\n       (not (= (xorshift128-s1 xs0) 0)))))", "tags": ["tier1", "random", "prng", "translation", "chez", "make-xorshift128"], "split": "train"}
{"id": "random_prng_translation_015", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `xorshift128-next`\n\n```python\ndef xorshift128_next(xs):\n    s0 = xorshift128_s0(xs)\n    s1 = xorshift128_s1(xs)\n    result = u64(s0 + s1)\n    s1_new = s0 ^ s1\n    new_s0 = u64((rotl64(s0, 24) ^ s1_new) ^ (s1_new << 16))\n    new_s1 = rotl64(s1_new, 37)\n    return result, [\"xorshift128\", new_s0, new_s1]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (let* ([xs (make-xorshift128 42)] [r1 (xorshift128-next xs)] [v1 (car r1)] [xs1 (cdr r1)] [r1b (xorshift128-next xs)]) (and (= v1 (car r1b)) (equal? xs1 (cdr r1b)) (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs)))) (<= 0 v1) (< v1 (expt 2 64)) (eq? (car xs1) 'xorshift128))))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "translation", "python", "xorshift128-next"], "split": "train"}
{"id": "random_prng_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `u32` in `lattice/random/prng.ss`.\nKnown issue: This keeps 64 bits instead of truncating to 32 bits.\n\n```scheme\n(define (u32 n)\n  (u64 n))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: This keeps 64 bits instead of truncating to 32 bits.\n\nExpected behavior after patch:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "bugfix", "u32"], "split": "train"}
{"id": "random_prng_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `u64` in `lattice/random/prng.ss`.\nKnown issue: This truncates to 32 bits, not 64 bits.\n\n```scheme\n(define (u64 n)\n  (bitwise-and n #xFFFFFFFF))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF))\n(let () (= (u64 #x10000000000000000) 0))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (u64 n)\n  (bitwise-and n mask-64))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF)\n  (= (u64 #x10000000000000000) 0)\n  (= (u64 -1) #xFFFFFFFFFFFFFFFF)\n  (= (u64 0) 0)))", "tags": ["tier1", "random", "prng", "bugfix", "u64"], "split": "train"}
{"id": "random_prng_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `u64` in `lattice/random/prng.ss`.\nKnown issue: Unsigned wrapping is required; abs does not implement 64-bit masking semantics.\n\n```scheme\n(define (u64 n)\n  (abs n))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (u64 n)\n  (bitwise-and n mask-64))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF)\n  (= (u64 #x10000000000000000) 0)\n  (= (u64 -1) #xFFFFFFFFFFFFFFFF)\n  (= (u64 0) 0)))", "tags": ["tier1", "random", "prng", "bugfix", "u64"], "split": "train"}
{"id": "random_prng_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rotl32` in `lattice/random/prng.ss`.\nKnown issue: Shift amount must be reduced modulo 32 before rotation.\n\n```scheme\n(define (rotl32 x k)\n  (let ([x (u32 x)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (rotl32 1 1) 2))\n(let () (= (rotl32 #x80000000 1) 1))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (and\n  (= (rotl32 1 1) 2)\n  (= (rotl32 #x80000000 1) 1)\n  (= (rotl32 #x12345678 4) #x23456781)\n  (= (rotl32 1 33) 2)))", "tags": ["tier1", "random", "prng", "bugfix", "rotl32"], "split": "train"}
{"id": "random_prng_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `rotl32` in `lattice/random/prng.ss`.\nKnown issue: The right-shift component uses -k instead of (k-32), breaking rotate behavior.\n\n```scheme\n(define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k))))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The right-shift component uses -k instead of (k-32), breaking rotate behavior.\n\nExpected behavior after patch:\n```scheme\n(let () (= (rotl32 1 1) 2))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (rotl32 1 1) 2))\n(let () (= (rotl32 #x80000000 1) 1))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (and\n  (= (rotl32 1 1) 2)\n  (= (rotl32 #x80000000 1) 1)\n  (= (rotl32 #x12345678 4) #x23456781)\n  (= (rotl32 1 33) 2)))", "tags": ["tier1", "random", "prng", "bugfix", "rotl32"], "split": "train"}
{"id": "random_prng_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `splitmix-next` in `lattice/random/prng.ss`.\nKnown issue: Returning raw incremented state skips the required splitmix mixing rounds.\n\n```scheme\n(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))])\n    (cons s (make-splitmix s))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([sm0 (make-splitmix 42)] [r1 (splitmix-next sm0)] [v1 (car r1)] [sm1 (cdr r1)] [r2 (splitmix-next sm1)] [v2 (car r2)]) (and (<= 0 v1) (< v1 (expt 2 64)) (<= 0 v2) (< v2 (expt 2 64)) (not (= v1 v2)) (= (splitmix-state sm1) (u64 (+ 42 #x9e3779b97f4a7c15))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([sm0 (make-splitmix 42)]\n       [r1 (splitmix-next sm0)]\n       [v1 (car r1)]\n       [sm1 (cdr r1)]\n       [r2 (splitmix-next sm1)]\n       [v2 (car r2)])\n  (and (<= 0 v1)\n       (< v1 (expt 2 64))\n       (<= 0 v2)\n       (< v2 (expt 2 64))\n       (not (= v1 v2))\n       (= (splitmix-state sm1)\n          (u64 (+ 42 #x9e3779b97f4a7c15))))))", "tags": ["tier1", "random", "prng", "bugfix", "splitmix-next"], "split": "train"}
{"id": "random_prng_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `splitmix-next` in `lattice/random/prng.ss`.\nKnown issue: The final `xor`/`ash -31` diffusion step is missing, so output quality is degraded.\n\n```scheme\n(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30)) #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27)) #x94d049bb133111eb))])\n    (cons z (make-splitmix s))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([sm0 (make-splitmix 42)]\n       [r1 (splitmix-next sm0)]\n       [v1 (car r1)]\n       [sm1 (cdr r1)]\n       [r2 (splitmix-next sm1)]\n       [v2 (car r2)])\n  (and (<= 0 v1)\n       (< v1 (expt 2 64))\n       (<= 0 v2)\n       (< v2 (expt 2 64))\n       (not (= v1 v2))\n       (= (splitmix-state sm1)\n          (u64 (+ 42 #x9e3779b97f4a7c15))))))", "tags": ["tier1", "random", "prng", "bugfix", "splitmix-next"], "split": "train"}
{"id": "random_prng_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-pcg` in `lattice/random/prng.ss`.\nKnown issue: PCG seeding requires warm-up transitions, not direct state assignment.\n\n```scheme\n(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))])\n    (list 'pcg (u64 seed) inc)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (make-pcg 42 7)] [p2 (make-pcg 42 7)] [p3 (make-pcg 42 8)]) (and (equal? p1 p2) (not (equal? p1 p3)) (eq? (car p1) 'pcg) (odd? (pcg-inc p1)) (< (pcg-state p1) (expt 2 64)) (< (pcg-inc p1) (expt 2 64)))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "bugfix", "make-pcg"], "split": "train"}
{"id": "random_prng_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pcg-next` in `lattice/random/prng.ss`.\nKnown issue: Rotation count must use the top 5 bits (state >> 59), not >> 58.\n\n```scheme\n(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -58)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p0 (make-pcg 12345 1)] [r1 (pcg-next p0)] [out1 (car r1)] [p1 (cdr r1)] [r1b (pcg-next p0)]) (and (= out1 (car r1b)) (equal? p1 (cdr r1b)) (<= 0 out1) (< out1 (expt 2 32)) (= (pcg-inc p0) (pcg-inc p1)) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (let* ([p0 (make-pcg 12345 1)]\n       [r1 (pcg-next p0)]\n       [out1 (car r1)]\n       [p1 (cdr r1)]\n       [r1b (pcg-next p0)])\n  (and (= out1 (car r1b))\n       (equal? p1 (cdr r1b))\n       (<= 0 out1)\n       (< out1 (expt 2 32))\n       (= (pcg-inc p0) (pcg-inc p1))\n       (= (pcg-state p1)\n          (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))", "tags": ["tier1", "random", "prng", "bugfix", "pcg-next"], "split": "train"}
{"id": "random_prng_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `pcg-next` in `lattice/random/prng.ss`.\nKnown issue: xorshifted must be truncated to 32 bits before rotation.\n\n```scheme\n(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (ash\n                      (bitwise-xor (ash state -18) state)\n                      -27)]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: xorshifted must be truncated to 32 bits before rotation.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([p0 (make-pcg 12345 1)] [r1 (pcg-next p0)] [out1 (car r1)] [p1 (cdr r1)] [r1b (pcg-next p0)]) (and (= out1 (car r1b)) (equal? p1 (cdr r1b)) (<= 0 out1) (< out1 (expt 2 32)) (= (pcg-inc p0) (pcg-inc p1)) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p0 (make-pcg 12345 1)] [r1 (pcg-next p0)] [out1 (car r1)] [p1 (cdr r1)] [r1b (pcg-next p0)]) (and (= out1 (car r1b)) (equal? p1 (cdr r1b)) (<= 0 out1) (< out1 (expt 2 32)) (= (pcg-inc p0) (pcg-inc p1)) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (let* ([p0 (make-pcg 12345 1)]\n       [r1 (pcg-next p0)]\n       [out1 (car r1)]\n       [p1 (cdr r1)]\n       [r1b (pcg-next p0)])\n  (and (= out1 (car r1b))\n       (equal? p1 (cdr r1b))\n       (<= 0 out1)\n       (< out1 (expt 2 32))\n       (= (pcg-inc p0) (pcg-inc p1))\n       (= (pcg-state p1)\n          (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))))", "tags": ["tier1", "random", "prng", "bugfix", "pcg-next"], "split": "train"}
{"id": "random_prng_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-xorshift128` in `lattice/random/prng.ss`.\nKnown issue: State words must be forced non-zero for robustness of xorshift128+.\n\n```scheme\n(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128 s0 s1)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (let* ([xs0 (make-xorshift128 0)]\n       [xs1 (make-xorshift128 0)]\n       [xs2 (make-xorshift128 1)])\n  (and (equal? xs0 xs1)\n       (not (equal? xs0 xs2))\n       (eq? (car xs0) 'xorshift128)\n       (not (= (xorshift128-s0 xs0) 0))\n       (not (= (xorshift128-s1 xs0) 0)))))", "tags": ["tier1", "random", "prng", "bugfix", "make-xorshift128"], "split": "train"}
{"id": "random_prng_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-xorshift128` in `lattice/random/prng.ss`.\nKnown issue: The second state word must come from a second splitmix step, not reused from the first.\n\n```scheme\n(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [s1 (car r1)])\n    (list 'xorshift128 (if (= s0 0) 1 s0) (if (= s1 0) 1 s1))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The second state word must come from a second splitmix step, not reused from the first.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([xs0 (make-xorshift128 0)] [xs1 (make-xorshift128 0)] [xs2 (make-xorshift128 1)]) (and (equal? xs0 xs1) (not (equal? xs0 xs2)) (eq? (car xs0) 'xorshift128) (not (= (xorshift128-s0 xs0) 0)) (not (= (xorshift128-s1 xs0) 0)))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([xs0 (make-xorshift128 0)] [xs1 (make-xorshift128 0)] [xs2 (make-xorshift128 1)]) (and (equal? xs0 xs1) (not (equal? xs0 xs2)) (eq? (car xs0) 'xorshift128) (not (= (xorshift128-s0 xs0) 0)) (not (= (xorshift128-s1 xs0) 0)))))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (let* ([xs0 (make-xorshift128 0)]\n       [xs1 (make-xorshift128 0)]\n       [xs2 (make-xorshift128 1)])\n  (and (equal? xs0 xs1)\n       (not (equal? xs0 xs2))\n       (eq? (car xs0) 'xorshift128)\n       (not (= (xorshift128-s0 xs0) 0))\n       (not (= (xorshift128-s1 xs0) 0)))))", "tags": ["tier1", "random", "prng", "bugfix", "make-xorshift128"], "split": "train"}
{"id": "random_prng_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `xorshift128-next` in `lattice/random/prng.ss`.\nKnown issue: xorshift128+ output is sum mod 2^64, not xor.\n\n```scheme\n(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (bitwise-xor s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: xorshift128+ output is sum mod 2^64, not xor.\n\nExpected behavior after patch:\n```scheme\n(let () (let* ([xs (make-xorshift128 42)] [r1 (xorshift128-next xs)] [v1 (car r1)] [xs1 (cdr r1)] [r1b (xorshift128-next xs)]) (and (= v1 (car r1b)) (equal? xs1 (cdr r1b)) (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs)))) (<= 0 v1) (< v1 (expt 2 64)) (eq? (car xs1) 'xorshift128))))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([xs (make-xorshift128 42)] [r1 (xorshift128-next xs)] [v1 (car r1)] [xs1 (cdr r1)] [r1b (xorshift128-next xs)]) (and (= v1 (car r1b)) (equal? xs1 (cdr r1b)) (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs)))) (<= 0 v1) (< v1 (expt 2 64)) (eq? (car xs1) 'xorshift128))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "bugfix", "xorshift128-next"], "split": "train"}
{"id": "random_prng_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: compose existing APIs into one expression.\n\nMap `u32` over the integers `'(0 -1 #x100000000)` and return the result list.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(map u32 '(0 -1 #x100000000))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (map u32 '(0 -1 #x100000000)) '(0 #xFFFFFFFF 0)))", "tags": ["tier1", "random", "prng", "composition", "u32", "map"], "split": "train"}
{"id": "random_prng_composition_003", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff applying `u32` twice is idempotent for `-17`.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (u32 (u32 -17)) (u32 -17))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (= (u32 (u32 -17)) (u32 -17)) #t))", "tags": ["tier1", "random", "prng", "composition", "u32", "property"], "split": "train"}
{"id": "random_prng_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompute the low 32 bits of `(+ #xFFFFFFFF 2)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(u32 (+ #xFFFFFFFF 2))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (u32 (+ #xFFFFFFFF 2)) 1))", "tags": ["tier1", "random", "prng", "composition", "u32", "arithmetic"], "split": "train"}
{"id": "random_prng_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: compose existing APIs into one expression.\n\nTruncate `#x10000000000000005` to unsigned 64-bit.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(u64 #x10000000000000005)", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (u64 #x10000000000000005) 5))", "tags": ["tier1", "random", "prng", "composition", "u64", "direct"], "split": "train"}
{"id": "random_prng_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nMap `u64` over `'(0 -1 #x10000000000000000)`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(map u64 '(0 -1 #x10000000000000000))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (map u64 '(0 -1 #x10000000000000000)) '(0 #xFFFFFFFFFFFFFFFF 0)))", "tags": ["tier1", "random", "prng", "composition", "u64", "map"], "split": "train"}
{"id": "random_prng_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff `u64` is idempotent on `-987654321`.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(= (u64 (u64 -987654321)) (u64 -987654321))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (= (u64 (u64 -987654321)) (u64 -987654321)) #t))", "tags": ["tier1", "random", "prng", "composition", "u64", "property"], "split": "train"}
{"id": "random_prng_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompute wrapped addition: low 64 bits of `(+ #xFFFFFFFFFFFFFFFF 2)`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(u64 (+ #xFFFFFFFFFFFFFFFF 2))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (u64 (+ #xFFFFFFFFFFFFFFFF 2)) 1))", "tags": ["tier1", "random", "prng", "composition", "u64", "arithmetic"], "split": "train"}
{"id": "random_prng_composition_010", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff rotating by 40 is equivalent to rotating by 8.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (rotl32 #xDEADBEEF 40) (rotl32 #xDEADBEEF 8))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (= (rotl32 #xDEADBEEF 40) (rotl32 #xDEADBEEF 8)) #t))", "tags": ["tier1", "random", "prng", "composition", "rotl32", "modulo"], "split": "train"}
{"id": "random_prng_composition_011", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: small integration task across module primitives.\n\nRotate then undo with `rotr32` for `#x89ABCDEF` and shift 13; return whether original value is recovered.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (rotr32 (rotl32 #x89ABCDEF 13) 13) (u32 #x89ABCDEF))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (= (rotr32 (rotl32 #x89ABCDEF 13) 13) (u32 #x89ABCDEF)) #t))", "tags": ["tier1", "random", "prng", "composition", "rotl32", "inverse"], "split": "train"}
{"id": "random_prng_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRotate `1` left by 31 bits.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(rotl32 1 31)", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (rotl32 1 31) #x80000000))", "tags": ["tier1", "random", "prng", "composition", "rotl32", "edge-case"], "split": "train"}
{"id": "random_prng_composition_013", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: small integration task across module primitives.\n\nAdvance `(make-splitmix 5)` once and return the next generator state value.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(splitmix-state (cdr (splitmix-next (make-splitmix 5))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (splitmix-state (cdr (splitmix-next (make-splitmix 5)))) (u64 (+ 5 #x9e3779b97f4a7c15))))", "tags": ["tier1", "random", "prng", "composition", "splitmix-next", "state"], "split": "train"}
{"id": "random_prng_composition_014", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff the first splitmix output is deterministic for seed 7.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([a (car (splitmix-next (make-splitmix 7)))] [b (car (splitmix-next (make-splitmix 7)))]) (= a b))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let ([a (car (splitmix-next (make-splitmix 7)))] [b (car (splitmix-next (make-splitmix 7)))]) (= a b)) #t))", "tags": ["tier1", "random", "prng", "composition", "splitmix-next", "determinism"], "split": "train"}
{"id": "random_prng_composition_015", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: compose existing APIs into one expression.\n\nReturn #t iff two consecutive outputs from the same seed are different.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([g (make-splitmix 7)] [r1 (splitmix-next g)] [r2 (splitmix-next (cdr r1))]) (not (= (car r1) (car r2))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let* ([g (make-splitmix 7)] [r1 (splitmix-next g)] [r2 (splitmix-next (cdr r1))]) (not (= (car r1) (car r2)))) #t))", "tags": ["tier1", "random", "prng", "composition", "splitmix-next", "sequence"], "split": "train"}
{"id": "random_prng_composition_016", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: compose existing APIs into one expression.\n\nCheck that splitmix output always lies in unsigned 64-bit range for seed 123.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([v (car (splitmix-next (make-splitmix 123)))]) (and (<= 0 v) (< v (expt 2 64))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let ([v (car (splitmix-next (make-splitmix 123)))]) (and (<= 0 v) (< v (expt 2 64)))) #t))", "tags": ["tier1", "random", "prng", "composition", "splitmix-next", "range"], "split": "train"}
{"id": "random_prng_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff `make-pcg` is deterministic for identical seed/stream.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (make-pcg 42 7) (make-pcg 42 7))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (equal? (make-pcg 42 7) (make-pcg 42 7)) #t))", "tags": ["tier1", "random", "prng", "composition", "make-pcg", "determinism"], "split": "train"}
{"id": "random_prng_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff different stream ids produce different PCG states for seed 42.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(not (equal? (make-pcg 42 7) (make-pcg 42 8)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (not (equal? (make-pcg 42 7) (make-pcg 42 8))) #t))", "tags": ["tier1", "random", "prng", "composition", "make-pcg", "streams"], "split": "train"}
{"id": "random_prng_composition_020", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: small integration task across module primitives.\n\nGenerate one value from `(make-pcg 99 1)` and check that output is 32-bit.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([v (car (pcg-next (make-pcg 99 1)))]) (and (<= 0 v) (< v (expt 2 32))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let ([v (car (pcg-next (make-pcg 99 1)))]) (and (<= 0 v) (< v (expt 2 32)))) #t))", "tags": ["tier1", "random", "prng", "composition", "make-pcg", "integration"], "split": "train"}
{"id": "random_prng_composition_021", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: small integration task across module primitives.\n\nRun `pcg-next` on `(make-pcg 12345 1)` and return the output value.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(car (pcg-next (make-pcg 12345 1)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (let ([v (car (pcg-next (make-pcg 12345 1)))]) (and (<= 0 v) (< v (expt 2 32)))))", "tags": ["tier1", "random", "prng", "composition", "pcg-next", "direct"], "split": "train"}
{"id": "random_prng_composition_022", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff one-step state transition matches the PCG LCG recurrence.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p0 (make-pcg 12345 1)] [p1 (cdr (pcg-next p0))]) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0)))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let* ([p0 (make-pcg 12345 1)] [p1 (cdr (pcg-next p0))]) (= (pcg-state p1) (u64 (+ (* (pcg-state p0) #x5851f42d4c957f2d) (pcg-inc p0))))) #t))", "tags": ["tier1", "random", "prng", "composition", "pcg-next", "state-update"], "split": "train"}
{"id": "random_prng_composition_023", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff `pcg-next` is deterministic for the same input state.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p (make-pcg 77 3)] [r1 (pcg-next p)] [r2 (pcg-next p)]) (and (= (car r1) (car r2)) (equal? (cdr r1) (cdr r2))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let* ([p (make-pcg 77 3)] [r1 (pcg-next p)] [r2 (pcg-next p)]) (and (= (car r1) (car r2)) (equal? (cdr r1) (cdr r2)))) #t))", "tags": ["tier1", "random", "prng", "composition", "pcg-next", "determinism"], "split": "train"}
{"id": "random_prng_composition_025", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate `(make-xorshift128 0)` and return whether both state words are non-zero.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([xs (make-xorshift128 0)]) (and (not (= (xorshift128-s0 xs) 0)) (not (= (xorshift128-s1 xs) 0))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let ([xs (make-xorshift128 0)]) (and (not (= (xorshift128-s0 xs) 0)) (not (= (xorshift128-s1 xs) 0)))) #t))", "tags": ["tier1", "random", "prng", "composition", "make-xorshift128", "edge-case"], "split": "train"}
{"id": "random_prng_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff xorshift constructor is deterministic for identical seed 42.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (make-xorshift128 42) (make-xorshift128 42))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (equal? (make-xorshift128 42) (make-xorshift128 42)) #t))", "tags": ["tier1", "random", "prng", "composition", "make-xorshift128", "determinism"], "split": "train"}
{"id": "random_prng_composition_027", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff seeds 1 and 2 produce distinct initial xorshift states.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(not (equal? (make-xorshift128 1) (make-xorshift128 2)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (not (equal? (make-xorshift128 1) (make-xorshift128 2))) #t))", "tags": ["tier1", "random", "prng", "composition", "make-xorshift128", "seeds"], "split": "train"}
{"id": "random_prng_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate `(make-xorshift128 9)` and check that tag symbol is `xorshift128`.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(car (make-xorshift128 9))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (car (make-xorshift128 9)) 'xorshift128))", "tags": ["tier1", "random", "prng", "composition", "make-xorshift128", "shape"], "split": "train"}
{"id": "random_prng_composition_029", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun one xorshift step from `(make-xorshift128 42)` and return output value.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(car (xorshift128-next (make-xorshift128 42)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (let ([v (car (xorshift128-next (make-xorshift128 42)))]) (and (<= 0 v) (< v (expt 2 64)))))", "tags": ["tier1", "random", "prng", "composition", "xorshift128-next", "direct"], "split": "train"}
{"id": "random_prng_composition_030", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: small integration task across module primitives.\n\nReturn #t iff xorshift output equals `(u64 (+ s0 s1))` for current state.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([xs (make-xorshift128 42)] [v (car (xorshift128-next xs))]) (= v (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs)))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let* ([xs (make-xorshift128 42)] [v (car (xorshift128-next xs))]) (= v (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))) #t))", "tags": ["tier1", "random", "prng", "composition", "xorshift128-next", "formula"], "split": "train"}
{"id": "random_prng_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nReturn #t iff `xorshift128-next` is deterministic for the same input state.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([xs (make-xorshift128 5)] [r1 (xorshift128-next xs)] [r2 (xorshift128-next xs)]) (and (= (car r1) (car r2)) (equal? (cdr r1) (cdr r2))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let* ([xs (make-xorshift128 5)] [r1 (xorshift128-next xs)] [r2 (xorshift128-next xs)]) (and (= (car r1) (car r2)) (equal? (cdr r1) (cdr r2)))) #t))", "tags": ["tier1", "random", "prng", "composition", "xorshift128-next", "determinism"], "split": "train"}
{"id": "random_prng_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `u64`\nSpec: Truncate an integer to unsigned 64-bit by masking with (2^64 - 1).\n\nWrite exactly one Scheme function definition for `u64`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (u64 n)\n  (bitwise-and n mask-64))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF)\n  (= (u64 #x10000000000000000) 0)\n  (= (u64 -1) #xFFFFFFFFFFFFFFFF)\n  (= (u64 0) 0)))", "tags": ["tier1", "random", "prng", "spec-to-code", "u64"], "split": "eval"}
{"id": "random_prng_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `splitmix-next`\nSpec: Advance splitmix64 state once and return (output . next-generator).\n\nWrite exactly one Scheme function definition for `splitmix-next`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([sm0 (make-splitmix 42)] [r1 (splitmix-next sm0)] [v1 (car r1)] [sm1 (cdr r1)] [r2 (splitmix-next sm1)] [v2 (car r2)]) (and (<= 0 v1) (< v1 (expt 2 64)) (<= 0 v2) (< v2 (expt 2 64)) (not (= v1 v2)) (= (splitmix-state sm1) (u64 (+ 42 #x9e3779b97f4a7c15))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([sm0 (make-splitmix 42)]\n       [r1 (splitmix-next sm0)]\n       [v1 (car r1)]\n       [sm1 (cdr r1)]\n       [r2 (splitmix-next sm1)]\n       [v2 (car r2)])\n  (and (<= 0 v1)\n       (< v1 (expt 2 64))\n       (<= 0 v2)\n       (< v2 (expt 2 64))\n       (not (= v1 v2))\n       (= (splitmix-state sm1)\n          (u64 (+ 42 #x9e3779b97f4a7c15))))))", "tags": ["tier1", "random", "prng", "spec-to-code", "splitmix-next"], "split": "eval"}
{"id": "random_prng_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `make-xorshift128`\nSpec: Seed xorshift128+ from splitmix outputs and force both state words non-zero.\n\nWrite exactly one Scheme function definition for `make-xorshift128`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([xs0 (make-xorshift128 0)] [xs1 (make-xorshift128 0)] [xs2 (make-xorshift128 1)]) (and (equal? xs0 xs1) (not (equal? xs0 xs2)) (eq? (car xs0) 'xorshift128) (not (= (xorshift128-s0 xs0) 0)) (not (= (xorshift128-s1 xs0) 0)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (let* ([xs0 (make-xorshift128 0)]\n       [xs1 (make-xorshift128 0)]\n       [xs2 (make-xorshift128 1)])\n  (and (equal? xs0 xs1)\n       (not (equal? xs0 xs2))\n       (eq? (car xs0) 'xorshift128)\n       (not (= (xorshift128-s0 xs0) 0))\n       (not (= (xorshift128-s1 xs0) 0)))))", "tags": ["tier1", "random", "prng", "spec-to-code", "make-xorshift128"], "split": "eval"}
{"id": "random_prng_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `u32`\n\n```python\ndef u32(n):\n    return n & ((1 << 32) - 1)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n(let () (= (u32 #x100000000) 0))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "translation", "python", "u32"], "split": "eval"}
{"id": "random_prng_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `make-pcg`\n\n```python\ndef make_pcg(seed, stream):\n    inc = u64((stream << 1) | 1)\n    state0 = 0\n    state1 = u64(state0 * 0x5851F42D4C957F2D + inc)\n    state2 = u64(state1 + u64(seed))\n    state3 = u64(state2 * 0x5851F42D4C957F2D + inc)\n    return [\"pcg\", state3, inc]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "translation", "python", "make-pcg"], "split": "eval"}
{"id": "random_prng_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `xorshift128-next`\n\n```scheme\n(define (xorshift-step xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "translation", "chez", "xorshift128-next"], "split": "eval"}
{"id": "random_prng_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `u32` in `lattice/random/prng.ss`.\nKnown issue: The mask drops the high bit; unsigned 32-bit truncation must keep all 32 bits.\n\n```scheme\n(define (u32 n)\n  (bitwise-and n #x7FFFFFFF))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The mask drops the high bit; unsigned 32-bit truncation must keep all 32 bits.\n\nExpected behavior after patch:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n(let () (= (u32 #x100000000) 0))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "bugfix", "u32"], "split": "eval"}
{"id": "random_prng_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-pcg` in `lattice/random/prng.ss`.\nKnown issue: PCG increment must be odd; dropping the low-bit OR can create invalid streams.\n\n```scheme\n(define (make-pcg seed stream)\n  (let* ([inc (u64 (ash stream 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (make-pcg 42 7)] [p2 (make-pcg 42 7)] [p3 (make-pcg 42 8)]) (and (equal? p1 p2) (not (equal? p1 p3)) (eq? (car p1) 'pcg) (odd? (pcg-inc p1)) (< (pcg-state p1) (expt 2 64)) (< (pcg-inc p1) (expt 2 64)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "bugfix", "make-pcg"], "split": "eval"}
{"id": "random_prng_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `xorshift128-next` in `lattice/random/prng.ss`.\nKnown issue: The second state word must be rotated by 37 bits each step.\n\n```scheme\n(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))])\n    (cons result (list 'xorshift128 new-s0 s1-new))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([xs (make-xorshift128 42)] [r1 (xorshift128-next xs)] [v1 (car r1)] [xs1 (cdr r1)] [r1b (xorshift128-next xs)]) (and (= v1 (car r1b)) (equal? xs1 (cdr r1b)) (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs)))) (<= 0 v1) (< v1 (expt 2 64)) (eq? (car xs1) 'xorshift128))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "bugfix", "xorshift128-next"], "split": "eval"}
{"id": "random_prng_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nTruncate `#x100000001` to unsigned 32-bit.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(u32 #x100000001)", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (u32 #x100000001) 1))", "tags": ["tier1", "random", "prng", "composition", "u32", "direct"], "split": "eval"}
{"id": "random_prng_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt": "Task mode: compose existing APIs into one expression.\n\nRotate `#x12345678` left by 8 bits.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(rotl32 #x12345678 8)", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (rotl32 #x12345678 8) #x34567812))", "tags": ["tier1", "random", "prng", "composition", "rotl32", "direct"], "split": "eval"}
{"id": "random_prng_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate `(make-pcg 42 7)` and return its increment field.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(pcg-inc (make-pcg 42 7))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (modulo (pcg-inc (make-pcg 42 7)) 2) 1))", "tags": ["tier1", "random", "prng", "composition", "make-pcg", "direct"], "split": "eval"}
{"id": "random_prng_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun two PCG steps and return #t iff increment stays unchanged.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p0 (make-pcg 77 3)] [p1 (cdr (pcg-next p0))] [p2 (cdr (pcg-next p1))]) (= (pcg-inc p0) (pcg-inc p2)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let* ([p0 (make-pcg 77 3)] [p1 (cdr (pcg-next p0))] [p2 (cdr (pcg-next p1))]) (= (pcg-inc p0) (pcg-inc p2))) #t))", "tags": ["tier1", "random", "prng", "composition", "pcg-next", "invariant"], "split": "eval"}
{"id": "random_prng_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt": "Task mode: small integration task across module primitives.\n\nRun one step and check that the returned state tag remains `xorshift128`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(car (cdr (xorshift128-next (make-xorshift128 5))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (car (cdr (xorshift128-next (make-xorshift128 5)))) 'xorshift128))", "tags": ["tier1", "random", "prng", "composition", "xorshift128-next", "state-shape"], "split": "eval"}
