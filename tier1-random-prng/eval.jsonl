{"id": "random_prng_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u64", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `u64`\nSpec: Truncate an integer to unsigned 64-bit by masking with (2^64 - 1).\n\nWrite exactly one Scheme function definition for `u64`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `u64`\nSpec: Truncate an integer to unsigned 64-bit by masking with (2^64 - 1).\n\nWrite exactly one Scheme function definition for `u64`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (u64 n)\n  (bitwise-and n mask-64))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u64 #xFFFFFFFFFFFFFFFF) #xFFFFFFFFFFFFFFFF)\n  (= (u64 #x10000000000000000) 0)\n  (= (u64 -1) #xFFFFFFFFFFFFFFFF)\n  (= (u64 0) 0)))", "tags": ["tier1", "random", "prng", "spec-to-code", "u64"], "split": "eval"}
{"id": "random_prng_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "splitmix-next", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `splitmix-next`\nSpec: Advance splitmix64 state once and return (output . next-generator).\n\nWrite exactly one Scheme function definition for `splitmix-next`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `splitmix-next`\nSpec: Advance splitmix64 state once and return (output . next-generator).\n\nWrite exactly one Scheme function definition for `splitmix-next`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([sm0 (make-splitmix 42)] [r1 (splitmix-next sm0)] [v1 (car r1)] [sm1 (cdr r1)] [r2 (splitmix-next sm1)] [v2 (car r2)]) (and (<= 0 v1) (< v1 (expt 2 64)) (<= 0 v2) (< v2 (expt 2 64)) (not (= v1 v2)) (= (splitmix-state sm1) (u64 (+ 42 #x9e3779b97f4a7c15))))))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([sm0 (make-splitmix 42)]\n       [r1 (splitmix-next sm0)]\n       [v1 (car r1)]\n       [sm1 (cdr r1)]\n       [r2 (splitmix-next sm1)]\n       [v2 (car r2)])\n  (and (<= 0 v1)\n       (< v1 (expt 2 64))\n       (<= 0 v2)\n       (< v2 (expt 2 64))\n       (not (= v1 v2))\n       (= (splitmix-state sm1)\n          (u64 (+ 42 #x9e3779b97f4a7c15))))))", "tags": ["tier1", "random", "prng", "spec-to-code", "splitmix-next"], "split": "eval"}
{"id": "random_prng_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-xorshift128", "prompt_body": "Implement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `make-xorshift128`\nSpec: Seed xorshift128+ from splitmix outputs and force both state words non-zero.\n\nWrite exactly one Scheme function definition for `make-xorshift128`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this function in Fold-native Scheme.\n\nTarget module: lattice/random/prng.ss\nFunction: `make-xorshift128`\nSpec: Seed xorshift128+ from splitmix outputs and force both state words non-zero.\n\nWrite exactly one Scheme function definition for `make-xorshift128`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let () (let* ([xs0 (make-xorshift128 0)] [xs1 (make-xorshift128 0)] [xs2 (make-xorshift128 1)]) (and (equal? xs0 xs1) (not (equal? xs0 xs2)) (eq? (car xs0) 'xorshift128) (not (= (xorshift128-s0 xs0) 0)) (not (= (xorshift128-s1 xs0) 0)))))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (let* ([xs0 (make-xorshift128 0)]\n       [xs1 (make-xorshift128 0)]\n       [xs2 (make-xorshift128 1)])\n  (and (equal? xs0 xs1)\n       (not (equal? xs0 xs2))\n       (eq? (car xs0) 'xorshift128)\n       (not (= (xorshift128-s0 xs0) 0))\n       (not (= (xorshift128-s1 xs0) 0)))))", "tags": ["tier1", "random", "prng", "spec-to-code", "make-xorshift128"], "split": "eval"}
{"id": "random_prng_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `u32`\n\n```python\ndef u32(n):\n    return n & ((1 << 32) - 1)\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `u32`\n\n```python\ndef u32(n):\n    return n & ((1 << 32) - 1)\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n(let () (= (u32 #x100000000) 0))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "translation", "python", "u32"], "split": "eval"}
{"id": "random_prng_translation_009", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt_body": "Translate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `make-pcg`\n\n```python\ndef make_pcg(seed, stream):\n    inc = u64((stream << 1) | 1)\n    state0 = 0\n    state1 = u64(state0 * 0x5851F42D4C957F2D + inc)\n    state2 = u64(state1 + u64(seed))\n    state3 = u64(state2 * 0x5851F42D4C957F2D + inc)\n    return [\"pcg\", state3, inc]\n```\n\nReturn only the Scheme definition.", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate the following Python function into Fold-native Scheme.\nPreserve behavior exactly.\n\nTarget function name: `make-pcg`\n\n```python\ndef make_pcg(seed, stream):\n    inc = u64((stream << 1) | 1)\n    state0 = 0\n    state1 = u64(state0 * 0x5851F42D4C957F2D + inc)\n    state2 = u64(state1 + u64(seed))\n    state3 = u64(state2 * 0x5851F42D4C957F2D + inc)\n    return [\"pcg\", state3, inc]\n```\n\nReturn only the Scheme definition.\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "translation", "python", "make-pcg"], "split": "eval"}
{"id": "random_prng_translation_016", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `xorshift128-next`\n\n```scheme\n(define (xorshift-step xs)\n  (let* ([a (xorshift128-s0 xs)]\n         [b (xorshift128-s1 xs)]\n         [sum (u64 (+ a b))]\n         [t (bitwise-xor a b)]\n         [a* (u64 (bitwise-xor\n                   (bitwise-xor (rotl64 a 24) t)\n                   (ash t 16)))]\n         [b* (rotl64 t 37)])\n    (cons sum (list 'xorshift128 a* b*))))\n```\n\nReturn only Fold code.", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nKeep semantics identical.\n\nTarget function: `xorshift128-next`\n\n```scheme\n(define (xorshift-step xs)\n  (let* ([a (xorshift128-s0 xs)]\n         [b (xorshift128-s1 xs)]\n         [sum (u64 (+ a b))]\n         [t (bitwise-xor a b)]\n         [a* (u64 (bitwise-xor\n                   (bitwise-xor (rotl64 a 24) t)\n                   (ash t 16)))]\n         [b* (rotl64 t 37)])\n    (cons sum (list 'xorshift128 a* b*))))\n```\n\nReturn only Fold code.\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "translation", "chez", "xorshift128-next"], "split": "eval"}
{"id": "random_prng_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `u32` in `lattice/random/prng.ss`.\nKnown issue: The mask drops the high bit; unsigned 32-bit truncation must keep all 32 bits.\n\n```scheme\n(define (u32 n)\n  (bitwise-and n #x7FFFFFFF))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `u32` in `lattice/random/prng.ss`.\nKnown issue: The mask drops the high bit; unsigned 32-bit truncation must keep all 32 bits.\n\n```scheme\n(define (u32 n)\n  (bitwise-and n #x7FFFFFFF))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: The mask drops the high bit; unsigned 32-bit truncation must keep all 32 bits.\n\nExpected behavior after patch:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (= (u32 #xFFFFFFFF) #xFFFFFFFF))\n(let () (= (u32 #x100000000) 0))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (u32 n)\n  (bitwise-and n mask-32))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (and\n  (= (u32 #xFFFFFFFF) #xFFFFFFFF)\n  (= (u32 #x100000000) 0)\n  (= (u32 -1) #xFFFFFFFF)\n  (= (u32 0) 0)))", "tags": ["tier1", "random", "prng", "bugfix", "u32"], "split": "eval"}
{"id": "random_prng_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-pcg` in `lattice/random/prng.ss`.\nKnown issue: PCG increment must be odd; dropping the low-bit OR can create invalid streams.\n\n```scheme\n(define (make-pcg seed stream)\n  (let* ([inc (u64 (ash stream 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-pcg` in `lattice/random/prng.ss`.\nKnown issue: PCG increment must be odd; dropping the low-bit OR can create invalid streams.\n\n```scheme\n(define (make-pcg seed stream)\n  (let* ([inc (u64 (ash stream 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([p1 (make-pcg 42 7)] [p2 (make-pcg 42 7)] [p3 (make-pcg 42 8)]) (and (equal? p1 p2) (not (equal? p1 p3)) (eq? (car p1) 'pcg) (odd? (pcg-inc p1)) (< (pcg-state p1) (expt 2 64)) (< (pcg-inc p1) (expt 2 64)))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (let* ([p1 (make-pcg 42 7)]\n       [p2 (make-pcg 42 7)]\n       [p3 (make-pcg 42 8)])\n  (and (equal? p1 p2)\n       (not (equal? p1 p3))\n       (eq? (car p1) 'pcg)\n       (odd? (pcg-inc p1))\n       (< (pcg-state p1) (expt 2 64))\n       (< (pcg-inc p1) (expt 2 64)))))", "tags": ["tier1", "random", "prng", "bugfix", "make-pcg"], "split": "eval"}
{"id": "random_prng_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `xorshift128-next` in `lattice/random/prng.ss`.\nKnown issue: The second state word must be rotated by 37 bits each step.\n\n```scheme\n(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))])\n    (cons result (list 'xorshift128 new-s0 s1-new))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `xorshift128-next` in `lattice/random/prng.ss`.\nKnown issue: The second state word must be rotated by 37 bits each step.\n\n```scheme\n(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))])\n    (cons result (list 'xorshift128 new-s0 s1-new))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let () (let* ([xs (make-xorshift128 42)] [r1 (xorshift128-next xs)] [v1 (car r1)] [xs1 (cdr r1)] [r1b (xorshift128-next xs)]) (and (= v1 (car r1b)) (equal? xs1 (cdr r1b)) (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs)))) (<= 0 v1) (< v1 (expt 2 64)) (eq? (car xs1) 'xorshift128))))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (let* ([xs (make-xorshift128 42)]\n       [r1 (xorshift128-next xs)]\n       [v1 (car r1)]\n       [xs1 (cdr r1)]\n       [r1b (xorshift128-next xs)])\n  (and (= v1 (car r1b))\n       (equal? xs1 (cdr r1b))\n       (= v1 (u64 (+ (xorshift128-s0 xs) (xorshift128-s1 xs))))\n       (<= 0 v1)\n       (< v1 (expt 2 64))\n       (eq? (car xs1) 'xorshift128))))", "tags": ["tier1", "random", "prng", "bugfix", "xorshift128-next"], "split": "eval"}
{"id": "random_prng_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "u32", "prompt_body": "Truncate `#x100000001` to unsigned 32-bit.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nTruncate `#x100000001` to unsigned 32-bit.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(u32 #x100000001)", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (u32 #x100000001) 1))", "tags": ["tier1", "random", "prng", "composition", "u32", "direct"], "split": "eval"}
{"id": "random_prng_composition_009", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "rotl32", "prompt_body": "Rotate `#x12345678` left by 8 bits.", "prompt": "Task mode: compose existing APIs into one expression.\n\nRotate `#x12345678` left by 8 bits.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(rotl32 #x12345678 8)", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (rotl32 #x12345678 8) #x34567812))", "tags": ["tier1", "random", "prng", "composition", "rotl32", "direct"], "split": "eval"}
{"id": "random_prng_composition_017", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "make-pcg", "prompt_body": "Create `(make-pcg 42 7)` and return its increment field.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCreate `(make-pcg 42 7)` and return its increment field.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(pcg-inc (make-pcg 42 7))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (modulo (pcg-inc (make-pcg 42 7)) 2) 1))", "tags": ["tier1", "random", "prng", "composition", "make-pcg", "direct"], "split": "eval"}
{"id": "random_prng_composition_024", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "pcg-next", "prompt_body": "Run two PCG steps and return #t iff increment stays unchanged.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nRun two PCG steps and return #t iff increment stays unchanged.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p0 (make-pcg 77 3)] [p1 (cdr (pcg-next p0))] [p2 (cdr (pcg-next p1))]) (= (pcg-inc p0) (pcg-inc p2)))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (let* ([p0 (make-pcg 77 3)] [p1 (cdr (pcg-next p0))] [p2 (cdr (pcg-next p1))]) (= (pcg-inc p0) (pcg-inc p2))) #t))", "tags": ["tier1", "random", "prng", "composition", "pcg-next", "invariant"], "split": "eval"}
{"id": "random_prng_composition_032", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/random/prng.ss", "source_test": "lattice/random/test-prng.ss", "source_function": "xorshift128-next", "prompt_body": "Run one step and check that the returned state tag remains `xorshift128`.", "prompt": "Task mode: small integration task across module primitives.\n\nRun one step and check that the returned state tag remains `xorshift128`.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(car (cdr (xorshift128-next (make-xorshift128 5))))", "verify_expr": "(let ()\n  (define mask-32 (- (expt 2 32) 1))\n  (define mask-64 (- (expt 2 64) 1))\n  (define (make-splitmix seed)\n  (list 'splitmix (u64 seed)))\n  (define (splitmix-state sm)\n  (cadr sm))\n  (define (rotr32 x k)\n  (rotl32 x (- 32 k)))\n  (define (pcg-state p)\n  (cadr p))\n  (define (pcg-inc p)\n  (caddr p))\n  (define (rotl64 x k)\n  (let ([x (u64 x)]\n        [k (modulo k 64)])\n    (u64 (bitwise-ior (ash x k)\n                      (ash x (- k 64))))))\n  (define (xorshift128-s0 xs)\n  (cadr xs))\n  (define (xorshift128-s1 xs)\n  (caddr xs))\n  (define (u32 n)\n  (bitwise-and n mask-32))\n  (define (u64 n)\n  (bitwise-and n mask-64))\n  (define (rotl32 x k)\n  (let ([x (u32 x)]\n        [k (modulo k 32)])\n    (u32 (bitwise-ior (ash x k)\n                      (ash x (- k 32))))))\n  (define (splitmix-next sm)\n  (let* ([s (u64 (+ (splitmix-state sm) #x9e3779b97f4a7c15))]\n         [z (u64 (* (bitwise-xor s (ash s -30))\n                    #xbf58476d1ce4e5b9))]\n         [z (u64 (* (bitwise-xor z (ash z -27))\n                    #x94d049bb133111eb))]\n         [z (bitwise-xor z (ash z -31))])\n    (cons z (make-splitmix s))))\n  (define (make-pcg seed stream)\n  (let* ([inc (u64 (bitwise-ior (ash stream 1) 1))]\n         [state0 0]\n         [state1 (u64 (+ (* state0 #x5851f42d4c957f2d) inc))]\n         [state2 (u64 (+ state1 (u64 seed)))]\n         [state3 (u64 (+ (* state2 #x5851f42d4c957f2d) inc))])\n    (list 'pcg state3 inc)))\n  (define (pcg-next p)\n  (let* ([state (pcg-state p)]\n         [inc (pcg-inc p)]\n         [xorshifted (u32 (ash\n                           (bitwise-xor (ash state -18) state)\n                           -27))]\n         [rot (ash state -59)]\n         [output (rotr32 xorshifted rot)]\n         [new-state (u64 (+ (* state #x5851f42d4c957f2d) inc))])\n    (cons output (list 'pcg new-state inc))))\n  (define (make-xorshift128 seed)\n  (let* ([sm0 (make-splitmix seed)]\n         [r1 (splitmix-next sm0)]\n         [s0 (car r1)]\n         [sm1 (cdr r1)]\n         [r2 (splitmix-next sm1)]\n         [s1 (car r2)])\n    (list 'xorshift128\n          (if (= s0 0) 1 s0)\n          (if (= s1 0) 1 s1))))\n  (define (xorshift128-next xs)\n  (let* ([s0 (xorshift128-s0 xs)]\n         [s1 (xorshift128-s1 xs)]\n         [result (u64 (+ s0 s1))]\n         [s1-new (bitwise-xor s0 s1)]\n         [new-s0 (u64 (bitwise-xor\n                       (bitwise-xor (rotl64 s0 24) s1-new)\n                       (ash s1-new 16)))]\n         [new-s1 (rotl64 s1-new 37)])\n    (cons result (list 'xorshift128 new-s0 new-s1))))\n  (equal? (car (cdr (xorshift128-next (make-xorshift128 5)))) 'xorshift128))", "tags": ["tier1", "random", "prng", "composition", "xorshift128-next", "state-shape"], "split": "eval"}
