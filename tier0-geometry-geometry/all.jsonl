{"id": "geometry_spec_to_code_001", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point3`\nSignature: `point3`\nDescription: Point3 is just a Vec3\n\nWrite exactly one definition for `point3`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point3`\nSignature: `point3`\nDescription: Point3 is just a Vec3\n\nWrite exactly one definition for `point3`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define point3 vec3)", "verify_expr": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "tags": ["tier0", "geometry", "spec-to-code", "point3"], "split": "train"}
{"id": "geometry_spec_to_code_002", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define point3\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point3`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define point3\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point3`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define point3 vec3)", "verify_expr": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "tags": ["tier0", "geometry", "skeleton-completion", "point3"], "split": "train"}
{"id": "geometry_spec_to_code_003", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point3`\nSignature: `point3`\n\nReturn only executable Scheme code for `point3` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point3`\nSignature: `point3`\n\nReturn only executable Scheme code for `point3` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (vec3-x p) 1)\n(= (vec3-y p) 2)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define point3 vec3)", "verify_expr": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "tags": ["tier0", "geometry", "doc-free", "point3"], "split": "train"}
{"id": "geometry_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\nDescription: Infinite line through origin in direction\n\nWrite exactly one definition for `line3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\nDescription: Infinite line through origin in direction\n\nWrite exactly one definition for `line3`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "spec-to-code", "line3"], "split": "eval"}
{"id": "geometry_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (line3 origin direction)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (line3 origin direction)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "skeleton-completion", "line3"], "split": "train"}
{"id": "geometry_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\n\nReturn only executable Scheme code for `line3` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\n\nReturn only executable Scheme code for `line3` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3 origin direction)\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "doc-free", "line3"], "split": "train"}
{"id": "geometry_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3?`\nSignature: `(line3? l)`\nDescription: Return #t iff l is a line3\n\nWrite exactly one definition for `line3?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3?`\nSignature: `(line3? l)`\nDescription: Return #t iff l is a line3\n\nWrite exactly one definition for `line3?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(line3? (line3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (line3? '(not-a-line)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3? l)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "spec-to-code", "line3?"], "split": "eval"}
{"id": "geometry_spec_to_code_008", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (line3? l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (line3? l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3?`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(line3? (line3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (line3? '(not-a-line)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3? l)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "skeleton-completion", "line3?"], "split": "train"}
{"id": "geometry_spec_to_code_009", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3?`\nSignature: `(line3? l)`\n\nReturn only executable Scheme code for `line3?` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3?`\nSignature: `(line3? l)`\n\nReturn only executable Scheme code for `line3?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(line3? (line3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (line3? '(not-a-line)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3? l)\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "doc-free", "line3?"], "split": "train"}
{"id": "geometry_spec_to_code_010", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-origin`\nSignature: `(line3-origin l)`\nDescription: Get origin of line3\n\nWrite exactly one definition for `line3-origin`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-origin`\nSignature: `(line3-origin l)`\nDescription: Get origin of line3\n\nWrite exactly one definition for `line3-origin`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (line3-origin l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (cadr l))", "verify_expr": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "spec-to-code", "line3-origin"], "split": "train"}
{"id": "geometry_spec_to_code_011", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (line3-origin l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3-origin`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (line3-origin l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3-origin`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3-origin l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (cadr l))", "verify_expr": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "skeleton-completion", "line3-origin"], "split": "train"}
{"id": "geometry_spec_to_code_012", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-origin`\nSignature: `(line3-origin l)`\n\nReturn only executable Scheme code for `line3-origin` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-origin`\nSignature: `(line3-origin l)`\n\nReturn only executable Scheme code for `line3-origin` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (line3-origin l)\n  (cadr l))", "verify_expr": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "doc-free", "line3-origin"], "split": "train"}
{"id": "geometry_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\nDescription: Get direction of line3\n\nWrite exactly one definition for `line3-direction`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\nDescription: Get direction of line3\n\nWrite exactly one definition for `line3-direction`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "spec-to-code", "line3-direction"], "split": "eval"}
{"id": "geometry_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (line3-direction l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3-direction`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (line3-direction l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3-direction`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "skeleton-completion", "line3-direction"], "split": "train"}
{"id": "geometry_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\n\nReturn only executable Scheme code for `line3-direction` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\n\nReturn only executable Scheme code for `line3-direction` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3-direction l)\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "doc-free", "line3-direction"], "split": "train"}
{"id": "geometry_spec_to_code_016", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3`\nSignature: `(ray3 origin direction)`\nDescription: Half-infinite ray starting at origin going in direction\n\nWrite exactly one definition for `ray3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3`\nSignature: `(ray3 origin direction)`\nDescription: Half-infinite ray starting at origin going in direction\n\nWrite exactly one definition for `ray3`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(ray3? r)\n(equal? (ray3-origin r) o)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ray3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Ray3))\n  (doc 'description \"Half-infinite ray starting at origin going in direction\")\n  (list 'ray3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "tags": ["tier0", "geometry", "spec-to-code", "ray3"], "split": "train"}
{"id": "geometry_spec_to_code_017", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3 origin direction)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3 origin direction)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Ray3))\n  (doc 'description \"Half-infinite ray starting at origin going in direction\")\n  (list 'ray3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "tags": ["tier0", "geometry", "skeleton-completion", "ray3"], "split": "train"}
{"id": "geometry_spec_to_code_018", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3`\nSignature: `(ray3 origin direction)`\n\nReturn only executable Scheme code for `ray3` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3`\nSignature: `(ray3 origin direction)`\n\nReturn only executable Scheme code for `ray3` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ray3 origin direction)\n  (list 'ray3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "tags": ["tier0", "geometry", "doc-free", "ray3"], "split": "train"}
{"id": "geometry_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\nDescription: Return #t iff r is a ray3\n\nWrite exactly one definition for `ray3?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\nDescription: Return #t iff r is a ray3\n\nWrite exactly one definition for `ray3?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "spec-to-code", "ray3?"], "split": "eval"}
{"id": "geometry_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3? r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3? r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3?`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "skeleton-completion", "ray3?"], "split": "train"}
{"id": "geometry_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\n\nReturn only executable Scheme code for `ray3?` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\n\nReturn only executable Scheme code for `ray3?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "doc-free", "ray3?"], "split": "train"}
{"id": "geometry_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-origin`\nSignature: `(ray3-origin r)`\nDescription: Get origin of ray3\n\nWrite exactly one definition for `ray3-origin`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-origin`\nSignature: `(ray3-origin r)`\nDescription: Get origin of ray3\n\nWrite exactly one definition for `ray3-origin`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ray3-origin r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "ray3-origin"], "split": "eval"}
{"id": "geometry_spec_to_code_023", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3-origin r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3-origin`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3-origin r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3-origin`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ray3-origin r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "skeleton-completion", "ray3-origin"], "split": "train"}
{"id": "geometry_spec_to_code_024", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-origin`\nSignature: `(ray3-origin r)`\n\nReturn only executable Scheme code for `ray3-origin` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-origin`\nSignature: `(ray3-origin r)`\n\nReturn only executable Scheme code for `ray3-origin` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ray3-origin r)\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "doc-free", "ray3-origin"], "split": "train"}
{"id": "geometry_spec_to_code_025", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-direction`\nSignature: `(ray3-direction r)`\nDescription: Get direction of ray3\n\nWrite exactly one definition for `ray3-direction`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-direction`\nSignature: `(ray3-direction r)`\nDescription: Get direction of ray3\n\nWrite exactly one definition for `ray3-direction`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ray3-direction r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (caddr r))", "verify_expr": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "tags": ["tier0", "geometry", "spec-to-code", "ray3-direction"], "split": "train"}
{"id": "geometry_spec_to_code_026", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3-direction r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3-direction`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3-direction r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3-direction`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ray3-direction r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (caddr r))", "verify_expr": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "tags": ["tier0", "geometry", "skeleton-completion", "ray3-direction"], "split": "train"}
{"id": "geometry_spec_to_code_027", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-direction`\nSignature: `(ray3-direction r)`\n\nReturn only executable Scheme code for `ray3-direction` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-direction`\nSignature: `(ray3-direction r)`\n\nReturn only executable Scheme code for `ray3-direction` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3-direction r)\n  (caddr r))", "verify_expr": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "tags": ["tier0", "geometry", "doc-free", "ray3-direction"], "split": "train"}
{"id": "geometry_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-point-at`\nSignature: `(ray3-point-at ray t)`\nDescription: Get point at parameter t along ray (t >= 0)\n\nWrite exactly one definition for `ray3-point-at`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-point-at`\nSignature: `(ray3-point-at ray t)`\nDescription: Get point at parameter t along ray (t >= 0)\n\nWrite exactly one definition for `ray3-point-at`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3-point-at ray t)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Number Point3))\n  (doc 'description \"Get point at parameter t along ray (t >= 0)\")\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "ray3-point-at"], "split": "eval"}
{"id": "geometry_spec_to_code_029", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3-point-at ray t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3-point-at`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3-point-at ray t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3-point-at`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ray3-point-at ray t)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Number Point3))\n  (doc 'description \"Get point at parameter t along ray (t >= 0)\")\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "ray3-point-at"], "split": "train"}
{"id": "geometry_spec_to_code_030", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-point-at`\nSignature: `(ray3-point-at ray t)`\n\nReturn only executable Scheme code for `ray3-point-at` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-point-at`\nSignature: `(ray3-point-at ray t)`\n\nReturn only executable Scheme code for `ray3-point-at` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (ray3-point-at ray t)\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "ray3-point-at"], "split": "train"}
{"id": "geometry_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3`\nSignature: `(plane3 normal d)`\nDescription: Plane defined by normal·p + d = 0\n\nWrite exactly one definition for `plane3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3`\nSignature: `(plane3 normal d)`\nDescription: Plane defined by normal·p + d = 0\n\nWrite exactly one definition for `plane3`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3 normal d)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Plane3))\n  (doc 'description \"Plane defined by normal·p + d = 0\")\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "spec-to-code", "plane3"], "split": "eval"}
{"id": "geometry_spec_to_code_032", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3 normal d)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3 normal d)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(plane3? pl)\n(equal? (plane3-normal pl) n)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3 normal d)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Plane3))\n  (doc 'description \"Plane defined by normal·p + d = 0\")\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "skeleton-completion", "plane3"], "split": "train"}
{"id": "geometry_spec_to_code_033", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3`\nSignature: `(plane3 normal d)`\n\nReturn only executable Scheme code for `plane3` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3`\nSignature: `(plane3 normal d)`\n\nReturn only executable Scheme code for `plane3` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(plane3? pl)\n(equal? (plane3-normal pl) n)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3 normal d)\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "doc-free", "plane3"], "split": "train"}
{"id": "geometry_spec_to_code_034", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3?`\nSignature: `(plane3? p)`\nDescription: Return #t iff p is a plane3\n\nWrite exactly one definition for `plane3?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3?`\nSignature: `(plane3? p)`\nDescription: Return #t iff p is a plane3\n\nWrite exactly one definition for `plane3?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(plane3? (plane3 (vec3 0 1 0) 0))\n(not (plane3? '(not-a-plane)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3? p)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? p) (eq? (car p) 'plane3)))", "verify_expr": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "tags": ["tier0", "geometry", "spec-to-code", "plane3?"], "split": "train"}
{"id": "geometry_spec_to_code_035", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3? p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3? p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(plane3? (plane3 (vec3 0 1 0) 0))\n(not (plane3? '(not-a-plane)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3? p)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? p) (eq? (car p) 'plane3)))", "verify_expr": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "tags": ["tier0", "geometry", "skeleton-completion", "plane3?"], "split": "train"}
{"id": "geometry_spec_to_code_036", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3?`\nSignature: `(plane3? p)`\n\nReturn only executable Scheme code for `plane3?` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3?`\nSignature: `(plane3? p)`\n\nReturn only executable Scheme code for `plane3?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(plane3? (plane3 (vec3 0 1 0) 0))\n(not (plane3? '(not-a-plane)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3? p)\n  (and (pair? p) (eq? (car p) 'plane3)))", "verify_expr": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "tags": ["tier0", "geometry", "doc-free", "plane3?"], "split": "train"}
{"id": "geometry_spec_to_code_037", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-normal`\nSignature: `(plane3-normal p)`\nDescription: Get normal of plane3\n\nWrite exactly one definition for `plane3-normal`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-normal`\nSignature: `(plane3-normal p)`\nDescription: Get normal of plane3\n\nWrite exactly one definition for `plane3-normal`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3-normal p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Vec3))\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "spec-to-code", "plane3-normal"], "split": "eval"}
{"id": "geometry_spec_to_code_038", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-normal p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-normal`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-normal p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-normal`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3-normal p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Vec3))\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "skeleton-completion", "plane3-normal"], "split": "train"}
{"id": "geometry_spec_to_code_039", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-normal`\nSignature: `(plane3-normal p)`\n\nReturn only executable Scheme code for `plane3-normal` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-normal`\nSignature: `(plane3-normal p)`\n\nReturn only executable Scheme code for `plane3-normal` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3-normal p)\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "doc-free", "plane3-normal"], "split": "train"}
{"id": "geometry_spec_to_code_040", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-d`\nSignature: `(plane3-d p)`\nDescription: Get d coefficient of plane3\n\nWrite exactly one definition for `plane3-d`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-d`\nSignature: `(plane3-d p)`\nDescription: Get d coefficient of plane3\n\nWrite exactly one definition for `plane3-d`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3-d p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Number))\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "spec-to-code", "plane3-d"], "split": "eval"}
{"id": "geometry_spec_to_code_041", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-d p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-d`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-d p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-d`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3-d p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Number))\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "skeleton-completion", "plane3-d"], "split": "train"}
{"id": "geometry_spec_to_code_042", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-d`\nSignature: `(plane3-d p)`\n\nReturn only executable Scheme code for `plane3-d` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-d`\nSignature: `(plane3-d p)`\n\nReturn only executable Scheme code for `plane3-d` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3-d p)\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "doc-free", "plane3-d"], "split": "train"}
{"id": "geometry_spec_to_code_043", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-point-normal`\nSignature: `(plane3-from-point-normal point normal)`\nDescription: Create plane from point and normal\n\nWrite exactly one definition for `plane3-from-point-normal`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-point-normal`\nSignature: `(plane3-from-point-normal point normal)`\nDescription: Create plane from point and normal\n\nWrite exactly one definition for `plane3-from-point-normal`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(plane3? pl)\n(< (abs (- (plane3-d pl) -5)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Vec3 Plane3))\n  (doc 'description \"Create plane from point and normal\")\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_spec_to_code_044", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-from-point-normal point normal)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-from-point-normal`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-from-point-normal point normal)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-from-point-normal`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(plane3? pl)\n(< (abs (- (plane3-d pl) -5)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Vec3 Plane3))\n  (doc 'description \"Create plane from point and normal\")\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_spec_to_code_045", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-point-normal`\nSignature: `(plane3-from-point-normal point normal)`\n\nReturn only executable Scheme code for `plane3-from-point-normal` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-point-normal`\nSignature: `(plane3-from-point-normal point normal)`\n\nReturn only executable Scheme code for `plane3-from-point-normal` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_spec_to_code_046", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\nDescription: Create plane from three points (returns error if collinear)\n\nWrite exactly one definition for `plane3-from-points`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\nDescription: Create plane from three points (returns error if collinear)\n\nWrite exactly one definition for `plane3-from-points`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "plane3-from-points"], "split": "eval"}
{"id": "geometry_spec_to_code_047", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-from-points`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-from-points`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "plane3-from-points"], "split": "train"}
{"id": "geometry_spec_to_code_048", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\n\nReturn only executable Scheme code for `plane3-from-points` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\n\nReturn only executable Scheme code for `plane3-from-points` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "plane3-from-points"], "split": "train"}
{"id": "geometry_spec_to_code_049", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3`\nSignature: `(triangle3 p1 p2 p3)`\nDescription: Create triangle from three points\n\nWrite exactly one definition for `triangle3`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3`\nSignature: `(triangle3 p1 p2 p3)`\nDescription: Create triangle from three points\n\nWrite exactly one definition for `triangle3`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Vec3 Triangle3))\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3"], "split": "eval"}
{"id": "geometry_spec_to_code_050", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3 p1 p2 p3)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3 p1 p2 p3)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Vec3 Triangle3))\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle3"], "split": "train"}
{"id": "geometry_spec_to_code_051", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3`\nSignature: `(triangle3 p1 p2 p3)`\n\nReturn only executable Scheme code for `triangle3` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3`\nSignature: `(triangle3 p1 p2 p3)`\n\nReturn only executable Scheme code for `triangle3` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "doc-free", "triangle3"], "split": "train"}
{"id": "geometry_spec_to_code_052", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3?`\nSignature: `(triangle3? t)`\nDescription: Return #t iff t is a triangle3\n\nWrite exactly one definition for `triangle3?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3?`\nSignature: `(triangle3? t)`\nDescription: Return #t iff t is a triangle3\n\nWrite exactly one definition for `triangle3?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3? t)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? t) (eq? (car t) 'triangle3)))", "verify_expr": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3?"], "split": "train"}
{"id": "geometry_spec_to_code_053", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3? t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3? t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3?`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(triangle3?\n  (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0)))\n(not (triangle3? '(not-a-triangle)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3? t)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? t) (eq? (car t) 'triangle3)))", "verify_expr": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle3?"], "split": "train"}
{"id": "geometry_spec_to_code_054", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3?`\nSignature: `(triangle3? t)`\n\nReturn only executable Scheme code for `triangle3?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3?`\nSignature: `(triangle3? t)`\n\nReturn only executable Scheme code for `triangle3?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(triangle3?\n  (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0)))\n(not (triangle3? '(not-a-triangle)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle3? t)\n  (and (pair? t) (eq? (car t) 'triangle3)))", "verify_expr": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "tags": ["tier0", "geometry", "doc-free", "triangle3?"], "split": "train"}
{"id": "geometry_spec_to_code_055", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\nDescription: Get first vertex of triangle3\n\nWrite exactly one definition for `triangle3-p1`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\nDescription: Get first vertex of triangle3\n\nWrite exactly one definition for `triangle3-p1`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3-p1"], "split": "eval"}
{"id": "geometry_spec_to_code_056", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p1 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p1`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p1 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p1`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle3-p1"], "split": "train"}
{"id": "geometry_spec_to_code_057", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\n\nReturn only executable Scheme code for `triangle3-p1` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\n\nReturn only executable Scheme code for `triangle3-p1` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle3-p1 t)\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "doc-free", "triangle3-p1"], "split": "train"}
{"id": "geometry_spec_to_code_058", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p2`\nSignature: `(triangle3-p2 t)`\nDescription: Get second vertex of triangle3\n\nWrite exactly one definition for `triangle3-p2`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p2`\nSignature: `(triangle3-p2 t)`\nDescription: Get second vertex of triangle3\n\nWrite exactly one definition for `triangle3-p2`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p2 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3-p2"], "split": "eval"}
{"id": "geometry_spec_to_code_059", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p2 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p2`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p2 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p2`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p2 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle3-p2"], "split": "train"}
{"id": "geometry_spec_to_code_060", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p2`\nSignature: `(triangle3-p2 t)`\n\nReturn only executable Scheme code for `triangle3-p2` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p2`\nSignature: `(triangle3-p2 t)`\n\nReturn only executable Scheme code for `triangle3-p2` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle3-p2 t)\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "doc-free", "triangle3-p2"], "split": "train"}
{"id": "geometry_spec_to_code_061", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\nDescription: Get third vertex of triangle3\n\nWrite exactly one definition for `triangle3-p3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\nDescription: Get third vertex of triangle3\n\nWrite exactly one definition for `triangle3-p3`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3-p3"], "split": "train"}
{"id": "geometry_spec_to_code_062", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p3 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p3`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p3 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p3`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle3-p3"], "split": "train"}
{"id": "geometry_spec_to_code_063", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\n\nReturn only executable Scheme code for `triangle3-p3` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\n\nReturn only executable Scheme code for `triangle3-p3` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle3-p3 t)\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "doc-free", "triangle3-p3"], "split": "train"}
{"id": "geometry_spec_to_code_064", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle`\nSignature: `(circle center radius)`\nDescription: Create 2D circle\n\nWrite exactly one definition for `circle`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle`\nSignature: `(circle center radius)`\nDescription: Create 2D circle\n\nWrite exactly one definition for `circle`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(circle? ci)\n(equal? (circle-center ci) c)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec2 Number Circle))\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "spec-to-code", "circle"], "split": "eval"}
{"id": "geometry_spec_to_code_065", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (circle center radius)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (circle center radius)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(circle? ci)\n(equal? (circle-center ci) c)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (circle center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec2 Number Circle))\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "skeleton-completion", "circle"], "split": "train"}
{"id": "geometry_spec_to_code_066", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle`\nSignature: `(circle center radius)`\n\nReturn only executable Scheme code for `circle` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle`\nSignature: `(circle center radius)`\n\nReturn only executable Scheme code for `circle` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (circle center radius)\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "doc-free", "circle"], "split": "train"}
{"id": "geometry_spec_to_code_067", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle?`\nSignature: `(circle? c)`\nDescription: Return #t iff c is a circle\n\nWrite exactly one definition for `circle?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle?`\nSignature: `(circle? c)`\nDescription: Return #t iff c is a circle\n\nWrite exactly one definition for `circle?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(circle? (circle (vec3 0 0 0) 1))\n(not (circle? '(not-a-circle)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (circle? c)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "spec-to-code", "circle?"], "split": "eval"}
{"id": "geometry_spec_to_code_068", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (circle? c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (circle? c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle?`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (circle? c)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "skeleton-completion", "circle?"], "split": "train"}
{"id": "geometry_spec_to_code_069", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle?`\nSignature: `(circle? c)`\n\nReturn only executable Scheme code for `circle?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle?`\nSignature: `(circle? c)`\n\nReturn only executable Scheme code for `circle?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(circle? (circle (vec3 0 0 0) 1))\n(not (circle? '(not-a-circle)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle? c)\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "doc-free", "circle?"], "split": "train"}
{"id": "geometry_spec_to_code_070", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\nDescription: Get center of circle\n\nWrite exactly one definition for `circle-center`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\nDescription: Get center of circle\n\nWrite exactly one definition for `circle-center`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "spec-to-code", "circle-center"], "split": "train"}
{"id": "geometry_spec_to_code_071", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (circle-center c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle-center`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (circle-center c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle-center`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "skeleton-completion", "circle-center"], "split": "train"}
{"id": "geometry_spec_to_code_072", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\n\nReturn only executable Scheme code for `circle-center` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\n\nReturn only executable Scheme code for `circle-center` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle-center c)\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "doc-free", "circle-center"], "split": "train"}
{"id": "geometry_spec_to_code_073", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-radius`\nSignature: `(circle-radius c)`\nDescription: Get radius of circle\n\nWrite exactly one definition for `circle-radius`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-radius`\nSignature: `(circle-radius c)`\nDescription: Get radius of circle\n\nWrite exactly one definition for `circle-radius`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (circle-radius (circle (vec3 0 0 0) 7)) 7)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle-radius c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Number))\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "spec-to-code", "circle-radius"], "split": "eval"}
{"id": "geometry_spec_to_code_074", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (circle-radius c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle-radius`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (circle-radius c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle-radius`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (circle-radius (circle (vec3 0 0 0) 7)) 7)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle-radius c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Number))\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "skeleton-completion", "circle-radius"], "split": "train"}
{"id": "geometry_spec_to_code_075", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-radius`\nSignature: `(circle-radius c)`\n\nReturn only executable Scheme code for `circle-radius` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-radius`\nSignature: `(circle-radius c)`\n\nReturn only executable Scheme code for `circle-radius` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(= (circle-radius (circle (vec3 0 0 0) 7)) 7)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (circle-radius c)\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "doc-free", "circle-radius"], "split": "train"}
{"id": "geometry_spec_to_code_076", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere`\nSignature: `(sphere center radius)`\nDescription: Create sphere\n\nWrite exactly one definition for `sphere`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere`\nSignature: `(sphere center radius)`\nDescription: Create sphere\n\nWrite exactly one definition for `sphere`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(sphere? s)\n(equal? (sphere-center s) c)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Sphere))\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "spec-to-code", "sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_077", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere center radius)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere center radius)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(sphere? s)\n(equal? (sphere-center s) c)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Sphere))\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "skeleton-completion", "sphere"], "split": "train"}
{"id": "geometry_spec_to_code_078", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere`\nSignature: `(sphere center radius)`\n\nReturn only executable Scheme code for `sphere` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere`\nSignature: `(sphere center radius)`\n\nReturn only executable Scheme code for `sphere` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(sphere? s)\n(equal? (sphere-center s) c)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere center radius)\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "doc-free", "sphere"], "split": "train"}
{"id": "geometry_spec_to_code_079", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere?`\nSignature: `(sphere? s)`\nDescription: Return #t iff s is a sphere\n\nWrite exactly one definition for `sphere?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere?`\nSignature: `(sphere? s)`\nDescription: Return #t iff s is a sphere\n\nWrite exactly one definition for `sphere?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere? s)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? s) (eq? (car s) 'sphere)))", "verify_expr": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "tags": ["tier0", "geometry", "spec-to-code", "sphere?"], "split": "train"}
{"id": "geometry_spec_to_code_080", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere? s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere? s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(sphere? (sphere (vec3 0 0 0) 1))\n(not (sphere? '(not-a-sphere)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (sphere? s)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? s) (eq? (car s) 'sphere)))", "verify_expr": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "tags": ["tier0", "geometry", "skeleton-completion", "sphere?"], "split": "train"}
{"id": "geometry_spec_to_code_081", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere?`\nSignature: `(sphere? s)`\n\nReturn only executable Scheme code for `sphere?` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere?`\nSignature: `(sphere? s)`\n\nReturn only executable Scheme code for `sphere?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere? s)\n  (and (pair? s) (eq? (car s) 'sphere)))", "verify_expr": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "tags": ["tier0", "geometry", "doc-free", "sphere?"], "split": "train"}
{"id": "geometry_spec_to_code_082", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-center`\nSignature: `(sphere-center s)`\nDescription: Get center of sphere\n\nWrite exactly one definition for `sphere-center`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-center`\nSignature: `(sphere-center s)`\nDescription: Get center of sphere\n\nWrite exactly one definition for `sphere-center`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere-center s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Vec3))\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "sphere-center"], "split": "eval"}
{"id": "geometry_spec_to_code_083", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-center s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-center`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-center s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-center`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere-center s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Vec3))\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "skeleton-completion", "sphere-center"], "split": "train"}
{"id": "geometry_spec_to_code_084", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-center`\nSignature: `(sphere-center s)`\n\nReturn only executable Scheme code for `sphere-center` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-center`\nSignature: `(sphere-center s)`\n\nReturn only executable Scheme code for `sphere-center` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere-center s)\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "doc-free", "sphere-center"], "split": "train"}
{"id": "geometry_spec_to_code_085", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-radius`\nSignature: `(sphere-radius s)`\nDescription: Get radius of sphere\n\nWrite exactly one definition for `sphere-radius`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-radius`\nSignature: `(sphere-radius s)`\nDescription: Get radius of sphere\n\nWrite exactly one definition for `sphere-radius`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere-radius s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (caddr s))", "verify_expr": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "tags": ["tier0", "geometry", "spec-to-code", "sphere-radius"], "split": "train"}
{"id": "geometry_spec_to_code_086", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-radius s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-radius`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-radius s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-radius`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere-radius s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (caddr s))", "verify_expr": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "tags": ["tier0", "geometry", "skeleton-completion", "sphere-radius"], "split": "train"}
{"id": "geometry_spec_to_code_087", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-radius`\nSignature: `(sphere-radius s)`\n\nReturn only executable Scheme code for `sphere-radius` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-radius`\nSignature: `(sphere-radius s)`\n\nReturn only executable Scheme code for `sphere-radius` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere-radius s)\n  (caddr s))", "verify_expr": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "tags": ["tier0", "geometry", "doc-free", "sphere-radius"], "split": "train"}
{"id": "geometry_spec_to_code_088", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb`\nSignature: `(aabb min-point max-point)`\nDescription: Axis-Aligned Bounding Box from min/max corners\n\nWrite exactly one definition for `aabb`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb`\nSignature: `(aabb min-point max-point)`\nDescription: Axis-Aligned Bounding Box from min/max corners\n\nWrite exactly one definition for `aabb`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(aabb? b)\n(equal? (aabb-min b) mn)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb min-point max-point)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 AABB))\n  (doc 'description \"Axis-Aligned Bounding Box from min/max corners\")\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "spec-to-code", "aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_089", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb min-point max-point)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb min-point max-point)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb min-point max-point)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 AABB))\n  (doc 'description \"Axis-Aligned Bounding Box from min/max corners\")\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb"], "split": "train"}
{"id": "geometry_spec_to_code_090", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb`\nSignature: `(aabb min-point max-point)`\n\nReturn only executable Scheme code for `aabb` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb`\nSignature: `(aabb min-point max-point)`\n\nReturn only executable Scheme code for `aabb` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(aabb? b)\n(equal? (aabb-min b) mn)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb min-point max-point)\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "doc-free", "aabb"], "split": "train"}
{"id": "geometry_spec_to_code_091", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb?`\nSignature: `(aabb? b)`\nDescription: Return #t iff b is an aabb\n\nWrite exactly one definition for `aabb?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb?`\nSignature: `(aabb? b)`\nDescription: Return #t iff b is an aabb\n\nWrite exactly one definition for `aabb?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(aabb? (aabb (vec3 0 0 0) (vec3 1 1 1)))\n(not (aabb? '(not-an-aabb)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "spec-to-code", "aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_092", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb? b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb? b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb?`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(aabb? (aabb (vec3 0 0 0) (vec3 1 1 1)))\n(not (aabb? '(not-an-aabb)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb?"], "split": "train"}
{"id": "geometry_spec_to_code_093", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb?`\nSignature: `(aabb? b)`\n\nReturn only executable Scheme code for `aabb?` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb?`\nSignature: `(aabb? b)`\n\nReturn only executable Scheme code for `aabb?` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(aabb? (aabb (vec3 0 0 0) (vec3 1 1 1)))\n(not (aabb? '(not-an-aabb)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb? b)\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "doc-free", "aabb?"], "split": "train"}
{"id": "geometry_spec_to_code_094", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-min`\nSignature: `(aabb-min b)`\nDescription: Get min corner of aabb\n\nWrite exactly one definition for `aabb-min`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-min`\nSignature: `(aabb-min b)`\nDescription: Get min corner of aabb\n\nWrite exactly one definition for `aabb-min`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-min b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (cadr b))", "verify_expr": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-min"], "split": "train"}
{"id": "geometry_spec_to_code_095", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-min b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-min`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-min b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-min`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-min b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (cadr b))", "verify_expr": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-min"], "split": "train"}
{"id": "geometry_spec_to_code_096", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-min`\nSignature: `(aabb-min b)`\n\nReturn only executable Scheme code for `aabb-min` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-min`\nSignature: `(aabb-min b)`\n\nReturn only executable Scheme code for `aabb-min` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-min b)\n  (cadr b))", "verify_expr": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "tags": ["tier0", "geometry", "doc-free", "aabb-min"], "split": "train"}
{"id": "geometry_spec_to_code_097", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-max`\nSignature: `(aabb-max b)`\nDescription: Get max corner of aabb\n\nWrite exactly one definition for `aabb-max`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-max`\nSignature: `(aabb-max b)`\nDescription: Get max corner of aabb\n\nWrite exactly one definition for `aabb-max`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-max b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-max"], "split": "eval"}
{"id": "geometry_spec_to_code_098", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-max b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-max`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-max b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-max`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-max b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-max"], "split": "train"}
{"id": "geometry_spec_to_code_099", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-max`\nSignature: `(aabb-max b)`\n\nReturn only executable Scheme code for `aabb-max` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-max`\nSignature: `(aabb-max b)`\n\nReturn only executable Scheme code for `aabb-max` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-max b)\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "doc-free", "aabb-max"], "split": "train"}
{"id": "geometry_spec_to_code_100", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-center`\nSignature: `(aabb-center box)`\nDescription: Get center point of aabb\n\nWrite exactly one definition for `aabb-center`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-center`\nSignature: `(aabb-center box)`\nDescription: Get center point of aabb\n\nWrite exactly one definition for `aabb-center`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-center box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Point3))\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-center"], "split": "eval"}
{"id": "geometry_spec_to_code_101", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-center box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-center`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-center box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-center`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-center box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Point3))\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-center"], "split": "train"}
{"id": "geometry_spec_to_code_102", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-center`\nSignature: `(aabb-center box)`\n\nReturn only executable Scheme code for `aabb-center` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-center`\nSignature: `(aabb-center box)`\n\nReturn only executable Scheme code for `aabb-center` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb-center box)\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "aabb-center"], "split": "train"}
{"id": "geometry_spec_to_code_103", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-extents`\nSignature: `(aabb-extents box)`\nDescription: Get half-size in each dimension (extents)\n\nWrite exactly one definition for `aabb-extents`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-extents`\nSignature: `(aabb-extents box)`\nDescription: Get half-size in each dimension (extents)\n\nWrite exactly one definition for `aabb-extents`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-extents box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (doc 'description \"Half-size in each dimension\")\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-extents"], "split": "train"}
{"id": "geometry_spec_to_code_104", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-extents box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-extents`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-extents box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-extents`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb-extents box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (doc 'description \"Half-size in each dimension\")\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-extents"], "split": "train"}
{"id": "geometry_spec_to_code_105", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-extents`\nSignature: `(aabb-extents box)`\n\nReturn only executable Scheme code for `aabb-extents` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-extents`\nSignature: `(aabb-extents box)`\n\nReturn only executable Scheme code for `aabb-extents` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-extents box)\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "aabb-extents"], "split": "train"}
{"id": "geometry_spec_to_code_106", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb`\nSignature: `(obb center axes extents)`\nDescription: Oriented Bounding Box from center, axes, and extents\n\nWrite exactly one definition for `obb`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb`\nSignature: `(obb center axes extents)`\nDescription: Oriented Bounding Box from center, axes, and extents\n\nWrite exactly one definition for `obb`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb center axes extents)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Vec3) Vec3 OBB))\n  (doc 'description \"Oriented Bounding Box from center, axes, and extents\")\n  (doc 'param 'axes \"list of 3 orthonormal vectors\")\n  (doc 'param 'extents \"vec3 of half-sizes along each axis\")\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "spec-to-code", "obb"], "split": "eval"}
{"id": "geometry_spec_to_code_107", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (obb center axes extents)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (obb center axes extents)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb center axes extents)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Vec3) Vec3 OBB))\n  (doc 'description \"Oriented Bounding Box from center, axes, and extents\")\n  (doc 'param 'axes \"list of 3 orthonormal vectors\")\n  (doc 'param 'extents \"vec3 of half-sizes along each axis\")\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "skeleton-completion", "obb"], "split": "train"}
{"id": "geometry_spec_to_code_108", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb`\nSignature: `(obb center axes extents)`\n\nReturn only executable Scheme code for `obb` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb`\nSignature: `(obb center axes extents)`\n\nReturn only executable Scheme code for `obb` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb center axes extents)\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "doc-free", "obb"], "split": "train"}
{"id": "geometry_spec_to_code_109", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb?`\nSignature: `(obb? b)`\nDescription: Return #t iff b is an obb\n\nWrite exactly one definition for `obb?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb?`\nSignature: `(obb? b)`\nDescription: Return #t iff b is an obb\n\nWrite exactly one definition for `obb?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1)))\n(not (obb? '(not-an-obb)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "spec-to-code", "obb?"], "split": "eval"}
{"id": "geometry_spec_to_code_110", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (obb? b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (obb? b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb?`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1)))\n(not (obb? '(not-an-obb)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (obb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "skeleton-completion", "obb?"], "split": "train"}
{"id": "geometry_spec_to_code_111", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb?`\nSignature: `(obb? b)`\n\nReturn only executable Scheme code for `obb?` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb?`\nSignature: `(obb? b)`\n\nReturn only executable Scheme code for `obb?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb? b)\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "doc-free", "obb?"], "split": "train"}
{"id": "geometry_spec_to_code_112", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-center`\nSignature: `(obb-center b)`\nDescription: Get center of obb\n\nWrite exactly one definition for `obb-center`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-center`\nSignature: `(obb-center b)`\nDescription: Get center of obb\n\nWrite exactly one definition for `obb-center`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (obb-center b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadr b))", "verify_expr": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "spec-to-code", "obb-center"], "split": "train"}
{"id": "geometry_spec_to_code_113", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (obb-center b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb-center`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (obb-center b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb-center`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (obb-center b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadr b))", "verify_expr": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "skeleton-completion", "obb-center"], "split": "train"}
{"id": "geometry_spec_to_code_114", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-center`\nSignature: `(obb-center b)`\n\nReturn only executable Scheme code for `obb-center` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-center`\nSignature: `(obb-center b)`\n\nReturn only executable Scheme code for `obb-center` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (obb-center b)\n  (cadr b))", "verify_expr": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "doc-free", "obb-center"], "split": "train"}
{"id": "geometry_spec_to_code_115", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-axes`\nSignature: `(obb-axes b)`\nDescription: Get axes of obb\n\nWrite exactly one definition for `obb-axes`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-axes`\nSignature: `(obb-axes b)`\nDescription: Get axes of obb\n\nWrite exactly one definition for `obb-axes`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb-axes b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB (List Vec3)))\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "spec-to-code", "obb-axes"], "split": "eval"}
{"id": "geometry_spec_to_code_116", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (obb-axes b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb-axes`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (obb-axes b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb-axes`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (obb-axes b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB (List Vec3)))\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "skeleton-completion", "obb-axes"], "split": "train"}
{"id": "geometry_spec_to_code_117", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-axes`\nSignature: `(obb-axes b)`\n\nReturn only executable Scheme code for `obb-axes` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-axes`\nSignature: `(obb-axes b)`\n\nReturn only executable Scheme code for `obb-axes` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb-axes b)\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "doc-free", "obb-axes"], "split": "train"}
{"id": "geometry_spec_to_code_118", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-extents`\nSignature: `(obb-extents b)`\nDescription: Get extents of obb\n\nWrite exactly one definition for `obb-extents`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-extents`\nSignature: `(obb-extents b)`\nDescription: Get extents of obb\n\nWrite exactly one definition for `obb-extents`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (obb-extents b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "obb-extents"], "split": "eval"}
{"id": "geometry_spec_to_code_119", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (obb-extents b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb-extents`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (obb-extents b)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `obb-extents`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (obb-extents b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "skeleton-completion", "obb-extents"], "split": "train"}
{"id": "geometry_spec_to_code_120", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-extents`\nSignature: `(obb-extents b)`\n\nReturn only executable Scheme code for `obb-extents` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-extents`\nSignature: `(obb-extents b)`\n\nReturn only executable Scheme code for `obb-extents` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (obb-extents b)\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "doc-free", "obb-extents"], "split": "train"}
{"id": "geometry_spec_to_code_121", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-identity`\nSignature: `transform-identity`\nDescription: Return 4x4 identity transformation matrix\n\nWrite exactly one definition for `transform-identity`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-identity`\nSignature: `transform-identity`\nDescription: Return 4x4 identity transformation matrix\n\nWrite exactly one definition for `transform-identity`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-identity)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix))\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-identity"], "split": "train"}
{"id": "geometry_spec_to_code_122", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define transform-identity\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-identity`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define transform-identity\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-identity`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-identity)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix))\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-identity"], "split": "train"}
{"id": "geometry_spec_to_code_123", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-identity`\nSignature: `transform-identity`\n\nReturn only executable Scheme code for `transform-identity` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-identity`\nSignature: `transform-identity`\n\nReturn only executable Scheme code for `transform-identity` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (- (vec3-y r) 2)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-identity)\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-identity"], "split": "train"}
{"id": "geometry_spec_to_code_124", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\nDescription: Return 4x4 translation matrix\n\nWrite exactly one definition for `transform-translation`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\nDescription: Return 4x4 translation matrix\n\nWrite exactly one definition for `transform-translation`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-translation"], "split": "eval"}
{"id": "geometry_spec_to_code_125", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-translation v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-translation`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-translation v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-translation`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-translation"], "split": "train"}
{"id": "geometry_spec_to_code_126", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\n\nReturn only executable Scheme code for `transform-translation` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\n\nReturn only executable Scheme code for `transform-translation` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-translation v)\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-translation"], "split": "train"}
{"id": "geometry_spec_to_code_127", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\nDescription: Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\n\nWrite exactly one definition for `transform-scale`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\nDescription: Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\n\nWrite exactly one definition for `transform-scale`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-scale"], "split": "eval"}
{"id": "geometry_spec_to_code_128", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-scale s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-scale`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-scale s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-scale`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-scale"], "split": "train"}
{"id": "geometry_spec_to_code_129", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\n\nReturn only executable Scheme code for `transform-scale` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\n\nReturn only executable Scheme code for `transform-scale` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-scale s)\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-scale"], "split": "train"}
{"id": "geometry_spec_to_code_130", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-x`\nSignature: `(transform-rotation-x angle)`\nDescription: Return 4x4 rotation matrix around x-axis\n\nWrite exactly one definition for `transform-rotation-x`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-x`\nSignature: `(transform-rotation-x angle)`\nDescription: Return 4x4 rotation matrix around x-axis\n\nWrite exactly one definition for `transform-rotation-x`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-rotation-x angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (doc 'description \"Rotation around x-axis by angle (radians)\")\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-rotation-x"], "split": "train"}
{"id": "geometry_spec_to_code_131", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-x angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-x`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-x angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-x`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-rotation-x angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (doc 'description \"Rotation around x-axis by angle (radians)\")\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-rotation-x"], "split": "train"}
{"id": "geometry_spec_to_code_132", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-x`\nSignature: `(transform-rotation-x angle)`\n\nReturn only executable Scheme code for `transform-rotation-x` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-x`\nSignature: `(transform-rotation-x angle)`\n\nReturn only executable Scheme code for `transform-rotation-x` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-rotation-x angle)\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-rotation-x"], "split": "train"}
{"id": "geometry_spec_to_code_133", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-y`\nSignature: `(transform-rotation-y angle)`\nDescription: Return 4x4 rotation matrix around y-axis\n\nWrite exactly one definition for `transform-rotation-y`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-y`\nSignature: `(transform-rotation-y angle)`\nDescription: Return 4x4 rotation matrix around y-axis\n\nWrite exactly one definition for `transform-rotation-y`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-rotation-y angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-rotation-y"], "split": "eval"}
{"id": "geometry_spec_to_code_134", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-y angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-y`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-y angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-y`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-rotation-y angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-rotation-y"], "split": "train"}
{"id": "geometry_spec_to_code_135", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-y`\nSignature: `(transform-rotation-y angle)`\n\nReturn only executable Scheme code for `transform-rotation-y` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-y`\nSignature: `(transform-rotation-y angle)`\n\nReturn only executable Scheme code for `transform-rotation-y` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-rotation-y angle)\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-rotation-y"], "split": "train"}
{"id": "geometry_spec_to_code_136", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-z`\nSignature: `(transform-rotation-z angle)`\nDescription: Return 4x4 rotation matrix around z-axis\n\nWrite exactly one definition for `transform-rotation-z`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-z`\nSignature: `(transform-rotation-z angle)`\nDescription: Return 4x4 rotation matrix around z-axis\n\nWrite exactly one definition for `transform-rotation-z`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-rotation-z angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-rotation-z"], "split": "eval"}
{"id": "geometry_spec_to_code_137", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-z angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-z`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-z angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-z`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-rotation-z angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-rotation-z"], "split": "train"}
{"id": "geometry_spec_to_code_138", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-z`\nSignature: `(transform-rotation-z angle)`\n\nReturn only executable Scheme code for `transform-rotation-z` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-z`\nSignature: `(transform-rotation-z angle)`\n\nReturn only executable Scheme code for `transform-rotation-z` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-rotation-z angle)\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-rotation-z"], "split": "train"}
{"id": "geometry_spec_to_code_139", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-axis`\nSignature: `(transform-rotation-axis axis angle)`\nDescription: Return 4x4 rotation matrix around arbitrary axis (Rodriguez formula)\n\nWrite exactly one definition for `transform-rotation-axis`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-axis`\nSignature: `(transform-rotation-axis axis angle)`\nDescription: Return 4x4 rotation matrix around arbitrary axis (Rodriguez formula)\n\nWrite exactly one definition for `transform-rotation-axis`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Matrix))\n  (doc 'description \"Rotation around arbitrary axis by angle (Rodriguez formula)\")\n  (doc 'note \"Returns identity matrix if axis is zero vector\")\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_spec_to_code_140", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-axis axis angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-axis`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-rotation-axis axis angle)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-rotation-axis`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Matrix))\n  (doc 'description \"Rotation around arbitrary axis by angle (Rodriguez formula)\")\n  (doc 'note \"Returns identity matrix if axis is zero vector\")\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_spec_to_code_141", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-axis`\nSignature: `(transform-rotation-axis axis angle)`\n\nReturn only executable Scheme code for `transform-rotation-axis` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-axis`\nSignature: `(transform-rotation-axis axis angle)`\n\nReturn only executable Scheme code for `transform-rotation-axis` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_spec_to_code_142", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-from-quaternion`\nSignature: `(transform-from-quaternion q)`\nDescription: Convert quaternion to 4x4 transformation matrix\n\nWrite exactly one definition for `transform-from-quaternion`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-from-quaternion`\nSignature: `(transform-from-quaternion q)`\nDescription: Convert quaternion to 4x4 transformation matrix\n\nWrite exactly one definition for `transform-from-quaternion`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-from-quaternion q)\n  (doc 'export #t)\n  (doc 'type '(-> Quaternion Matrix))\n  (doc 'description \"Convert quaternion to 4x4 transformation matrix\")\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-from-quaternion"], "split": "eval"}
{"id": "geometry_spec_to_code_143", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-from-quaternion q)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-from-quaternion`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-from-quaternion q)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-from-quaternion`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-from-quaternion q)\n  (doc 'export #t)\n  (doc 'type '(-> Quaternion Matrix))\n  (doc 'description \"Convert quaternion to 4x4 transformation matrix\")\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-from-quaternion"], "split": "train"}
{"id": "geometry_spec_to_code_144", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-from-quaternion`\nSignature: `(transform-from-quaternion q)`\n\nReturn only executable Scheme code for `transform-from-quaternion` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-from-quaternion`\nSignature: `(transform-from-quaternion q)`\n\nReturn only executable Scheme code for `transform-from-quaternion` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-from-quaternion q)\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-from-quaternion"], "split": "train"}
{"id": "geometry_spec_to_code_145", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-point`\nSignature: `(transform-point mat p)`\nDescription: Apply transformation to point (with translation)\n\nWrite exactly one definition for `transform-point`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-point`\nSignature: `(transform-point mat p)`\nDescription: Apply transformation to point (with translation)\n\nWrite exactly one definition for `transform-point`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-point mat p)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Point3 Point3))\n  (doc 'description \"Apply transformation to point (with translation)\")\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-point"], "split": "train"}
{"id": "geometry_spec_to_code_146", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-point mat p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-point`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-point mat p)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-point`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 6)) 0.001)\n(< (abs (- (vec3-y r) 12)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-point mat p)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Point3 Point3))\n  (doc 'description \"Apply transformation to point (with translation)\")\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-point"], "split": "train"}
{"id": "geometry_spec_to_code_147", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-point`\nSignature: `(transform-point mat p)`\n\nReturn only executable Scheme code for `transform-point` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-point`\nSignature: `(transform-point mat p)`\n\nReturn only executable Scheme code for `transform-point` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-point mat p)\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-point"], "split": "train"}
{"id": "geometry_spec_to_code_148", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\nDescription: Apply transformation to vector (no translation)\n\nWrite exactly one definition for `transform-vector`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\nDescription: Apply transformation to vector (no translation)\n\nWrite exactly one definition for `transform-vector`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-vector"], "split": "eval"}
{"id": "geometry_spec_to_code_149", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-vector mat v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-vector`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-vector mat v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-vector`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-vector"], "split": "eval"}
{"id": "geometry_spec_to_code_150", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\n\nReturn only executable Scheme code for `transform-vector` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\n\nReturn only executable Scheme code for `transform-vector` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-vector mat v)\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-vector"], "split": "eval"}
{"id": "geometry_spec_to_code_151", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\nDescription: Return Euclidean distance between two points\n\nWrite exactly one definition for `distance-point-point`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\nDescription: Return Euclidean distance between two points\n\nWrite exactly one definition for `distance-point-point`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-point"], "split": "eval"}
{"id": "geometry_spec_to_code_152", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-point p1 p2)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-point`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-point p1 p2)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-point`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-point"], "split": "eval"}
{"id": "geometry_spec_to_code_153", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\n\nReturn only executable Scheme code for `distance-point-point` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\n\nReturn only executable Scheme code for `distance-point-point` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distance-point-point p1 p2)\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-point"], "split": "eval"}
{"id": "geometry_spec_to_code_154", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\nDescription: Return signed distance from point to plane (positive = in front)\n\nWrite exactly one definition for `distance-point-plane`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\nDescription: Return signed distance from point to plane (positive = in front)\n\nWrite exactly one definition for `distance-point-plane`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_155", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-plane`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-plane`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_156", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\n\nReturn only executable Scheme code for `distance-point-plane` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\n\nReturn only executable Scheme code for `distance-point-plane` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-plane point plane)\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_157", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\nDescription: Return distance from point to infinite line\n\nWrite exactly one definition for `distance-point-line`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\nDescription: Return distance from point to infinite line\n\nWrite exactly one definition for `distance-point-line`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-line"], "split": "eval"}
{"id": "geometry_spec_to_code_158", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-line point line)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-line`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-line point line)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-line`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-line"], "split": "eval"}
{"id": "geometry_spec_to_code_159", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\n\nReturn only executable Scheme code for `distance-point-line` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\n\nReturn only executable Scheme code for `distance-point-line` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-line"], "split": "eval"}
{"id": "geometry_spec_to_code_160", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\nDescription: Return signed distance from point to sphere (negative if inside)\n\nWrite exactly one definition for `distance-point-sphere`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\nDescription: Return signed distance from point to sphere (negative if inside)\n\nWrite exactly one definition for `distance-point-sphere`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_161", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-sphere`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-sphere`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_162", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\n\nReturn only executable Scheme code for `distance-point-sphere` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\n\nReturn only executable Scheme code for `distance-point-sphere` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_163", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\nDescription: Return t parameter where ray intersects plane, or #f\n\nWrite exactly one definition for `intersect-ray-plane`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\nDescription: Return t parameter where ray intersects plane, or #f\n\nWrite exactly one definition for `intersect-ray-plane`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_164", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-plane`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-plane`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_165", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\n\nReturn only executable Scheme code for `intersect-ray-plane` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\n\nReturn only executable Scheme code for `intersect-ray-plane` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_166", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\nDescription: Return (t1 t2) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-sphere`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\nDescription: Return (t1 t2) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-sphere`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\nres\n(list? res)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_167", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-sphere`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-sphere`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\nres\n(list? res)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_168", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\n\nReturn only executable Scheme code for `intersect-ray-sphere` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\n\nReturn only executable Scheme code for `intersect-ray-sphere` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_169", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\nDescription: Return (tmin tmax) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-aabb`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\nDescription: Return (tmin tmax) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-aabb`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\nres\n(list? res)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_170", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-aabb`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-aabb`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_171", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\n\nReturn only executable Scheme code for `intersect-ray-aabb` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\n\nReturn only executable Scheme code for `intersect-ray-aabb` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\nres\n(list? res)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_172", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\nDescription: Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\n\nWrite exactly one definition for `intersect-ray-triangle`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\nDescription: Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\n\nWrite exactly one definition for `intersect-ray-triangle`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_spec_to_code_173", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-triangle`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-triangle`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_spec_to_code_174", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\n\nReturn only executable Scheme code for `intersect-ray-triangle` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\n\nReturn only executable Scheme code for `intersect-ray-triangle` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_spec_to_code_175", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\nDescription: Return #t iff point is inside or on sphere\n\nWrite exactly one definition for `point-in-sphere?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\nDescription: Return #t iff point is inside or on sphere\n\nWrite exactly one definition for `point-in-sphere?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "spec-to-code", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_spec_to_code_176", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-sphere?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-sphere?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "skeleton-completion", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_spec_to_code_177", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\n\nReturn only executable Scheme code for `point-in-sphere?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\n\nReturn only executable Scheme code for `point-in-sphere?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "doc-free", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_spec_to_code_178", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\nDescription: Return #t iff point is inside or on aabb\n\nWrite exactly one definition for `point-in-aabb?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\nDescription: Return #t iff point is inside or on aabb\n\nWrite exactly one definition for `point-in-aabb?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "spec-to-code", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_179", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-aabb? point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-aabb?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-aabb? point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-aabb?`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "skeleton-completion", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_180", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\n\nReturn only executable Scheme code for `point-in-aabb?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\n\nReturn only executable Scheme code for `point-in-aabb?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-aabb? point box)\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "doc-free", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_181", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\nDescription: Return #t iff point is inside triangle (point must be coplanar)\n\nWrite exactly one definition for `point-in-triangle?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\nDescription: Return #t iff point is inside triangle (point must be coplanar)\n\nWrite exactly one definition for `point-in-triangle?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "spec-to-code", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_spec_to_code_182", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-triangle? point tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-triangle?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-triangle? point tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-triangle?`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "skeleton-completion", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_spec_to_code_183", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\n\nReturn only executable Scheme code for `point-in-triangle?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\n\nReturn only executable Scheme code for `point-in-triangle?` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "doc-free", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_spec_to_code_184", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-line`\nSignature: `(closest-point-on-line point line)`\nDescription: Return closest point on infinite line to given point\n\nWrite exactly one definition for `closest-point-on-line`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-line`\nSignature: `(closest-point-on-line point line)`\nDescription: Return closest point on infinite line to given point\n\nWrite exactly one definition for `closest-point-on-line`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (closest-point-on-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Point3))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "closest-point-on-line"], "split": "eval"}
{"id": "geometry_spec_to_code_185", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-line point line)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-line`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-line point line)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-line`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Point3))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "closest-point-on-line"], "split": "train"}
{"id": "geometry_spec_to_code_186", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-line`\nSignature: `(closest-point-on-line point line)`\n\nReturn only executable Scheme code for `closest-point-on-line` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-line`\nSignature: `(closest-point-on-line point line)`\n\nReturn only executable Scheme code for `closest-point-on-line` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (closest-point-on-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "closest-point-on-line"], "split": "train"}
{"id": "geometry_spec_to_code_187", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-plane`\nSignature: `(closest-point-on-plane point plane)`\nDescription: Return closest point on plane to given point\n\nWrite exactly one definition for `closest-point-on-plane`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-plane`\nSignature: `(closest-point-on-plane point plane)`\nDescription: Return closest point on plane to given point\n\nWrite exactly one definition for `closest-point-on-plane`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Point3))\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "closest-point-on-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_188", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-plane`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-plane`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Point3))\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "closest-point-on-plane"], "split": "train"}
{"id": "geometry_spec_to_code_189", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-plane`\nSignature: `(closest-point-on-plane point plane)`\n\nReturn only executable Scheme code for `closest-point-on-plane` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-plane`\nSignature: `(closest-point-on-plane point plane)`\n\nReturn only executable Scheme code for `closest-point-on-plane` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "closest-point-on-plane"], "split": "train"}
{"id": "geometry_spec_to_code_190", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\nDescription: Return closest point on aabb to given point\n\nWrite exactly one definition for `closest-point-on-aabb`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\nDescription: Return closest point on aabb to given point\n\nWrite exactly one definition for `closest-point-on-aabb`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "closest-point-on-aabb"], "split": "train"}
{"id": "geometry_spec_to_code_191", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-aabb`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-aabb`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "closest-point-on-aabb"], "split": "train"}
{"id": "geometry_spec_to_code_192", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\n\nReturn only executable Scheme code for `closest-point-on-aabb` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\n\nReturn only executable Scheme code for `closest-point-on-aabb` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "closest-point-on-aabb"], "split": "train"}
{"id": "geometry_spec_to_code_193", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-area`\nSignature: `(triangle-area tri)`\nDescription: Return area of triangle\n\nWrite exactly one definition for `triangle-area`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-area`\nSignature: `(triangle-area tri)`\nDescription: Return area of triangle\n\nWrite exactly one definition for `triangle-area`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle-area tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Number))\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 0.5 (vec3-length cross))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "triangle-area"], "split": "train"}
{"id": "geometry_spec_to_code_194", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle-area tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle-area`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle-area tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle-area`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle-area tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Number))\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 0.5 (vec3-length cross))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle-area"], "split": "train"}
{"id": "geometry_spec_to_code_195", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-area`\nSignature: `(triangle-area tri)`\n\nReturn only executable Scheme code for `triangle-area` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-area`\nSignature: `(triangle-area tri)`\n\nReturn only executable Scheme code for `triangle-area` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle-area tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 0.5 (vec3-length cross))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "triangle-area"], "split": "train"}
{"id": "geometry_spec_to_code_196", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-volume`\nSignature: `(sphere-volume sphere)`\nDescription: Return volume of sphere\n\nWrite exactly one definition for `sphere-volume`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-volume`\nSignature: `(sphere-volume sphere)`\nDescription: Return volume of sphere\n\nWrite exactly one definition for `sphere-volume`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere-volume sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "sphere-volume"], "split": "eval"}
{"id": "geometry_spec_to_code_197", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-volume sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-volume`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-volume sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-volume`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (sphere-volume sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "sphere-volume"], "split": "train"}
{"id": "geometry_spec_to_code_198", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-volume`\nSignature: `(sphere-volume sphere)`\n\nReturn only executable Scheme code for `sphere-volume` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-volume`\nSignature: `(sphere-volume sphere)`\n\nReturn only executable Scheme code for `sphere-volume` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere-volume sphere)\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "sphere-volume"], "split": "train"}
{"id": "geometry_spec_to_code_199", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-surface-area`\nSignature: `(sphere-surface-area sphere)`\nDescription: Return surface area of sphere\n\nWrite exactly one definition for `sphere-surface-area`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-surface-area`\nSignature: `(sphere-surface-area sphere)`\nDescription: Return surface area of sphere\n\nWrite exactly one definition for `sphere-surface-area`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (sphere-surface-area sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* 4.0 3.141592653589793 r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "sphere-surface-area"], "split": "train"}
{"id": "geometry_spec_to_code_200", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-surface-area sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-surface-area`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (sphere-surface-area sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `sphere-surface-area`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere-surface-area sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* 4.0 3.141592653589793 r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "sphere-surface-area"], "split": "train"}
{"id": "geometry_spec_to_code_201", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-surface-area`\nSignature: `(sphere-surface-area sphere)`\n\nReturn only executable Scheme code for `sphere-surface-area` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-surface-area`\nSignature: `(sphere-surface-area sphere)`\n\nReturn only executable Scheme code for `sphere-surface-area` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (sphere-surface-area sphere)\n  (let ([r (sphere-radius sphere)])\n       (* 4.0 3.141592653589793 r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "sphere-surface-area"], "split": "train"}
{"id": "geometry_spec_to_code_202", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\nDescription: Return volume of aabb\n\nWrite exactly one definition for `aabb-volume`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\nDescription: Return volume of aabb\n\nWrite exactly one definition for `aabb-volume`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-volume"], "split": "eval"}
{"id": "geometry_spec_to_code_203", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-volume box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-volume`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-volume box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-volume`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-volume"], "split": "train"}
{"id": "geometry_spec_to_code_204", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\n\nReturn only executable Scheme code for `aabb-volume` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\n\nReturn only executable Scheme code for `aabb-volume` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-volume box)\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "aabb-volume"], "split": "train"}
{"id": "geometry_spec_to_code_205", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `barycentric-coords`\nSignature: `(barycentric-coords p a b c)`\nDescription: Compute barycentric coordinates (u, v, w) of p w.r.t. triangle (a, b, c)\n\nWrite exactly one definition for `barycentric-coords`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `barycentric-coords`\nSignature: `(barycentric-coords p a b c)`\nDescription: Compute barycentric coordinates (u, v, w) of p w.r.t. triangle (a, b, c)\n\nWrite exactly one definition for `barycentric-coords`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (barycentric-coords p a b c)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 Point3 (List Number Number Number)))\n  (doc 'description \"Compute barycentric coordinates (u, v, w) of point p with respect to triangle (a, b, c)\")\n  (doc 'note \"p = u*a + v*b + w*c where u + v + w = 1\")\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "spec-to-code", "barycentric-coords"], "split": "eval"}
{"id": "geometry_spec_to_code_206", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (barycentric-coords p a b c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `barycentric-coords`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (barycentric-coords p a b c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `barycentric-coords`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (barycentric-coords p a b c)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 Point3 (List Number Number Number)))\n  (doc 'description \"Compute barycentric coordinates (u, v, w) of point p with respect to triangle (a, b, c)\")\n  (doc 'note \"p = u*a + v*b + w*c where u + v + w = 1\")\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "skeleton-completion", "barycentric-coords"], "split": "train"}
{"id": "geometry_spec_to_code_207", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `barycentric-coords`\nSignature: `(barycentric-coords p a b c)`\n\nReturn only executable Scheme code for `barycentric-coords` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `barycentric-coords`\nSignature: `(barycentric-coords p a b c)`\n\nReturn only executable Scheme code for `barycentric-coords` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (car bc) 1.0)) 0.01)\n(< (abs (cadr bc)) 0.01)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (barycentric-coords p a b c)\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "doc-free", "barycentric-coords"], "split": "train"}
{"id": "geometry_spec_to_code_208", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-normal`\nSignature: `(triangle-normal tri)`\nDescription: Compute face normal of triangle (counter-clockwise winding)\n\nWrite exactly one definition for `triangle-normal`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-normal`\nSignature: `(triangle-normal tri)`\nDescription: Compute face normal of triangle (counter-clockwise winding)\n\nWrite exactly one definition for `triangle-normal`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle-normal tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (doc 'description \"Compute face normal (counter-clockwise winding)\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)])\n        (vec3-normalize (vec3-cross edge1 edge2))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "triangle-normal"], "split": "train"}
{"id": "geometry_spec_to_code_209", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle-normal tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle-normal`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle-normal tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle-normal`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle-normal tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (doc 'description \"Compute face normal (counter-clockwise winding)\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)])\n        (vec3-normalize (vec3-cross edge1 edge2))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle-normal"], "split": "train"}
{"id": "geometry_spec_to_code_210", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-normal`\nSignature: `(triangle-normal tri)`\n\nReturn only executable Scheme code for `triangle-normal` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle-normal`\nSignature: `(triangle-normal tri)`\n\nReturn only executable Scheme code for `triangle-normal` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle-normal tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)])\n        (vec3-normalize (vec3-cross edge1 edge2))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "triangle-normal"], "split": "train"}
{"id": "geometry_spec_to_code_211", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-merge`\nSignature: `(aabb-merge b1 b2)`\nDescription: Compute minimal AABB containing both boxes\n\nWrite exactly one definition for `aabb-merge`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-merge`\nSignature: `(aabb-merge b1 b2)`\nDescription: Compute minimal AABB containing both boxes\n\nWrite exactly one definition for `aabb-merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x (aabb-min mg))) 0.001)\n(< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-merge b1 b2)\n  (doc 'export #t)\n  (doc 'type '(-> AABB AABB AABB))\n  (doc 'description \"Compute minimal AABB containing both boxes\")\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-merge"], "split": "eval"}
{"id": "geometry_spec_to_code_212", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-merge b1 b2)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-merge`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-merge b1 b2)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-merge`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x (aabb-min mg))) 0.001)\n(< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-merge b1 b2)\n  (doc 'export #t)\n  (doc 'type '(-> AABB AABB AABB))\n  (doc 'description \"Compute minimal AABB containing both boxes\")\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-merge"], "split": "train"}
{"id": "geometry_spec_to_code_213", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-merge`\nSignature: `(aabb-merge b1 b2)`\n\nReturn only executable Scheme code for `aabb-merge` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-merge`\nSignature: `(aabb-merge b1 b2)`\n\nReturn only executable Scheme code for `aabb-merge` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-merge b1 b2)\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "aabb-merge"], "split": "train"}
{"id": "geometry_spec_to_code_214", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-from-points`\nSignature: `(aabb-from-points points)`\nDescription: Compute minimal AABB containing all points\n\nWrite exactly one definition for `aabb-from-points`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-from-points`\nSignature: `(aabb-from-points points)`\nDescription: Compute minimal AABB containing all points\n\nWrite exactly one definition for `aabb-from-points`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x (aabb-min box)) -1)) 0.001)\n(< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-from-points points)\n  (doc 'export #t)\n  (doc 'type '(-> (List Point3) AABB))\n  (doc 'description \"Compute minimal AABB containing all points\")\n  (if (null? points)\n      (aabb (vec3-zero) (vec3-zero))\n      (let loop ([pts (cdr points)]\n                 [min-p (car points)]\n                 [max-p (car points)])\n           (if (null? pts)\n               (aabb min-p max-p)\n               (let ([p (car pts)])\n                    (loop (cdr pts)\n                          (vec3 (min (vec3-x min-p) (vec3-x p))\n                                (min (vec3-y min-p) (vec3-y p))\n                                (min (vec3-z min-p) (vec3-z p)))\n                          (vec3 (max (vec3-x max-p) (vec3-x p))\n                                (max (vec3-y max-p) (vec3-y p))\n                                (max (vec3-z max-p) (vec3-z p)))))))))", "verify_expr": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-from-points"], "split": "train"}
{"id": "geometry_spec_to_code_215", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-from-points points)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-from-points`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-from-points points)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-from-points`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x (aabb-min box)) -1)) 0.001)\n(< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb-from-points points)\n  (doc 'export #t)\n  (doc 'type '(-> (List Point3) AABB))\n  (doc 'description \"Compute minimal AABB containing all points\")\n  (if (null? points)\n      (aabb (vec3-zero) (vec3-zero))\n      (let loop ([pts (cdr points)]\n                 [min-p (car points)]\n                 [max-p (car points)])\n           (if (null? pts)\n               (aabb min-p max-p)\n               (let ([p (car pts)])\n                    (loop (cdr pts)\n                          (vec3 (min (vec3-x min-p) (vec3-x p))\n                                (min (vec3-y min-p) (vec3-y p))\n                                (min (vec3-z min-p) (vec3-z p)))\n                          (vec3 (max (vec3-x max-p) (vec3-x p))\n                                (max (vec3-y max-p) (vec3-y p))\n                                (max (vec3-z max-p) (vec3-z p)))))))))", "verify_expr": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-from-points"], "split": "train"}
{"id": "geometry_spec_to_code_216", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-from-points`\nSignature: `(aabb-from-points points)`\n\nReturn only executable Scheme code for `aabb-from-points` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-from-points`\nSignature: `(aabb-from-points points)`\n\nReturn only executable Scheme code for `aabb-from-points` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x (aabb-min box)) -1)) 0.001)\n(< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-from-points points)\n  (if (null? points)\n      (aabb (vec3-zero) (vec3-zero))\n      (let loop ([pts (cdr points)]\n                 [min-p (car points)]\n                 [max-p (car points)])\n           (if (null? pts)\n               (aabb min-p max-p)\n               (let ([p (car pts)])\n                    (loop (cdr pts)\n                          (vec3 (min (vec3-x min-p) (vec3-x p))\n                                (min (vec3-y min-p) (vec3-y p))\n                                (min (vec3-z min-p) (vec3-z p)))\n                          (vec3 (max (vec3-x max-p) (vec3-x p))\n                                (max (vec3-y max-p) (vec3-y p))\n                                (max (vec3-z max-p) (vec3-z p)))))))))", "verify_expr": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "aabb-from-points"], "split": "train"}
{"id": "geometry_spec_to_code_217", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-spherical`\nSignature: `(vec3-to-spherical v)`\nDescription: Convert Cartesian to spherical (r, θ, φ)\n\nWrite exactly one definition for `vec3-to-spherical`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-spherical`\nSignature: `(vec3-to-spherical v)`\nDescription: Convert Cartesian to spherical (r, θ, φ)\n\nWrite exactly one definition for `vec3-to-spherical`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec3-to-spherical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to spherical (r, θ, φ)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "vec3-to-spherical"], "split": "eval"}
{"id": "geometry_spec_to_code_218", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (vec3-to-spherical v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `vec3-to-spherical`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (vec3-to-spherical v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `vec3-to-spherical`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec3-to-spherical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to spherical (r, θ, φ)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "vec3-to-spherical"], "split": "train"}
{"id": "geometry_spec_to_code_219", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-spherical`\nSignature: `(vec3-to-spherical v)`\n\nReturn only executable Scheme code for `vec3-to-spherical` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-spherical`\nSignature: `(vec3-to-spherical v)`\n\nReturn only executable Scheme code for `vec3-to-spherical` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (car sph) 1.0)) 0.001)\n(< (abs (- (cadr sph) 1.5708)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec3-to-spherical v)\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "vec3-to-spherical"], "split": "train"}
{"id": "geometry_spec_to_code_220", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-cylindrical`\nSignature: `(vec3-to-cylindrical v)`\nDescription: Convert Cartesian to cylindrical (r, θ, z)\n\nWrite exactly one definition for `vec3-to-cylindrical`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-cylindrical`\nSignature: `(vec3-to-cylindrical v)`\nDescription: Convert Cartesian to cylindrical (r, θ, z)\n\nWrite exactly one definition for `vec3-to-cylindrical`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec3-to-cylindrical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to cylindrical (r, θ, z)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [theta (atan y x)])\n        (list r theta z)))", "verify_expr": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "vec3-to-cylindrical"], "split": "train"}
{"id": "geometry_spec_to_code_221", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (vec3-to-cylindrical v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `vec3-to-cylindrical`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (vec3-to-cylindrical v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `vec3-to-cylindrical`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (car cyl) 1.0)) 0.001)\n(< (abs (cadr cyl)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec3-to-cylindrical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to cylindrical (r, θ, z)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [theta (atan y x)])\n        (list r theta z)))", "verify_expr": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "vec3-to-cylindrical"], "split": "train"}
{"id": "geometry_spec_to_code_222", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-cylindrical`\nSignature: `(vec3-to-cylindrical v)`\n\nReturn only executable Scheme code for `vec3-to-cylindrical` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-cylindrical`\nSignature: `(vec3-to-cylindrical v)`\n\nReturn only executable Scheme code for `vec3-to-cylindrical` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (car cyl) 1.0)) 0.001)\n(< (abs (cadr cyl)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (vec3-to-cylindrical v)\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [theta (atan y x)])\n        (list r theta z)))", "verify_expr": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "vec3-to-cylindrical"], "split": "train"}
{"id": "geometry_translation_001", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point3`.\nReturn only the Scheme definition.\n\n```python\n# Point3 is just a Vec3\npoint3 = None\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point3`.\nReturn only the Scheme definition.\n\n```python\n# Point3 is just a Vec3\npoint3 = None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (vec3-x p) 1)\n(= (vec3-y p) 2)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define point3 vec3)", "verify_expr": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "tags": ["tier0", "geometry", "python-to-scheme", "point3"], "split": "train"}
{"id": "geometry_translation_002", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point3 vec3)\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point3 vec3)\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define point3 vec3)", "verify_expr": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "tags": ["tier0", "geometry", "chez-to-fold", "point3"], "split": "train"}
{"id": "geometry_translation_003", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point3 vec3)\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point3 vec3)\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (vec3-x p) 1)\n(= (vec3-y p) 2)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define point3 vec3)", "verify_expr": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point3"], "split": "train"}
{"id": "geometry_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3`.\nReturn only the Scheme definition.\n\n```python\ndef line3(origin, direction):\n    \"\"\"Infinite line through origin in direction\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3`.\nReturn only the Scheme definition.\n\n```python\ndef line3(origin, direction):\n    \"\"\"Infinite line through origin in direction\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "python-to-scheme", "line3"], "split": "train"}
{"id": "geometry_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3\n  (lambda (origin direction)\n    (list 'line3 origin direction)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3\n  (lambda (origin direction)\n    (list 'line3 origin direction)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "chez-to-fold", "line3"], "split": "train"}
{"id": "geometry_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3\n    (lambda (origin direction)\n      (list 'line3 origin direction)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3\n    (lambda (origin direction)\n      (list 'line3 origin direction)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (line3 origin direction)\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "line3"], "split": "train"}
{"id": "geometry_translation_007", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3?`.\nReturn only the Scheme definition.\n\n```python\ndef line3_p(l):\n    \"\"\"Return #t iff l is a line3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3?`.\nReturn only the Scheme definition.\n\n```python\ndef line3_p(l):\n    \"\"\"Return #t iff l is a line3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(line3? (line3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (line3? '(not-a-line)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (line3? l)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "python-to-scheme", "line3?"], "split": "train"}
{"id": "geometry_translation_008", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3?\n  (lambda (l)\n    (and (pair? l) (eq? (car l) 'line3))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3?\n  (lambda (l)\n    (and (pair? l) (eq? (car l) 'line3))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (line3? l)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "chez-to-fold", "line3?"], "split": "train"}
{"id": "geometry_translation_009", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3?\n    (lambda (l)\n      (and (pair? l) (eq? (car l) 'line3))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3?\n    (lambda (l)\n      (and (pair? l) (eq? (car l) 'line3))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (line3? l)\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "line3?"], "split": "train"}
{"id": "geometry_translation_010", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3-origin`.\nReturn only the Scheme definition.\n\n```python\ndef line3_origin(l):\n    \"\"\"Get origin of line3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3-origin`.\nReturn only the Scheme definition.\n\n```python\ndef line3_origin(l):\n    \"\"\"Get origin of line3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (line3-origin l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (cadr l))", "verify_expr": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "python-to-scheme", "line3-origin"], "split": "train"}
{"id": "geometry_translation_011", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3-origin`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3-origin\n  (lambda (l)\n    (cadr l)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3-origin`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3-origin\n  (lambda (l)\n    (cadr l)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (line3-origin l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (cadr l))", "verify_expr": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "chez-to-fold", "line3-origin"], "split": "train"}
{"id": "geometry_translation_012", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3-origin`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3-origin\n    (lambda (l)\n      (cadr l)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3-origin`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3-origin\n    (lambda (l)\n      (cadr l)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (line3-origin l)\n  (cadr l))", "verify_expr": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "line3-origin"], "split": "train"}
{"id": "geometry_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3-direction`.\nReturn only the Scheme definition.\n\n```python\ndef line3_direction(l):\n    \"\"\"Get direction of line3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3-direction`.\nReturn only the Scheme definition.\n\n```python\ndef line3_direction(l):\n    \"\"\"Get direction of line3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "python-to-scheme", "line3-direction"], "split": "train"}
{"id": "geometry_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3-direction`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3-direction\n  (lambda (l)\n    (caddr l)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3-direction`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3-direction\n  (lambda (l)\n    (caddr l)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "chez-to-fold", "line3-direction"], "split": "train"}
{"id": "geometry_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3-direction`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3-direction\n    (lambda (l)\n      (caddr l)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3-direction`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3-direction\n    (lambda (l)\n      (caddr l)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (line3-direction l)\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "line3-direction"], "split": "train"}
{"id": "geometry_translation_016", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3`.\nReturn only the Scheme definition.\n\n```python\ndef ray3(origin, direction):\n    \"\"\"Half-infinite ray starting at origin going in direction\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3`.\nReturn only the Scheme definition.\n\n```python\ndef ray3(origin, direction):\n    \"\"\"Half-infinite ray starting at origin going in direction\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(ray3? r)\n(equal? (ray3-origin r) o)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ray3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Ray3))\n  (doc 'description \"Half-infinite ray starting at origin going in direction\")\n  (list 'ray3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "tags": ["tier0", "geometry", "python-to-scheme", "ray3"], "split": "train"}
{"id": "geometry_translation_017", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3\n  (lambda (origin direction)\n    (list 'ray3 origin direction)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3\n  (lambda (origin direction)\n    (list 'ray3 origin direction)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(ray3? r)\n(equal? (ray3-origin r) o)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ray3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Ray3))\n  (doc 'description \"Half-infinite ray starting at origin going in direction\")\n  (list 'ray3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "tags": ["tier0", "geometry", "chez-to-fold", "ray3"], "split": "train"}
{"id": "geometry_translation_018", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3\n    (lambda (origin direction)\n      (list 'ray3 origin direction)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3\n    (lambda (origin direction)\n      (list 'ray3 origin direction)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ray3 origin direction)\n  (list 'ray3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "ray3"], "split": "train"}
{"id": "geometry_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3?`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_p(r):\n    \"\"\"Return #t iff r is a ray3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3?`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_p(r):\n    \"\"\"Return #t iff r is a ray3\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "python-to-scheme", "ray3?"], "split": "train"}
{"id": "geometry_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3?\n  (lambda (r)\n    (and (pair? r) (eq? (car r) 'ray3))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3?\n  (lambda (r)\n    (and (pair? r) (eq? (car r) 'ray3))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "chez-to-fold", "ray3?"], "split": "train"}
{"id": "geometry_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3?\n    (lambda (r)\n      (and (pair? r) (eq? (car r) 'ray3))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3?\n    (lambda (r)\n      (and (pair? r) (eq? (car r) 'ray3))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "ray3?"], "split": "train"}
{"id": "geometry_translation_022", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3-origin`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_origin(r):\n    \"\"\"Get origin of ray3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3-origin`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_origin(r):\n    \"\"\"Get origin of ray3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ray3-origin r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "python-to-scheme", "ray3-origin"], "split": "train"}
{"id": "geometry_translation_023", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3-origin`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3-origin\n  (lambda (r)\n    (cadr r)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3-origin`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3-origin\n  (lambda (r)\n    (cadr r)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ray3-origin r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "chez-to-fold", "ray3-origin"], "split": "train"}
{"id": "geometry_translation_024", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3-origin`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3-origin\n    (lambda (r)\n      (cadr r)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3-origin`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3-origin\n    (lambda (r)\n      (cadr r)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ray3-origin r)\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "ray3-origin"], "split": "train"}
{"id": "geometry_translation_025", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3-direction`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_direction(r):\n    \"\"\"Get direction of ray3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3-direction`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_direction(r):\n    \"\"\"Get direction of ray3\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ray3-direction r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (caddr r))", "verify_expr": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "tags": ["tier0", "geometry", "python-to-scheme", "ray3-direction"], "split": "train"}
{"id": "geometry_translation_026", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3-direction`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3-direction\n  (lambda (r)\n    (caddr r)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3-direction`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3-direction\n  (lambda (r)\n    (caddr r)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ray3-direction r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (caddr r))", "verify_expr": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "tags": ["tier0", "geometry", "chez-to-fold", "ray3-direction"], "split": "train"}
{"id": "geometry_translation_027", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3-direction`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3-direction\n    (lambda (r)\n      (caddr r)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3-direction`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3-direction\n    (lambda (r)\n      (caddr r)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ray3-direction r)\n  (caddr r))", "verify_expr": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "ray3-direction"], "split": "train"}
{"id": "geometry_translation_028", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3-point-at`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_point_at(ray, t):\n    \"\"\"Get point at parameter t along ray (t >= 0)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3-point-at`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_point_at(ray, t):\n    \"\"\"Get point at parameter t along ray (t >= 0)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ray3-point-at ray t)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Number Point3))\n  (doc 'description \"Get point at parameter t along ray (t >= 0)\")\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "ray3-point-at"], "split": "train"}
{"id": "geometry_translation_029", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3-point-at`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3-point-at\n  (lambda (ray t)\n    (vec3-add (ray3-origin ray)\n                (vec3-scale (ray3-direction ray) t))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3-point-at`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3-point-at\n  (lambda (ray t)\n    (vec3-add (ray3-origin ray)\n                (vec3-scale (ray3-direction ray) t))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ray3-point-at ray t)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Number Point3))\n  (doc 'description \"Get point at parameter t along ray (t >= 0)\")\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "ray3-point-at"], "split": "train"}
{"id": "geometry_translation_030", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3-point-at`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3-point-at\n    (lambda (ray t)\n      (vec3-add (ray3-origin ray)\n                  (vec3-scale (ray3-direction ray) t))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3-point-at`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3-point-at\n    (lambda (ray t)\n      (vec3-add (ray3-origin ray)\n                  (vec3-scale (ray3-direction ray) t))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ray3-point-at ray t)\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "ray3-point-at"], "split": "train"}
{"id": "geometry_translation_031", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3`.\nReturn only the Scheme definition.\n\n```python\ndef plane3(normal, d):\n    \"\"\"Plane defined by normal·p + d = 0\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3`.\nReturn only the Scheme definition.\n\n```python\ndef plane3(normal, d):\n    \"\"\"Plane defined by normal·p + d = 0\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3 normal d)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Plane3))\n  (doc 'description \"Plane defined by normal·p + d = 0\")\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "python-to-scheme", "plane3"], "split": "train"}
{"id": "geometry_translation_032", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3\n  (lambda (normal d)\n    (list 'plane3 normal d)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3\n  (lambda (normal d)\n    (list 'plane3 normal d)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(equal? (plane3-normal pl) n)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (plane3 normal d)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Plane3))\n  (doc 'description \"Plane defined by normal·p + d = 0\")\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "chez-to-fold", "plane3"], "split": "train"}
{"id": "geometry_translation_033", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3\n    (lambda (normal d)\n      (list 'plane3 normal d)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3\n    (lambda (normal d)\n      (list 'plane3 normal d)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3 normal d)\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "plane3"], "split": "train"}
{"id": "geometry_translation_034", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3?`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_p(p):\n    \"\"\"Return #t iff p is a plane3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3?`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_p(p):\n    \"\"\"Return #t iff p is a plane3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3? p)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? p) (eq? (car p) 'plane3)))", "verify_expr": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "tags": ["tier0", "geometry", "python-to-scheme", "plane3?"], "split": "train"}
{"id": "geometry_translation_035", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3?\n  (lambda (p)\n    (and (pair? p) (eq? (car p) 'plane3))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3?\n  (lambda (p)\n    (and (pair? p) (eq? (car p) 'plane3))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3? p)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? p) (eq? (car p) 'plane3)))", "verify_expr": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "tags": ["tier0", "geometry", "chez-to-fold", "plane3?"], "split": "train"}
{"id": "geometry_translation_036", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3?\n    (lambda (p)\n      (and (pair? p) (eq? (car p) 'plane3))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3?\n    (lambda (p)\n      (and (pair? p) (eq? (car p) 'plane3))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(plane3? (plane3 (vec3 0 1 0) 0))\n(not (plane3? '(not-a-plane)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3? p)\n  (and (pair? p) (eq? (car p) 'plane3)))", "verify_expr": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "plane3?"], "split": "train"}
{"id": "geometry_translation_037", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-normal`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_normal(p):\n    \"\"\"Get normal of plane3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-normal`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_normal(p):\n    \"\"\"Get normal of plane3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3-normal p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Vec3))\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "python-to-scheme", "plane3-normal"], "split": "train"}
{"id": "geometry_translation_038", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-normal`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-normal\n  (lambda (p)\n    (cadr p)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-normal`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-normal\n  (lambda (p)\n    (cadr p)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3-normal p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Vec3))\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "chez-to-fold", "plane3-normal"], "split": "train"}
{"id": "geometry_translation_039", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-normal`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-normal\n    (lambda (p)\n      (cadr p)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-normal`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-normal\n    (lambda (p)\n      (cadr p)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (plane3-normal p)\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "plane3-normal"], "split": "train"}
{"id": "geometry_translation_040", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-d`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_d(p):\n    \"\"\"Get d coefficient of plane3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-d`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_d(p):\n    \"\"\"Get d coefficient of plane3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3-d p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Number))\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "python-to-scheme", "plane3-d"], "split": "train"}
{"id": "geometry_translation_041", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-d`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-d\n  (lambda (p)\n    (caddr p)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-d`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-d\n  (lambda (p)\n    (caddr p)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3-d p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Number))\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "chez-to-fold", "plane3-d"], "split": "train"}
{"id": "geometry_translation_042", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-d`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-d\n    (lambda (p)\n      (caddr p)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-d`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-d\n    (lambda (p)\n      (caddr p)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (plane3-d p)\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "plane3-d"], "split": "train"}
{"id": "geometry_translation_043", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-from-point-normal`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_from_point_normal(point, normal):\n    \"\"\"Create plane from point and normal\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-from-point-normal`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_from_point_normal(point, normal):\n    \"\"\"Create plane from point and normal\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(< (abs (- (plane3-d pl) -5)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Vec3 Plane3))\n  (doc 'description \"Create plane from point and normal\")\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_translation_044", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-from-point-normal`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-from-point-normal\n  (lambda (point normal)\n    (let ([d (- (vec3-dot normal point))])\n           (plane3 normal d))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-from-point-normal`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-from-point-normal\n  (lambda (point normal)\n    (let ([d (- (vec3-dot normal point))])\n           (plane3 normal d))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Vec3 Plane3))\n  (doc 'description \"Create plane from point and normal\")\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_translation_045", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-from-point-normal`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-from-point-normal\n    (lambda (point normal)\n      (let ([d (- (vec3-dot normal point))])\n             (plane3 normal d))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-from-point-normal`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-from-point-normal\n    (lambda (point normal)\n      (let ([d (- (vec3-dot normal point))])\n             (plane3 normal d))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_translation_046", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-from-points`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_from_points(p1, p2, p3):\n    \"\"\"Create plane from three points (returns error if collinear)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-from-points`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_from_points(p1, p2, p3):\n    \"\"\"Create plane from three points (returns error if collinear)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "plane3-from-points"], "split": "train"}
{"id": "geometry_translation_047", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-from-points`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-from-points\n  (lambda (p1 p2 p3)\n    (let* ([v1 (vec3-sub p2 p1)]\n             [v2 (vec3-sub p3 p1)]\n             [cp (vec3-cross v1 v2)]\n             [mag (vec3-magnitude cp)])\n            (if (< mag 1e-10)\n                (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                (let ([normal (vec3-scale-inv cp mag)])\n                     (plane3-from-point-normal p1 normal))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-from-points`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-from-points\n  (lambda (p1 p2 p3)\n    (let* ([v1 (vec3-sub p2 p1)]\n             [v2 (vec3-sub p3 p1)]\n             [cp (vec3-cross v1 v2)]\n             [mag (vec3-magnitude cp)])\n            (if (< mag 1e-10)\n                (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                (let ([normal (vec3-scale-inv cp mag)])\n                     (plane3-from-point-normal p1 normal))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "plane3-from-points"], "split": "train"}
{"id": "geometry_translation_048", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-from-points`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-from-points\n    (lambda (p1 p2 p3)\n      (let* ([v1 (vec3-sub p2 p1)]\n               [v2 (vec3-sub p3 p1)]\n               [cp (vec3-cross v1 v2)]\n               [mag (vec3-magnitude cp)])\n              (if (< mag 1e-10)\n                  (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                  (let ([normal (vec3-scale-inv cp mag)])\n                       (plane3-from-point-normal p1 normal))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-from-points`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-from-points\n    (lambda (p1 p2 p3)\n      (let* ([v1 (vec3-sub p2 p1)]\n               [v2 (vec3-sub p3 p1)]\n               [cp (vec3-cross v1 v2)]\n               [mag (vec3-magnitude cp)])\n              (if (< mag 1e-10)\n                  (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                  (let ([normal (vec3-scale-inv cp mag)])\n                       (plane3-from-point-normal p1 normal))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "plane3-from-points"], "split": "train"}
{"id": "geometry_translation_049", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3(p1, p2, p3):\n    \"\"\"Create triangle from three points\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3(p1, p2, p3):\n    \"\"\"Create triangle from three points\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(triangle3? t)\n(equal? (triangle3-p1 t) p1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Vec3 Triangle3))\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle3"], "split": "train"}
{"id": "geometry_translation_050", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3\n  (lambda (p1 p2 p3)\n    (list 'triangle3 p1 p2 p3)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3\n  (lambda (p1 p2 p3)\n    (list 'triangle3 p1 p2 p3)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(triangle3? t)\n(equal? (triangle3-p1 t) p1)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Vec3 Triangle3))\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle3"], "split": "train"}
{"id": "geometry_translation_051", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3\n    (lambda (p1 p2 p3)\n      (list 'triangle3 p1 p2 p3)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3\n    (lambda (p1 p2 p3)\n      (list 'triangle3 p1 p2 p3)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle3"], "split": "train"}
{"id": "geometry_translation_052", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3?`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p(t):\n    \"\"\"Return #t iff t is a triangle3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3?`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p(t):\n    \"\"\"Return #t iff t is a triangle3\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(triangle3?\n  (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0)))\n(not (triangle3? '(not-a-triangle)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3? t)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? t) (eq? (car t) 'triangle3)))", "verify_expr": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle3?"], "split": "train"}
{"id": "geometry_translation_053", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3?\n  (lambda (t)\n    (and (pair? t) (eq? (car t) 'triangle3))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3?\n  (lambda (t)\n    (and (pair? t) (eq? (car t) 'triangle3))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (triangle3? t)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? t) (eq? (car t) 'triangle3)))", "verify_expr": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle3?"], "split": "train"}
{"id": "geometry_translation_054", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3?\n    (lambda (t)\n      (and (pair? t) (eq? (car t) 'triangle3))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3?\n    (lambda (t)\n      (and (pair? t) (eq? (car t) 'triangle3))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(triangle3?\n  (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0)))\n(not (triangle3? '(not-a-triangle)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (triangle3? t)\n  (and (pair? t) (eq? (car t) 'triangle3)))", "verify_expr": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle3?"], "split": "train"}
{"id": "geometry_translation_055", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p1`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p1(t):\n    \"\"\"Get first vertex of triangle3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p1`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p1(t):\n    \"\"\"Get first vertex of triangle3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle3-p1"], "split": "train"}
{"id": "geometry_translation_056", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p1`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p1\n  (lambda (t)\n    (cadr t)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p1`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p1\n  (lambda (t)\n    (cadr t)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle3-p1"], "split": "train"}
{"id": "geometry_translation_057", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p1`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p1\n    (lambda (t)\n      (cadr t)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p1`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p1\n    (lambda (t)\n      (cadr t)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3-p1 t)\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle3-p1"], "split": "train"}
{"id": "geometry_translation_058", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p2`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p2(t):\n    \"\"\"Get second vertex of triangle3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p2`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p2(t):\n    \"\"\"Get second vertex of triangle3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3-p2 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle3-p2"], "split": "train"}
{"id": "geometry_translation_059", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p2`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p2\n  (lambda (t)\n    (caddr t)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p2`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p2\n  (lambda (t)\n    (caddr t)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p2 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle3-p2"], "split": "train"}
{"id": "geometry_translation_060", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p2`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p2\n    (lambda (t)\n      (caddr t)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p2`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p2\n    (lambda (t)\n      (caddr t)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p2 t)\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle3-p2"], "split": "train"}
{"id": "geometry_translation_061", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p3`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p3(t):\n    \"\"\"Get third vertex of triangle3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p3`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p3(t):\n    \"\"\"Get third vertex of triangle3\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle3-p3"], "split": "train"}
{"id": "geometry_translation_062", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p3\n  (lambda (t)\n    (cadddr t)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p3\n  (lambda (t)\n    (cadddr t)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle3-p3"], "split": "train"}
{"id": "geometry_translation_063", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p3\n    (lambda (t)\n      (cadddr t)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p3\n    (lambda (t)\n      (cadddr t)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p3 t)\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle3-p3"], "split": "train"}
{"id": "geometry_translation_064", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle`.\nReturn only the Scheme definition.\n\n```python\ndef circle(center, radius):\n    \"\"\"Create 2D circle\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle`.\nReturn only the Scheme definition.\n\n```python\ndef circle(center, radius):\n    \"\"\"Create 2D circle\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec2 Number Circle))\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "python-to-scheme", "circle"], "split": "train"}
{"id": "geometry_translation_065", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle\n  (lambda (center radius)\n    (list 'circle center radius)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle\n  (lambda (center radius)\n    (list 'circle center radius)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(circle? ci)\n(equal? (circle-center ci) c)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (circle center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec2 Number Circle))\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "chez-to-fold", "circle"], "split": "train"}
{"id": "geometry_translation_066", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle\n    (lambda (center radius)\n      (list 'circle center radius)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle\n    (lambda (center radius)\n      (list 'circle center radius)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle center radius)\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "circle"], "split": "train"}
{"id": "geometry_translation_067", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle?`.\nReturn only the Scheme definition.\n\n```python\ndef circle_p(c):\n    \"\"\"Return #t iff c is a circle\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle?`.\nReturn only the Scheme definition.\n\n```python\ndef circle_p(c):\n    \"\"\"Return #t iff c is a circle\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (circle? c)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "python-to-scheme", "circle?"], "split": "train"}
{"id": "geometry_translation_068", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle?\n  (lambda (c)\n    (and (pair? c) (eq? (car c) 'circle))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle?\n  (lambda (c)\n    (and (pair? c) (eq? (car c) 'circle))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(circle? (circle (vec3 0 0 0) 1))\n(not (circle? '(not-a-circle)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle? c)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "chez-to-fold", "circle?"], "split": "train"}
{"id": "geometry_translation_069", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle?\n    (lambda (c)\n      (and (pair? c) (eq? (car c) 'circle))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle?\n    (lambda (c)\n      (and (pair? c) (eq? (car c) 'circle))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle? c)\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "circle?"], "split": "train"}
{"id": "geometry_translation_070", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle-center`.\nReturn only the Scheme definition.\n\n```python\ndef circle_center(c):\n    \"\"\"Get center of circle\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle-center`.\nReturn only the Scheme definition.\n\n```python\ndef circle_center(c):\n    \"\"\"Get center of circle\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "python-to-scheme", "circle-center"], "split": "train"}
{"id": "geometry_translation_071", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle-center\n  (lambda (c)\n    (cadr c)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle-center\n  (lambda (c)\n    (cadr c)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "chez-to-fold", "circle-center"], "split": "train"}
{"id": "geometry_translation_072", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle-center\n    (lambda (c)\n      (cadr c)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle-center\n    (lambda (c)\n      (cadr c)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (circle-center c)\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "circle-center"], "split": "train"}
{"id": "geometry_translation_073", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle-radius`.\nReturn only the Scheme definition.\n\n```python\ndef circle_radius(c):\n    \"\"\"Get radius of circle\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle-radius`.\nReturn only the Scheme definition.\n\n```python\ndef circle_radius(c):\n    \"\"\"Get radius of circle\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle-radius c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Number))\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "python-to-scheme", "circle-radius"], "split": "train"}
{"id": "geometry_translation_074", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle-radius`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle-radius\n  (lambda (c)\n    (caddr c)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle-radius`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle-radius\n  (lambda (c)\n    (caddr c)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle-radius c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Number))\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "chez-to-fold", "circle-radius"], "split": "train"}
{"id": "geometry_translation_075", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle-radius`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle-radius\n    (lambda (c)\n      (caddr c)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle-radius`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle-radius\n    (lambda (c)\n      (caddr c)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(= (circle-radius (circle (vec3 0 0 0) 7)) 7)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (circle-radius c)\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "circle-radius"], "split": "train"}
{"id": "geometry_translation_076", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere`.\nReturn only the Scheme definition.\n\n```python\ndef sphere(center, radius):\n    \"\"\"Create sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere`.\nReturn only the Scheme definition.\n\n```python\ndef sphere(center, radius):\n    \"\"\"Create sphere\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sphere center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Sphere))\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "python-to-scheme", "sphere"], "split": "train"}
{"id": "geometry_translation_077", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere\n  (lambda (center radius)\n    (list 'sphere center radius)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere\n  (lambda (center radius)\n    (list 'sphere center radius)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sphere center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Sphere))\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "chez-to-fold", "sphere"], "split": "train"}
{"id": "geometry_translation_078", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere\n    (lambda (center radius)\n      (list 'sphere center radius)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere\n    (lambda (center radius)\n      (list 'sphere center radius)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(sphere? s)\n(equal? (sphere-center s) c)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sphere center radius)\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "sphere"], "split": "train"}
{"id": "geometry_translation_079", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere?`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_p(s):\n    \"\"\"Return #t iff s is a sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere?`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_p(s):\n    \"\"\"Return #t iff s is a sphere\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(sphere? (sphere (vec3 0 0 0) 1))\n(not (sphere? '(not-a-sphere)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sphere? s)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? s) (eq? (car s) 'sphere)))", "verify_expr": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "tags": ["tier0", "geometry", "python-to-scheme", "sphere?"], "split": "train"}
{"id": "geometry_translation_080", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere?\n  (lambda (s)\n    (and (pair? s) (eq? (car s) 'sphere))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere?\n  (lambda (s)\n    (and (pair? s) (eq? (car s) 'sphere))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(sphere? (sphere (vec3 0 0 0) 1))\n(not (sphere? '(not-a-sphere)))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sphere? s)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? s) (eq? (car s) 'sphere)))", "verify_expr": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "tags": ["tier0", "geometry", "chez-to-fold", "sphere?"], "split": "train"}
{"id": "geometry_translation_081", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere?\n    (lambda (s)\n      (and (pair? s) (eq? (car s) 'sphere))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere?\n    (lambda (s)\n      (and (pair? s) (eq? (car s) 'sphere))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sphere? s)\n  (and (pair? s) (eq? (car s) 'sphere)))", "verify_expr": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "sphere?"], "split": "train"}
{"id": "geometry_translation_082", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-center`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_center(s):\n    \"\"\"Get center of sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-center`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_center(s):\n    \"\"\"Get center of sphere\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sphere-center s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Vec3))\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "python-to-scheme", "sphere-center"], "split": "train"}
{"id": "geometry_translation_083", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-center\n  (lambda (s)\n    (cadr s)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-center\n  (lambda (s)\n    (cadr s)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sphere-center s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Vec3))\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "chez-to-fold", "sphere-center"], "split": "train"}
{"id": "geometry_translation_084", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-center\n    (lambda (s)\n      (cadr s)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-center\n    (lambda (s)\n      (cadr s)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sphere-center s)\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "sphere-center"], "split": "train"}
{"id": "geometry_translation_085", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-radius`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_radius(s):\n    \"\"\"Get radius of sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-radius`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_radius(s):\n    \"\"\"Get radius of sphere\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sphere-radius s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (caddr s))", "verify_expr": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "tags": ["tier0", "geometry", "python-to-scheme", "sphere-radius"], "split": "train"}
{"id": "geometry_translation_086", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-radius`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-radius\n  (lambda (s)\n    (caddr s)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-radius`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-radius\n  (lambda (s)\n    (caddr s)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sphere-radius s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (caddr s))", "verify_expr": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "tags": ["tier0", "geometry", "chez-to-fold", "sphere-radius"], "split": "train"}
{"id": "geometry_translation_087", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-radius`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-radius\n    (lambda (s)\n      (caddr s)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-radius`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-radius\n    (lambda (s)\n      (caddr s)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sphere-radius s)\n  (caddr s))", "verify_expr": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "sphere-radius"], "split": "train"}
{"id": "geometry_translation_088", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb`.\nReturn only the Scheme definition.\n\n```python\ndef aabb(min_point, max_point):\n    \"\"\"Axis-Aligned Bounding Box from min/max corners\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb`.\nReturn only the Scheme definition.\n\n```python\ndef aabb(min_point, max_point):\n    \"\"\"Axis-Aligned Bounding Box from min/max corners\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(aabb? b)\n(equal? (aabb-min b) mn)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb min-point max-point)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 AABB))\n  (doc 'description \"Axis-Aligned Bounding Box from min/max corners\")\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb"], "split": "train"}
{"id": "geometry_translation_089", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb\n  (lambda (min-point max-point)\n    (list 'aabb min-point max-point)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb\n  (lambda (min-point max-point)\n    (list 'aabb min-point max-point)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aabb min-point max-point)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 AABB))\n  (doc 'description \"Axis-Aligned Bounding Box from min/max corners\")\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb"], "split": "train"}
{"id": "geometry_translation_090", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb\n    (lambda (min-point max-point)\n      (list 'aabb min-point max-point)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb\n    (lambda (min-point max-point)\n      (list 'aabb min-point max-point)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(aabb? b)\n(equal? (aabb-min b) mn)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb min-point max-point)\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb"], "split": "train"}
{"id": "geometry_translation_091", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_p(b):\n    \"\"\"Return #t iff b is an aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_p(b):\n    \"\"\"Return #t iff b is an aabb\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aabb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb?"], "split": "train"}
{"id": "geometry_translation_092", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb?\n  (lambda (b)\n    (and (pair? b) (eq? (car b) 'aabb))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb?\n  (lambda (b)\n    (and (pair? b) (eq? (car b) 'aabb))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(aabb? (aabb (vec3 0 0 0) (vec3 1 1 1)))\n(not (aabb? '(not-an-aabb)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aabb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb?"], "split": "train"}
{"id": "geometry_translation_093", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb?\n    (lambda (b)\n      (and (pair? b) (eq? (car b) 'aabb))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb?\n    (lambda (b)\n      (and (pair? b) (eq? (car b) 'aabb))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb? b)\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb?"], "split": "train"}
{"id": "geometry_translation_094", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-min`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_min(b):\n    \"\"\"Get min corner of aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-min`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_min(b):\n    \"\"\"Get min corner of aabb\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-min b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (cadr b))", "verify_expr": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-min"], "split": "train"}
{"id": "geometry_translation_095", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-min`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-min\n  (lambda (b)\n    (cadr b)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-min`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-min\n  (lambda (b)\n    (cadr b)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-min b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (cadr b))", "verify_expr": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-min"], "split": "train"}
{"id": "geometry_translation_096", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-min`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-min\n    (lambda (b)\n      (cadr b)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-min`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-min\n    (lambda (b)\n      (cadr b)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-min b)\n  (cadr b))", "verify_expr": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-min"], "split": "train"}
{"id": "geometry_translation_097", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-max`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_max(b):\n    \"\"\"Get max corner of aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-max`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_max(b):\n    \"\"\"Get max corner of aabb\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-max b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-max"], "split": "train"}
{"id": "geometry_translation_098", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-max`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-max\n  (lambda (b)\n    (caddr b)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-max`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-max\n  (lambda (b)\n    (caddr b)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-max b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-max"], "split": "train"}
{"id": "geometry_translation_099", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-max`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-max\n    (lambda (b)\n      (caddr b)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-max`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-max\n    (lambda (b)\n      (caddr b)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-max b)\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-max"], "split": "train"}
{"id": "geometry_translation_100", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-center`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_center(box):\n    \"\"\"Get center point of aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-center`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_center(box):\n    \"\"\"Get center point of aabb\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-center box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Point3))\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-center"], "split": "train"}
{"id": "geometry_translation_101", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-center\n  (lambda (box)\n    (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-center\n  (lambda (box)\n    (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aabb-center box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Point3))\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-center"], "split": "train"}
{"id": "geometry_translation_102", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-center\n    (lambda (box)\n      (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-center\n    (lambda (box)\n      (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aabb-center box)\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-center"], "split": "train"}
{"id": "geometry_translation_103", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-extents`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_extents(box):\n    \"\"\"Get half-size in each dimension (extents)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-extents`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_extents(box):\n    \"\"\"Get half-size in each dimension (extents)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-extents box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (doc 'description \"Half-size in each dimension\")\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-extents"], "split": "train"}
{"id": "geometry_translation_104", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-extents`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-extents\n  (lambda (box)\n    (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-extents`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-extents\n  (lambda (box)\n    (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-extents box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (doc 'description \"Half-size in each dimension\")\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-extents"], "split": "train"}
{"id": "geometry_translation_105", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-extents`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-extents\n    (lambda (box)\n      (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-extents`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-extents\n    (lambda (box)\n      (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-extents box)\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-extents"], "split": "train"}
{"id": "geometry_translation_106", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb`.\nReturn only the Scheme definition.\n\n```python\ndef obb(center, axes, extents):\n    \"\"\"Oriented Bounding Box from center, axes, and extents\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb`.\nReturn only the Scheme definition.\n\n```python\ndef obb(center, axes, extents):\n    \"\"\"Oriented Bounding Box from center, axes, and extents\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (obb center axes extents)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Vec3) Vec3 OBB))\n  (doc 'description \"Oriented Bounding Box from center, axes, and extents\")\n  (doc 'param 'axes \"list of 3 orthonormal vectors\")\n  (doc 'param 'extents \"vec3 of half-sizes along each axis\")\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "python-to-scheme", "obb"], "split": "train"}
{"id": "geometry_translation_107", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb\n  (lambda (center axes extents)\n    (list 'obb center axes extents)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb\n  (lambda (center axes extents)\n    (list 'obb center axes extents)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (obb center axes extents)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Vec3) Vec3 OBB))\n  (doc 'description \"Oriented Bounding Box from center, axes, and extents\")\n  (doc 'param 'axes \"list of 3 orthonormal vectors\")\n  (doc 'param 'extents \"vec3 of half-sizes along each axis\")\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "chez-to-fold", "obb"], "split": "train"}
{"id": "geometry_translation_108", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb\n    (lambda (center axes extents)\n      (list 'obb center axes extents)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb\n    (lambda (center axes extents)\n      (list 'obb center axes extents)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (obb center axes extents)\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "obb"], "split": "train"}
{"id": "geometry_translation_109", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb?`.\nReturn only the Scheme definition.\n\n```python\ndef obb_p(b):\n    \"\"\"Return #t iff b is an obb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb?`.\nReturn only the Scheme definition.\n\n```python\ndef obb_p(b):\n    \"\"\"Return #t iff b is an obb\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1)))\n(not (obb? '(not-an-obb)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (obb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "python-to-scheme", "obb?"], "split": "train"}
{"id": "geometry_translation_110", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb?\n  (lambda (b)\n    (and (pair? b) (eq? (car b) 'obb))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb?\n  (lambda (b)\n    (and (pair? b) (eq? (car b) 'obb))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1)))\n(not (obb? '(not-an-obb)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (obb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "chez-to-fold", "obb?"], "split": "train"}
{"id": "geometry_translation_111", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb?\n    (lambda (b)\n      (and (pair? b) (eq? (car b) 'obb))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb?\n    (lambda (b)\n      (and (pair? b) (eq? (car b) 'obb))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (obb? b)\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "obb?"], "split": "train"}
{"id": "geometry_translation_112", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb-center`.\nReturn only the Scheme definition.\n\n```python\ndef obb_center(b):\n    \"\"\"Get center of obb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb-center`.\nReturn only the Scheme definition.\n\n```python\ndef obb_center(b):\n    \"\"\"Get center of obb\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (obb-center b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadr b))", "verify_expr": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "python-to-scheme", "obb-center"], "split": "train"}
{"id": "geometry_translation_113", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb-center\n  (lambda (b)\n    (cadr b)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb-center\n  (lambda (b)\n    (cadr b)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (obb-center b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadr b))", "verify_expr": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "chez-to-fold", "obb-center"], "split": "train"}
{"id": "geometry_translation_114", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb-center\n    (lambda (b)\n      (cadr b)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb-center\n    (lambda (b)\n      (cadr b)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (obb-center b)\n  (cadr b))", "verify_expr": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "obb-center"], "split": "train"}
{"id": "geometry_translation_115", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb-axes`.\nReturn only the Scheme definition.\n\n```python\ndef obb_axes(b):\n    \"\"\"Get axes of obb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb-axes`.\nReturn only the Scheme definition.\n\n```python\ndef obb_axes(b):\n    \"\"\"Get axes of obb\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (obb-axes b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB (List Vec3)))\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "python-to-scheme", "obb-axes"], "split": "train"}
{"id": "geometry_translation_116", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb-axes`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb-axes\n  (lambda (b)\n    (caddr b)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb-axes`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb-axes\n  (lambda (b)\n    (caddr b)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (obb-axes b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB (List Vec3)))\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "chez-to-fold", "obb-axes"], "split": "train"}
{"id": "geometry_translation_117", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb-axes`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb-axes\n    (lambda (b)\n      (caddr b)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb-axes`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb-axes\n    (lambda (b)\n      (caddr b)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (obb-axes b)\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "obb-axes"], "split": "train"}
{"id": "geometry_translation_118", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb-extents`.\nReturn only the Scheme definition.\n\n```python\ndef obb_extents(b):\n    \"\"\"Get extents of obb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `obb-extents`.\nReturn only the Scheme definition.\n\n```python\ndef obb_extents(b):\n    \"\"\"Get extents of obb\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (obb-extents b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "python-to-scheme", "obb-extents"], "split": "train"}
{"id": "geometry_translation_119", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb-extents`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb-extents\n  (lambda (b)\n    (cadddr b)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `obb-extents`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-obb-extents\n  (lambda (b)\n    (cadddr b)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (obb-extents b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "chez-to-fold", "obb-extents"], "split": "train"}
{"id": "geometry_translation_120", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb-extents`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb-extents\n    (lambda (b)\n      (cadddr b)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `obb-extents`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-obb-extents\n    (lambda (b)\n      (cadddr b)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (obb-extents b)\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "obb-extents"], "split": "train"}
{"id": "geometry_translation_121", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-identity`.\nReturn only the Scheme definition.\n\n```python\n# Return 4x4 identity transformation matrix\ntransform-identity = None\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-identity`.\nReturn only the Scheme definition.\n\n```python\n# Return 4x4 identity transformation matrix\ntransform-identity = None\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-identity)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix))\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-identity"], "split": "train"}
{"id": "geometry_translation_122", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-identity`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-identity\n  (lambda ()\n    (matrix-from-lists '((1 0 0 0)\n                           (0 1 0 0)\n                           (0 0 1 0)\n                           (0 0 0 1)))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-identity`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-identity\n  (lambda ()\n    (matrix-from-lists '((1 0 0 0)\n                           (0 1 0 0)\n                           (0 0 1 0)\n                           (0 0 0 1)))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (- (vec3-y r) 2)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-identity)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix))\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-identity"], "split": "train"}
{"id": "geometry_translation_123", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-identity`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-identity\n    (lambda ()\n      (matrix-from-lists '((1 0 0 0)\n                             (0 1 0 0)\n                             (0 0 1 0)\n                             (0 0 0 1)))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-identity`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-identity\n    (lambda ()\n      (matrix-from-lists '((1 0 0 0)\n                             (0 1 0 0)\n                             (0 0 1 0)\n                             (0 0 0 1)))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (- (vec3-y r) 2)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-identity)\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-identity"], "split": "train"}
{"id": "geometry_translation_124", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-translation`.\nReturn only the Scheme definition.\n\n```python\ndef transform_translation(v):\n    \"\"\"Return 4x4 translation matrix\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-translation`.\nReturn only the Scheme definition.\n\n```python\ndef transform_translation(v):\n    \"\"\"Return 4x4 translation matrix\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-translation"], "split": "train"}
{"id": "geometry_translation_125", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-translation`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-translation\n  (lambda (v)\n    (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                           (0 1 0 ,(vec3-y v))\n                           (0 0 1 ,(vec3-z v))\n                           (0 0 0 1)))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-translation`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-translation\n  (lambda (v)\n    (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                           (0 1 0 ,(vec3-y v))\n                           (0 0 1 ,(vec3-z v))\n                           (0 0 0 1)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-translation"], "split": "train"}
{"id": "geometry_translation_126", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-translation`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-translation\n    (lambda (v)\n      (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                             (0 1 0 ,(vec3-y v))\n                             (0 0 1 ,(vec3-z v))\n                             (0 0 0 1)))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-translation`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-translation\n    (lambda (v)\n      (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                             (0 1 0 ,(vec3-y v))\n                             (0 0 1 ,(vec3-z v))\n                             (0 0 0 1)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-translation v)\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-translation"], "split": "train"}
{"id": "geometry_translation_127", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-scale`.\nReturn only the Scheme definition.\n\n```python\ndef transform_scale(s):\n    \"\"\"Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-scale`.\nReturn only the Scheme definition.\n\n```python\ndef transform_scale(s):\n    \"\"\"Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-scale"], "split": "train"}
{"id": "geometry_translation_128", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-scale`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-scale\n  (lambda (s)\n    (if (number? s)\n          (matrix-from-lists `((,s 0 0 0)\n                               (0 ,s 0 0)\n                               (0 0 ,s 0)\n                               (0 0 0 1)))\n          (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                               (0 ,(vec3-y s) 0 0)\n                               (0 0 ,(vec3-z s) 0)\n                               (0 0 0 1))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-scale`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-scale\n  (lambda (s)\n    (if (number? s)\n          (matrix-from-lists `((,s 0 0 0)\n                               (0 ,s 0 0)\n                               (0 0 ,s 0)\n                               (0 0 0 1)))\n          (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                               (0 ,(vec3-y s) 0 0)\n                               (0 0 ,(vec3-z s) 0)\n                               (0 0 0 1))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-scale"], "split": "train"}
{"id": "geometry_translation_129", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-scale`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-scale\n    (lambda (s)\n      (if (number? s)\n            (matrix-from-lists `((,s 0 0 0)\n                                 (0 ,s 0 0)\n                                 (0 0 ,s 0)\n                                 (0 0 0 1)))\n            (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                                 (0 ,(vec3-y s) 0 0)\n                                 (0 0 ,(vec3-z s) 0)\n                                 (0 0 0 1))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-scale`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-scale\n    (lambda (s)\n      (if (number? s)\n            (matrix-from-lists `((,s 0 0 0)\n                                 (0 ,s 0 0)\n                                 (0 0 ,s 0)\n                                 (0 0 0 1)))\n            (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                                 (0 ,(vec3-y s) 0 0)\n                                 (0 0 ,(vec3-z s) 0)\n                                 (0 0 0 1))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-scale s)\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-scale"], "split": "train"}
{"id": "geometry_translation_130", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-x`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_x(angle):\n    \"\"\"Return 4x4 rotation matrix around x-axis\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-x`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_x(angle):\n    \"\"\"Return 4x4 rotation matrix around x-axis\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-rotation-x angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (doc 'description \"Rotation around x-axis by angle (radians)\")\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-rotation-x"], "split": "train"}
{"id": "geometry_translation_131", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-x`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-x\n  (lambda (angle)\n    (let ([c (cos angle)]\n            [s (sin angle)])\n           (matrix-from-lists `((1 0 0 0)\n                                (0 ,c ,(- s) 0)\n                                (0 ,s ,c 0)\n                                (0 0 0 1))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-x`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-x\n  (lambda (angle)\n    (let ([c (cos angle)]\n            [s (sin angle)])\n           (matrix-from-lists `((1 0 0 0)\n                                (0 ,c ,(- s) 0)\n                                (0 ,s ,c 0)\n                                (0 0 0 1))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-rotation-x angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (doc 'description \"Rotation around x-axis by angle (radians)\")\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-rotation-x"], "split": "train"}
{"id": "geometry_translation_132", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-x`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-x\n    (lambda (angle)\n      (let ([c (cos angle)]\n              [s (sin angle)])\n             (matrix-from-lists `((1 0 0 0)\n                                  (0 ,c ,(- s) 0)\n                                  (0 ,s ,c 0)\n                                  (0 0 0 1))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-x`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-x\n    (lambda (angle)\n      (let ([c (cos angle)]\n              [s (sin angle)])\n             (matrix-from-lists `((1 0 0 0)\n                                  (0 ,c ,(- s) 0)\n                                  (0 ,s ,c 0)\n                                  (0 0 0 1))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-rotation-x angle)\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-rotation-x"], "split": "train"}
{"id": "geometry_translation_133", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-y`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_y(angle):\n    \"\"\"Return 4x4 rotation matrix around y-axis\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-y`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_y(angle):\n    \"\"\"Return 4x4 rotation matrix around y-axis\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-rotation-y angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-rotation-y"], "split": "train"}
{"id": "geometry_translation_134", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-y`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-y\n  (lambda (angle)\n    (let ([c (cos angle)]\n            [s (sin angle)])\n           (matrix-from-lists `((,c 0 ,s 0)\n                                (0 1 0 0)\n                                (,(- s) 0 ,c 0)\n                                (0 0 0 1))))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-y`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-y\n  (lambda (angle)\n    (let ([c (cos angle)]\n            [s (sin angle)])\n           (matrix-from-lists `((,c 0 ,s 0)\n                                (0 1 0 0)\n                                (,(- s) 0 ,c 0)\n                                (0 0 0 1))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-rotation-y angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-rotation-y"], "split": "train"}
{"id": "geometry_translation_135", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-y`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-y\n    (lambda (angle)\n      (let ([c (cos angle)]\n              [s (sin angle)])\n             (matrix-from-lists `((,c 0 ,s 0)\n                                  (0 1 0 0)\n                                  (,(- s) 0 ,c 0)\n                                  (0 0 0 1))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-y`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-y\n    (lambda (angle)\n      (let ([c (cos angle)]\n              [s (sin angle)])\n             (matrix-from-lists `((,c 0 ,s 0)\n                                  (0 1 0 0)\n                                  (,(- s) 0 ,c 0)\n                                  (0 0 0 1))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-rotation-y angle)\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-rotation-y"], "split": "train"}
{"id": "geometry_translation_136", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-z`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_z(angle):\n    \"\"\"Return 4x4 rotation matrix around z-axis\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-z`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_z(angle):\n    \"\"\"Return 4x4 rotation matrix around z-axis\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-rotation-z angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-rotation-z"], "split": "train"}
{"id": "geometry_translation_137", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-z`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-z\n  (lambda (angle)\n    (let ([c (cos angle)]\n            [s (sin angle)])\n           (matrix-from-lists `((,c ,(- s) 0 0)\n                                (,s ,c 0 0)\n                                (0 0 1 0)\n                                (0 0 0 1))))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-z`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-z\n  (lambda (angle)\n    (let ([c (cos angle)]\n            [s (sin angle)])\n           (matrix-from-lists `((,c ,(- s) 0 0)\n                                (,s ,c 0 0)\n                                (0 0 1 0)\n                                (0 0 0 1))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-rotation-z angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-rotation-z"], "split": "train"}
{"id": "geometry_translation_138", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-z`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-z\n    (lambda (angle)\n      (let ([c (cos angle)]\n              [s (sin angle)])\n             (matrix-from-lists `((,c ,(- s) 0 0)\n                                  (,s ,c 0 0)\n                                  (0 0 1 0)\n                                  (0 0 0 1))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-z`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-z\n    (lambda (angle)\n      (let ([c (cos angle)]\n              [s (sin angle)])\n             (matrix-from-lists `((,c ,(- s) 0 0)\n                                  (,s ,c 0 0)\n                                  (0 0 1 0)\n                                  (0 0 0 1))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-rotation-z angle)\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-rotation-z"], "split": "train"}
{"id": "geometry_translation_139", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-axis`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_axis(axis, angle):\n    \"\"\"Return 4x4 rotation matrix around arbitrary axis (Rodriguez formula)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-rotation-axis`.\nReturn only the Scheme definition.\n\n```python\ndef transform_rotation_axis(axis, angle):\n    \"\"\"Return 4x4 rotation matrix around arbitrary axis (Rodriguez formula)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Matrix))\n  (doc 'description \"Rotation around arbitrary axis by angle (Rodriguez formula)\")\n  (doc 'note \"Returns identity matrix if axis is zero vector\")\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_translation_140", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-axis`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-axis\n  (lambda (axis angle)\n    (let ([mag-val (vec3-magnitude axis)])\n           (if (< mag-val 1e-10)\n               ; Zero axis: return identity transformation\n               (transform-identity)\n               (let* ([ax-val (vec3-scale-inv axis mag-val)]\n                      [x-val (vec3-x ax-val)]\n                      [y-val (vec3-y ax-val)]\n                      [z-val (vec3-z ax-val)]\n                      [c-val (cos angle)]\n                      [s-val (sin angle)]\n                      [t-val (- 1 c-val)])\n                     (matrix-from-lists\n                      `((,(+ (* t-val x-val x-val) c-val)      ,(- (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val x-val z-val) (* s-val y-val)) 0)\n                        (,(+ (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val y-val y-val) c-val)      ,(- (* t-val y-val z-val) (* s-val x-val)) 0)\n                        (,(- (* t-val x-val z-val) (* s-val y-val)) ,(+ (* t-val y-val z-val) (* s-val x-val)) ,(+ (* t-val z-val z-val) c-val)      0)\n                        (0                     0                     0                     1))))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-rotation-axis`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-rotation-axis\n  (lambda (axis angle)\n    (let ([mag-val (vec3-magnitude axis)])\n           (if (< mag-val 1e-10)\n               ; Zero axis: return identity transformation\n               (transform-identity)\n               (let* ([ax-val (vec3-scale-inv axis mag-val)]\n                      [x-val (vec3-x ax-val)]\n                      [y-val (vec3-y ax-val)]\n                      [z-val (vec3-z ax-val)]\n                      [c-val (cos angle)]\n                      [s-val (sin angle)]\n                      [t-val (- 1 c-val)])\n                     (matrix-from-lists\n                      `((,(+ (* t-val x-val x-val) c-val)      ,(- (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val x-val z-val) (* s-val y-val)) 0)\n                        (,(+ (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val y-val y-val) c-val)      ,(- (* t-val y-val z-val) (* s-val x-val)) 0)\n                        (,(- (* t-val x-val z-val) (* s-val y-val)) ,(+ (* t-val y-val z-val) (* s-val x-val)) ,(+ (* t-val z-val z-val) c-val)      0)\n                        (0                     0                     0                     1))))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Matrix))\n  (doc 'description \"Rotation around arbitrary axis by angle (Rodriguez formula)\")\n  (doc 'note \"Returns identity matrix if axis is zero vector\")\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_translation_141", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-axis`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-axis\n    (lambda (axis angle)\n      (let ([mag-val (vec3-magnitude axis)])\n             (if (< mag-val 1e-10)\n                 ; Zero axis: return identity transformation\n                 (transform-identity)\n                 (let* ([ax-val (vec3-scale-inv axis mag-val)]\n                        [x-val (vec3-x ax-val)]\n                        [y-val (vec3-y ax-val)]\n                        [z-val (vec3-z ax-val)]\n                        [c-val (cos angle)]\n                        [s-val (sin angle)]\n                        [t-val (- 1 c-val)])\n                       (matrix-from-lists\n                        `((,(+ (* t-val x-val x-val) c-val)      ,(- (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val x-val z-val) (* s-val y-val)) 0)\n                          (,(+ (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val y-val y-val) c-val)      ,(- (* t-val y-val z-val) (* s-val x-val)) 0)\n                          (,(- (* t-val x-val z-val) (* s-val y-val)) ,(+ (* t-val y-val z-val) (* s-val x-val)) ,(+ (* t-val z-val z-val) c-val)      0)\n                          (0                     0                     0                     1))))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-rotation-axis`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-rotation-axis\n    (lambda (axis angle)\n      (let ([mag-val (vec3-magnitude axis)])\n             (if (< mag-val 1e-10)\n                 ; Zero axis: return identity transformation\n                 (transform-identity)\n                 (let* ([ax-val (vec3-scale-inv axis mag-val)]\n                        [x-val (vec3-x ax-val)]\n                        [y-val (vec3-y ax-val)]\n                        [z-val (vec3-z ax-val)]\n                        [c-val (cos angle)]\n                        [s-val (sin angle)]\n                        [t-val (- 1 c-val)])\n                       (matrix-from-lists\n                        `((,(+ (* t-val x-val x-val) c-val)      ,(- (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val x-val z-val) (* s-val y-val)) 0)\n                          (,(+ (* t-val x-val y-val) (* s-val z-val)) ,(+ (* t-val y-val y-val) c-val)      ,(- (* t-val y-val z-val) (* s-val x-val)) 0)\n                          (,(- (* t-val x-val z-val) (* s-val y-val)) ,(+ (* t-val y-val z-val) (* s-val x-val)) ,(+ (* t-val z-val z-val) c-val)      0)\n                          (0                     0                     0                     1))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_translation_142", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-from-quaternion`.\nReturn only the Scheme definition.\n\n```python\ndef transform_from_quaternion(q):\n    \"\"\"Convert quaternion to 4x4 transformation matrix\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-from-quaternion`.\nReturn only the Scheme definition.\n\n```python\ndef transform_from_quaternion(q):\n    \"\"\"Convert quaternion to 4x4 transformation matrix\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-from-quaternion q)\n  (doc 'export #t)\n  (doc 'type '(-> Quaternion Matrix))\n  (doc 'description \"Convert quaternion to 4x4 transformation matrix\")\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-from-quaternion"], "split": "train"}
{"id": "geometry_translation_143", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-from-quaternion`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-from-quaternion\n  (lambda (q)\n    (let ([w-val (quat-w q)])\n             (let ([x-val (quat-x q)])\n             (let ([y-val (quat-y q)])\n             (let ([z-val (quat-z q)])\n             (let ([x2-val (* x-val x-val)])\n             (let ([y2-val (* y-val y-val)])\n             (let ([z2-val (* z-val z-val)])\n             (let ([xy-val (* x-val y-val)])\n             (let ([xz-val (* x-val z-val)])\n             (let ([yz-val (* y-val z-val)])\n             (let ([wx-val (* w-val x-val)])\n             (let ([wy-val (* w-val y-val)])\n             (let ([wz-val (* w-val z-val)])\n             (matrix-from-lists\n             `((,(- 1 (* 2 (+ y2-val z2-val))) ,(* 2 (- xy-val wz-val))       ,(* 2 (+ xz-val wy-val))       0)\n               (,(* 2 (+ xy-val wz-val))       ,(- 1 (* 2 (+ x2-val z2-val))) ,(* 2 (- yz-val wx-val))       0)\n               (,(* 2 (- xz-val wy-val))       ,(* 2 (+ yz-val wx-val))       ,(- 1 (* 2 (+ x2-val y2-val))) 0)\n               (0                     0                     0                     1))))))))))))))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-from-quaternion`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-from-quaternion\n  (lambda (q)\n    (let ([w-val (quat-w q)])\n             (let ([x-val (quat-x q)])\n             (let ([y-val (quat-y q)])\n             (let ([z-val (quat-z q)])\n             (let ([x2-val (* x-val x-val)])\n             (let ([y2-val (* y-val y-val)])\n             (let ([z2-val (* z-val z-val)])\n             (let ([xy-val (* x-val y-val)])\n             (let ([xz-val (* x-val z-val)])\n             (let ([yz-val (* y-val z-val)])\n             (let ([wx-val (* w-val x-val)])\n             (let ([wy-val (* w-val y-val)])\n             (let ([wz-val (* w-val z-val)])\n             (matrix-from-lists\n             `((,(- 1 (* 2 (+ y2-val z2-val))) ,(* 2 (- xy-val wz-val))       ,(* 2 (+ xz-val wy-val))       0)\n               (,(* 2 (+ xy-val wz-val))       ,(- 1 (* 2 (+ x2-val z2-val))) ,(* 2 (- yz-val wx-val))       0)\n               (,(* 2 (- xz-val wy-val))       ,(* 2 (+ yz-val wx-val))       ,(- 1 (* 2 (+ x2-val y2-val))) 0)\n               (0                     0                     0                     1))))))))))))))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-from-quaternion q)\n  (doc 'export #t)\n  (doc 'type '(-> Quaternion Matrix))\n  (doc 'description \"Convert quaternion to 4x4 transformation matrix\")\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-from-quaternion"], "split": "train"}
{"id": "geometry_translation_144", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-from-quaternion`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-from-quaternion\n    (lambda (q)\n      (let ([w-val (quat-w q)])\n               (let ([x-val (quat-x q)])\n               (let ([y-val (quat-y q)])\n               (let ([z-val (quat-z q)])\n               (let ([x2-val (* x-val x-val)])\n               (let ([y2-val (* y-val y-val)])\n               (let ([z2-val (* z-val z-val)])\n               (let ([xy-val (* x-val y-val)])\n               (let ([xz-val (* x-val z-val)])\n               (let ([yz-val (* y-val z-val)])\n               (let ([wx-val (* w-val x-val)])\n               (let ([wy-val (* w-val y-val)])\n               (let ([wz-val (* w-val z-val)])\n               (matrix-from-lists\n               `((,(- 1 (* 2 (+ y2-val z2-val))) ,(* 2 (- xy-val wz-val))       ,(* 2 (+ xz-val wy-val))       0)\n                 (,(* 2 (+ xy-val wz-val))       ,(- 1 (* 2 (+ x2-val z2-val))) ,(* 2 (- yz-val wx-val))       0)\n                 (,(* 2 (- xz-val wy-val))       ,(* 2 (+ yz-val wx-val))       ,(- 1 (* 2 (+ x2-val y2-val))) 0)\n                 (0                     0                     0                     1))))))))))))))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-from-quaternion`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-from-quaternion\n    (lambda (q)\n      (let ([w-val (quat-w q)])\n               (let ([x-val (quat-x q)])\n               (let ([y-val (quat-y q)])\n               (let ([z-val (quat-z q)])\n               (let ([x2-val (* x-val x-val)])\n               (let ([y2-val (* y-val y-val)])\n               (let ([z2-val (* z-val z-val)])\n               (let ([xy-val (* x-val y-val)])\n               (let ([xz-val (* x-val z-val)])\n               (let ([yz-val (* y-val z-val)])\n               (let ([wx-val (* w-val x-val)])\n               (let ([wy-val (* w-val y-val)])\n               (let ([wz-val (* w-val z-val)])\n               (matrix-from-lists\n               `((,(- 1 (* 2 (+ y2-val z2-val))) ,(* 2 (- xy-val wz-val))       ,(* 2 (+ xz-val wy-val))       0)\n                 (,(* 2 (+ xy-val wz-val))       ,(- 1 (* 2 (+ x2-val z2-val))) ,(* 2 (- yz-val wx-val))       0)\n                 (,(* 2 (- xz-val wy-val))       ,(* 2 (+ yz-val wx-val))       ,(- 1 (* 2 (+ x2-val y2-val))) 0)\n                 (0                     0                     0                     1))))))))))))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-from-quaternion q)\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-from-quaternion"], "split": "train"}
{"id": "geometry_translation_145", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-point`.\nReturn only the Scheme definition.\n\n```python\ndef transform_point(mat, p):\n    \"\"\"Apply transformation to point (with translation)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-point`.\nReturn only the Scheme definition.\n\n```python\ndef transform_point(mat, p):\n    \"\"\"Apply transformation to point (with translation)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-point mat p)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Point3 Point3))\n  (doc 'description \"Apply transformation to point (with translation)\")\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-point"], "split": "train"}
{"id": "geometry_translation_146", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-point`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-point\n  (lambda (mat p)\n    (let ([x-val (vec3-x p)]\n            [y-val (vec3-y p)]\n            [z-val (vec3-z p)])\n           (let ([nx-val (+ (* (matrix-ref mat 0 0) x-val)\n                        (* (matrix-ref mat 0 1) y-val)\n                        (* (matrix-ref mat 0 2) z-val)\n                        (matrix-ref mat 0 3))]\n                 [ny-val (+ (* (matrix-ref mat 1 0) x-val)\n                        (* (matrix-ref mat 1 1) y-val)\n                        (* (matrix-ref mat 1 2) z-val)\n                        (matrix-ref mat 1 3))]\n                 [nz-val (+ (* (matrix-ref mat 2 0) x-val)\n                        (* (matrix-ref mat 2 1) y-val)\n                        (* (matrix-ref mat 2 2) z-val)\n                        (matrix-ref mat 2 3))]\n                 [nw-val (+ (* (matrix-ref mat 3 0) x-val)\n                        (* (matrix-ref mat 3 1) y-val)\n                        (* (matrix-ref mat 3 2) z-val)\n                        (matrix-ref mat 3 3))])\n                (cond\n                 [(< (abs nw-val) 1e-10)\n                  (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n                 [(= nw-val 1)\n                  (vec3 nx-val ny-val nz-val)]\n                 [else\n                  (vec3 (/ nx-val nw-val) (/ ny-val nw-val) (/ nz-val nw-val))])))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-point`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-point\n  (lambda (mat p)\n    (let ([x-val (vec3-x p)]\n            [y-val (vec3-y p)]\n            [z-val (vec3-z p)])\n           (let ([nx-val (+ (* (matrix-ref mat 0 0) x-val)\n                        (* (matrix-ref mat 0 1) y-val)\n                        (* (matrix-ref mat 0 2) z-val)\n                        (matrix-ref mat 0 3))]\n                 [ny-val (+ (* (matrix-ref mat 1 0) x-val)\n                        (* (matrix-ref mat 1 1) y-val)\n                        (* (matrix-ref mat 1 2) z-val)\n                        (matrix-ref mat 1 3))]\n                 [nz-val (+ (* (matrix-ref mat 2 0) x-val)\n                        (* (matrix-ref mat 2 1) y-val)\n                        (* (matrix-ref mat 2 2) z-val)\n                        (matrix-ref mat 2 3))]\n                 [nw-val (+ (* (matrix-ref mat 3 0) x-val)\n                        (* (matrix-ref mat 3 1) y-val)\n                        (* (matrix-ref mat 3 2) z-val)\n                        (matrix-ref mat 3 3))])\n                (cond\n                 [(< (abs nw-val) 1e-10)\n                  (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n                 [(= nw-val 1)\n                  (vec3 nx-val ny-val nz-val)]\n                 [else\n                  (vec3 (/ nx-val nw-val) (/ ny-val nw-val) (/ nz-val nw-val))])))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x r) 6)) 0.001)\n(< (abs (- (vec3-y r) 12)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-point mat p)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Point3 Point3))\n  (doc 'description \"Apply transformation to point (with translation)\")\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-point"], "split": "train"}
{"id": "geometry_translation_147", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-point`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-point\n    (lambda (mat p)\n      (let ([x-val (vec3-x p)]\n              [y-val (vec3-y p)]\n              [z-val (vec3-z p)])\n             (let ([nx-val (+ (* (matrix-ref mat 0 0) x-val)\n                          (* (matrix-ref mat 0 1) y-val)\n                          (* (matrix-ref mat 0 2) z-val)\n                          (matrix-ref mat 0 3))]\n                   [ny-val (+ (* (matrix-ref mat 1 0) x-val)\n                          (* (matrix-ref mat 1 1) y-val)\n                          (* (matrix-ref mat 1 2) z-val)\n                          (matrix-ref mat 1 3))]\n                   [nz-val (+ (* (matrix-ref mat 2 0) x-val)\n                          (* (matrix-ref mat 2 1) y-val)\n                          (* (matrix-ref mat 2 2) z-val)\n                          (matrix-ref mat 2 3))]\n                   [nw-val (+ (* (matrix-ref mat 3 0) x-val)\n                          (* (matrix-ref mat 3 1) y-val)\n                          (* (matrix-ref mat 3 2) z-val)\n                          (matrix-ref mat 3 3))])\n                  (cond\n                   [(< (abs nw-val) 1e-10)\n                    (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n                   [(= nw-val 1)\n                    (vec3 nx-val ny-val nz-val)]\n                   [else\n                    (vec3 (/ nx-val nw-val) (/ ny-val nw-val) (/ nz-val nw-val))])))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-point`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-point\n    (lambda (mat p)\n      (let ([x-val (vec3-x p)]\n              [y-val (vec3-y p)]\n              [z-val (vec3-z p)])\n             (let ([nx-val (+ (* (matrix-ref mat 0 0) x-val)\n                          (* (matrix-ref mat 0 1) y-val)\n                          (* (matrix-ref mat 0 2) z-val)\n                          (matrix-ref mat 0 3))]\n                   [ny-val (+ (* (matrix-ref mat 1 0) x-val)\n                          (* (matrix-ref mat 1 1) y-val)\n                          (* (matrix-ref mat 1 2) z-val)\n                          (matrix-ref mat 1 3))]\n                   [nz-val (+ (* (matrix-ref mat 2 0) x-val)\n                          (* (matrix-ref mat 2 1) y-val)\n                          (* (matrix-ref mat 2 2) z-val)\n                          (matrix-ref mat 2 3))]\n                   [nw-val (+ (* (matrix-ref mat 3 0) x-val)\n                          (* (matrix-ref mat 3 1) y-val)\n                          (* (matrix-ref mat 3 2) z-val)\n                          (matrix-ref mat 3 3))])\n                  (cond\n                   [(< (abs nw-val) 1e-10)\n                    (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n                   [(= nw-val 1)\n                    (vec3 nx-val ny-val nz-val)]\n                   [else\n                    (vec3 (/ nx-val nw-val) (/ ny-val nw-val) (/ nz-val nw-val))])))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x r) 6)) 0.001)\n(< (abs (- (vec3-y r) 12)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-point mat p)\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-point"], "split": "train"}
{"id": "geometry_translation_148", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-vector`.\nReturn only the Scheme definition.\n\n```python\ndef transform_vector(mat, v):\n    \"\"\"Apply transformation to vector (no translation)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-vector`.\nReturn only the Scheme definition.\n\n```python\ndef transform_vector(mat, v):\n    \"\"\"Apply transformation to vector (no translation)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-vector"], "split": "eval"}
{"id": "geometry_translation_149", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-vector`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-vector\n  (lambda (mat v)\n    (let ([x (vec3-x v)]\n            [y (vec3-y v)]\n            [z (vec3-z v)])\n           (vec3 (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z))\n                 (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z))\n                 (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-vector`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-vector\n  (lambda (mat v)\n    (let ([x (vec3-x v)]\n            [y (vec3-y v)]\n            [z (vec3-z v)])\n           (vec3 (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z))\n                 (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z))\n                 (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-vector"], "split": "eval"}
{"id": "geometry_translation_150", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-vector`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-vector\n    (lambda (mat v)\n      (let ([x (vec3-x v)]\n              [y (vec3-y v)]\n              [z (vec3-z v)])\n             (vec3 (+ (* (matrix-ref mat 0 0) x)\n                      (* (matrix-ref mat 0 1) y)\n                      (* (matrix-ref mat 0 2) z))\n                   (+ (* (matrix-ref mat 1 0) x)\n                      (* (matrix-ref mat 1 1) y)\n                      (* (matrix-ref mat 1 2) z))\n                   (+ (* (matrix-ref mat 2 0) x)\n                      (* (matrix-ref mat 2 1) y)\n                      (* (matrix-ref mat 2 2) z))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-vector`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-vector\n    (lambda (mat v)\n      (let ([x (vec3-x v)]\n              [y (vec3-y v)]\n              [z (vec3-z v)])\n             (vec3 (+ (* (matrix-ref mat 0 0) x)\n                      (* (matrix-ref mat 0 1) y)\n                      (* (matrix-ref mat 0 2) z))\n                   (+ (* (matrix-ref mat 1 0) x)\n                      (* (matrix-ref mat 1 1) y)\n                      (* (matrix-ref mat 1 2) z))\n                   (+ (* (matrix-ref mat 2 0) x)\n                      (* (matrix-ref mat 2 1) y)\n                      (* (matrix-ref mat 2 2) z))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-vector mat v)\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-vector"], "split": "eval"}
{"id": "geometry_translation_151", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-point`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_point(p1, p2):\n    \"\"\"Return Euclidean distance between two points\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-point`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_point(p1, p2):\n    \"\"\"Return Euclidean distance between two points\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-point"], "split": "eval"}
{"id": "geometry_translation_152", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-point`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-point\n  (lambda (p1 p2)\n    (vec3-length (vec3-sub p2 p1))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-point`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-point\n  (lambda (p1 p2)\n    (vec3-length (vec3-sub p2 p1))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-point"], "split": "eval"}
{"id": "geometry_translation_153", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-point`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-point\n    (lambda (p1 p2)\n      (vec3-length (vec3-sub p2 p1))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-point`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-point\n    (lambda (p1 p2)\n      (vec3-length (vec3-sub p2 p1))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-point p1 p2)\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-point"], "split": "eval"}
{"id": "geometry_translation_154", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-plane`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_plane(point, plane):\n    \"\"\"Return signed distance from point to plane (positive = in front)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-plane`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_plane(point, plane):\n    \"\"\"Return signed distance from point to plane (positive = in front)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_155", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-plane\n  (lambda (point plane)\n    (let ([n (plane3-normal plane)]\n            [d (plane3-d plane)])\n           (/ (+ (vec3-dot n point) d)\n              (vec3-magnitude n)))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-plane\n  (lambda (point plane)\n    (let ([n (plane3-normal plane)]\n            [d (plane3-d plane)])\n           (/ (+ (vec3-dot n point) d)\n              (vec3-magnitude n)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_156", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-plane\n    (lambda (point plane)\n      (let ([n (plane3-normal plane)]\n              [d (plane3-d plane)])\n             (/ (+ (vec3-dot n point) d)\n                (vec3-magnitude n)))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-plane\n    (lambda (point plane)\n      (let ([n (plane3-normal plane)]\n              [d (plane3-d plane)])\n             (/ (+ (vec3-dot n point) d)\n                (vec3-magnitude n)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-plane point plane)\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_157", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-line`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_line(point, line):\n    \"\"\"Return distance from point to infinite line\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-line`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_line(point, line):\n    \"\"\"Return distance from point to infinite line\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-line"], "split": "eval"}
{"id": "geometry_translation_158", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-line`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-line\n  (lambda (point line)\n    (let* ([origin (line3-origin line)]\n             [dir (vec3-normalize (line3-direction line))]\n             [v (vec3-sub point origin)]\n             [proj (vec3-scale dir (vec3-dot v dir))]\n             [perp (vec3-sub v proj)])\n            (vec3-length perp))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-line`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-line\n  (lambda (point line)\n    (let* ([origin (line3-origin line)]\n             [dir (vec3-normalize (line3-direction line))]\n             [v (vec3-sub point origin)]\n             [proj (vec3-scale dir (vec3-dot v dir))]\n             [perp (vec3-sub v proj)])\n            (vec3-length perp))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-line"], "split": "eval"}
{"id": "geometry_translation_159", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-line`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-line\n    (lambda (point line)\n      (let* ([origin (line3-origin line)]\n               [dir (vec3-normalize (line3-direction line))]\n               [v (vec3-sub point origin)]\n               [proj (vec3-scale dir (vec3-dot v dir))]\n               [perp (vec3-sub v proj)])\n              (vec3-length perp))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-line`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-line\n    (lambda (point line)\n      (let* ([origin (line3-origin line)]\n               [dir (vec3-normalize (line3-direction line))]\n               [v (vec3-sub point origin)]\n               [proj (vec3-scale dir (vec3-dot v dir))]\n               [perp (vec3-sub v proj)])\n              (vec3-length perp))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-line"], "split": "eval"}
{"id": "geometry_translation_160", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_sphere(point, sphere):\n    \"\"\"Return signed distance from point to sphere (negative if inside)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_sphere(point, sphere):\n    \"\"\"Return signed distance from point to sphere (negative if inside)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_translation_161", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-sphere\n  (lambda (point sphere)\n    (- (distance-point-point point (sphere-center sphere))\n         (sphere-radius sphere))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-sphere\n  (lambda (point sphere)\n    (- (distance-point-point point (sphere-center sphere))\n         (sphere-radius sphere))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_translation_162", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-sphere\n    (lambda (point sphere)\n      (- (distance-point-point point (sphere-center sphere))\n           (sphere-radius sphere))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-sphere\n    (lambda (point sphere)\n      (- (distance-point-point point (sphere-center sphere))\n           (sphere-radius sphere))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_translation_163", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-plane`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_plane(ray, plane):\n    \"\"\"Return t parameter where ray intersects plane, or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-plane`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_plane(ray, plane):\n    \"\"\"Return t parameter where ray intersects plane, or #f\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_translation_164", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-plane\n  (lambda (ray plane)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [normal (plane3-normal plane)]\n             [denom (vec3-dot normal dir)])\n            (if (< (abs denom) 1e-10)\n                #f  ; Ray parallel to plane\n                (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                            denom)])\n                     (if (>= t 0) t #f))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-plane\n  (lambda (ray plane)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [normal (plane3-normal plane)]\n             [denom (vec3-dot normal dir)])\n            (if (< (abs denom) 1e-10)\n                #f  ; Ray parallel to plane\n                (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                            denom)])\n                     (if (>= t 0) t #f))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_translation_165", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-plane\n    (lambda (ray plane)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [normal (plane3-normal plane)]\n               [denom (vec3-dot normal dir)])\n              (if (< (abs denom) 1e-10)\n                  #f  ; Ray parallel to plane\n                  (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                              denom)])\n                       (if (>= t 0) t #f))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-plane\n    (lambda (ray plane)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [normal (plane3-normal plane)]\n               [denom (vec3-dot normal dir)])\n              (if (< (abs denom) 1e-10)\n                  #f  ; Ray parallel to plane\n                  (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                              denom)])\n                       (if (>= t 0) t #f))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_translation_166", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_sphere(ray, sphere):\n    \"\"\"Return (t1 t2) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_sphere(ray, sphere):\n    \"\"\"Return (t1 t2) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_translation_167", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-sphere\n  (lambda (ray sphere)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([center-val (sphere-center sphere)])\n             (let ([radius-val (sphere-radius sphere)])\n             (let ([oc-val (vec3-sub origin-val center-val)])\n             (let ([a-val (vec3-dot dir-val dir-val)])\n             (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n             (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n             (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n             (if (< discriminant-val 0)\n                #f\n                (let* ([sqrt-d-val (sqrt discriminant-val)]\n                       [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                       [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                      (if (or (>= t1-val 0) (>= t2-val 0))\n                          (list t1-val t2-val)\n                          #f))))))))))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-sphere\n  (lambda (ray sphere)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([center-val (sphere-center sphere)])\n             (let ([radius-val (sphere-radius sphere)])\n             (let ([oc-val (vec3-sub origin-val center-val)])\n             (let ([a-val (vec3-dot dir-val dir-val)])\n             (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n             (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n             (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n             (if (< discriminant-val 0)\n                #f\n                (let* ([sqrt-d-val (sqrt discriminant-val)]\n                       [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                       [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                      (if (or (>= t1-val 0) (>= t2-val 0))\n                          (list t1-val t2-val)\n                          #f))))))))))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_translation_168", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-sphere\n    (lambda (ray sphere)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([center-val (sphere-center sphere)])\n               (let ([radius-val (sphere-radius sphere)])\n               (let ([oc-val (vec3-sub origin-val center-val)])\n               (let ([a-val (vec3-dot dir-val dir-val)])\n               (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n               (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n               (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n               (if (< discriminant-val 0)\n                  #f\n                  (let* ([sqrt-d-val (sqrt discriminant-val)]\n                         [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                         [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                        (if (or (>= t1-val 0) (>= t2-val 0))\n                            (list t1-val t2-val)\n                            #f))))))))))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-sphere\n    (lambda (ray sphere)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([center-val (sphere-center sphere)])\n               (let ([radius-val (sphere-radius sphere)])\n               (let ([oc-val (vec3-sub origin-val center-val)])\n               (let ([a-val (vec3-dot dir-val dir-val)])\n               (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n               (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n               (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n               (if (< discriminant-val 0)\n                  #f\n                  (let* ([sqrt-d-val (sqrt discriminant-val)]\n                         [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                         [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                        (if (or (>= t1-val 0) (>= t2-val 0))\n                            (list t1-val t2-val)\n                            #f))))))))))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_translation_169", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_aabb(ray, box):\n    \"\"\"Return (tmin tmax) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_aabb(ray, box):\n    \"\"\"Return (tmin tmax) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_translation_170", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-aabb\n  (lambda (ray box)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([bmin-val (aabb-min box)])\n             (let ([bmax-val (aabb-max box)])\n             ; Helper to compute t-range for one axis\n            (define (slab-t dir-comp origin-comp box-min box-max)\n              (if (< (abs dir-comp) 1e-10)\n                  ; Ray parallel to slab - check if origin-val is within slab\n                  (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                      (list -1e10 1e10)  ; Effectively infinite range\n                      (list 1 -1))       ; Invalid range (will fail intersection)\n                  ; Normal case\n                  (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                         [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                         [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                        (if (< t1-val t2-val)\n                            (list t1-val t2-val)\n                            (list t2-val t1-val)))))\n            (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                   [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                   [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                   [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                   [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                  (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                      (list tmin-val tmax-val)\n                      #f))))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-aabb\n  (lambda (ray box)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([bmin-val (aabb-min box)])\n             (let ([bmax-val (aabb-max box)])\n             ; Helper to compute t-range for one axis\n            (define (slab-t dir-comp origin-comp box-min box-max)\n              (if (< (abs dir-comp) 1e-10)\n                  ; Ray parallel to slab - check if origin-val is within slab\n                  (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                      (list -1e10 1e10)  ; Effectively infinite range\n                      (list 1 -1))       ; Invalid range (will fail intersection)\n                  ; Normal case\n                  (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                         [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                         [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                        (if (< t1-val t2-val)\n                            (list t1-val t2-val)\n                            (list t2-val t1-val)))))\n            (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                   [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                   [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                   [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                   [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                  (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                      (list tmin-val tmax-val)\n                      #f))))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_translation_171", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-aabb\n    (lambda (ray box)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([bmin-val (aabb-min box)])\n               (let ([bmax-val (aabb-max box)])\n               ; Helper to compute t-range for one axis\n              (define (slab-t dir-comp origin-comp box-min box-max)\n                (if (< (abs dir-comp) 1e-10)\n                    ; Ray parallel to slab - check if origin-val is within slab\n                    (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                        (list -1e10 1e10)  ; Effectively infinite range\n                        (list 1 -1))       ; Invalid range (will fail intersection)\n                    ; Normal case\n                    (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                           [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                           [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                          (if (< t1-val t2-val)\n                              (list t1-val t2-val)\n                              (list t2-val t1-val)))))\n              (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                     [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                     [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                     [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                     [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                    (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                        (list tmin-val tmax-val)\n                        #f))))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-aabb\n    (lambda (ray box)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([bmin-val (aabb-min box)])\n               (let ([bmax-val (aabb-max box)])\n               ; Helper to compute t-range for one axis\n              (define (slab-t dir-comp origin-comp box-min box-max)\n                (if (< (abs dir-comp) 1e-10)\n                    ; Ray parallel to slab - check if origin-val is within slab\n                    (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                        (list -1e10 1e10)  ; Effectively infinite range\n                        (list 1 -1))       ; Invalid range (will fail intersection)\n                    ; Normal case\n                    (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                           [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                           [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                          (if (< t1-val t2-val)\n                              (list t1-val t2-val)\n                              (list t2-val t1-val)))))\n              (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                     [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                     [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                     [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                     [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                    (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                        (list tmin-val tmax-val)\n                        #f))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_translation_172", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-triangle`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_triangle(ray, tri):\n    \"\"\"Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-triangle`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_triangle(ray, tri):\n    \"\"\"Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_translation_173", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-triangle`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-triangle\n  (lambda (ray tri)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)]\n             [h (vec3-cross dir edge2)]\n             [a (vec3-dot edge1 h)])\n            (if (< (abs a) 1e-10)\n                #f  ; Ray parallel to triangle\n                (let* ([f (/ 1.0 a)]\n                       [s (vec3-sub origin v0)]\n                       [u (* f (vec3-dot s h))])\n                      (if (or (< u 0.0) (> u 1.0))\n                          #f\n                          (let* ([q (vec3-cross s edge1)]\n                                 [v (* f (vec3-dot dir q))])\n                                (if (or (< v 0.0) (> (+ u v) 1.0))\n                                    #f\n                                    (let ([t (* f (vec3-dot edge2 q))])\n                                         (if (> t 1e-10) t #f))))))))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-triangle`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-triangle\n  (lambda (ray tri)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)]\n             [h (vec3-cross dir edge2)]\n             [a (vec3-dot edge1 h)])\n            (if (< (abs a) 1e-10)\n                #f  ; Ray parallel to triangle\n                (let* ([f (/ 1.0 a)]\n                       [s (vec3-sub origin v0)]\n                       [u (* f (vec3-dot s h))])\n                      (if (or (< u 0.0) (> u 1.0))\n                          #f\n                          (let* ([q (vec3-cross s edge1)]\n                                 [v (* f (vec3-dot dir q))])\n                                (if (or (< v 0.0) (> (+ u v) 1.0))\n                                    #f\n                                    (let ([t (* f (vec3-dot edge2 q))])\n                                         (if (> t 1e-10) t #f))))))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_translation_174", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-triangle`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-triangle\n    (lambda (ray tri)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)]\n               [h (vec3-cross dir edge2)]\n               [a (vec3-dot edge1 h)])\n              (if (< (abs a) 1e-10)\n                  #f  ; Ray parallel to triangle\n                  (let* ([f (/ 1.0 a)]\n                         [s (vec3-sub origin v0)]\n                         [u (* f (vec3-dot s h))])\n                        (if (or (< u 0.0) (> u 1.0))\n                            #f\n                            (let* ([q (vec3-cross s edge1)]\n                                   [v (* f (vec3-dot dir q))])\n                                  (if (or (< v 0.0) (> (+ u v) 1.0))\n                                      #f\n                                      (let ([t (* f (vec3-dot edge2 q))])\n                                           (if (> t 1e-10) t #f))))))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-triangle`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-triangle\n    (lambda (ray tri)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)]\n               [h (vec3-cross dir edge2)]\n               [a (vec3-dot edge1 h)])\n              (if (< (abs a) 1e-10)\n                  #f  ; Ray parallel to triangle\n                  (let* ([f (/ 1.0 a)]\n                         [s (vec3-sub origin v0)]\n                         [u (* f (vec3-dot s h))])\n                        (if (or (< u 0.0) (> u 1.0))\n                            #f\n                            (let* ([q (vec3-cross s edge1)]\n                                   [v (* f (vec3-dot dir q))])\n                                  (if (or (< v 0.0) (> (+ u v) 1.0))\n                                      #f\n                                      (let ([t (* f (vec3-dot edge2 q))])\n                                           (if (> t 1e-10) t #f))))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_translation_175", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-sphere?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_sphere_p(point, sphere):\n    \"\"\"Return #t iff point is inside or on sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-sphere?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_sphere_p(point, sphere):\n    \"\"\"Return #t iff point is inside or on sphere\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "python-to-scheme", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_translation_176", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-sphere?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-sphere?\n  (lambda (point sphere)\n    (<= (distance-point-sphere point sphere) 0)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-sphere?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-sphere?\n  (lambda (point sphere)\n    (<= (distance-point-sphere point sphere) 0)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "chez-to-fold", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_translation_177", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-sphere?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-sphere?\n    (lambda (point sphere)\n      (<= (distance-point-sphere point sphere) 0)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-sphere?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-sphere?\n    (lambda (point sphere)\n      (<= (distance-point-sphere point sphere) 0)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_translation_178", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_aabb_p(point, box):\n    \"\"\"Return #t iff point is inside or on aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_aabb_p(point, box):\n    \"\"\"Return #t iff point is inside or on aabb\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "python-to-scheme", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_179", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-aabb?\n  (lambda (point box)\n    (let ([p point]\n            [bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (and (>= (vec3-x p) (vec3-x bmin))\n                (<= (vec3-x p) (vec3-x bmax))\n                (>= (vec3-y p) (vec3-y bmin))\n                (<= (vec3-y p) (vec3-y bmax))\n                (>= (vec3-z p) (vec3-z bmin))\n                (<= (vec3-z p) (vec3-z bmax))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-aabb?\n  (lambda (point box)\n    (let ([p point]\n            [bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (and (>= (vec3-x p) (vec3-x bmin))\n                (<= (vec3-x p) (vec3-x bmax))\n                (>= (vec3-y p) (vec3-y bmin))\n                (<= (vec3-y p) (vec3-y bmax))\n                (>= (vec3-z p) (vec3-z bmin))\n                (<= (vec3-z p) (vec3-z bmax))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "chez-to-fold", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_180", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-aabb?\n    (lambda (point box)\n      (let ([p point]\n              [bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (and (>= (vec3-x p) (vec3-x bmin))\n                  (<= (vec3-x p) (vec3-x bmax))\n                  (>= (vec3-y p) (vec3-y bmin))\n                  (<= (vec3-y p) (vec3-y bmax))\n                  (>= (vec3-z p) (vec3-z bmin))\n                  (<= (vec3-z p) (vec3-z bmax))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-aabb?\n    (lambda (point box)\n      (let ([p point]\n              [bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (and (>= (vec3-x p) (vec3-x bmin))\n                  (<= (vec3-x p) (vec3-x bmax))\n                  (>= (vec3-y p) (vec3-y bmin))\n                  (<= (vec3-y p) (vec3-y bmax))\n                  (>= (vec3-z p) (vec3-z bmin))\n                  (<= (vec3-z p) (vec3-z bmax))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (point-in-aabb? point box)\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_181", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-triangle?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_triangle_p(point, tri):\n    \"\"\"Return #t iff point is inside triangle (point must be coplanar)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-triangle?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_triangle_p(point, tri):\n    \"\"\"Return #t iff point is inside triangle (point must be coplanar)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "python-to-scheme", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_translation_182", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-triangle?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-triangle?\n  (lambda (point tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [bary (barycentric-coords point v0 v1 v2)]\n             [u (car bary)]\n             [v (cadr bary)]\n             [w (caddr bary)])\n            (and (>= u 0) (>= v 0) (>= w 0)\n                 (<= (+ u v w) 1.0001)))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-triangle?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-triangle?\n  (lambda (point tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [bary (barycentric-coords point v0 v1 v2)]\n             [u (car bary)]\n             [v (cadr bary)]\n             [w (caddr bary)])\n            (and (>= u 0) (>= v 0) (>= w 0)\n                 (<= (+ u v w) 1.0001)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "chez-to-fold", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_translation_183", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-triangle?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-triangle?\n    (lambda (point tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [bary (barycentric-coords point v0 v1 v2)]\n               [u (car bary)]\n               [v (cadr bary)]\n               [w (caddr bary)])\n              (and (>= u 0) (>= v 0) (>= w 0)\n                   (<= (+ u v w) 1.0001)))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-triangle?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-triangle?\n    (lambda (point tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [bary (barycentric-coords point v0 v1 v2)]\n               [u (car bary)]\n               [v (cadr bary)]\n               [w (caddr bary)])\n              (and (>= u 0) (>= v 0) (>= w 0)\n                   (<= (+ u v w) 1.0001)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_translation_184", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-line`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_line(point, line):\n    \"\"\"Return closest point on infinite line to given point\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-line`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_line(point, line):\n    \"\"\"Return closest point on infinite line to given point\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (closest-point-on-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Point3))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "closest-point-on-line"], "split": "train"}
{"id": "geometry_translation_185", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-line`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-line\n  (lambda (point line)\n    (let* ([origin (line3-origin line)]\n             [dir (vec3-normalize (line3-direction line))]\n             [v (vec3-sub point origin)]\n             [t (vec3-dot v dir)])\n            (vec3-add origin (vec3-scale dir t)))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-line`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-line\n  (lambda (point line)\n    (let* ([origin (line3-origin line)]\n             [dir (vec3-normalize (line3-direction line))]\n             [v (vec3-sub point origin)]\n             [t (vec3-dot v dir)])\n            (vec3-add origin (vec3-scale dir t)))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (closest-point-on-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Point3))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "closest-point-on-line"], "split": "train"}
{"id": "geometry_translation_186", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-line`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-line\n    (lambda (point line)\n      (let* ([origin (line3-origin line)]\n               [dir (vec3-normalize (line3-direction line))]\n               [v (vec3-sub point origin)]\n               [t (vec3-dot v dir)])\n              (vec3-add origin (vec3-scale dir t)))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-line`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-line\n    (lambda (point line)\n      (let* ([origin (line3-origin line)]\n               [dir (vec3-normalize (line3-direction line))]\n               [v (vec3-sub point origin)]\n               [t (vec3-dot v dir)])\n              (vec3-add origin (vec3-scale dir t)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (closest-point-on-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "closest-point-on-line"], "split": "train"}
{"id": "geometry_translation_187", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-plane`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_plane(point, plane):\n    \"\"\"Return closest point on plane to given point\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-plane`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_plane(point, plane):\n    \"\"\"Return closest point on plane to given point\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Point3))\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "closest-point-on-plane"], "split": "train"}
{"id": "geometry_translation_188", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-plane\n  (lambda (point plane)\n    (let ([dist (distance-point-plane point plane)]\n            [normal (plane3-normal plane)])\n           (vec3-sub point (vec3-scale normal dist)))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-plane\n  (lambda (point plane)\n    (let ([dist (distance-point-plane point plane)]\n            [normal (plane3-normal plane)])\n           (vec3-sub point (vec3-scale normal dist)))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Point3))\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "closest-point-on-plane"], "split": "train"}
{"id": "geometry_translation_189", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-plane\n    (lambda (point plane)\n      (let ([dist (distance-point-plane point plane)]\n              [normal (plane3-normal plane)])\n             (vec3-sub point (vec3-scale normal dist)))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-plane\n    (lambda (point plane)\n      (let ([dist (distance-point-plane point plane)]\n              [normal (plane3-normal plane)])\n             (vec3-sub point (vec3-scale normal dist)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "closest-point-on-plane"], "split": "train"}
{"id": "geometry_translation_190", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_aabb(point, box):\n    \"\"\"Return closest point on aabb to given point\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_aabb(point, box):\n    \"\"\"Return closest point on aabb to given point\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "closest-point-on-aabb"], "split": "train"}
{"id": "geometry_translation_191", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-aabb\n  (lambda (point box)\n    (let ([bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                 (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                 (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-aabb\n  (lambda (point box)\n    (let ([bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                 (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                 (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "closest-point-on-aabb"], "split": "train"}
{"id": "geometry_translation_192", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-aabb\n    (lambda (point box)\n      (let ([bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                   (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                   (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-aabb\n    (lambda (point box)\n      (let ([bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                   (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                   (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "closest-point-on-aabb"], "split": "train"}
{"id": "geometry_translation_193", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle-area`.\nReturn only the Scheme definition.\n\n```python\ndef triangle_area(tri):\n    \"\"\"Return area of triangle\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle-area`.\nReturn only the Scheme definition.\n\n```python\ndef triangle_area(tri):\n    \"\"\"Return area of triangle\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (triangle-area tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Number))\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 0.5 (vec3-length cross))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle-area"], "split": "train"}
{"id": "geometry_translation_194", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle-area`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle-area\n  (lambda (tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)]\n             [cross (vec3-cross edge1 edge2)])\n            (* 0.5 (vec3-length cross)))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle-area`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle-area\n  (lambda (tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)]\n             [cross (vec3-cross edge1 edge2)])\n            (* 0.5 (vec3-length cross)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle-area tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Number))\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 0.5 (vec3-length cross))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle-area"], "split": "train"}
{"id": "geometry_translation_195", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle-area`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle-area\n    (lambda (tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)]\n               [cross (vec3-cross edge1 edge2)])\n              (* 0.5 (vec3-length cross)))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle-area`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle-area\n    (lambda (tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)]\n               [cross (vec3-cross edge1 edge2)])\n              (* 0.5 (vec3-length cross)))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle-area tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 0.5 (vec3-length cross))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle-area"], "split": "train"}
{"id": "geometry_translation_196", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-volume`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_volume(sphere):\n    \"\"\"Return volume of sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-volume`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_volume(sphere):\n    \"\"\"Return volume of sphere\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sphere-volume sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "sphere-volume"], "split": "train"}
{"id": "geometry_translation_197", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-volume`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-volume\n  (lambda (sphere)\n    (let ([r (sphere-radius sphere)])\n           (* (/ 4.0 3.0) 3.141592653589793 r r r))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-volume`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-volume\n  (lambda (sphere)\n    (let ([r (sphere-radius sphere)])\n           (* (/ 4.0 3.0) 3.141592653589793 r r r))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sphere-volume sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "sphere-volume"], "split": "train"}
{"id": "geometry_translation_198", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-volume`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-volume\n    (lambda (sphere)\n      (let ([r (sphere-radius sphere)])\n             (* (/ 4.0 3.0) 3.141592653589793 r r r))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-volume`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-volume\n    (lambda (sphere)\n      (let ([r (sphere-radius sphere)])\n             (* (/ 4.0 3.0) 3.141592653589793 r r r))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sphere-volume sphere)\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "sphere-volume"], "split": "train"}
{"id": "geometry_translation_199", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-surface-area`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_surface_area(sphere):\n    \"\"\"Return surface area of sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `sphere-surface-area`.\nReturn only the Scheme definition.\n\n```python\ndef sphere_surface_area(sphere):\n    \"\"\"Return surface area of sphere\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (sphere-surface-area sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* 4.0 3.141592653589793 r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "sphere-surface-area"], "split": "train"}
{"id": "geometry_translation_200", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-surface-area`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-surface-area\n  (lambda (sphere)\n    (let ([r (sphere-radius sphere)])\n           (* 4.0 3.141592653589793 r r))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `sphere-surface-area`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-sphere-surface-area\n  (lambda (sphere)\n    (let ([r (sphere-radius sphere)])\n           (* 4.0 3.141592653589793 r r))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (sphere-surface-area sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* 4.0 3.141592653589793 r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "sphere-surface-area"], "split": "train"}
{"id": "geometry_translation_201", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-surface-area`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-surface-area\n    (lambda (sphere)\n      (let ([r (sphere-radius sphere)])\n             (* 4.0 3.141592653589793 r r))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `sphere-surface-area`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-sphere-surface-area\n    (lambda (sphere)\n      (let ([r (sphere-radius sphere)])\n             (* 4.0 3.141592653589793 r r))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (sphere-surface-area sphere)\n  (let ([r (sphere-radius sphere)])\n       (* 4.0 3.141592653589793 r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "sphere-surface-area"], "split": "train"}
{"id": "geometry_translation_202", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-volume`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_volume(box):\n    \"\"\"Return volume of aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-volume`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_volume(box):\n    \"\"\"Return volume of aabb\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-volume"], "split": "train"}
{"id": "geometry_translation_203", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-volume`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-volume\n  (lambda (box)\n    (let* ([extents (aabb-extents box)]\n             [x (vec3-x extents)]\n             [y (vec3-y extents)]\n             [z (vec3-z extents)])\n            (* 8 x y z))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-volume`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-volume\n  (lambda (box)\n    (let* ([extents (aabb-extents box)]\n             [x (vec3-x extents)]\n             [y (vec3-y extents)]\n             [z (vec3-z extents)])\n            (* 8 x y z))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-volume"], "split": "train"}
{"id": "geometry_translation_204", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-volume`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-volume\n    (lambda (box)\n      (let* ([extents (aabb-extents box)]\n               [x (vec3-x extents)]\n               [y (vec3-y extents)]\n               [z (vec3-z extents)])\n              (* 8 x y z))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-volume`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-volume\n    (lambda (box)\n      (let* ([extents (aabb-extents box)]\n               [x (vec3-x extents)]\n               [y (vec3-y extents)]\n               [z (vec3-z extents)])\n              (* 8 x y z))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-volume box)\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-volume"], "split": "train"}
{"id": "geometry_translation_205", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `barycentric-coords`.\nReturn only the Scheme definition.\n\n```python\ndef barycentric_coords(p, a, b, c):\n    \"\"\"Compute barycentric coordinates (u, v, w) of p w.r.t. triangle (a, b, c)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `barycentric-coords`.\nReturn only the Scheme definition.\n\n```python\ndef barycentric_coords(p, a, b, c):\n    \"\"\"Compute barycentric coordinates (u, v, w) of p w.r.t. triangle (a, b, c)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (car bc) 1.0)) 0.01)\n(< (abs (cadr bc)) 0.01)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (barycentric-coords p a b c)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 Point3 (List Number Number Number)))\n  (doc 'description \"Compute barycentric coordinates (u, v, w) of point p with respect to triangle (a, b, c)\")\n  (doc 'note \"p = u*a + v*b + w*c where u + v + w = 1\")\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "python-to-scheme", "barycentric-coords"], "split": "train"}
{"id": "geometry_translation_206", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `barycentric-coords`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-barycentric-coords\n  (lambda (p a b c)\n    (let ([v0-val (vec3-sub b a)])\n             (let ([v1-val (vec3-sub c a)])\n             (let ([v2-val (vec3-sub p a)])\n             (let ([d00-val (vec3-dot v0-val v0-val)])\n             (let ([d01-val (vec3-dot v0-val v1-val)])\n             (let ([d11-val (vec3-dot v1-val v1-val)])\n             (let ([d20-val (vec3-dot v2-val v0-val)])\n             (let ([d21-val (vec3-dot v2-val v1-val)])\n             (let ([denom-val (- (* d00-val d11-val) (* d01-val d01-val))])\n             (if (< (abs denom-val) 1e-10)\n                (list 1.0 0.0 0.0)  ; Degenerate triangle\n                (let* ([v-val (/ (- (* d11-val d20-val) (* d01-val d21-val)) denom-val)]\n                       [w-val (/ (- (* d00-val d21-val) (* d01-val d20-val)) denom-val)]\n                       [u-val (- 1.0 v-val w-val)])\n                      (list u-val v-val w-val))))))))))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `barycentric-coords`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-barycentric-coords\n  (lambda (p a b c)\n    (let ([v0-val (vec3-sub b a)])\n             (let ([v1-val (vec3-sub c a)])\n             (let ([v2-val (vec3-sub p a)])\n             (let ([d00-val (vec3-dot v0-val v0-val)])\n             (let ([d01-val (vec3-dot v0-val v1-val)])\n             (let ([d11-val (vec3-dot v1-val v1-val)])\n             (let ([d20-val (vec3-dot v2-val v0-val)])\n             (let ([d21-val (vec3-dot v2-val v1-val)])\n             (let ([denom-val (- (* d00-val d11-val) (* d01-val d01-val))])\n             (if (< (abs denom-val) 1e-10)\n                (list 1.0 0.0 0.0)  ; Degenerate triangle\n                (let* ([v-val (/ (- (* d11-val d20-val) (* d01-val d21-val)) denom-val)]\n                       [w-val (/ (- (* d00-val d21-val) (* d01-val d20-val)) denom-val)]\n                       [u-val (- 1.0 v-val w-val)])\n                      (list u-val v-val w-val))))))))))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (car bc) 1.0)) 0.01)\n(< (abs (cadr bc)) 0.01)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (barycentric-coords p a b c)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 Point3 (List Number Number Number)))\n  (doc 'description \"Compute barycentric coordinates (u, v, w) of point p with respect to triangle (a, b, c)\")\n  (doc 'note \"p = u*a + v*b + w*c where u + v + w = 1\")\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "chez-to-fold", "barycentric-coords"], "split": "train"}
{"id": "geometry_translation_207", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `barycentric-coords`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-barycentric-coords\n    (lambda (p a b c)\n      (let ([v0-val (vec3-sub b a)])\n               (let ([v1-val (vec3-sub c a)])\n               (let ([v2-val (vec3-sub p a)])\n               (let ([d00-val (vec3-dot v0-val v0-val)])\n               (let ([d01-val (vec3-dot v0-val v1-val)])\n               (let ([d11-val (vec3-dot v1-val v1-val)])\n               (let ([d20-val (vec3-dot v2-val v0-val)])\n               (let ([d21-val (vec3-dot v2-val v1-val)])\n               (let ([denom-val (- (* d00-val d11-val) (* d01-val d01-val))])\n               (if (< (abs denom-val) 1e-10)\n                  (list 1.0 0.0 0.0)  ; Degenerate triangle\n                  (let* ([v-val (/ (- (* d11-val d20-val) (* d01-val d21-val)) denom-val)]\n                         [w-val (/ (- (* d00-val d21-val) (* d01-val d20-val)) denom-val)]\n                         [u-val (- 1.0 v-val w-val)])\n                        (list u-val v-val w-val))))))))))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `barycentric-coords`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-barycentric-coords\n    (lambda (p a b c)\n      (let ([v0-val (vec3-sub b a)])\n               (let ([v1-val (vec3-sub c a)])\n               (let ([v2-val (vec3-sub p a)])\n               (let ([d00-val (vec3-dot v0-val v0-val)])\n               (let ([d01-val (vec3-dot v0-val v1-val)])\n               (let ([d11-val (vec3-dot v1-val v1-val)])\n               (let ([d20-val (vec3-dot v2-val v0-val)])\n               (let ([d21-val (vec3-dot v2-val v1-val)])\n               (let ([denom-val (- (* d00-val d11-val) (* d01-val d01-val))])\n               (if (< (abs denom-val) 1e-10)\n                  (list 1.0 0.0 0.0)  ; Degenerate triangle\n                  (let* ([v-val (/ (- (* d11-val d20-val) (* d01-val d21-val)) denom-val)]\n                         [w-val (/ (- (* d00-val d21-val) (* d01-val d20-val)) denom-val)]\n                         [u-val (- 1.0 v-val w-val)])\n                        (list u-val v-val w-val))))))))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (barycentric-coords p a b c)\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "barycentric-coords"], "split": "train"}
{"id": "geometry_translation_208", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle-normal`.\nReturn only the Scheme definition.\n\n```python\ndef triangle_normal(tri):\n    \"\"\"Compute face normal of triangle (counter-clockwise winding)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle-normal`.\nReturn only the Scheme definition.\n\n```python\ndef triangle_normal(tri):\n    \"\"\"Compute face normal of triangle (counter-clockwise winding)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (vec3-x n)) 0.001)\n(< (abs (vec3-y n)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle-normal tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (doc 'description \"Compute face normal (counter-clockwise winding)\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)])\n        (vec3-normalize (vec3-cross edge1 edge2))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle-normal"], "split": "train"}
{"id": "geometry_translation_209", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle-normal`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle-normal\n  (lambda (tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)])\n            (vec3-normalize (vec3-cross edge1 edge2)))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle-normal`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle-normal\n  (lambda (tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)])\n            (vec3-normalize (vec3-cross edge1 edge2)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (vec3-x n)) 0.001)\n(< (abs (vec3-y n)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle-normal tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (doc 'description \"Compute face normal (counter-clockwise winding)\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)])\n        (vec3-normalize (vec3-cross edge1 edge2))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle-normal"], "split": "train"}
{"id": "geometry_translation_210", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle-normal`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle-normal\n    (lambda (tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)])\n              (vec3-normalize (vec3-cross edge1 edge2)))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle-normal`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle-normal\n    (lambda (tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)])\n              (vec3-normalize (vec3-cross edge1 edge2)))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (vec3-x n)) 0.001)\n(< (abs (vec3-y n)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle-normal tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)])\n        (vec3-normalize (vec3-cross edge1 edge2))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle-normal"], "split": "train"}
{"id": "geometry_translation_211", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-merge`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_merge(b1, b2):\n    \"\"\"Compute minimal AABB containing both boxes\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-merge`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_merge(b1, b2):\n    \"\"\"Compute minimal AABB containing both boxes\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-merge b1 b2)\n  (doc 'export #t)\n  (doc 'type '(-> AABB AABB AABB))\n  (doc 'description \"Compute minimal AABB containing both boxes\")\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-merge"], "split": "train"}
{"id": "geometry_translation_212", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-merge`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-merge\n  (lambda (b1 b2)\n    (let ([min1 (aabb-min b1)]\n            [max1 (aabb-max b1)]\n            [min2 (aabb-min b2)]\n            [max2 (aabb-max b2)])\n           (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                       (min (vec3-y min1) (vec3-y min2))\n                       (min (vec3-z min1) (vec3-z min2)))\n                 (vec3 (max (vec3-x max1) (vec3-x max2))\n                       (max (vec3-y max1) (vec3-y max2))\n                       (max (vec3-z max1) (vec3-z max2)))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-merge`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-merge\n  (lambda (b1 b2)\n    (let ([min1 (aabb-min b1)]\n            [max1 (aabb-max b1)]\n            [min2 (aabb-min b2)]\n            [max2 (aabb-max b2)])\n           (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                       (min (vec3-y min1) (vec3-y min2))\n                       (min (vec3-z min1) (vec3-z min2)))\n                 (vec3 (max (vec3-x max1) (vec3-x max2))\n                       (max (vec3-y max1) (vec3-y max2))\n                       (max (vec3-z max1) (vec3-z max2)))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-merge b1 b2)\n  (doc 'export #t)\n  (doc 'type '(-> AABB AABB AABB))\n  (doc 'description \"Compute minimal AABB containing both boxes\")\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-merge"], "split": "train"}
{"id": "geometry_translation_213", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-merge`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-merge\n    (lambda (b1 b2)\n      (let ([min1 (aabb-min b1)]\n              [max1 (aabb-max b1)]\n              [min2 (aabb-min b2)]\n              [max2 (aabb-max b2)])\n             (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                         (min (vec3-y min1) (vec3-y min2))\n                         (min (vec3-z min1) (vec3-z min2)))\n                   (vec3 (max (vec3-x max1) (vec3-x max2))\n                         (max (vec3-y max1) (vec3-y max2))\n                         (max (vec3-z max1) (vec3-z max2)))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-merge`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-merge\n    (lambda (b1 b2)\n      (let ([min1 (aabb-min b1)]\n              [max1 (aabb-max b1)]\n              [min2 (aabb-min b2)]\n              [max2 (aabb-max b2)])\n             (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                         (min (vec3-y min1) (vec3-y min2))\n                         (min (vec3-z min1) (vec3-z min2)))\n                   (vec3 (max (vec3-x max1) (vec3-x max2))\n                         (max (vec3-y max1) (vec3-y max2))\n                         (max (vec3-z max1) (vec3-z max2)))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (aabb-merge b1 b2)\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-merge"], "split": "train"}
{"id": "geometry_translation_214", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-from-points`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_from_points(points):\n    \"\"\"Compute minimal AABB containing all points\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-from-points`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_from_points(points):\n    \"\"\"Compute minimal AABB containing all points\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x (aabb-min box)) -1)) 0.001)\n(< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-from-points points)\n  (doc 'export #t)\n  (doc 'type '(-> (List Point3) AABB))\n  (doc 'description \"Compute minimal AABB containing all points\")\n  (if (null? points)\n      (aabb (vec3-zero) (vec3-zero))\n      (let loop ([pts (cdr points)]\n                 [min-p (car points)]\n                 [max-p (car points)])\n           (if (null? pts)\n               (aabb min-p max-p)\n               (let ([p (car pts)])\n                    (loop (cdr pts)\n                          (vec3 (min (vec3-x min-p) (vec3-x p))\n                                (min (vec3-y min-p) (vec3-y p))\n                                (min (vec3-z min-p) (vec3-z p)))\n                          (vec3 (max (vec3-x max-p) (vec3-x p))\n                                (max (vec3-y max-p) (vec3-y p))\n                                (max (vec3-z max-p) (vec3-z p)))))))))", "verify_expr": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-from-points"], "split": "train"}
{"id": "geometry_translation_215", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-from-points`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-from-points\n  (lambda (points)\n    (if (null? points)\n          (aabb (vec3-zero) (vec3-zero))\n          (let loop ([pts (cdr points)]\n                     [min-p (car points)]\n                     [max-p (car points)])\n               (if (null? pts)\n                   (aabb min-p max-p)\n                   (let ([p (car pts)])\n                        (loop (cdr pts)\n                              (vec3 (min (vec3-x min-p) (vec3-x p))\n                                    (min (vec3-y min-p) (vec3-y p))\n                                    (min (vec3-z min-p) (vec3-z p)))\n                              (vec3 (max (vec3-x max-p) (vec3-x p))\n                                    (max (vec3-y max-p) (vec3-y p))\n                                    (max (vec3-z max-p) (vec3-z p))))))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-from-points`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-from-points\n  (lambda (points)\n    (if (null? points)\n          (aabb (vec3-zero) (vec3-zero))\n          (let loop ([pts (cdr points)]\n                     [min-p (car points)]\n                     [max-p (car points)])\n               (if (null? pts)\n                   (aabb min-p max-p)\n                   (let ([p (car pts)])\n                        (loop (cdr pts)\n                              (vec3 (min (vec3-x min-p) (vec3-x p))\n                                    (min (vec3-y min-p) (vec3-y p))\n                                    (min (vec3-z min-p) (vec3-z p)))\n                              (vec3 (max (vec3-x max-p) (vec3-x p))\n                                    (max (vec3-y max-p) (vec3-y p))\n                                    (max (vec3-z max-p) (vec3-z p))))))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x (aabb-min box)) -1)) 0.001)\n(< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-from-points points)\n  (doc 'export #t)\n  (doc 'type '(-> (List Point3) AABB))\n  (doc 'description \"Compute minimal AABB containing all points\")\n  (if (null? points)\n      (aabb (vec3-zero) (vec3-zero))\n      (let loop ([pts (cdr points)]\n                 [min-p (car points)]\n                 [max-p (car points)])\n           (if (null? pts)\n               (aabb min-p max-p)\n               (let ([p (car pts)])\n                    (loop (cdr pts)\n                          (vec3 (min (vec3-x min-p) (vec3-x p))\n                                (min (vec3-y min-p) (vec3-y p))\n                                (min (vec3-z min-p) (vec3-z p)))\n                          (vec3 (max (vec3-x max-p) (vec3-x p))\n                                (max (vec3-y max-p) (vec3-y p))\n                                (max (vec3-z max-p) (vec3-z p)))))))))", "verify_expr": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-from-points"], "split": "train"}
{"id": "geometry_translation_216", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-from-points`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-from-points\n    (lambda (points)\n      (if (null? points)\n            (aabb (vec3-zero) (vec3-zero))\n            (let loop ([pts (cdr points)]\n                       [min-p (car points)]\n                       [max-p (car points)])\n                 (if (null? pts)\n                     (aabb min-p max-p)\n                     (let ([p (car pts)])\n                          (loop (cdr pts)\n                                (vec3 (min (vec3-x min-p) (vec3-x p))\n                                      (min (vec3-y min-p) (vec3-y p))\n                                      (min (vec3-z min-p) (vec3-z p)))\n                                (vec3 (max (vec3-x max-p) (vec3-x p))\n                                      (max (vec3-y max-p) (vec3-y p))\n                                      (max (vec3-z max-p) (vec3-z p))))))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-from-points`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-from-points\n    (lambda (points)\n      (if (null? points)\n            (aabb (vec3-zero) (vec3-zero))\n            (let loop ([pts (cdr points)]\n                       [min-p (car points)]\n                       [max-p (car points)])\n                 (if (null? pts)\n                     (aabb min-p max-p)\n                     (let ([p (car pts)])\n                          (loop (cdr pts)\n                                (vec3 (min (vec3-x min-p) (vec3-x p))\n                                      (min (vec3-y min-p) (vec3-y p))\n                                      (min (vec3-z min-p) (vec3-z p)))\n                                (vec3 (max (vec3-x max-p) (vec3-x p))\n                                      (max (vec3-y max-p) (vec3-y p))\n                                      (max (vec3-z max-p) (vec3-z p))))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x (aabb-min box)) -1)) 0.001)\n(< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-from-points points)\n  (if (null? points)\n      (aabb (vec3-zero) (vec3-zero))\n      (let loop ([pts (cdr points)]\n                 [min-p (car points)]\n                 [max-p (car points)])\n           (if (null? pts)\n               (aabb min-p max-p)\n               (let ([p (car pts)])\n                    (loop (cdr pts)\n                          (vec3 (min (vec3-x min-p) (vec3-x p))\n                                (min (vec3-y min-p) (vec3-y p))\n                                (min (vec3-z min-p) (vec3-z p)))\n                          (vec3 (max (vec3-x max-p) (vec3-x p))\n                                (max (vec3-y max-p) (vec3-y p))\n                                (max (vec3-z max-p) (vec3-z p)))))))))", "verify_expr": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-from-points"], "split": "train"}
{"id": "geometry_translation_217", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `vec3-to-spherical`.\nReturn only the Scheme definition.\n\n```python\ndef vec3_to_spherical(v):\n    \"\"\"Convert Cartesian to spherical (r, θ, φ)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `vec3-to-spherical`.\nReturn only the Scheme definition.\n\n```python\ndef vec3_to_spherical(v):\n    \"\"\"Convert Cartesian to spherical (r, θ, φ)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (vec3-to-spherical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to spherical (r, θ, φ)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "vec3-to-spherical"], "split": "train"}
{"id": "geometry_translation_218", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `vec3-to-spherical`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-vec3-to-spherical\n  (lambda (v)\n    (let* ([x (vec3-x v)]\n             [y (vec3-y v)]\n             [z (vec3-z v)]\n             [r (vec3-length v)]\n             [theta (if (= r 0) 0 (acos (/ z r)))]\n             [phi (atan y x)])\n            (list r theta phi))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `vec3-to-spherical`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-vec3-to-spherical\n  (lambda (v)\n    (let* ([x (vec3-x v)]\n             [y (vec3-y v)]\n             [z (vec3-z v)]\n             [r (vec3-length v)]\n             [theta (if (= r 0) 0 (acos (/ z r)))]\n             [phi (atan y x)])\n            (list r theta phi))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (car sph) 1.0)) 0.001)\n(< (abs (- (cadr sph) 1.5708)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec3-to-spherical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to spherical (r, θ, φ)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "vec3-to-spherical"], "split": "train"}
{"id": "geometry_translation_219", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `vec3-to-spherical`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-vec3-to-spherical\n    (lambda (v)\n      (let* ([x (vec3-x v)]\n               [y (vec3-y v)]\n               [z (vec3-z v)]\n               [r (vec3-length v)]\n               [theta (if (= r 0) 0 (acos (/ z r)))]\n               [phi (atan y x)])\n              (list r theta phi))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `vec3-to-spherical`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-vec3-to-spherical\n    (lambda (v)\n      (let* ([x (vec3-x v)]\n               [y (vec3-y v)]\n               [z (vec3-z v)]\n               [r (vec3-length v)]\n               [theta (if (= r 0) 0 (acos (/ z r)))]\n               [phi (atan y x)])\n              (list r theta phi))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (car sph) 1.0)) 0.001)\n(< (abs (- (cadr sph) 1.5708)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (vec3-to-spherical v)\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "vec3-to-spherical"], "split": "train"}
{"id": "geometry_translation_220", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `vec3-to-cylindrical`.\nReturn only the Scheme definition.\n\n```python\ndef vec3_to_cylindrical(v):\n    \"\"\"Convert Cartesian to cylindrical (r, θ, z)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `vec3-to-cylindrical`.\nReturn only the Scheme definition.\n\n```python\ndef vec3_to_cylindrical(v):\n    \"\"\"Convert Cartesian to cylindrical (r, θ, z)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (car cyl) 1.0)) 0.001)\n(< (abs (cadr cyl)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (vec3-to-cylindrical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to cylindrical (r, θ, z)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [theta (atan y x)])\n        (list r theta z)))", "verify_expr": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "vec3-to-cylindrical"], "split": "train"}
{"id": "geometry_translation_221", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `vec3-to-cylindrical`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-vec3-to-cylindrical\n  (lambda (v)\n    (let* ([x (vec3-x v)]\n             [y (vec3-y v)]\n             [z (vec3-z v)]\n             [r (sqrt (+ (* x x) (* y y)))]\n             [theta (atan y x)])\n            (list r theta z))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `vec3-to-cylindrical`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-vec3-to-cylindrical\n  (lambda (v)\n    (let* ([x (vec3-x v)]\n             [y (vec3-y v)]\n             [z (vec3-z v)]\n             [r (sqrt (+ (* x x) (* y y)))]\n             [theta (atan y x)])\n            (list r theta z))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (car cyl) 1.0)) 0.001)\n(< (abs (cadr cyl)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (vec3-to-cylindrical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to cylindrical (r, θ, z)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [theta (atan y x)])\n        (list r theta z)))", "verify_expr": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "vec3-to-cylindrical"], "split": "train"}
{"id": "geometry_translation_222", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `vec3-to-cylindrical`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-vec3-to-cylindrical\n    (lambda (v)\n      (let* ([x (vec3-x v)]\n               [y (vec3-y v)]\n               [z (vec3-z v)]\n               [r (sqrt (+ (* x x) (* y y)))]\n               [theta (atan y x)])\n              (list r theta z))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `vec3-to-cylindrical`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-vec3-to-cylindrical\n    (lambda (v)\n      (let* ([x (vec3-x v)]\n               [y (vec3-y v)]\n               [z (vec3-z v)]\n               [r (sqrt (+ (* x x) (* y y)))]\n               [theta (atan y x)])\n              (list r theta z))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (vec3-to-cylindrical v)\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [theta (atan y x)])\n        (list r theta z)))", "verify_expr": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "vec3-to-cylindrical"], "split": "train"}
{"id": "geometry_bugfix_001", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point3` in `lattice/geometry/geometry.ss`.\nKnown issue: Constant/function alias replaced with #f.\n\n```scheme\n(define point3\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point3` in `lattice/geometry/geometry.ss`.\nKnown issue: Constant/function alias replaced with #f.\n\n```scheme\n(define point3\n  #f)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (vec3-x p) 1)\n(= (vec3-y p) 2)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define point3 vec3)", "verify_expr": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "tags": ["tier0", "geometry", "bugfix", "point3"], "split": "train"}
{"id": "geometry_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (line3 origin direction)\n  (list 'line3-broken origin direction))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (line3 origin direction)\n  (list 'line3-broken origin direction))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "bugfix", "line3"], "split": "train"}
{"id": "geometry_bugfix_003", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (line3? l)\n  (and (pair? l) (eq? (car l) 'line3-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (line3? l)\n  (and (pair? l) (eq? (car l) 'line3-broken)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(line3? (line3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (line3? '(not-a-line)))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(line3? (line3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (line3? '(not-a-line)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (line3? l)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "bugfix", "line3?"], "split": "train"}
{"id": "geometry_bugfix_004", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3-origin` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (line3-origin l)\n  (caddr l))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3-origin` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (line3-origin l)\n  (caddr l))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (line3-origin l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (cadr l))", "verify_expr": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "bugfix", "line3-origin"], "split": "train"}
{"id": "geometry_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3-direction` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (line3-direction l)\n  (cadr l))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3-direction` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (line3-direction l)\n  (cadr l))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "bugfix", "line3-direction"], "split": "train"}
{"id": "geometry_bugfix_006", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (ray3 origin direction)\n  (list 'ray3-broken origin direction))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (ray3 origin direction)\n  (list 'ray3-broken origin direction))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(ray3? r)\n(equal? (ray3-origin r) o)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (ray3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Ray3))\n  (doc 'description \"Half-infinite ray starting at origin going in direction\")\n  (list 'ray3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "tags": ["tier0", "geometry", "bugfix", "ray3"], "split": "train"}
{"id": "geometry_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3-broken)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "bugfix", "ray3?"], "split": "train"}
{"id": "geometry_bugfix_008", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-origin` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (ray3-origin r)\n  (caddr r))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-origin` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (ray3-origin r)\n  (caddr r))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (ray3-origin r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "bugfix", "ray3-origin"], "split": "train"}
{"id": "geometry_bugfix_009", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-direction` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (ray3-direction r)\n  (cadr r))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-direction` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (ray3-direction r)\n  (cadr r))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (ray3-direction r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (caddr r))", "verify_expr": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "tags": ["tier0", "geometry", "bugfix", "ray3-direction"], "split": "train"}
{"id": "geometry_bugfix_010", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-point-at` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector combination operator uses subtraction instead of addition.\n\n```scheme\n(define (ray3-point-at ray t)\n  (vec3-sub (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-point-at` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector combination operator uses subtraction instead of addition.\n\n```scheme\n(define (ray3-point-at ray t)\n  (vec3-sub (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (ray3-point-at ray t)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Number Point3))\n  (doc 'description \"Get point at parameter t along ray (t >= 0)\")\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "ray3-point-at"], "split": "train"}
{"id": "geometry_bugfix_011", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (plane3 normal d)\n  (list 'plane3-broken normal d))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (plane3 normal d)\n  (list 'plane3-broken normal d))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(plane3? pl)\n(equal? (plane3-normal pl) n)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (plane3 normal d)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Plane3))\n  (doc 'description \"Plane defined by normal·p + d = 0\")\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "bugfix", "plane3"], "split": "train"}
{"id": "geometry_bugfix_012", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (plane3? p)\n  (and (pair? p) (eq? (car p) 'plane3-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (plane3? p)\n  (and (pair? p) (eq? (car p) 'plane3-broken)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(plane3? (plane3 (vec3 0 1 0) 0))\n(not (plane3? '(not-a-plane)))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(plane3? (plane3 (vec3 0 1 0) 0))\n(not (plane3? '(not-a-plane)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (plane3? p)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? p) (eq? (car p) 'plane3)))", "verify_expr": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "tags": ["tier0", "geometry", "bugfix", "plane3?"], "split": "train"}
{"id": "geometry_bugfix_013", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (plane3-normal p)\n  (caddr p))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (plane3-normal p)\n  (caddr p))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (plane3-normal p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Vec3))\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "bugfix", "plane3-normal"], "split": "train"}
{"id": "geometry_bugfix_014", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-d` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (plane3-d p)\n  (cadr p))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-d` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (plane3-d p)\n  (cadr p))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (plane3-d p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Number))\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "bugfix", "plane3-d"], "split": "train"}
{"id": "geometry_bugfix_015", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-point-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (plane3-from-point-normal point normal)\n  (error 'plane3-from-point-normal \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-point-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (plane3-from-point-normal point normal)\n  (error 'plane3-from-point-normal \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Vec3 Plane3))\n  (doc 'description \"Create plane from point and normal\")\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  (error 'plane3-from-points \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  (error 'plane3-from-points \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "plane3-from-points"], "split": "train"}
{"id": "geometry_bugfix_017", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (triangle3 p1 p2 p3)\n  (list 'triangle3-broken p1 p2 p3))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (triangle3 p1 p2 p3)\n  (list 'triangle3-broken p1 p2 p3))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(triangle3? t)\n(equal? (triangle3-p1 t) p1)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(triangle3? t)\n(equal? (triangle3-p1 t) p1)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Vec3 Triangle3))\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "bugfix", "triangle3"], "split": "train"}
{"id": "geometry_bugfix_018", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (triangle3? t)\n  (and (pair? t) (eq? (car t) 'triangle3-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (triangle3? t)\n  (and (pair? t) (eq? (car t) 'triangle3-broken)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(triangle3?\n  (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0)))\n(not (triangle3? '(not-a-triangle)))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(triangle3?\n  (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0)))\n(not (triangle3? '(not-a-triangle)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (triangle3? t)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? t) (eq? (car t) 'triangle3)))", "verify_expr": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "tags": ["tier0", "geometry", "bugfix", "triangle3?"], "split": "train"}
{"id": "geometry_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p1` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (triangle3-p1 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p1` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (triangle3-p1 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "bugfix", "triangle3-p1"], "split": "train"}
{"id": "geometry_bugfix_020", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p2` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (triangle3-p2 t)\n  (cadr t))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p2` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (triangle3-p2 t)\n  (cadr t))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (triangle3-p2 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "bugfix", "triangle3-p2"], "split": "train"}
{"id": "geometry_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p3` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from fourth slot to third slot.\n\n```scheme\n(define (triangle3-p3 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p3` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from fourth slot to third slot.\n\n```scheme\n(define (triangle3-p3 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "bugfix", "triangle3-p3"], "split": "train"}
{"id": "geometry_bugfix_022", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (circle center radius)\n  (list 'circle-broken center radius))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (circle center radius)\n  (list 'circle-broken center radius))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(circle? ci)\n(equal? (circle-center ci) c)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (circle center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec2 Number Circle))\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "bugfix", "circle"], "split": "train"}
{"id": "geometry_bugfix_023", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (circle? c)\n  (and (pair? c) (eq? (car c) 'circle-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (circle? c)\n  (and (pair? c) (eq? (car c) 'circle-broken)))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(circle? (circle (vec3 0 0 0) 1))\n(not (circle? '(not-a-circle)))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(circle? (circle (vec3 0 0 0) 1))\n(not (circle? '(not-a-circle)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (circle? c)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "bugfix", "circle?"], "split": "train"}
{"id": "geometry_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (circle-center c)\n  (caddr c))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (circle-center c)\n  (caddr c))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "bugfix", "circle-center"], "split": "train"}
{"id": "geometry_bugfix_025", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle-radius` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (circle-radius c)\n  (cadr c))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle-radius` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (circle-radius c)\n  (cadr c))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (circle-radius c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Number))\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "bugfix", "circle-radius"], "split": "train"}
{"id": "geometry_bugfix_026", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (sphere center radius)\n  (list 'sphere-broken center radius))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (sphere center radius)\n  (list 'sphere-broken center radius))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (sphere center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Sphere))\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "bugfix", "sphere"], "split": "train"}
{"id": "geometry_bugfix_027", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (sphere? s)\n  (and (pair? s) (eq? (car s) 'sphere-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (sphere? s)\n  (and (pair? s) (eq? (car s) 'sphere-broken)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(sphere? (sphere (vec3 0 0 0) 1))\n(not (sphere? '(not-a-sphere)))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(sphere? (sphere (vec3 0 0 0) 1))\n(not (sphere? '(not-a-sphere)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sphere? s)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? s) (eq? (car s) 'sphere)))", "verify_expr": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "tags": ["tier0", "geometry", "bugfix", "sphere?"], "split": "train"}
{"id": "geometry_bugfix_028", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (sphere-center s)\n  (caddr s))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (sphere-center s)\n  (caddr s))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (sphere-center s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Vec3))\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "bugfix", "sphere-center"], "split": "train"}
{"id": "geometry_bugfix_029", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-radius` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (sphere-radius s)\n  (cadr s))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-radius` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (sphere-radius s)\n  (cadr s))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sphere-radius s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (caddr s))", "verify_expr": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "tags": ["tier0", "geometry", "bugfix", "sphere-radius"], "split": "train"}
{"id": "geometry_bugfix_030", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (aabb min-point max-point)\n  (list 'aabb-broken min-point max-point))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (aabb min-point max-point)\n  (list 'aabb-broken min-point max-point))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(aabb? b)\n(equal? (aabb-min b) mn)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(aabb? b)\n(equal? (aabb-min b) mn)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aabb min-point max-point)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 AABB))\n  (doc 'description \"Axis-Aligned Bounding Box from min/max corners\")\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "bugfix", "aabb"], "split": "train"}
{"id": "geometry_bugfix_031", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (aabb? b)\n  (and (pair? b) (eq? (car b) 'aabb-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (aabb? b)\n  (and (pair? b) (eq? (car b) 'aabb-broken)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (aabb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "bugfix", "aabb?"], "split": "train"}
{"id": "geometry_bugfix_032", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-min` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (aabb-min b)\n  (caddr b))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-min` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (aabb-min b)\n  (caddr b))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (aabb-min b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (cadr b))", "verify_expr": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "tags": ["tier0", "geometry", "bugfix", "aabb-min"], "split": "train"}
{"id": "geometry_bugfix_033", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-max` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (aabb-max b)\n  (cadr b))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-max` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (aabb-max b)\n  (cadr b))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (aabb-max b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "bugfix", "aabb-max"], "split": "train"}
{"id": "geometry_bugfix_034", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector combination operator uses subtraction instead of addition.\n\n```scheme\n(define (aabb-center box)\n  (vec3-scale (vec3-sub (aabb-min box) (aabb-max box)) 0.5))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector combination operator uses subtraction instead of addition.\n\n```scheme\n(define (aabb-center box)\n  (vec3-scale (vec3-sub (aabb-min box) (aabb-max box)) 0.5))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aabb-center box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Point3))\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "aabb-center"], "split": "train"}
{"id": "geometry_bugfix_035", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-extents` in `lattice/geometry/geometry.ss`.\nKnown issue: Midpoint/half-scale factor was changed from 0.5 to 1.0.\n\n```scheme\n(define (aabb-extents box)\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 1.0))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-extents` in `lattice/geometry/geometry.ss`.\nKnown issue: Midpoint/half-scale factor was changed from 0.5 to 1.0.\n\n```scheme\n(define (aabb-extents box)\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 1.0))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (aabb-extents box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (doc 'description \"Half-size in each dimension\")\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "aabb-extents"], "split": "train"}
{"id": "geometry_bugfix_036", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (obb center axes extents)\n  (list 'obb-broken center axes extents))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (obb center axes extents)\n  (list 'obb-broken center axes extents))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (obb center axes extents)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Vec3) Vec3 OBB))\n  (doc 'description \"Oriented Bounding Box from center, axes, and extents\")\n  (doc 'param 'axes \"list of 3 orthonormal vectors\")\n  (doc 'param 'extents \"vec3 of half-sizes along each axis\")\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "bugfix", "obb"], "split": "train"}
{"id": "geometry_bugfix_037", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (obb? b)\n  (and (pair? b) (eq? (car b) 'obb-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (obb? b)\n  (and (pair? b) (eq? (car b) 'obb-broken)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1)))\n(not (obb? '(not-an-obb)))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1)))\n(not (obb? '(not-an-obb)))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (obb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "bugfix", "obb?"], "split": "train"}
{"id": "geometry_bugfix_038", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (obb-center b)\n  (caddr b))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (obb-center b)\n  (caddr b))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (obb-center b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadr b))", "verify_expr": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "bugfix", "obb-center"], "split": "train"}
{"id": "geometry_bugfix_039", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb-axes` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (obb-axes b)\n  (cadr b))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb-axes` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (obb-axes b)\n  (cadr b))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (obb-axes b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB (List Vec3)))\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "bugfix", "obb-axes"], "split": "train"}
{"id": "geometry_bugfix_040", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb-extents` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from fourth slot to third slot.\n\n```scheme\n(define (obb-extents b)\n  (caddr b))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `obb-extents` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from fourth slot to third slot.\n\n```scheme\n(define (obb-extents b)\n  (caddr b))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (obb-extents b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "bugfix", "obb-extents"], "split": "train"}
{"id": "geometry_bugfix_041", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-identity` in `lattice/geometry/geometry.ss`.\nKnown issue: Constant/function alias replaced with #f.\n\n```scheme\n(define transform-identity\n  #f)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-identity` in `lattice/geometry/geometry.ss`.\nKnown issue: Constant/function alias replaced with #f.\n\n```scheme\n(define transform-identity\n  #f)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (- (vec3-y r) 2)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (transform-identity)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix))\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-identity"], "split": "train"}
{"id": "geometry_bugfix_042", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-translation v)\n  (error 'transform-translation \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-translation v)\n  (error 'transform-translation \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-translation"], "split": "train"}
{"id": "geometry_bugfix_043", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-scale s)\n  (error 'transform-scale \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-scale s)\n  (error 'transform-scale \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-scale"], "split": "train"}
{"id": "geometry_bugfix_044", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-x` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-x angle)\n  (error 'transform-rotation-x \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-x` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-x angle)\n  (error 'transform-rotation-x \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (transform-rotation-x angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (doc 'description \"Rotation around x-axis by angle (radians)\")\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-x"], "split": "train"}
{"id": "geometry_bugfix_045", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-y` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-y angle)\n  (error 'transform-rotation-y \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-y` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-y angle)\n  (error 'transform-rotation-y \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-rotation-y angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-y"], "split": "train"}
{"id": "geometry_bugfix_046", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-z` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-z angle)\n  (error 'transform-rotation-z \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-z` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-z angle)\n  (error 'transform-rotation-z \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-rotation-z angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-z"], "split": "train"}
{"id": "geometry_bugfix_047", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-axis` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-axis axis angle)\n  (error 'transform-rotation-axis \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-axis` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-rotation-axis axis angle)\n  (error 'transform-rotation-axis \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Matrix))\n  (doc 'description \"Rotation around arbitrary axis by angle (Rodriguez formula)\")\n  (doc 'note \"Returns identity matrix if axis is zero vector\")\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_bugfix_048", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-from-quaternion` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-from-quaternion q)\n  (error 'transform-from-quaternion \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-from-quaternion` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-from-quaternion q)\n  (error 'transform-from-quaternion \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (transform-from-quaternion q)\n  (doc 'export #t)\n  (doc 'type '(-> Quaternion Matrix))\n  (doc 'description \"Convert quaternion to 4x4 transformation matrix\")\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-from-quaternion"], "split": "train"}
{"id": "geometry_bugfix_049", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-point mat p)\n  (error 'transform-point \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-point mat p)\n  (error 'transform-point \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x r) 6)) 0.001)\n(< (abs (- (vec3-y r) 12)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-point mat p)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Point3 Point3))\n  (doc 'description \"Apply transformation to point (with translation)\")\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-point"], "split": "train"}
{"id": "geometry_bugfix_050", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-vector mat v)\n  (error 'transform-vector \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-vector mat v)\n  (error 'transform-vector \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-vector"], "split": "eval"}
{"id": "geometry_bugfix_051", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-point p1 p2)\n  (error 'distance-point-point \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-point p1 p2)\n  (error 'distance-point-point \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-point"], "split": "eval"}
{"id": "geometry_bugfix_052", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-plane point plane)\n  (error 'distance-point-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-plane point plane)\n  (error 'distance-point-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-plane"], "split": "eval"}
{"id": "geometry_bugfix_053", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-line point line)\n  (error 'distance-point-line \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-line point line)\n  (error 'distance-point-line \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-line"], "split": "eval"}
{"id": "geometry_bugfix_054", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  (error 'distance-point-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  (error 'distance-point-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_bugfix_055", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  (error 'intersect-ray-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  (error 'intersect-ray-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_bugfix_056", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  (error 'intersect-ray-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  (error 'intersect-ray-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_bugfix_057", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (caddr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (caddr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\nres\n(list? res)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_bugfix_058", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 0.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 0.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_bugfix_059", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  (error 'point-in-sphere? \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  (error 'point-in-sphere? \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "bugfix", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_bugfix_060", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-aabb? point box)\n  (error 'point-in-aabb? \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-aabb? point box)\n  (error 'point-in-aabb? \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "bugfix", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_bugfix_061", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 0.0001))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 0.0001))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "bugfix", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_bugfix_062", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector combination operator uses subtraction instead of addition.\n\n```scheme\n(define (closest-point-on-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-sub origin (vec3-scale dir t))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector combination operator uses subtraction instead of addition.\n\n```scheme\n(define (closest-point-on-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-sub origin (vec3-scale dir t))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (closest-point-on-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Point3))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "closest-point-on-line"], "split": "train"}
{"id": "geometry_bugfix_063", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector difference operator uses addition instead of subtraction.\n\n```scheme\n(define (closest-point-on-plane point plane)\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-add point (vec3-scale normal dist))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Vector difference operator uses addition instead of subtraction.\n\n```scheme\n(define (closest-point-on-plane point plane)\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-add point (vec3-scale normal dist))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Point3))\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "closest-point-on-plane"], "split": "train"}
{"id": "geometry_bugfix_064", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  (error 'closest-point-on-aabb \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  (error 'closest-point-on-aabb \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "closest-point-on-aabb"], "split": "train"}
{"id": "geometry_bugfix_065", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle-area` in `lattice/geometry/geometry.ss`.\nKnown issue: Midpoint/half-scale factor was changed from 0.5 to 1.0.\n\n```scheme\n(define (triangle-area tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 1.0 (vec3-length cross))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle-area` in `lattice/geometry/geometry.ss`.\nKnown issue: Midpoint/half-scale factor was changed from 0.5 to 1.0.\n\n```scheme\n(define (triangle-area tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 1.0 (vec3-length cross))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (triangle-area tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Number))\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [cross (vec3-cross edge1 edge2)])\n        (* 0.5 (vec3-length cross))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "triangle-area"], "split": "train"}
{"id": "geometry_bugfix_066", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-volume` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (sphere-volume sphere)\n  (error 'sphere-volume \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-volume` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (sphere-volume sphere)\n  (error 'sphere-volume \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sphere-volume sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "sphere-volume"], "split": "train"}
{"id": "geometry_bugfix_067", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-surface-area` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (sphere-surface-area sphere)\n  (error 'sphere-surface-area \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `sphere-surface-area` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (sphere-surface-area sphere)\n  (error 'sphere-surface-area \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (sphere-surface-area sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* 4.0 3.141592653589793 r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "sphere-surface-area"], "split": "train"}
{"id": "geometry_bugfix_068", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-volume` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-volume box)\n  (error 'aabb-volume \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-volume` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-volume box)\n  (error 'aabb-volume \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "aabb-volume"], "split": "train"}
{"id": "geometry_bugfix_069", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `barycentric-coords` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (barycentric-coords p a b c)\n  (error 'barycentric-coords \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `barycentric-coords` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (barycentric-coords p a b c)\n  (error 'barycentric-coords \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (car bc) 1.0)) 0.01)\n(< (abs (cadr bc)) 0.01)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (car bc) 1.0)) 0.01)\n(< (abs (cadr bc)) 0.01)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (barycentric-coords p a b c)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 Point3 (List Number Number Number)))\n  (doc 'description \"Compute barycentric coordinates (u, v, w) of point p with respect to triangle (a, b, c)\")\n  (doc 'note \"p = u*a + v*b + w*c where u + v + w = 1\")\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "bugfix", "barycentric-coords"], "split": "train"}
{"id": "geometry_bugfix_070", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (triangle-normal tri)\n  (error 'triangle-normal \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (triangle-normal tri)\n  (error 'triangle-normal \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (vec3-x n)) 0.001)\n(< (abs (vec3-y n)) 0.001)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (vec3-x n)) 0.001)\n(< (abs (vec3-y n)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (triangle-normal tri)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (doc 'description \"Compute face normal (counter-clockwise winding)\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)])\n        (vec3-normalize (vec3-cross edge1 edge2))))", "verify_expr": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "triangle-normal"], "split": "train"}
{"id": "geometry_bugfix_071", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-merge` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-merge b1 b2)\n  (error 'aabb-merge \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-merge` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-merge b1 b2)\n  (error 'aabb-merge \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aabb-merge b1 b2)\n  (doc 'export #t)\n  (doc 'type '(-> AABB AABB AABB))\n  (doc 'description \"Compute minimal AABB containing both boxes\")\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "aabb-merge"], "split": "train"}
{"id": "geometry_bugfix_072", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-from-points points)\n  (error 'aabb-from-points \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-from-points points)\n  (error 'aabb-from-points \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x (aabb-min box)) -1)) 0.001)\n(< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aabb-from-points points)\n  (doc 'export #t)\n  (doc 'type '(-> (List Point3) AABB))\n  (doc 'description \"Compute minimal AABB containing all points\")\n  (if (null? points)\n      (aabb (vec3-zero) (vec3-zero))\n      (let loop ([pts (cdr points)]\n                 [min-p (car points)]\n                 [max-p (car points)])\n           (if (null? pts)\n               (aabb min-p max-p)\n               (let ([p (car pts)])\n                    (loop (cdr pts)\n                          (vec3 (min (vec3-x min-p) (vec3-x p))\n                                (min (vec3-y min-p) (vec3-y p))\n                                (min (vec3-z min-p) (vec3-z p)))\n                          (vec3 (max (vec3-x max-p) (vec3-x p))\n                                (max (vec3-y max-p) (vec3-y p))\n                                (max (vec3-z max-p) (vec3-z p)))))))))", "verify_expr": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "aabb-from-points"], "split": "train"}
{"id": "geometry_bugfix_073", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec3-to-spherical` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (vec3-to-spherical v)\n  (error 'vec3-to-spherical \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec3-to-spherical` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (vec3-to-spherical v)\n  (error 'vec3-to-spherical \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(< (abs (- (car sph) 1.0)) 0.001)\n(< (abs (- (cadr sph) 1.5708)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec3-to-spherical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to spherical (r, θ, φ)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "vec3-to-spherical"], "split": "train"}
{"id": "geometry_bugfix_074", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec3-to-cylindrical` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (vec3-to-cylindrical v)\n  (error 'vec3-to-cylindrical \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `vec3-to-cylindrical` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (vec3-to-cylindrical v)\n  (error 'vec3-to-cylindrical \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (car cyl) 1.0)) 0.001)\n(< (abs (cadr cyl)) 0.001)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (car cyl) 1.0)) 0.001)\n(< (abs (cadr cyl)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (vec3-to-cylindrical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to cylindrical (r, θ, z)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (sqrt (+ (* x x) (* y y)))]\n         [theta (atan y x)])\n        (list r theta z)))", "verify_expr": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "vec3-to-cylindrical"], "split": "train"}
{"id": "geometry_bugfix_075", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-point-at` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (ray3-point-at ray t)\n  (error 'ray3-point-at \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3-point-at` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (ray3-point-at ray t)\n  (error 'ray3-point-at \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (ray3-point-at ray t)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Number Point3))\n  (doc 'description \"Get point at parameter t along ray (t >= 0)\")\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "ray3-point-at"], "split": "train"}
{"id": "geometry_bugfix_076", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-point-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (plane3-from-point-normal point normal)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-point-normal` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (plane3-from-point-normal point normal)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(plane3? pl)\n(< (abs (- (plane3-d pl) -5)) 0.001)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (plane3-from-point-normal point normal)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Vec3 Plane3))\n  (doc 'description \"Create plane from point and normal\")\n  (let ([d (- (vec3-dot normal point))])\n       (plane3 normal d)))", "verify_expr": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "plane3-from-point-normal"], "split": "train"}
{"id": "geometry_bugfix_077", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  p1)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  p1)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "plane3-from-points"], "split": "train"}
{"id": "geometry_bugfix_078", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Midpoint/half-scale factor was changed from 0.5 to 1.0.\n\n```scheme\n(define (aabb-center box)\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 1.0))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Midpoint/half-scale factor was changed from 0.5 to 1.0.\n\n```scheme\n(define (aabb-center box)\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 1.0))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (aabb-center box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Point3))\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "aabb-center"], "split": "train"}
{"id": "geometry_bugfix_079", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-extents` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-extents box)\n  (error 'aabb-extents \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-extents` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-extents box)\n  (error 'aabb-extents \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aabb-extents box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (doc 'description \"Half-size in each dimension\")\n  (vec3-scale (vec3-sub (aabb-max box) (aabb-min box)) 0.5))", "verify_expr": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "aabb-extents"], "split": "train"}
{"id": "geometry_bugfix_080", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-identity` in `lattice/geometry/geometry.ss`.\nKnown issue: Alias replaced with an erroring lambda.\n\n```scheme\n(define transform-identity\n  (lambda args (error 'transform-identity \"intentional bug\")))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-identity` in `lattice/geometry/geometry.ss`.\nKnown issue: Alias replaced with an erroring lambda.\n\n```scheme\n(define transform-identity\n  (lambda args (error 'transform-identity \"intentional bug\")))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (- (vec3-y r) 2)) 0.001)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (- (vec3-y r) 2)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-identity)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix))\n  (matrix-from-lists '((1 0 0 0)\n                       (0 1 0 0)\n                       (0 0 1 0)\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-identity"], "split": "train"}
{"id": "geometry_bugfix_081", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-translation v)\n  v)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-translation v)\n  v)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-translation"], "split": "train"}
{"id": "geometry_bugfix_082", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-scale s)\n  s)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-scale s)\n  s)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-scale"], "split": "train"}
{"id": "geometry_bugfix_083", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-x` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-x angle)\n  angle)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-x` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-x angle)\n  angle)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (transform-rotation-x angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (doc 'description \"Rotation around x-axis by angle (radians)\")\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((1 0 0 0)\n                            (0 ,c ,(- s) 0)\n                            (0 ,s ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-x"], "split": "train"}
{"id": "geometry_bugfix_084", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-y` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-y angle)\n  angle)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-y` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-y angle)\n  angle)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (transform-rotation-y angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-y"], "split": "train"}
{"id": "geometry_bugfix_085", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-z` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-z angle)\n  angle)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-z` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-z angle)\n  angle)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-rotation-z angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-z"], "split": "train"}
{"id": "geometry_bugfix_086", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-axis` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-axis axis angle)\n  axis)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-rotation-axis` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-rotation-axis axis angle)\n  axis)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-rotation-axis axis angle)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Matrix))\n  (doc 'description \"Rotation around arbitrary axis by angle (Rodriguez formula)\")\n  (doc 'note \"Returns identity matrix if axis is zero vector\")\n  (let ([mag (vec3-magnitude axis)])\n       (if (< mag 1e-10)\n           ; Zero axis: return identity transformation\n           (transform-identity)\n           (let* ([ax (vec3-scale-inv axis mag)]\n                  [x (vec3-x ax)]\n                  [y (vec3-y ax)]\n                  [z (vec3-z ax)]\n                  [c (cos angle)]\n                  [s (sin angle)]\n                  [t (- 1 c)])\n                 (matrix-from-lists\n                  `((,(+ (* t x x) c)      ,(- (* t x y) (* s z)) ,(+ (* t x z) (* s y)) 0)\n                    (,(+ (* t x y) (* s z)) ,(+ (* t y y) c)      ,(- (* t y z) (* s x)) 0)\n                    (,(- (* t x z) (* s y)) ,(+ (* t y z) (* s x)) ,(+ (* t z z) c)      0)\n                    (0                     0                     0                     1)))))))", "verify_expr": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-rotation-axis"], "split": "train"}
{"id": "geometry_bugfix_087", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-from-quaternion` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-from-quaternion q)\n  q)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-from-quaternion` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-from-quaternion q)\n  q)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-from-quaternion q)\n  (doc 'export #t)\n  (doc 'type '(-> Quaternion Matrix))\n  (doc 'description \"Convert quaternion to 4x4 transformation matrix\")\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-from-quaternion"], "split": "train"}
{"id": "geometry_bugfix_088", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-point mat p)\n  mat)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-point mat p)\n  mat)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 6)) 0.001)\n(< (abs (- (vec3-y r) 12)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-point mat p)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Point3 Point3))\n  (doc 'description \"Apply transformation to point (with translation)\")\n  (let ([x (vec3-x p)]\n        [y (vec3-y p)]\n        [z (vec3-z p)])\n       (let ([nx (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z)\n                    (matrix-ref mat 0 3))]\n             [ny (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z)\n                    (matrix-ref mat 1 3))]\n             [nz (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z)\n                    (matrix-ref mat 2 3))]\n             [nw (+ (* (matrix-ref mat 3 0) x)\n                    (* (matrix-ref mat 3 1) y)\n                    (* (matrix-ref mat 3 2) z)\n                    (matrix-ref mat 3 3))])\n            (cond\n             [(< (abs nw) 1e-10)\n              (list 'error 'transform-point \"Point transformed to infinity (w=0)\")]\n             [(= nw 1)\n              (vec3 nx ny nz)]\n             [else\n              (vec3 (/ nx nw) (/ ny nw) (/ nz nw))]))))", "verify_expr": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-point"], "split": "train"}
{"id": "geometry_bugfix_089", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-vector mat v)\n  mat)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-vector mat v)\n  mat)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-vector"], "split": "eval"}
{"id": "geometry_bugfix_090", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-point p1 p2)\n  p1)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-point p1 p2)\n  p1)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-point"], "split": "eval"}
{"id": "geometry_bugfix_091", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-plane point plane)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-plane point plane)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-plane"], "split": "eval"}
{"id": "geometry_bugfix_092", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-line point line)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-line point line)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-line"], "split": "eval"}
{"id": "geometry_bugfix_093", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  point)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_bugfix_094", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ray)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ray)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_bugfix_095", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ray)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ray)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\nres\n(list? res)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_bugfix_096", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 0.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 0.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_bugfix_097", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (error 'intersect-ray-triangle \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (error 'intersect-ray-triangle \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_bugfix_098", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  point)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "bugfix", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_bugfix_099", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-aabb? point box)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-aabb? point box)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "bugfix", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_bugfix_100", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (error 'point-in-triangle? \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (error 'point-in-triangle? \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "bugfix", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point3` on representative inputs.\n\nEnsure `point3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point3` on representative inputs.\n\nEnsure `point3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "verify_expr": "(equal? (let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3))) #t)", "tags": ["tier0", "geometry", "composition", "point3", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_002", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `point3` that returns `'ok` when expected behavior holds.\n\nEnsure `point3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `point3` that returns `'ok` when expected behavior holds.\n\nEnsure `point3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3))) 'ok 'bad)", "verify_expr": "(equal? (if (let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "point3", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3` on representative inputs.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3` on representative inputs.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "verify_expr": "(equal? (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d))) #t)", "tags": ["tier0", "geometry", "composition", "line3", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `line3` that returns `'ok` when expected behavior holds.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `line3` that returns `'ok` when expected behavior holds.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "line3", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_005", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3?` on representative inputs.\n\nEnsure `line3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3?` on representative inputs.\n\nEnsure `line3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "verify_expr": "(equal? (and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42))) #t)", "tags": ["tier0", "geometry", "composition", "line3?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_006", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `line3?` that returns `'ok` when expected behavior holds.\n\nEnsure `line3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `line3?` that returns `'ok` when expected behavior holds.\n\nEnsure `line3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42))) 'ok 'bad)", "verify_expr": "(equal? (if (and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "line3?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-origin` on representative inputs.\n\nEnsure `line3-origin` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-origin` on representative inputs.\n\nEnsure `line3-origin` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "verify_expr": "(equal? (equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3)) #t)", "tags": ["tier0", "geometry", "composition", "line3-origin", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_008", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `line3-origin` that returns `'ok` when expected behavior holds.\n\nEnsure `line3-origin` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `line3-origin` that returns `'ok` when expected behavior holds.\n\nEnsure `line3-origin` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "line3-origin", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-direction` on representative inputs.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-direction` on representative inputs.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "verify_expr": "(equal? (equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1)) #t)", "tags": ["tier0", "geometry", "composition", "line3-direction", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `line3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `line3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "line3-direction", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_011", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3` on representative inputs.\n\nEnsure `ray3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3` on representative inputs.\n\nEnsure `ray3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d)))", "verify_expr": "(equal? (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d))) #t)", "tags": ["tier0", "geometry", "composition", "ray3", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3?` on representative inputs.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3?` on representative inputs.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "verify_expr": "(equal? (and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3))) #t)", "tags": ["tier0", "geometry", "composition", "ray3?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3?` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3?` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3))) 'ok 'bad)", "verify_expr": "(equal? (if (and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_015", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3-origin` on representative inputs.\n\nEnsure `ray3-origin` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3-origin` on representative inputs.\n\nEnsure `ray3-origin` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "verify_expr": "(equal? (equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5)) #t)", "tags": ["tier0", "geometry", "composition", "ray3-origin", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_016", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3-origin` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-origin` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3-origin` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-origin` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3-origin", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_017", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3-direction` on representative inputs.\n\nEnsure `ray3-direction` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3-direction` on representative inputs.\n\nEnsure `ray3-direction` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0))", "verify_expr": "(equal? (equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0)) #t)", "tags": ["tier0", "geometry", "composition", "ray3-direction", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-direction` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-direction` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3-direction", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_019", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3-point-at` on representative inputs.\n\nEnsure `ray3-point-at` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3-point-at` on representative inputs.\n\nEnsure `ray3-point-at` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "verify_expr": "(equal? (let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "ray3-point-at", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_020", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3-point-at` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-point-at` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3-point-at` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-point-at` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3-point-at", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_021", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3` on representative inputs.\n\nEnsure `plane3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3` on representative inputs.\n\nEnsure `plane3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "verify_expr": "(equal? (let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5))) #t)", "tags": ["tier0", "geometry", "composition", "plane3", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_022", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_023", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3?` on representative inputs.\n\nEnsure `plane3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3?` on representative inputs.\n\nEnsure `plane3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14)))", "verify_expr": "(equal? (and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14))) #t)", "tags": ["tier0", "geometry", "composition", "plane3?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3?` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3?` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14))) 'ok 'bad)", "verify_expr": "(equal? (if (and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3?", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_025", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-normal` on representative inputs.\n\nEnsure `plane3-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-normal` on representative inputs.\n\nEnsure `plane3-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "verify_expr": "(equal? (equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0)) #t)", "tags": ["tier0", "geometry", "composition", "plane3-normal", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_026", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3-normal", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_027", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-d` on representative inputs.\n\nEnsure `plane3-d` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-d` on representative inputs.\n\nEnsure `plane3-d` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "verify_expr": "(equal? (= (plane3-d (plane3 (vec3 0 1 0) 10)) 10) #t)", "tags": ["tier0", "geometry", "composition", "plane3-d", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_028", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3-d` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-d` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3-d` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-d` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (= (plane3-d (plane3 (vec3 0 1 0) 10)) 10) 'ok 'bad)", "verify_expr": "(equal? (if (= (plane3-d (plane3 (vec3 0 1 0) 10)) 10) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3-d", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_029", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-from-point-normal` on representative inputs.\n\nEnsure `plane3-from-point-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-from-point-normal` on representative inputs.\n\nEnsure `plane3-from-point-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001)))", "verify_expr": "(equal? (let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "plane3-from-point-normal", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-point-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-point-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-point-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-point-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3-from-point-normal", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-from-points` on representative inputs.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-from-points` on representative inputs.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "verify_expr": "(equal? (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "plane3-from-points", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3-from-points", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_033", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3` on representative inputs.\n\nEnsure `triangle3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3` on representative inputs.\n\nEnsure `triangle3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "verify_expr": "(equal? (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3))) #t)", "tags": ["tier0", "geometry", "composition", "triangle3", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_034", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle3` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle3` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle3", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_035", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3?` on representative inputs.\n\nEnsure `triangle3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3?` on representative inputs.\n\nEnsure `triangle3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "verify_expr": "(equal? (and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle)))) #t)", "tags": ["tier0", "geometry", "composition", "triangle3?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_036", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle3?` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle3?` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle)))) 'ok 'bad)", "verify_expr": "(equal? (if (and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle)))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle3?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_037", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p1` on representative inputs.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p1` on representative inputs.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "verify_expr": "(equal? (equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3)) #t)", "tags": ["tier0", "geometry", "composition", "triangle3-p1", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_038", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p1` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p1` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle3-p1", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_039", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p2` on representative inputs.\n\nEnsure `triangle3-p2` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p2` on representative inputs.\n\nEnsure `triangle3-p2` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "verify_expr": "(equal? (equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6)) #t)", "tags": ["tier0", "geometry", "composition", "triangle3-p2", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_040", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p2` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p2` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p2` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p2` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle3-p2", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_041", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p3` on representative inputs.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p3` on representative inputs.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "verify_expr": "(equal? (equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9)) #t)", "tags": ["tier0", "geometry", "composition", "triangle3-p3", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_042", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p3` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p3` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle3-p3", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_043", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle` on representative inputs.\n\nEnsure `circle` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle` on representative inputs.\n\nEnsure `circle` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "verify_expr": "(equal? (let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r))) #t)", "tags": ["tier0", "geometry", "composition", "circle", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_044", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `circle` that returns `'ok` when expected behavior holds.\n\nEnsure `circle` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `circle` that returns `'ok` when expected behavior holds.\n\nEnsure `circle` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "circle", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_045", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle?` on representative inputs.\n\nEnsure `circle?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle?` on representative inputs.\n\nEnsure `circle?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "verify_expr": "(equal? (and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42))) #t)", "tags": ["tier0", "geometry", "composition", "circle?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_046", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `circle?` that returns `'ok` when expected behavior holds.\n\nEnsure `circle?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `circle?` that returns `'ok` when expected behavior holds.\n\nEnsure `circle?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42))) 'ok 'bad)", "verify_expr": "(equal? (if (and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "circle?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_047", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-center` on representative inputs.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-center` on representative inputs.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "verify_expr": "(equal? (equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0)) #t)", "tags": ["tier0", "geometry", "composition", "circle-center", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_048", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `circle-center` that returns `'ok` when expected behavior holds.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `circle-center` that returns `'ok` when expected behavior holds.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "circle-center", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_049", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-radius` on representative inputs.\n\nEnsure `circle-radius` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-radius` on representative inputs.\n\nEnsure `circle-radius` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "verify_expr": "(equal? (= (circle-radius (circle (vec3 0 0 0) 7)) 7) #t)", "tags": ["tier0", "geometry", "composition", "circle-radius", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_050", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `circle-radius` that returns `'ok` when expected behavior holds.\n\nEnsure `circle-radius` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `circle-radius` that returns `'ok` when expected behavior holds.\n\nEnsure `circle-radius` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (= (circle-radius (circle (vec3 0 0 0) 7)) 7) 'ok 'bad)", "verify_expr": "(equal? (if (= (circle-radius (circle (vec3 0 0 0) 7)) 7) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "circle-radius", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_051", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere` on representative inputs.\n\nEnsure `sphere` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere` on representative inputs.\n\nEnsure `sphere` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "verify_expr": "(equal? (let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r))) #t)", "tags": ["tier0", "geometry", "composition", "sphere", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_052", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `sphere` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `sphere` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "sphere", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_053", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere?` on representative inputs.\n\nEnsure `sphere?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere?` on representative inputs.\n\nEnsure `sphere?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "verify_expr": "(equal? (and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere))) #t)", "tags": ["tier0", "geometry", "composition", "sphere?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_054", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `sphere?` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `sphere?` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere))) 'ok 'bad)", "verify_expr": "(equal? (if (and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "sphere?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_055", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-center` on representative inputs.\n\nEnsure `sphere-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-center` on representative inputs.\n\nEnsure `sphere-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "verify_expr": "(equal? (equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5)) #t)", "tags": ["tier0", "geometry", "composition", "sphere-center", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_056", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `sphere-center` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `sphere-center` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "sphere-center", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_057", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-radius` on representative inputs.\n\nEnsure `sphere-radius` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-radius` on representative inputs.\n\nEnsure `sphere-radius` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(= (sphere-radius (sphere (vec3 0 0 0) 15)) 15)", "verify_expr": "(equal? (= (sphere-radius (sphere (vec3 0 0 0) 15)) 15) #t)", "tags": ["tier0", "geometry", "composition", "sphere-radius", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_058", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `sphere-radius` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-radius` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `sphere-radius` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-radius` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (= (sphere-radius (sphere (vec3 0 0 0) 15)) 15) 'ok 'bad)", "verify_expr": "(equal? (if (= (sphere-radius (sphere (vec3 0 0 0) 15)) 15) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "sphere-radius", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_059", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb` on representative inputs.\n\nEnsure `aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb` on representative inputs.\n\nEnsure `aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "verify_expr": "(equal? (let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx))) #t)", "tags": ["tier0", "geometry", "composition", "aabb", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_060", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_061", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb?` on representative inputs.\n\nEnsure `aabb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb?` on representative inputs.\n\nEnsure `aabb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "verify_expr": "(equal? (and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb))) #t)", "tags": ["tier0", "geometry", "composition", "aabb?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_062", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb?` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb?` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb))) 'ok 'bad)", "verify_expr": "(equal? (if (and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_063", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-min` on representative inputs.\n\nEnsure `aabb-min` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-min` on representative inputs.\n\nEnsure `aabb-min` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5))", "verify_expr": "(equal? (equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5)) #t)", "tags": ["tier0", "geometry", "composition", "aabb-min", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_064", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-min` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-min` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-min` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-min` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-min", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_065", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-max` on representative inputs.\n\nEnsure `aabb-max` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-max` on representative inputs.\n\nEnsure `aabb-max` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "verify_expr": "(equal? (equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5)) #t)", "tags": ["tier0", "geometry", "composition", "aabb-max", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_066", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-max` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-max` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-max` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-max` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-max", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_067", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-center` on representative inputs.\n\nEnsure `aabb-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-center` on representative inputs.\n\nEnsure `aabb-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "verify_expr": "(equal? (let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "aabb-center", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_068", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-center` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-center` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-center", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_069", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-extents` on representative inputs.\n\nEnsure `aabb-extents` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-extents` on representative inputs.\n\nEnsure `aabb-extents` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001))", "verify_expr": "(equal? (let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "aabb-extents", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_070", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-extents` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-extents` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-extents` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-extents` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-extents", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_071", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb` on representative inputs.\n\nEnsure `obb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb` on representative inputs.\n\nEnsure `obb` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "verify_expr": "(equal? (let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex))) #t)", "tags": ["tier0", "geometry", "composition", "obb", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_072", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `obb` that returns `'ok` when expected behavior holds.\n\nEnsure `obb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `obb` that returns `'ok` when expected behavior holds.\n\nEnsure `obb` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "obb", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_073", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb?` on representative inputs.\n\nEnsure `obb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb?` on representative inputs.\n\nEnsure `obb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "verify_expr": "(equal? (and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb)))) #t)", "tags": ["tier0", "geometry", "composition", "obb?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_074", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `obb?` that returns `'ok` when expected behavior holds.\n\nEnsure `obb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `obb?` that returns `'ok` when expected behavior holds.\n\nEnsure `obb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb)))) 'ok 'bad)", "verify_expr": "(equal? (if (and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb)))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "obb?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_075", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-center` on representative inputs.\n\nEnsure `obb-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-center` on representative inputs.\n\nEnsure `obb-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "verify_expr": "(equal? (equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3)) #t)", "tags": ["tier0", "geometry", "composition", "obb-center", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_076", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `obb-center` that returns `'ok` when expected behavior holds.\n\nEnsure `obb-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `obb-center` that returns `'ok` when expected behavior holds.\n\nEnsure `obb-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "obb-center", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_077", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-axes` on representative inputs.\n\nEnsure `obb-axes` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-axes` on representative inputs.\n\nEnsure `obb-axes` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "verify_expr": "(equal? (let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax)) #t)", "tags": ["tier0", "geometry", "composition", "obb-axes", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_078", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `obb-axes` that returns `'ok` when expected behavior holds.\n\nEnsure `obb-axes` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `obb-axes` that returns `'ok` when expected behavior holds.\n\nEnsure `obb-axes` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax)) 'ok 'bad)", "verify_expr": "(equal? (if (let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "obb-axes", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_079", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-extents` on representative inputs.\n\nEnsure `obb-extents` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-extents` on representative inputs.\n\nEnsure `obb-extents` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "verify_expr": "(equal? (equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5)) #t)", "tags": ["tier0", "geometry", "composition", "obb-extents", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_080", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `obb-extents` that returns `'ok` when expected behavior holds.\n\nEnsure `obb-extents` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `obb-extents` that returns `'ok` when expected behavior holds.\n\nEnsure `obb-extents` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "obb-extents", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_081", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-identity` on representative inputs.\n\nEnsure `transform-identity` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-identity` on representative inputs.\n\nEnsure `transform-identity` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-identity", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_082", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-identity` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-identity` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-identity` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-identity` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-identity", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_083", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-translation` on representative inputs.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-translation` on representative inputs.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-translation", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_084", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-translation` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-translation` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-translation", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_085", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-scale` on representative inputs.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-scale` on representative inputs.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-scale", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_086", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-scale` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-scale` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-scale", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_087", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-x` on representative inputs.\n\nEnsure `transform-rotation-x` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-x` on representative inputs.\n\nEnsure `transform-rotation-x` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "verify_expr": "(equal? (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-rotation-x", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_088", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-x` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-x` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-x` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-x` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-rotation-x", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_089", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-y` on representative inputs.\n\nEnsure `transform-rotation-y` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-y` on representative inputs.\n\nEnsure `transform-rotation-y` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "verify_expr": "(equal? (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-rotation-y", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_090", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-y` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-y` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-y` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-y` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-rotation-y", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_091", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-z` on representative inputs.\n\nEnsure `transform-rotation-z` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-z` on representative inputs.\n\nEnsure `transform-rotation-z` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "verify_expr": "(equal? (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-rotation-z", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_092", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-z` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-z` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-z` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-z` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-rotation-z", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_093", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-axis` on representative inputs.\n\nEnsure `transform-rotation-axis` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-axis` on representative inputs.\n\nEnsure `transform-rotation-axis` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "verify_expr": "(equal? (let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-rotation-axis", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_094", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-axis` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-axis` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-rotation-axis` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-rotation-axis` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-rotation-axis", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_095", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-from-quaternion` on representative inputs.\n\nEnsure `transform-from-quaternion` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-from-quaternion` on representative inputs.\n\nEnsure `transform-from-quaternion` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "verify_expr": "(equal? (let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-from-quaternion", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_096", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-from-quaternion` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-from-quaternion` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-from-quaternion` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-from-quaternion` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-from-quaternion", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_097", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-point` on representative inputs.\n\nEnsure `transform-point` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-point` on representative inputs.\n\nEnsure `transform-point` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-point", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_098", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-point` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-point` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-point` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-point` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-point", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_099", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-vector` on representative inputs.\n\nEnsure `transform-vector` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-vector` on representative inputs.\n\nEnsure `transform-vector` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-vector", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_100", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-vector` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-vector` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-vector` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-vector` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-vector", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_101", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-point` on representative inputs.\n\nEnsure `distance-point-point` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-point` on representative inputs.\n\nEnsure `distance-point-point` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "verify_expr": "(equal? (let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "distance-point-point", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_102", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `distance-point-point` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-point` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `distance-point-point` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-point` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "distance-point-point", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_103", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-plane` on representative inputs.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-plane` on representative inputs.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "verify_expr": "(equal? (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "distance-point-plane", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_104", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `distance-point-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `distance-point-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "distance-point-plane", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_105", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-line` on representative inputs.\n\nEnsure `distance-point-line` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-line` on representative inputs.\n\nEnsure `distance-point-line` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "verify_expr": "(equal? (let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "distance-point-line", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_106", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `distance-point-line` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-line` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `distance-point-line` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-line` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "distance-point-line", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_107", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-sphere` on representative inputs.\n\nEnsure `distance-point-sphere` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-sphere` on representative inputs.\n\nEnsure `distance-point-sphere` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "verify_expr": "(equal? (let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "distance-point-sphere", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_108", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `distance-point-sphere` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-sphere` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `distance-point-sphere` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-sphere` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "distance-point-sphere", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_109", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-plane` on representative inputs.\n\nEnsure `intersect-ray-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-plane` on representative inputs.\n\nEnsure `intersect-ray-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "verify_expr": "(equal? (let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "intersect-ray-plane", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_110", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "intersect-ray-plane", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_111", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-sphere` on representative inputs.\n\nEnsure `intersect-ray-sphere` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-sphere` on representative inputs.\n\nEnsure `intersect-ray-sphere` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "verify_expr": "(equal? (let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "intersect-ray-sphere", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_112", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-sphere` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-sphere` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-sphere` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-sphere` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "intersect-ray-sphere", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_113", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-aabb` on representative inputs.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-aabb` on representative inputs.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "verify_expr": "(equal? (let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "intersect-ray-aabb", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_114", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "intersect-ray-aabb", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_115", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-triangle` on representative inputs.\n\nEnsure `intersect-ray-triangle` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `intersect-ray-triangle` on representative inputs.\n\nEnsure `intersect-ray-triangle` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "verify_expr": "(equal? (let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "intersect-ray-triangle", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_116", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-triangle` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-triangle` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-triangle` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-triangle` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "intersect-ray-triangle", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_117", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-sphere?` on representative inputs.\n\nEnsure `point-in-sphere?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-sphere?` on representative inputs.\n\nEnsure `point-in-sphere?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "verify_expr": "(equal? (let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp)) #t)", "tags": ["tier0", "geometry", "composition", "point-in-sphere?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_118", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `point-in-sphere?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-sphere?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `point-in-sphere?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-sphere?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "point-in-sphere?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_119", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-aabb?` on representative inputs.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-aabb?` on representative inputs.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "verify_expr": "(equal? (let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box)) #t)", "tags": ["tier0", "geometry", "composition", "point-in-aabb?", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_120", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `point-in-aabb?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `point-in-aabb?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "point-in-aabb?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_121", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-triangle?` on representative inputs.\n\nEnsure `point-in-triangle?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-triangle?` on representative inputs.\n\nEnsure `point-in-triangle?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "verify_expr": "(equal? (let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri)) #t)", "tags": ["tier0", "geometry", "composition", "point-in-triangle?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_122", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `point-in-triangle?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-triangle?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `point-in-triangle?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-triangle?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "point-in-triangle?", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_123", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-line` on representative inputs.\n\nEnsure `closest-point-on-line` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-line` on representative inputs.\n\nEnsure `closest-point-on-line` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "verify_expr": "(equal? (let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "closest-point-on-line", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_124", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-line` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-line` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-line` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-line` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "closest-point-on-line", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_125", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-plane` on representative inputs.\n\nEnsure `closest-point-on-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-plane` on representative inputs.\n\nEnsure `closest-point-on-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "verify_expr": "(equal? (let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "closest-point-on-plane", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_126", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "closest-point-on-plane", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_127", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-aabb` on representative inputs.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-aabb` on representative inputs.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "verify_expr": "(equal? (let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "closest-point-on-aabb", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_128", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "closest-point-on-aabb", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_129", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle-area` on representative inputs.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle-area` on representative inputs.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001))", "verify_expr": "(equal? (let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "triangle-area", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_130", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle-area` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle-area` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([tri (triangle3 (vec3 0 0 0) (vec3 2 0 0) (vec3 0 2 0))] [a (triangle-area tri)]) (< (abs (- a 2.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle-area", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_131", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-volume` on representative inputs.\n\nEnsure `sphere-volume` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-volume` on representative inputs.\n\nEnsure `sphere-volume` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "verify_expr": "(equal? (let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "sphere-volume", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_132", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `sphere-volume` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-volume` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `sphere-volume` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-volume` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "sphere-volume", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_133", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-surface-area` on representative inputs.\n\nEnsure `sphere-surface-area` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-surface-area` on representative inputs.\n\nEnsure `sphere-surface-area` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "verify_expr": "(equal? (let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "sphere-surface-area", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_134", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `sphere-surface-area` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-surface-area` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `sphere-surface-area` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-surface-area` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "sphere-surface-area", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_135", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-volume` on representative inputs.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-volume` on representative inputs.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "verify_expr": "(equal? (let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "aabb-volume", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_136", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-volume` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-volume` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-volume", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_137", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `barycentric-coords` on representative inputs.\n\nEnsure `barycentric-coords` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `barycentric-coords` on representative inputs.\n\nEnsure `barycentric-coords` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "verify_expr": "(equal? (let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01))) #t)", "tags": ["tier0", "geometry", "composition", "barycentric-coords", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_138", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `barycentric-coords` that returns `'ok` when expected behavior holds.\n\nEnsure `barycentric-coords` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `barycentric-coords` that returns `'ok` when expected behavior holds.\n\nEnsure `barycentric-coords` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "barycentric-coords", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_139", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle-normal` on representative inputs.\n\nEnsure `triangle-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle-normal` on representative inputs.\n\nEnsure `triangle-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "verify_expr": "(equal? (let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "triangle-normal", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_140", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle-normal", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_141", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-merge` on representative inputs.\n\nEnsure `aabb-merge` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-merge` on representative inputs.\n\nEnsure `aabb-merge` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "verify_expr": "(equal? (let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "aabb-merge", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_142", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-merge` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-merge` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-merge` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-merge` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-merge", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_143", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-from-points` on representative inputs.\n\nEnsure `aabb-from-points` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-from-points` on representative inputs.\n\nEnsure `aabb-from-points` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001)))", "verify_expr": "(equal? (let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "aabb-from-points", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_144", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-from-points` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-from-points` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-from-points", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_145", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `vec3-to-spherical` on representative inputs.\n\nEnsure `vec3-to-spherical` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `vec3-to-spherical` on representative inputs.\n\nEnsure `vec3-to-spherical` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "verify_expr": "(equal? (let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "vec3-to-spherical", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_146", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `vec3-to-spherical` that returns `'ok` when expected behavior holds.\n\nEnsure `vec3-to-spherical` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `vec3-to-spherical` that returns `'ok` when expected behavior holds.\n\nEnsure `vec3-to-spherical` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "vec3-to-spherical", "behavior-signal", "auto-composition"], "split": "train"}
{"id": "geometry_composition_147", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `vec3-to-cylindrical` on representative inputs.\n\nEnsure `vec3-to-cylindrical` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `vec3-to-cylindrical` on representative inputs.\n\nEnsure `vec3-to-cylindrical` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001)))", "verify_expr": "(equal? (let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "vec3-to-cylindrical", "behavior-check", "auto-composition"], "split": "train"}
{"id": "geometry_composition_148", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `vec3-to-cylindrical` that returns `'ok` when expected behavior holds.\n\nEnsure `vec3-to-cylindrical` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `vec3-to-cylindrical` that returns `'ok` when expected behavior holds.\n\nEnsure `vec3-to-cylindrical` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "vec3-to-cylindrical", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_149", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nCast a +Z ray from z=-10 into an AABB and return the entry distance.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCast a +Z ray from z=-10 into an AABB and return the entry distance.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(car (intersect-ray-aabb (ray3 (vec3 0 0 -10) (vec3 0 0 1)) (aabb (vec3 -1 -1 -1) (vec3 1 1 1))))", "verify_expr": "(< (abs (- (car (intersect-ray-aabb (ray3 (vec3 0 0 -10) (vec3 0 0 1)) (aabb (vec3 -1 -1 -1) (vec3 1 1 1)))) 9.0)) 0.001)", "tags": ["tier0", "geometry", "composition", "intersect-ray-aabb", "ray-box", "entry-distance"], "split": "eval"}
{"id": "geometry_composition_150", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Compose geometry functions to solve this task.\n\nCreate a 3-4-5 right triangle in the XY plane and return its area.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCreate a 3-4-5 right triangle in the XY plane and return its area.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(triangle-area (triangle3 (vec3 0 0 0) (vec3 3 0 0) (vec3 0 4 0)))", "verify_expr": "(< (abs (- (triangle-area (triangle3 (vec3 0 0 0) (vec3 3 0 0) (vec3 0 4 0))) 6.0)) 0.001)", "tags": ["tier0", "geometry", "composition", "triangle-area", "triangle", "area"], "split": "eval"}
