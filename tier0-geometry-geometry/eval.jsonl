{"id": "geometry_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\nDescription: Infinite line through origin in direction\n\nWrite exactly one definition for `line3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\nDescription: Infinite line through origin in direction\n\nWrite exactly one definition for `line3`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "spec-to-code", "line3"], "split": "eval"}
{"id": "geometry_spec_to_code_005", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (line3 origin direction)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (line3 origin direction)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "skeleton-completion", "line3"], "split": "eval"}
{"id": "geometry_spec_to_code_006", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\n\nReturn only executable Scheme code for `line3` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\n\nReturn only executable Scheme code for `line3` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3 origin direction)\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "doc-free", "line3"], "split": "eval"}
{"id": "geometry_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\nDescription: Get direction of line3\n\nWrite exactly one definition for `line3-direction`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\nDescription: Get direction of line3\n\nWrite exactly one definition for `line3-direction`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "spec-to-code", "line3-direction"], "split": "eval"}
{"id": "geometry_spec_to_code_014", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (line3-direction l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3-direction`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (line3-direction l)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `line3-direction`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "skeleton-completion", "line3-direction"], "split": "eval"}
{"id": "geometry_spec_to_code_015", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\n\nReturn only executable Scheme code for `line3-direction` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\n\nReturn only executable Scheme code for `line3-direction` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3-direction l)\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "doc-free", "line3-direction"], "split": "eval"}
{"id": "geometry_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\nDescription: Return #t iff r is a ray3\n\nWrite exactly one definition for `ray3?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\nDescription: Return #t iff r is a ray3\n\nWrite exactly one definition for `ray3?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "spec-to-code", "ray3?"], "split": "eval"}
{"id": "geometry_spec_to_code_020", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3? r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (ray3? r)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `ray3?`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "skeleton-completion", "ray3?"], "split": "eval"}
{"id": "geometry_spec_to_code_021", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\n\nReturn only executable Scheme code for `ray3?` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\n\nReturn only executable Scheme code for `ray3?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "doc-free", "ray3?"], "split": "eval"}
{"id": "geometry_spec_to_code_046", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\nDescription: Create plane from three points (returns error if collinear)\n\nWrite exactly one definition for `plane3-from-points`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\nDescription: Create plane from three points (returns error if collinear)\n\nWrite exactly one definition for `plane3-from-points`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "plane3-from-points"], "split": "eval"}
{"id": "geometry_spec_to_code_047", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-from-points`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `plane3-from-points`.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "plane3-from-points"], "split": "eval"}
{"id": "geometry_spec_to_code_048", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\n\nReturn only executable Scheme code for `plane3-from-points` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\n\nReturn only executable Scheme code for `plane3-from-points` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "plane3-from-points"], "split": "eval"}
{"id": "geometry_spec_to_code_055", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\nDescription: Get first vertex of triangle3\n\nWrite exactly one definition for `triangle3-p1`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\nDescription: Get first vertex of triangle3\n\nWrite exactly one definition for `triangle3-p1`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3-p1"], "split": "eval"}
{"id": "geometry_spec_to_code_056", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p1 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p1`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p1 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p1`.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle3-p1"], "split": "eval"}
{"id": "geometry_spec_to_code_057", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\n\nReturn only executable Scheme code for `triangle3-p1` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\n\nReturn only executable Scheme code for `triangle3-p1` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle3-p1 t)\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "doc-free", "triangle3-p1"], "split": "eval"}
{"id": "geometry_spec_to_code_061", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\nDescription: Get third vertex of triangle3\n\nWrite exactly one definition for `triangle3-p3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\nDescription: Get third vertex of triangle3\n\nWrite exactly one definition for `triangle3-p3`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3-p3"], "split": "eval"}
{"id": "geometry_spec_to_code_062", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p3 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p3`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (triangle3-p3 t)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `triangle3-p3`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "skeleton-completion", "triangle3-p3"], "split": "eval"}
{"id": "geometry_spec_to_code_063", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\n\nReturn only executable Scheme code for `triangle3-p3` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p3`\nSignature: `(triangle3-p3 t)`\n\nReturn only executable Scheme code for `triangle3-p3` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (triangle3-p3 t)\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "doc-free", "triangle3-p3"], "split": "eval"}
{"id": "geometry_spec_to_code_070", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\nDescription: Get center of circle\n\nWrite exactly one definition for `circle-center`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\nDescription: Get center of circle\n\nWrite exactly one definition for `circle-center`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "spec-to-code", "circle-center"], "split": "eval"}
{"id": "geometry_spec_to_code_071", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (circle-center c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle-center`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (circle-center c)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `circle-center`.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "skeleton-completion", "circle-center"], "split": "eval"}
{"id": "geometry_spec_to_code_072", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\n\nReturn only executable Scheme code for `circle-center` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-center`\nSignature: `(circle-center c)`\n\nReturn only executable Scheme code for `circle-center` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle-center c)\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "doc-free", "circle-center"], "split": "eval"}
{"id": "geometry_spec_to_code_124", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\nDescription: Return 4x4 translation matrix\n\nWrite exactly one definition for `transform-translation`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\nDescription: Return 4x4 translation matrix\n\nWrite exactly one definition for `transform-translation`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-translation"], "split": "eval"}
{"id": "geometry_spec_to_code_125", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-translation v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-translation`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-translation v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-translation`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-translation"], "split": "eval"}
{"id": "geometry_spec_to_code_126", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\n\nReturn only executable Scheme code for `transform-translation` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\n\nReturn only executable Scheme code for `transform-translation` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-translation v)\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-translation"], "split": "eval"}
{"id": "geometry_spec_to_code_127", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\nDescription: Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\n\nWrite exactly one definition for `transform-scale`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\nDescription: Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\n\nWrite exactly one definition for `transform-scale`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-scale"], "split": "eval"}
{"id": "geometry_spec_to_code_128", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-scale s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-scale`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-scale s)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-scale`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-scale"], "split": "eval"}
{"id": "geometry_spec_to_code_129", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\n\nReturn only executable Scheme code for `transform-scale` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\n\nReturn only executable Scheme code for `transform-scale` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-scale s)\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-scale"], "split": "eval"}
{"id": "geometry_spec_to_code_154", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\nDescription: Return signed distance from point to plane (positive = in front)\n\nWrite exactly one definition for `distance-point-plane`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\nDescription: Return signed distance from point to plane (positive = in front)\n\nWrite exactly one definition for `distance-point-plane`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_155", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-plane`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-plane`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_156", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\n\nReturn only executable Scheme code for `distance-point-plane` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\n\nReturn only executable Scheme code for `distance-point-plane` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-plane point plane)\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_178", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\nDescription: Return #t iff point is inside or on aabb\n\nWrite exactly one definition for `point-in-aabb?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\nDescription: Return #t iff point is inside or on aabb\n\nWrite exactly one definition for `point-in-aabb?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "spec-to-code", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_179", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-aabb? point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-aabb?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-aabb? point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-aabb?`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "skeleton-completion", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_180", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\n\nReturn only executable Scheme code for `point-in-aabb?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\n\nReturn only executable Scheme code for `point-in-aabb?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-aabb? point box)\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "doc-free", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_190", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\nDescription: Return closest point on aabb to given point\n\nWrite exactly one definition for `closest-point-on-aabb`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\nDescription: Return closest point on aabb to given point\n\nWrite exactly one definition for `closest-point-on-aabb`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "closest-point-on-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_191", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-aabb`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `closest-point-on-aabb`.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "closest-point-on-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_192", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\n\nReturn only executable Scheme code for `closest-point-on-aabb` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-aabb`\nSignature: `(closest-point-on-aabb point box)`\n\nReturn only executable Scheme code for `closest-point-on-aabb` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "closest-point-on-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_202", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\nDescription: Return volume of aabb\n\nWrite exactly one definition for `aabb-volume`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\nDescription: Return volume of aabb\n\nWrite exactly one definition for `aabb-volume`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-volume"], "split": "eval"}
{"id": "geometry_spec_to_code_203", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-volume box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-volume`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (aabb-volume box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `aabb-volume`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "aabb-volume"], "split": "eval"}
{"id": "geometry_spec_to_code_204", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\n\nReturn only executable Scheme code for `aabb-volume` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\n\nReturn only executable Scheme code for `aabb-volume` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-volume box)\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "aabb-volume"], "split": "eval"}
{"id": "geometry_translation_004", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3`.\nReturn only the Scheme definition.\n\n```python\ndef line3(origin, direction):\n    \"\"\"Infinite line through origin in direction\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3`.\nReturn only the Scheme definition.\n\n```python\ndef line3(origin, direction):\n    \"\"\"Infinite line through origin in direction\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "python-to-scheme", "line3"], "split": "eval"}
{"id": "geometry_translation_005", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3\n  (lambda (origin direction)\n    (list 'line3 origin direction)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3\n  (lambda (origin direction)\n    (list 'line3 origin direction)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "chez-to-fold", "line3"], "split": "eval"}
{"id": "geometry_translation_006", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3\n    (lambda (origin direction)\n      (list 'line3 origin direction)\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3\n    (lambda (origin direction)\n      (list 'line3 origin direction)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (line3 origin direction)\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "line3"], "split": "eval"}
{"id": "geometry_translation_013", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3-direction`.\nReturn only the Scheme definition.\n\n```python\ndef line3_direction(l):\n    \"\"\"Get direction of line3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `line3-direction`.\nReturn only the Scheme definition.\n\n```python\ndef line3_direction(l):\n    \"\"\"Get direction of line3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "python-to-scheme", "line3-direction"], "split": "eval"}
{"id": "geometry_translation_014", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3-direction`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3-direction\n  (lambda (l)\n    (caddr l)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `line3-direction`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-line3-direction\n  (lambda (l)\n    (caddr l)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "chez-to-fold", "line3-direction"], "split": "eval"}
{"id": "geometry_translation_015", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3-direction`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3-direction\n    (lambda (l)\n      (caddr l)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `line3-direction`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-line3-direction\n    (lambda (l)\n      (caddr l)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (line3-direction l)\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "line3-direction"], "split": "eval"}
{"id": "geometry_translation_019", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3?`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_p(r):\n    \"\"\"Return #t iff r is a ray3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `ray3?`.\nReturn only the Scheme definition.\n\n```python\ndef ray3_p(r):\n    \"\"\"Return #t iff r is a ray3\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "python-to-scheme", "ray3?"], "split": "eval"}
{"id": "geometry_translation_020", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3?\n  (lambda (r)\n    (and (pair? r) (eq? (car r) 'ray3))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `ray3?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-ray3?\n  (lambda (r)\n    (and (pair? r) (eq? (car r) 'ray3))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "chez-to-fold", "ray3?"], "split": "eval"}
{"id": "geometry_translation_021", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3?\n    (lambda (r)\n      (and (pair? r) (eq? (car r) 'ray3))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `ray3?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-ray3?\n    (lambda (r)\n      (and (pair? r) (eq? (car r) 'ray3))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "ray3?"], "split": "eval"}
{"id": "geometry_translation_046", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-from-points`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_from_points(p1, p2, p3):\n    \"\"\"Create plane from three points (returns error if collinear)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `plane3-from-points`.\nReturn only the Scheme definition.\n\n```python\ndef plane3_from_points(p1, p2, p3):\n    \"\"\"Create plane from three points (returns error if collinear)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "plane3-from-points"], "split": "eval"}
{"id": "geometry_translation_047", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-from-points`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-from-points\n  (lambda (p1 p2 p3)\n    (let* ([v1 (vec3-sub p2 p1)]\n             [v2 (vec3-sub p3 p1)]\n             [cp (vec3-cross v1 v2)]\n             [mag (vec3-magnitude cp)])\n            (if (< mag 1e-10)\n                (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                (let ([normal (vec3-scale-inv cp mag)])\n                     (plane3-from-point-normal p1 normal))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `plane3-from-points`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-plane3-from-points\n  (lambda (p1 p2 p3)\n    (let* ([v1 (vec3-sub p2 p1)]\n             [v2 (vec3-sub p3 p1)]\n             [cp (vec3-cross v1 v2)]\n             [mag (vec3-magnitude cp)])\n            (if (< mag 1e-10)\n                (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                (let ([normal (vec3-scale-inv cp mag)])\n                     (plane3-from-point-normal p1 normal))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "plane3-from-points"], "split": "eval"}
{"id": "geometry_translation_048", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-from-points`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-from-points\n    (lambda (p1 p2 p3)\n      (let* ([v1 (vec3-sub p2 p1)]\n               [v2 (vec3-sub p3 p1)]\n               [cp (vec3-cross v1 v2)]\n               [mag (vec3-magnitude cp)])\n              (if (< mag 1e-10)\n                  (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                  (let ([normal (vec3-scale-inv cp mag)])\n                       (plane3-from-point-normal p1 normal))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `plane3-from-points`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-plane3-from-points\n    (lambda (p1 p2 p3)\n      (let* ([v1 (vec3-sub p2 p1)]\n               [v2 (vec3-sub p3 p1)]\n               [cp (vec3-cross v1 v2)]\n               [mag (vec3-magnitude cp)])\n              (if (< mag 1e-10)\n                  (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n                  (let ([normal (vec3-scale-inv cp mag)])\n                       (plane3-from-point-normal p1 normal))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "plane3-from-points"], "split": "eval"}
{"id": "geometry_translation_055", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p1`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p1(t):\n    \"\"\"Get first vertex of triangle3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p1`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p1(t):\n    \"\"\"Get first vertex of triangle3\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle3-p1"], "split": "eval"}
{"id": "geometry_translation_056", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p1`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p1\n  (lambda (t)\n    (cadr t)\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p1`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p1\n  (lambda (t)\n    (cadr t)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle3-p1"], "split": "eval"}
{"id": "geometry_translation_057", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p1`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p1\n    (lambda (t)\n      (cadr t)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p1`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p1\n    (lambda (t)\n      (cadr t)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3-p1 t)\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle3-p1"], "split": "eval"}
{"id": "geometry_translation_061", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p3`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p3(t):\n    \"\"\"Get third vertex of triangle3\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `triangle3-p3`.\nReturn only the Scheme definition.\n\n```python\ndef triangle3_p3(t):\n    \"\"\"Get third vertex of triangle3\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "python-to-scheme", "triangle3-p3"], "split": "eval"}
{"id": "geometry_translation_062", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p3\n  (lambda (t)\n    (cadddr t)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `triangle3-p3`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-triangle3-p3\n  (lambda (t)\n    (cadddr t)\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "chez-to-fold", "triangle3-p3"], "split": "eval"}
{"id": "geometry_translation_063", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p3\n    (lambda (t)\n      (cadddr t)\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `triangle3-p3`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-triangle3-p3\n    (lambda (t)\n      (cadddr t)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (triangle3-p3 t)\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "triangle3-p3"], "split": "eval"}
{"id": "geometry_translation_070", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle-center`.\nReturn only the Scheme definition.\n\n```python\ndef circle_center(c):\n    \"\"\"Get center of circle\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `circle-center`.\nReturn only the Scheme definition.\n\n```python\ndef circle_center(c):\n    \"\"\"Get center of circle\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "python-to-scheme", "circle-center"], "split": "eval"}
{"id": "geometry_translation_071", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle-center\n  (lambda (c)\n    (cadr c)\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `circle-center`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-circle-center\n  (lambda (c)\n    (cadr c)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "chez-to-fold", "circle-center"], "split": "eval"}
{"id": "geometry_translation_072", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle-center\n    (lambda (c)\n      (cadr c)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `circle-center`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-circle-center\n    (lambda (c)\n      (cadr c)\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (circle-center c)\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "circle-center"], "split": "eval"}
{"id": "geometry_translation_124", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-translation`.\nReturn only the Scheme definition.\n\n```python\ndef transform_translation(v):\n    \"\"\"Return 4x4 translation matrix\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-translation`.\nReturn only the Scheme definition.\n\n```python\ndef transform_translation(v):\n    \"\"\"Return 4x4 translation matrix\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-translation"], "split": "eval"}
{"id": "geometry_translation_125", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-translation`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-translation\n  (lambda (v)\n    (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                           (0 1 0 ,(vec3-y v))\n                           (0 0 1 ,(vec3-z v))\n                           (0 0 0 1)))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-translation`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-translation\n  (lambda (v)\n    (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                           (0 1 0 ,(vec3-y v))\n                           (0 0 1 ,(vec3-z v))\n                           (0 0 0 1)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-translation"], "split": "eval"}
{"id": "geometry_translation_126", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-translation`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-translation\n    (lambda (v)\n      (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                             (0 1 0 ,(vec3-y v))\n                             (0 0 1 ,(vec3-z v))\n                             (0 0 0 1)))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-translation`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-translation\n    (lambda (v)\n      (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                             (0 1 0 ,(vec3-y v))\n                             (0 0 1 ,(vec3-z v))\n                             (0 0 0 1)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-translation v)\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-translation"], "split": "eval"}
{"id": "geometry_translation_127", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-scale`.\nReturn only the Scheme definition.\n\n```python\ndef transform_scale(s):\n    \"\"\"Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-scale`.\nReturn only the Scheme definition.\n\n```python\ndef transform_scale(s):\n    \"\"\"Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-scale"], "split": "eval"}
{"id": "geometry_translation_128", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-scale`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-scale\n  (lambda (s)\n    (if (number? s)\n          (matrix-from-lists `((,s 0 0 0)\n                               (0 ,s 0 0)\n                               (0 0 ,s 0)\n                               (0 0 0 1)))\n          (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                               (0 ,(vec3-y s) 0 0)\n                               (0 0 ,(vec3-z s) 0)\n                               (0 0 0 1))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-scale`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-scale\n  (lambda (s)\n    (if (number? s)\n          (matrix-from-lists `((,s 0 0 0)\n                               (0 ,s 0 0)\n                               (0 0 ,s 0)\n                               (0 0 0 1)))\n          (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                               (0 ,(vec3-y s) 0 0)\n                               (0 0 ,(vec3-z s) 0)\n                               (0 0 0 1))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-scale"], "split": "eval"}
{"id": "geometry_translation_129", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-scale`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-scale\n    (lambda (s)\n      (if (number? s)\n            (matrix-from-lists `((,s 0 0 0)\n                                 (0 ,s 0 0)\n                                 (0 0 ,s 0)\n                                 (0 0 0 1)))\n            (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                                 (0 ,(vec3-y s) 0 0)\n                                 (0 0 ,(vec3-z s) 0)\n                                 (0 0 0 1))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-scale`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-scale\n    (lambda (s)\n      (if (number? s)\n            (matrix-from-lists `((,s 0 0 0)\n                                 (0 ,s 0 0)\n                                 (0 0 ,s 0)\n                                 (0 0 0 1)))\n            (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                                 (0 ,(vec3-y s) 0 0)\n                                 (0 0 ,(vec3-z s) 0)\n                                 (0 0 0 1))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (transform-scale s)\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-scale"], "split": "eval"}
{"id": "geometry_translation_154", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-plane`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_plane(point, plane):\n    \"\"\"Return signed distance from point to plane (positive = in front)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-plane`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_plane(point, plane):\n    \"\"\"Return signed distance from point to plane (positive = in front)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_155", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-plane\n  (lambda (point plane)\n    (let ([n (plane3-normal plane)]\n            [d (plane3-d plane)])\n           (/ (+ (vec3-dot n point) d)\n              (vec3-magnitude n)))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-plane\n  (lambda (point plane)\n    (let ([n (plane3-normal plane)]\n            [d (plane3-d plane)])\n           (/ (+ (vec3-dot n point) d)\n              (vec3-magnitude n)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_156", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-plane\n    (lambda (point plane)\n      (let ([n (plane3-normal plane)]\n              [d (plane3-d plane)])\n             (/ (+ (vec3-dot n point) d)\n                (vec3-magnitude n)))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-plane\n    (lambda (point plane)\n      (let ([n (plane3-normal plane)]\n              [d (plane3-d plane)])\n             (/ (+ (vec3-dot n point) d)\n                (vec3-magnitude n)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-plane point plane)\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_178", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_aabb_p(point, box):\n    \"\"\"Return #t iff point is inside or on aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_aabb_p(point, box):\n    \"\"\"Return #t iff point is inside or on aabb\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "python-to-scheme", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_179", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-aabb?\n  (lambda (point box)\n    (let ([p point]\n            [bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (and (>= (vec3-x p) (vec3-x bmin))\n                (<= (vec3-x p) (vec3-x bmax))\n                (>= (vec3-y p) (vec3-y bmin))\n                (<= (vec3-y p) (vec3-y bmax))\n                (>= (vec3-z p) (vec3-z bmin))\n                (<= (vec3-z p) (vec3-z bmax))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-aabb?\n  (lambda (point box)\n    (let ([p point]\n            [bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (and (>= (vec3-x p) (vec3-x bmin))\n                (<= (vec3-x p) (vec3-x bmax))\n                (>= (vec3-y p) (vec3-y bmin))\n                (<= (vec3-y p) (vec3-y bmax))\n                (>= (vec3-z p) (vec3-z bmin))\n                (<= (vec3-z p) (vec3-z bmax))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "chez-to-fold", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_180", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-aabb?\n    (lambda (point box)\n      (let ([p point]\n              [bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (and (>= (vec3-x p) (vec3-x bmin))\n                  (<= (vec3-x p) (vec3-x bmax))\n                  (>= (vec3-y p) (vec3-y bmin))\n                  (<= (vec3-y p) (vec3-y bmax))\n                  (>= (vec3-z p) (vec3-z bmin))\n                  (<= (vec3-z p) (vec3-z bmax))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-aabb?\n    (lambda (point box)\n      (let ([p point]\n              [bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (and (>= (vec3-x p) (vec3-x bmin))\n                  (<= (vec3-x p) (vec3-x bmax))\n                  (>= (vec3-y p) (vec3-y bmin))\n                  (<= (vec3-y p) (vec3-y bmax))\n                  (>= (vec3-z p) (vec3-z bmin))\n                  (<= (vec3-z p) (vec3-z bmax))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (point-in-aabb? point box)\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_190", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_aabb(point, box):\n    \"\"\"Return closest point on aabb to given point\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `closest-point-on-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef closest_point_on_aabb(point, box):\n    \"\"\"Return closest point on aabb to given point\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "closest-point-on-aabb"], "split": "eval"}
{"id": "geometry_translation_191", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-aabb\n  (lambda (point box)\n    (let ([bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                 (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                 (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `closest-point-on-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-closest-point-on-aabb\n  (lambda (point box)\n    (let ([bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                 (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                 (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "closest-point-on-aabb"], "split": "eval"}
{"id": "geometry_translation_192", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-aabb\n    (lambda (point box)\n      (let ([bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                   (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                   (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `closest-point-on-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-closest-point-on-aabb\n    (lambda (point box)\n      (let ([bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n                   (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n                   (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax)))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "closest-point-on-aabb"], "split": "eval"}
{"id": "geometry_translation_202", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-volume`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_volume(box):\n    \"\"\"Return volume of aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `aabb-volume`.\nReturn only the Scheme definition.\n\n```python\ndef aabb_volume(box):\n    \"\"\"Return volume of aabb\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "aabb-volume"], "split": "eval"}
{"id": "geometry_translation_203", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-volume`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-volume\n  (lambda (box)\n    (let* ([extents (aabb-extents box)]\n             [x (vec3-x extents)]\n             [y (vec3-y extents)]\n             [z (vec3-z extents)])\n            (* 8 x y z))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `aabb-volume`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-aabb-volume\n  (lambda (box)\n    (let* ([extents (aabb-extents box)]\n             [x (vec3-x extents)]\n             [y (vec3-y extents)]\n             [z (vec3-z extents)])\n            (* 8 x y z))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "aabb-volume"], "split": "eval"}
{"id": "geometry_translation_204", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-volume`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-volume\n    (lambda (box)\n      (let* ([extents (aabb-extents box)]\n               [x (vec3-x extents)]\n               [y (vec3-y extents)]\n               [z (vec3-z extents)])\n              (* 8 x y z))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `aabb-volume`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-aabb-volume\n    (lambda (box)\n      (let* ([extents (aabb-extents box)]\n               [x (vec3-x extents)]\n               [y (vec3-y extents)]\n               [z (vec3-z extents)])\n              (* 8 x y z))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (aabb-volume box)\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "aabb-volume"], "split": "eval"}
{"id": "geometry_bugfix_002", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (line3 origin direction)\n  (list 'line3-broken origin direction))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3` in `lattice/geometry/geometry.ss`.\nKnown issue: Tag symbol was changed, breaking representation compatibility.\n\n```scheme\n(define (line3 origin direction)\n  (list 'line3-broken origin direction))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "bugfix", "line3"], "split": "eval"}
{"id": "geometry_bugfix_005", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3-direction` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (line3-direction l)\n  (cadr l))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `line3-direction` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from third slot to second slot.\n\n```scheme\n(define (line3-direction l)\n  (cadr l))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "bugfix", "line3-direction"], "split": "eval"}
{"id": "geometry_bugfix_007", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3-broken)))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `ray3?` in `lattice/geometry/geometry.ss`.\nKnown issue: Predicate checks the wrong tag symbol.\n\n```scheme\n(define (ray3? r)\n  (and (pair? r) (eq? (car r) 'ray3-broken)))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "bugfix", "ray3?"], "split": "eval"}
{"id": "geometry_bugfix_016", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  (error 'plane3-from-points \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  (error 'plane3-from-points \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "plane3-from-points"], "split": "eval"}
{"id": "geometry_bugfix_019", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p1` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (triangle3-p1 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p1` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (triangle3-p1 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "bugfix", "triangle3-p1"], "split": "eval"}
{"id": "geometry_bugfix_021", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p3` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from fourth slot to third slot.\n\n```scheme\n(define (triangle3-p3 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `triangle3-p3` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from fourth slot to third slot.\n\n```scheme\n(define (triangle3-p3 t)\n  (caddr t))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (triangle3-p3 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadddr t))", "verify_expr": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "tags": ["tier0", "geometry", "bugfix", "triangle3-p3"], "split": "eval"}
{"id": "geometry_bugfix_024", "family": "bugfix", "category": "debugging", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (circle-center c)\n  (caddr c))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `circle-center` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (circle-center c)\n  (caddr c))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (circle-center c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Vec2))\n  (cadr c))", "verify_expr": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "tags": ["tier0", "geometry", "bugfix", "circle-center"], "split": "eval"}
{"id": "geometry_bugfix_042", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-translation v)\n  (error 'transform-translation \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-translation v)\n  (error 'transform-translation \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-translation"], "split": "eval"}
{"id": "geometry_bugfix_043", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-scale s)\n  (error 'transform-scale \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-scale s)\n  (error 'transform-scale \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-scale"], "split": "eval"}
{"id": "geometry_bugfix_052", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-plane point plane)\n  (error 'distance-point-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-plane point plane)\n  (error 'distance-point-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-plane"], "split": "eval"}
{"id": "geometry_bugfix_060", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-aabb? point box)\n  (error 'point-in-aabb? \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-aabb? point box)\n  (error 'point-in-aabb? \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "bugfix", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_bugfix_064", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  (error 'closest-point-on-aabb \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `closest-point-on-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (closest-point-on-aabb point box)\n  (error 'closest-point-on-aabb \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x cp) 10)) 0.001)\n(< (abs (- (vec3-y cp) 5)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (closest-point-on-aabb point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Point3))\n  (let ([bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (vec3 (max (vec3-x bmin) (min (vec3-x point) (vec3-x bmax)))\n             (max (vec3-y bmin) (min (vec3-y point) (vec3-y bmax)))\n             (max (vec3-z bmin) (min (vec3-z point) (vec3-z bmax))))))", "verify_expr": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "closest-point-on-aabb"], "split": "eval"}
{"id": "geometry_bugfix_068", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-volume` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-volume box)\n  (error 'aabb-volume \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `aabb-volume` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (aabb-volume box)\n  (error 'aabb-volume \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "aabb-volume"], "split": "eval"}
{"id": "geometry_bugfix_077", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  p1)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `plane3-from-points` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (plane3-from-points p1 p2 p3)\n  p1)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(plane3? pl)\n(< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "plane3-from-points"], "split": "eval"}
{"id": "geometry_bugfix_081", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-translation v)\n  v)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-translation` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-translation v)\n  v)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 11)) 0.001)\n(< (abs (- (vec3-y r) 22)) 0.001)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-translation"], "split": "eval"}
{"id": "geometry_bugfix_082", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-scale s)\n  s)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-scale` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-scale s)\n  s)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-scale"], "split": "eval"}
{"id": "geometry_bugfix_091", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-plane point plane)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-plane point plane)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-plane"], "split": "eval"}
{"id": "geometry_bugfix_099", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-aabb? point box)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-aabb? point box)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "bugfix", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_composition_003", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3` on representative inputs.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3` on representative inputs.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "verify_expr": "(equal? (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d))) #t)", "tags": ["tier0", "geometry", "composition", "line3", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_004", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `line3` that returns `'ok` when expected behavior holds.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `line3` that returns `'ok` when expected behavior holds.\n\nEnsure `line3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "line3", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_009", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-direction` on representative inputs.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-direction` on representative inputs.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "verify_expr": "(equal? (equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1)) #t)", "tags": ["tier0", "geometry", "composition", "line3-direction", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_010", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `line3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `line3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `line3-direction` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "line3-direction", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_013", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3?` on representative inputs.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `ray3?` on representative inputs.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "verify_expr": "(equal? (and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3))) #t)", "tags": ["tier0", "geometry", "composition", "ray3?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_014", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3?` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3?` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3))) 'ok 'bad)", "verify_expr": "(equal? (if (and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3?", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_031", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-from-points` on representative inputs.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `plane3-from-points` on representative inputs.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "verify_expr": "(equal? (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "plane3-from-points", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_032", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-points` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3-from-points", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_037", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p1` on representative inputs.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p1` on representative inputs.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "verify_expr": "(equal? (equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3)) #t)", "tags": ["tier0", "geometry", "composition", "triangle3-p1", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_038", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p1` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p1` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p1` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle3-p1", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_041", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p3` on representative inputs.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p3` on representative inputs.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "verify_expr": "(equal? (equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9)) #t)", "tags": ["tier0", "geometry", "composition", "triangle3-p3", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_042", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p3` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `triangle3-p3` that returns `'ok` when expected behavior holds.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "triangle3-p3", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_047", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-center` on representative inputs.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-center` on representative inputs.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "verify_expr": "(equal? (equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0)) #t)", "tags": ["tier0", "geometry", "composition", "circle-center", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_048", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `circle-center` that returns `'ok` when expected behavior holds.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `circle-center` that returns `'ok` when expected behavior holds.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "circle-center", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_083", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-translation` on representative inputs.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-translation` on representative inputs.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-translation", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_084", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-translation` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-translation` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-translation` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-translation", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_085", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-scale` on representative inputs.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-scale` on representative inputs.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-scale", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_086", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-scale` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-scale` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-scale` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-scale", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_103", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-plane` on representative inputs.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `distance-point-plane` on representative inputs.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "verify_expr": "(equal? (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "distance-point-plane", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_104", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `distance-point-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `distance-point-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "distance-point-plane", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_119", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-aabb?` on representative inputs.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-aabb?` on representative inputs.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "verify_expr": "(equal? (let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box)) #t)", "tags": ["tier0", "geometry", "composition", "point-in-aabb?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_120", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `point-in-aabb?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `point-in-aabb?` that returns `'ok` when expected behavior holds.\n\nEnsure `point-in-aabb?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "point-in-aabb?", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_127", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-aabb` on representative inputs.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-aabb` on representative inputs.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "verify_expr": "(equal? (let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "closest-point-on-aabb", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_128", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `closest-point-on-aabb` that returns `'ok` when expected behavior holds.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "closest-point-on-aabb", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_135", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-volume` on representative inputs.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `aabb-volume` on representative inputs.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "verify_expr": "(equal? (let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "aabb-volume", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_136", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-volume` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-volume` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-volume` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-volume", "behavior-signal", "auto-composition"], "split": "eval"}
