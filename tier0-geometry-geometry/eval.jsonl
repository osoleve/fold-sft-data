{"id": "geometry_spec_to_code_004", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\nDescription: Infinite line through origin in direction\n\nWrite exactly one definition for `line3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3`\nSignature: `(line3 origin direction)`\nDescription: Infinite line through origin in direction\n\nWrite exactly one definition for `line3`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(line3? l)\n(equal? (line3-origin l) o)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (line3 origin direction)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Line3))\n  (doc 'description \"Infinite line through origin in direction\")\n  (list 'line3 origin direction))", "verify_expr": "(let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [l (line3 o d)]) (and (line3? l) (equal? (line3-origin l) o) (equal? (line3-direction l) d)))", "tags": ["tier0", "geometry", "spec-to-code", "line3"], "split": "eval"}
{"id": "geometry_spec_to_code_007", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3?`\nSignature: `(line3? l)`\nDescription: Return #t iff l is a line3\n\nWrite exactly one definition for `line3?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3?`\nSignature: `(line3? l)`\nDescription: Return #t iff l is a line3\n\nWrite exactly one definition for `line3?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(line3? (line3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (line3? '(not-a-line)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (line3? l)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? l) (eq? (car l) 'line3)))", "verify_expr": "(and (line3? (line3 (vec3 0 0 0) (vec3 1 0 0))) (not (line3? '(not-a-line))) (not (line3? 42)))", "tags": ["tier0", "geometry", "spec-to-code", "line3?"], "split": "eval"}
{"id": "geometry_spec_to_code_013", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-direction", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\nDescription: Get direction of line3\n\nWrite exactly one definition for `line3-direction`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `line3-direction`\nSignature: `(line3-direction l)`\nDescription: Get direction of line3\n\nWrite exactly one definition for `line3-direction`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (line3-direction l)\n  (doc 'export #t)\n  (doc 'type '(-> Line3 Vec3))\n  (caddr l))", "verify_expr": "(equal? (line3-direction (line3 (vec3 0 0 0) (vec3 0 0 1))) (vec3 0 0 1))", "tags": ["tier0", "geometry", "spec-to-code", "line3-direction"], "split": "eval"}
{"id": "geometry_spec_to_code_019", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\nDescription: Return #t iff r is a ray3\n\nWrite exactly one definition for `ray3?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3?`\nSignature: `(ray3? r)`\nDescription: Return #t iff r is a ray3\n\nWrite exactly one definition for `ray3?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0)))\n(not (ray3? '(not-a-ray)))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3? r)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? r) (eq? (car r) 'ray3)))", "verify_expr": "(and (ray3? (ray3 (vec3 0 0 0) (vec3 1 0 0))) (not (ray3? '(not-a-ray))) (not (ray3? 'ray3)))", "tags": ["tier0", "geometry", "spec-to-code", "ray3?"], "split": "eval"}
{"id": "geometry_spec_to_code_022", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-origin", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-origin`\nSignature: `(ray3-origin r)`\nDescription: Get origin of ray3\n\nWrite exactly one definition for `ray3-origin`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-origin`\nSignature: `(ray3-origin r)`\nDescription: Get origin of ray3\n\nWrite exactly one definition for `ray3-origin`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (ray3-origin r)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Vec3))\n  (cadr r))", "verify_expr": "(equal? (ray3-origin (ray3 (vec3 5 5 5) (vec3 1 0 0))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "ray3-origin"], "split": "eval"}
{"id": "geometry_spec_to_code_028", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-point-at", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-point-at`\nSignature: `(ray3-point-at ray t)`\nDescription: Get point at parameter t along ray (t >= 0)\n\nWrite exactly one definition for `ray3-point-at`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `ray3-point-at`\nSignature: `(ray3-point-at ray t)`\nDescription: Get point at parameter t along ray (t >= 0)\n\nWrite exactly one definition for `ray3-point-at`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (ray3-point-at ray t)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Number Point3))\n  (doc 'description \"Get point at parameter t along ray (t >= 0)\")\n  (vec3-add (ray3-origin ray)\n            (vec3-scale (ray3-direction ray) t)))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 0) (vec3 1 0 0))] [p (ray3-point-at r 5)]) (< (abs (- (vec3-x p) 5)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "ray3-point-at"], "split": "eval"}
{"id": "geometry_spec_to_code_031", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3`\nSignature: `(plane3 normal d)`\nDescription: Plane defined by normal·p + d = 0\n\nWrite exactly one definition for `plane3`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3`\nSignature: `(plane3 normal d)`\nDescription: Plane defined by normal·p + d = 0\n\nWrite exactly one definition for `plane3`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (plane3 normal d)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Plane3))\n  (doc 'description \"Plane defined by normal·p + d = 0\")\n  (list 'plane3 normal d))", "verify_expr": "(let* ([n (vec3 0 1 0)] [pl (plane3 n 5)]) (and (plane3? pl) (equal? (plane3-normal pl) n) (= (plane3-d pl) 5)))", "tags": ["tier0", "geometry", "spec-to-code", "plane3"], "split": "eval"}
{"id": "geometry_spec_to_code_037", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-normal", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-normal`\nSignature: `(plane3-normal p)`\nDescription: Get normal of plane3\n\nWrite exactly one definition for `plane3-normal`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-normal`\nSignature: `(plane3-normal p)`\nDescription: Get normal of plane3\n\nWrite exactly one definition for `plane3-normal`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3-normal p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Vec3))\n  (cadr p))", "verify_expr": "(equal? (plane3-normal (plane3 (vec3 1 0 0) 0)) (vec3 1 0 0))", "tags": ["tier0", "geometry", "spec-to-code", "plane3-normal"], "split": "eval"}
{"id": "geometry_spec_to_code_040", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-d", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-d`\nSignature: `(plane3-d p)`\nDescription: Get d coefficient of plane3\n\nWrite exactly one definition for `plane3-d`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-d`\nSignature: `(plane3-d p)`\nDescription: Get d coefficient of plane3\n\nWrite exactly one definition for `plane3-d`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (plane3-d p)\n  (doc 'export #t)\n  (doc 'type '(-> Plane3 Number))\n  (caddr p))", "verify_expr": "(= (plane3-d (plane3 (vec3 0 1 0) 10)) 10)", "tags": ["tier0", "geometry", "spec-to-code", "plane3-d"], "split": "eval"}
{"id": "geometry_spec_to_code_046", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-points", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\nDescription: Create plane from three points (returns error if collinear)\n\nWrite exactly one definition for `plane3-from-points`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `plane3-from-points`\nSignature: `(plane3-from-points p1 p2 p3)`\nDescription: Create plane from three points (returns error if collinear)\n\nWrite exactly one definition for `plane3-from-points`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (plane3-from-points p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 (Or Plane3 Error)))\n  (doc 'description \"Create plane from three points\")\n  (doc 'note \"Returns error if points are collinear\")\n  (let* ([v1 (vec3-sub p2 p1)]\n         [v2 (vec3-sub p3 p1)]\n         [cp (vec3-cross v1 v2)]\n         [mag (vec3-magnitude cp)])\n        (if (< mag 1e-10)\n            (list 'error 'plane3-from-points \"Collinear points do not define a unique plane\")\n            (let ([normal (vec3-scale-inv cp mag)])\n                 (plane3-from-point-normal p1 normal)))))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [pl (plane3-from-points p1 p2 p3)]) (and (plane3? pl) (< (abs (- (vec3-z (plane3-normal pl)) 1.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "plane3-from-points"], "split": "eval"}
{"id": "geometry_spec_to_code_049", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3`\nSignature: `(triangle3 p1 p2 p3)`\nDescription: Create triangle from three points\n\nWrite exactly one definition for `triangle3`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3`\nSignature: `(triangle3 p1 p2 p3)`\nDescription: Create triangle from three points\n\nWrite exactly one definition for `triangle3`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (triangle3 p1 p2 p3)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 Vec3 Triangle3))\n  (list 'triangle3 p1 p2 p3))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 1 0 0)] [p3 (vec3 0 1 0)] [t (triangle3 p1 p2 p3)]) (and (triangle3? t) (equal? (triangle3-p1 t) p1) (equal? (triangle3-p2 t) p2) (equal? (triangle3-p3 t) p3)))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3"], "split": "eval"}
{"id": "geometry_spec_to_code_055", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p1", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\nDescription: Get first vertex of triangle3\n\nWrite exactly one definition for `triangle3-p1`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p1`\nSignature: `(triangle3-p1 t)`\nDescription: Get first vertex of triangle3\n\nWrite exactly one definition for `triangle3-p1`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p1 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (cadr t))", "verify_expr": "(equal? (triangle3-p1 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 1 2 3))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3-p1"], "split": "eval"}
{"id": "geometry_spec_to_code_058", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p2", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p2`\nSignature: `(triangle3-p2 t)`\nDescription: Get second vertex of triangle3\n\nWrite exactly one definition for `triangle3-p2`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `triangle3-p2`\nSignature: `(triangle3-p2 t)`\nDescription: Get second vertex of triangle3\n\nWrite exactly one definition for `triangle3-p2`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (triangle3-p2 t)\n  (doc 'export #t)\n  (doc 'type '(-> Triangle3 Vec3))\n  (caddr t))", "verify_expr": "(equal? (triangle3-p2 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 4 5 6))", "tags": ["tier0", "geometry", "spec-to-code", "triangle3-p2"], "split": "eval"}
{"id": "geometry_spec_to_code_064", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle`\nSignature: `(circle center radius)`\nDescription: Create 2D circle\n\nWrite exactly one definition for `circle`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle`\nSignature: `(circle center radius)`\nDescription: Create 2D circle\n\nWrite exactly one definition for `circle`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(circle? ci)\n(equal? (circle-center ci) c)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec2 Number Circle))\n  (list 'circle center radius))", "verify_expr": "(let* ([c (vec3 1 2 0)] [r 5] [ci (circle c r)]) (and (circle? ci) (equal? (circle-center ci) c) (= (circle-radius ci) r)))", "tags": ["tier0", "geometry", "spec-to-code", "circle"], "split": "eval"}
{"id": "geometry_spec_to_code_067", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle?`\nSignature: `(circle? c)`\nDescription: Return #t iff c is a circle\n\nWrite exactly one definition for `circle?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle?`\nSignature: `(circle? c)`\nDescription: Return #t iff c is a circle\n\nWrite exactly one definition for `circle?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(circle? (circle (vec3 0 0 0) 1))\n(not (circle? '(not-a-circle)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (circle? c)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? c) (eq? (car c) 'circle)))", "verify_expr": "(and (circle? (circle (vec3 0 0 0) 1)) (not (circle? '(not-a-circle))) (not (circle? 42)))", "tags": ["tier0", "geometry", "spec-to-code", "circle?"], "split": "eval"}
{"id": "geometry_spec_to_code_073", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-radius", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-radius`\nSignature: `(circle-radius c)`\nDescription: Get radius of circle\n\nWrite exactly one definition for `circle-radius`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `circle-radius`\nSignature: `(circle-radius c)`\nDescription: Get radius of circle\n\nWrite exactly one definition for `circle-radius`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(= (circle-radius (circle (vec3 0 0 0) 7)) 7)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (circle-radius c)\n  (doc 'export #t)\n  (doc 'type '(-> Circle Number))\n  (caddr c))", "verify_expr": "(= (circle-radius (circle (vec3 0 0 0) 7)) 7)", "tags": ["tier0", "geometry", "spec-to-code", "circle-radius"], "split": "eval"}
{"id": "geometry_spec_to_code_076", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere`\nSignature: `(sphere center radius)`\nDescription: Create sphere\n\nWrite exactly one definition for `sphere`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere`\nSignature: `(sphere center radius)`\nDescription: Create sphere\n\nWrite exactly one definition for `sphere`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(sphere? s)\n(equal? (sphere-center s) c)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere center radius)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Number Sphere))\n  (list 'sphere center radius))", "verify_expr": "(let* ([c (vec3 1 2 3)] [r 10] [s (sphere c r)]) (and (sphere? s) (equal? (sphere-center s) c) (= (sphere-radius s) r)))", "tags": ["tier0", "geometry", "spec-to-code", "sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_082", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-center", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-center`\nSignature: `(sphere-center s)`\nDescription: Get center of sphere\n\nWrite exactly one definition for `sphere-center`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-center`\nSignature: `(sphere-center s)`\nDescription: Get center of sphere\n\nWrite exactly one definition for `sphere-center`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere-center s)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Vec3))\n  (cadr s))", "verify_expr": "(equal? (sphere-center (sphere (vec3 5 5 5) 3)) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "sphere-center"], "split": "eval"}
{"id": "geometry_spec_to_code_088", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb`\nSignature: `(aabb min-point max-point)`\nDescription: Axis-Aligned Bounding Box from min/max corners\n\nWrite exactly one definition for `aabb`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb`\nSignature: `(aabb min-point max-point)`\nDescription: Axis-Aligned Bounding Box from min/max corners\n\nWrite exactly one definition for `aabb`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(aabb? b)\n(equal? (aabb-min b) mn)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb min-point max-point)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Vec3 AABB))\n  (doc 'description \"Axis-Aligned Bounding Box from min/max corners\")\n  (list 'aabb min-point max-point))", "verify_expr": "(let* ([mn (vec3 -1 -1 -1)] [mx (vec3 1 1 1)] [b (aabb mn mx)]) (and (aabb? b) (equal? (aabb-min b) mn) (equal? (aabb-max b) mx)))", "tags": ["tier0", "geometry", "spec-to-code", "aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_091", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb?`\nSignature: `(aabb? b)`\nDescription: Return #t iff b is an aabb\n\nWrite exactly one definition for `aabb?`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb?`\nSignature: `(aabb? b)`\nDescription: Return #t iff b is an aabb\n\nWrite exactly one definition for `aabb?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(aabb? (aabb (vec3 0 0 0) (vec3 1 1 1)))\n(not (aabb? '(not-an-aabb)))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'aabb)))", "verify_expr": "(and (aabb? (aabb (vec3 0 0 0) (vec3 1 1 1))) (not (aabb? '(not-an-aabb))) (not (aabb? 'aabb)))", "tags": ["tier0", "geometry", "spec-to-code", "aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_097", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-max", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-max`\nSignature: `(aabb-max b)`\nDescription: Get max corner of aabb\n\nWrite exactly one definition for `aabb-max`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-max`\nSignature: `(aabb-max b)`\nDescription: Get max corner of aabb\n\nWrite exactly one definition for `aabb-max`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-max b)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Vec3))\n  (caddr b))", "verify_expr": "(equal? (aabb-max (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-max"], "split": "eval"}
{"id": "geometry_spec_to_code_100", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-center", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-center`\nSignature: `(aabb-center box)`\nDescription: Get center point of aabb\n\nWrite exactly one definition for `aabb-center`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-center`\nSignature: `(aabb-center box)`\nDescription: Get center point of aabb\n\nWrite exactly one definition for `aabb-center`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (aabb-center box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Point3))\n  (vec3-scale (vec3-add (aabb-min box) (aabb-max box)) 0.5))", "verify_expr": "(let ([c (aabb-center (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x c) 5)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-center"], "split": "eval"}
{"id": "geometry_spec_to_code_106", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb`\nSignature: `(obb center axes extents)`\nDescription: Oriented Bounding Box from center, axes, and extents\n\nWrite exactly one definition for `obb`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb`\nSignature: `(obb center axes extents)`\nDescription: Oriented Bounding Box from center, axes, and extents\n\nWrite exactly one definition for `obb`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(obb? b)\n(equal? (obb-center b) c)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb center axes extents)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Vec3) Vec3 OBB))\n  (doc 'description \"Oriented Bounding Box from center, axes, and extents\")\n  (doc 'param 'axes \"list of 3 orthonormal vectors\")\n  (doc 'param 'extents \"vec3 of half-sizes along each axis\")\n  (list 'obb center axes extents))", "verify_expr": "(let* ([c (vec3 0 0 0)] [ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))] [ex (vec3 1 2 3)] [b (obb c ax ex)]) (and (obb? b) (equal? (obb-center b) c) (equal? (obb-axes b) ax) (equal? (obb-extents b) ex)))", "tags": ["tier0", "geometry", "spec-to-code", "obb"], "split": "eval"}
{"id": "geometry_spec_to_code_109", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb?`\nSignature: `(obb? b)`\nDescription: Return #t iff b is an obb\n\nWrite exactly one definition for `obb?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb?`\nSignature: `(obb? b)`\nDescription: Return #t iff b is an obb\n\nWrite exactly one definition for `obb?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1)))\n(not (obb? '(not-an-obb)))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb? b)\n  (doc 'export #t)\n  (doc 'type '(-> α Bool))\n  (and (pair? b) (eq? (car b) 'obb)))", "verify_expr": "(and (obb? (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 1 1 1))) (not (obb? '(not-an-obb))))", "tags": ["tier0", "geometry", "spec-to-code", "obb?"], "split": "eval"}
{"id": "geometry_spec_to_code_115", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-axes", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-axes`\nSignature: `(obb-axes b)`\nDescription: Get axes of obb\n\nWrite exactly one definition for `obb-axes`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-axes`\nSignature: `(obb-axes b)`\nDescription: Get axes of obb\n\nWrite exactly one definition for `obb-axes`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (obb-axes b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB (List Vec3)))\n  (caddr b))", "verify_expr": "(let ([ax (list (vec3 1 0 0) (vec3 0 1 0) (vec3 0 0 1))]) (equal? (obb-axes (obb (vec3 0 0 0) ax (vec3 1 1 1))) ax))", "tags": ["tier0", "geometry", "spec-to-code", "obb-axes"], "split": "eval"}
{"id": "geometry_spec_to_code_118", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-extents", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-extents`\nSignature: `(obb-extents b)`\nDescription: Get extents of obb\n\nWrite exactly one definition for `obb-extents`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `obb-extents`\nSignature: `(obb-extents b)`\nDescription: Get extents of obb\n\nWrite exactly one definition for `obb-extents`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (obb-extents b)\n  (doc 'export #t)\n  (doc 'type '(-> OBB Vec3))\n  (cadddr b))", "verify_expr": "(equal? (obb-extents (obb (vec3 0 0 0) (list (vec3 1 0 0)) (vec3 5 5 5))) (vec3 5 5 5))", "tags": ["tier0", "geometry", "spec-to-code", "obb-extents"], "split": "eval"}
{"id": "geometry_spec_to_code_124", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-translation", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\nDescription: Return 4x4 translation matrix\n\nWrite exactly one definition for `transform-translation`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-translation`\nSignature: `(transform-translation v)`\nDescription: Return 4x4 translation matrix\n\nWrite exactly one definition for `transform-translation`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-translation v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 Matrix))\n  (matrix-from-lists `((1 0 0 ,(vec3-x v))\n                       (0 1 0 ,(vec3-y v))\n                       (0 0 1 ,(vec3-z v))\n                       (0 0 0 1))))", "verify_expr": "(let* ([m (transform-translation (vec3 10 20 30))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 11)) 0.001) (< (abs (- (vec3-y r) 22)) 0.001) (< (abs (- (vec3-z r) 33)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-translation"], "split": "eval"}
{"id": "geometry_spec_to_code_127", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-scale", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\nDescription: Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\n\nWrite exactly one definition for `transform-scale`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-scale`\nSignature: `(transform-scale s)`\nDescription: Return 4x4 scale matrix (uniform if number, non-uniform if vec3)\n\nWrite exactly one definition for `transform-scale`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 2)) 0.001)\n(< (abs (- (vec3-y r) 4)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-scale s)\n  (doc 'export #t)\n  (doc 'type '(-> (Or Number Vec3) Matrix))\n  (doc 'description \"Uniform scale if number, non-uniform if vec3\")\n  (if (number? s)\n      (matrix-from-lists `((,s 0 0 0)\n                           (0 ,s 0 0)\n                           (0 0 ,s 0)\n                           (0 0 0 1)))\n      (matrix-from-lists `((,(vec3-x s) 0 0 0)\n                           (0 ,(vec3-y s) 0 0)\n                           (0 0 ,(vec3-z s) 0)\n                           (0 0 0 1)))))", "verify_expr": "(let* ([m (transform-scale 2)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 2)) 0.001) (< (abs (- (vec3-y r) 4)) 0.001) (< (abs (- (vec3-z r) 6)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-scale"], "split": "eval"}
{"id": "geometry_spec_to_code_133", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-y", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-y`\nSignature: `(transform-rotation-y angle)`\nDescription: Return 4x4 rotation matrix around y-axis\n\nWrite exactly one definition for `transform-rotation-y`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-y`\nSignature: `(transform-rotation-y angle)`\nDescription: Return 4x4 rotation matrix around y-axis\n\nWrite exactly one definition for `transform-rotation-y`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-rotation-y angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c 0 ,s 0)\n                            (0 1 0 0)\n                            (,(- s) 0 ,c 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-y angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) -1)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-rotation-y"], "split": "eval"}
{"id": "geometry_spec_to_code_136", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-z", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-z`\nSignature: `(transform-rotation-z angle)`\nDescription: Return 4x4 rotation matrix around z-axis\n\nWrite exactly one definition for `transform-rotation-z`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-rotation-z`\nSignature: `(transform-rotation-z angle)`\nDescription: Return 4x4 rotation matrix around z-axis\n\nWrite exactly one definition for `transform-rotation-z`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x r)) 0.001)\n(< (abs (- (vec3-y r) 1)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-rotation-z angle)\n  (doc 'export #t)\n  (doc 'type '(-> Number Matrix))\n  (let ([c (cos angle)]\n        [s (sin angle)])\n       (matrix-from-lists `((,c ,(- s) 0 0)\n                            (,s ,c 0 0)\n                            (0 0 1 0)\n                            (0 0 0 1)))))", "verify_expr": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-z angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-rotation-z"], "split": "eval"}
{"id": "geometry_spec_to_code_142", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-from-quaternion", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-from-quaternion`\nSignature: `(transform-from-quaternion q)`\nDescription: Convert quaternion to 4x4 transformation matrix\n\nWrite exactly one definition for `transform-from-quaternion`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-from-quaternion`\nSignature: `(transform-from-quaternion q)`\nDescription: Convert quaternion to 4x4 transformation matrix\n\nWrite exactly one definition for `transform-from-quaternion`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-from-quaternion q)\n  (doc 'export #t)\n  (doc 'type '(-> Quaternion Matrix))\n  (doc 'description \"Convert quaternion to 4x4 transformation matrix\")\n  (let* ([w (quat-w q)]\n         [x (quat-x q)]\n         [y (quat-y q)]\n         [z (quat-z q)]\n         [x2 (* x x)]\n         [y2 (* y y)]\n         [z2 (* z z)]\n         [xy (* x y)]\n         [xz (* x z)]\n         [yz (* y z)]\n         [wx (* w x)]\n         [wy (* w y)]\n         [wz (* w z)])\n        (matrix-from-lists\n         `((,(- 1 (* 2 (+ y2 z2))) ,(* 2 (- xy wz))       ,(* 2 (+ xz wy))       0)\n           (,(* 2 (+ xy wz))       ,(- 1 (* 2 (+ x2 z2))) ,(* 2 (- yz wx))       0)\n           (,(* 2 (- xz wy))       ,(* 2 (+ yz wx))       ,(- 1 (* 2 (+ x2 y2))) 0)\n           (0                     0                     0                     1)))))", "verify_expr": "(let* ([q (quat 1 0 0 0)] [m (transform-from-quaternion q)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-from-quaternion"], "split": "eval"}
{"id": "geometry_spec_to_code_148", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\nDescription: Apply transformation to vector (no translation)\n\nWrite exactly one definition for `transform-vector`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\nDescription: Apply transformation to vector (no translation)\n\nWrite exactly one definition for `transform-vector`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "transform-vector"], "split": "eval"}
{"id": "geometry_spec_to_code_149", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-vector mat v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-vector`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (transform-vector mat v)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `transform-vector`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "transform-vector"], "split": "eval"}
{"id": "geometry_spec_to_code_150", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\n\nReturn only executable Scheme code for `transform-vector` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `transform-vector`\nSignature: `(transform-vector mat v)`\n\nReturn only executable Scheme code for `transform-vector` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (transform-vector mat v)\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "transform-vector"], "split": "eval"}
{"id": "geometry_spec_to_code_151", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\nDescription: Return Euclidean distance between two points\n\nWrite exactly one definition for `distance-point-point`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\nDescription: Return Euclidean distance between two points\n\nWrite exactly one definition for `distance-point-point`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-point"], "split": "eval"}
{"id": "geometry_spec_to_code_152", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-point p1 p2)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-point`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-point p1 p2)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-point`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-point"], "split": "eval"}
{"id": "geometry_spec_to_code_153", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\n\nReturn only executable Scheme code for `distance-point-point` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-point`\nSignature: `(distance-point-point p1 p2)`\n\nReturn only executable Scheme code for `distance-point-point` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distance-point-point p1 p2)\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-point"], "split": "eval"}
{"id": "geometry_spec_to_code_154", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\nDescription: Return signed distance from point to plane (positive = in front)\n\nWrite exactly one definition for `distance-point-plane`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\nDescription: Return signed distance from point to plane (positive = in front)\n\nWrite exactly one definition for `distance-point-plane`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_155", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-plane`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-plane point plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-plane`.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_156", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\n\nReturn only executable Scheme code for `distance-point-plane` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-plane`\nSignature: `(distance-point-plane point plane)`\n\nReturn only executable Scheme code for `distance-point-plane` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-plane point plane)\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_157", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\nDescription: Return distance from point to infinite line\n\nWrite exactly one definition for `distance-point-line`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\nDescription: Return distance from point to infinite line\n\nWrite exactly one definition for `distance-point-line`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-line"], "split": "eval"}
{"id": "geometry_spec_to_code_158", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-line point line)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-line`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-line point line)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-line`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-line"], "split": "eval"}
{"id": "geometry_spec_to_code_159", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\n\nReturn only executable Scheme code for `distance-point-line` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-line`\nSignature: `(distance-point-line point line)`\n\nReturn only executable Scheme code for `distance-point-line` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-line"], "split": "eval"}
{"id": "geometry_spec_to_code_160", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\nDescription: Return signed distance from point to sphere (negative if inside)\n\nWrite exactly one definition for `distance-point-sphere`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\nDescription: Return signed distance from point to sphere (negative if inside)\n\nWrite exactly one definition for `distance-point-sphere`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_161", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-sphere`.", "prompt": "Task mode: complete the target function to match module semantics.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `distance-point-sphere`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "skeleton-completion", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_162", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\n\nReturn only executable Scheme code for `distance-point-sphere` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `distance-point-sphere`\nSignature: `(distance-point-sphere point sphere)`\n\nReturn only executable Scheme code for `distance-point-sphere` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "doc-free", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_163", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\nDescription: Return t parameter where ray intersects plane, or #f\n\nWrite exactly one definition for `intersect-ray-plane`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\nDescription: Return t parameter where ray intersects plane, or #f\n\nWrite exactly one definition for `intersect-ray-plane`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_164", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-plane`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-plane`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_165", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\n\nReturn only executable Scheme code for `intersect-ray-plane` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-plane`\nSignature: `(intersect-ray-plane ray plane)`\n\nReturn only executable Scheme code for `intersect-ray-plane` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_166", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\nDescription: Return (t1 t2) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-sphere`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\nDescription: Return (t1 t2) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-sphere`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\nres\n(list? res)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_167", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-sphere`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-sphere`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\nres\n(list? res)\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_168", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\n\nReturn only executable Scheme code for `intersect-ray-sphere` without `(doc ...)` forms.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-sphere`\nSignature: `(intersect-ray-sphere ray sphere)`\n\nReturn only executable Scheme code for `intersect-ray-sphere` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_spec_to_code_169", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\nDescription: Return (tmin tmax) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-aabb`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\nDescription: Return (tmin tmax) intersection parameters, or #f\n\nWrite exactly one definition for `intersect-ray-aabb`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\nres\n(list? res)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_170", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-aabb`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-aabb`.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_171", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\n\nReturn only executable Scheme code for `intersect-ray-aabb` without `(doc ...)` forms.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-aabb`\nSignature: `(intersect-ray-aabb ray box)`\n\nReturn only executable Scheme code for `intersect-ray-aabb` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nBehavior examples your implementation must satisfy:\n```scheme\nres\n(list? res)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_spec_to_code_172", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\nDescription: Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\n\nWrite exactly one definition for `intersect-ray-triangle`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\nDescription: Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\n\nWrite exactly one definition for `intersect-ray-triangle`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_spec_to_code_173", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-triangle`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `intersect-ray-triangle`.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "skeleton-completion", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_spec_to_code_174", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\n\nReturn only executable Scheme code for `intersect-ray-triangle` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `intersect-ray-triangle`\nSignature: `(intersect-ray-triangle ray tri)`\n\nReturn only executable Scheme code for `intersect-ray-triangle` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "doc-free", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_spec_to_code_175", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\nDescription: Return #t iff point is inside or on sphere\n\nWrite exactly one definition for `point-in-sphere?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\nDescription: Return #t iff point is inside or on sphere\n\nWrite exactly one definition for `point-in-sphere?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "spec-to-code", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_spec_to_code_176", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-sphere?`.", "prompt": "Task mode: behavior-first function implementation.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-sphere?`.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "skeleton-completion", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_spec_to_code_177", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\n\nReturn only executable Scheme code for `point-in-sphere?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-sphere?`\nSignature: `(point-in-sphere? point sphere)`\n\nReturn only executable Scheme code for `point-in-sphere?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "doc-free", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_spec_to_code_178", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\nDescription: Return #t iff point is inside or on aabb\n\nWrite exactly one definition for `point-in-aabb?`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\nDescription: Return #t iff point is inside or on aabb\n\nWrite exactly one definition for `point-in-aabb?`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "spec-to-code", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_179", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-aabb? point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-aabb?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-aabb? point box)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-aabb?`.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "skeleton-completion", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_180", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\n\nReturn only executable Scheme code for `point-in-aabb?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-aabb?`\nSignature: `(point-in-aabb? point box)`\n\nReturn only executable Scheme code for `point-in-aabb?` without `(doc ...)` forms.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-aabb? point box)\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "doc-free", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_spec_to_code_181", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\nDescription: Return #t iff point is inside triangle (point must be coplanar)\n\nWrite exactly one definition for `point-in-triangle?`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\nDescription: Return #t iff point is inside triangle (point must be coplanar)\n\nWrite exactly one definition for `point-in-triangle?`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "spec-to-code", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_spec_to_code_182", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-triangle? point tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-triangle?`.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nComplete this Fold Scheme skeleton.\n\n```scheme\n(define (point-in-triangle? point tri)\n  ;; TODO: implement\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `point-in-triangle?`.\n\nMatch the stated contract exactly, including edge cases.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "skeleton-completion", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_spec_to_code_183", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Implement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\n\nReturn only executable Scheme code for `point-in-triangle?` without `(doc ...)` forms.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function without doc metadata.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `point-in-triangle?`\nSignature: `(point-in-triangle? point tri)`\n\nReturn only executable Scheme code for `point-in-triangle?` without `(doc ...)` forms.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "doc-free", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_spec_to_code_184", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-line", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-line`\nSignature: `(closest-point-on-line point line)`\nDescription: Return closest point on infinite line to given point\n\nWrite exactly one definition for `closest-point-on-line`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-line`\nSignature: `(closest-point-on-line point line)`\nDescription: Return closest point on infinite line to given point\n\nWrite exactly one definition for `closest-point-on-line`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (closest-point-on-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Point3))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [t (vec3-dot v dir)])\n        (vec3-add origin (vec3-scale dir t))))", "verify_expr": "(let* ([pt (vec3 5 10 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [cp (closest-point-on-line pt ln)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (vec3-z cp)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "closest-point-on-line"], "split": "eval"}
{"id": "geometry_spec_to_code_187", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-plane", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-plane`\nSignature: `(closest-point-on-plane point plane)`\nDescription: Return closest point on plane to given point\n\nWrite exactly one definition for `closest-point-on-plane`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `closest-point-on-plane`\nSignature: `(closest-point-on-plane point plane)`\nDescription: Return closest point on plane to given point\n\nWrite exactly one definition for `closest-point-on-plane`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nAcceptance checks to pass:\n```scheme\n(< (abs (- (vec3-x cp) 5)) 0.001)\n(< (abs (vec3-y cp)) 0.001)\n```\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (closest-point-on-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Point3))\n  (let ([dist (distance-point-plane point plane)]\n        [normal (plane3-normal plane)])\n       (vec3-sub point (vec3-scale normal dist))))", "verify_expr": "(let* ([pt (vec3 5 10 5)] [pl (plane3 (vec3 0 1 0) 0)] [cp (closest-point-on-plane pt pl)]) (and (< (abs (- (vec3-x cp) 5)) 0.001) (< (abs (vec3-y cp)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "closest-point-on-plane"], "split": "eval"}
{"id": "geometry_spec_to_code_196", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-volume", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-volume`\nSignature: `(sphere-volume sphere)`\nDescription: Return volume of sphere\n\nWrite exactly one definition for `sphere-volume`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `sphere-volume`\nSignature: `(sphere-volume sphere)`\nDescription: Return volume of sphere\n\nWrite exactly one definition for `sphere-volume`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (sphere-volume sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Sphere Number))\n  (let ([r (sphere-radius sphere)])\n       (* (/ 4.0 3.0) 3.141592653589793 r r r)))", "verify_expr": "(let* ([sp (sphere (vec3 0 0 0) 1)] [v (sphere-volume sp)]) (< (abs (- v 4.18879)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "sphere-volume"], "split": "eval"}
{"id": "geometry_spec_to_code_202", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-volume", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\nDescription: Return volume of aabb\n\nWrite exactly one definition for `aabb-volume`.\nReturn only code, no explanation.", "prompt": "Task mode: behavior-first function implementation.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-volume`\nSignature: `(aabb-volume box)`\nDescription: Return volume of aabb\n\nWrite exactly one definition for `aabb-volume`.\nReturn only code, no explanation.\n\nMatch the stated contract exactly, including edge cases.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (aabb-volume box)\n  (doc 'export #t)\n  (doc 'type '(-> AABB Number))\n  (let* ([extents (aabb-extents box)]\n         [x (vec3-x extents)]\n         [y (vec3-y extents)]\n         [z (vec3-z extents)])\n        (* 8 x y z)))", "verify_expr": "(let* ([box (aabb (vec3 0 0 0) (vec3 2 3 4))] [v (aabb-volume box)]) (< (abs (- v 24.0)) 0.001))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-volume"], "split": "eval"}
{"id": "geometry_spec_to_code_205", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "barycentric-coords", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `barycentric-coords`\nSignature: `(barycentric-coords p a b c)`\nDescription: Compute barycentric coordinates (u, v, w) of p w.r.t. triangle (a, b, c)\n\nWrite exactly one definition for `barycentric-coords`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `barycentric-coords`\nSignature: `(barycentric-coords p a b c)`\nDescription: Compute barycentric coordinates (u, v, w) of p w.r.t. triangle (a, b, c)\n\nWrite exactly one definition for `barycentric-coords`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nEnsure the definition is production-ready for module integration.", "ground_truth": "(define (barycentric-coords p a b c)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Point3 Point3 (List Number Number Number)))\n  (doc 'description \"Compute barycentric coordinates (u, v, w) of point p with respect to triangle (a, b, c)\")\n  (doc 'note \"p = u*a + v*b + w*c where u + v + w = 1\")\n  (let* ([v0 (vec3-sub b a)]\n         [v1 (vec3-sub c a)]\n         [v2 (vec3-sub p a)]\n         [d00 (vec3-dot v0 v0)]\n         [d01 (vec3-dot v0 v1)]\n         [d11 (vec3-dot v1 v1)]\n         [d20 (vec3-dot v2 v0)]\n         [d21 (vec3-dot v2 v1)]\n         [denom (- (* d00 d11) (* d01 d01))])\n        (if (< (abs denom) 1e-10)\n            (list 1.0 0.0 0.0)  ; Degenerate triangle\n            (let* ([v (/ (- (* d11 d20) (* d01 d21)) denom)]\n                   [w (/ (- (* d00 d21) (* d01 d20)) denom)]\n                   [u (- 1.0 v w)])\n                  (list u v w)))))", "verify_expr": "(let* ([p (vec3 0 0 0)] [a (vec3 0 0 0)] [b (vec3 1 0 0)] [c (vec3 0 1 0)] [bc (barycentric-coords p a b c)]) (and (< (abs (- (car bc) 1.0)) 0.01) (< (abs (cadr bc)) 0.01) (< (abs (caddr bc)) 0.01)))", "tags": ["tier0", "geometry", "spec-to-code", "barycentric-coords"], "split": "eval"}
{"id": "geometry_spec_to_code_211", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-merge", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-merge`\nSignature: `(aabb-merge b1 b2)`\nDescription: Compute minimal AABB containing both boxes\n\nWrite exactly one definition for `aabb-merge`.\nReturn only code, no explanation.", "prompt": "Task mode: complete the target function to match module semantics.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `aabb-merge`\nSignature: `(aabb-merge b1 b2)`\nDescription: Compute minimal AABB containing both boxes\n\nWrite exactly one definition for `aabb-merge`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nBehavior examples your implementation must satisfy:\n```scheme\n(< (abs (vec3-x (aabb-min mg))) 0.001)\n(< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)\n```\n\nPrioritize edge-case behavior when specified by the contract.", "ground_truth": "(define (aabb-merge b1 b2)\n  (doc 'export #t)\n  (doc 'type '(-> AABB AABB AABB))\n  (doc 'description \"Compute minimal AABB containing both boxes\")\n  (let ([min1 (aabb-min b1)]\n        [max1 (aabb-max b1)]\n        [min2 (aabb-min b2)]\n        [max2 (aabb-max b2)])\n       (aabb (vec3 (min (vec3-x min1) (vec3-x min2))\n                   (min (vec3-y min1) (vec3-y min2))\n                   (min (vec3-z min1) (vec3-z min2)))\n             (vec3 (max (vec3-x max1) (vec3-x max2))\n                   (max (vec3-y max1) (vec3-y max2))\n                   (max (vec3-z max1) (vec3-z max2))))))", "verify_expr": "(let* ([b1 (aabb (vec3 0 0 0) (vec3 1 1 1))] [b2 (aabb (vec3 2 2 2) (vec3 3 3 3))] [mg (aabb-merge b1 b2)]) (and (< (abs (vec3-x (aabb-min mg))) 0.001) (< (abs (- (vec3-x (aabb-max mg)) 3)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "aabb-merge"], "split": "eval"}
{"id": "geometry_spec_to_code_217", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-spherical", "prompt_body": "Implement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-spherical`\nSignature: `(vec3-to-spherical v)`\nDescription: Convert Cartesian to spherical (r, θ, φ)\n\nWrite exactly one definition for `vec3-to-spherical`.\nReturn only code, no explanation.", "prompt": "Task mode: implement the API contract in canonical Fold Scheme.\n\nImplement this geometry function in Fold-native Scheme.\n\nTarget module: lattice/geometry/geometry.ss\nFunction: `vec3-to-spherical`\nSignature: `(vec3-to-spherical v)`\nDescription: Convert Cartesian to spherical (r, θ, φ)\n\nWrite exactly one definition for `vec3-to-spherical`.\nReturn only code, no explanation.\n\nFocus on correctness first; keep structure straightforward.\n\nKeep the implementation idiomatic and dependency-aware.", "ground_truth": "(define (vec3-to-spherical v)\n  (doc 'export #t)\n  (doc 'type '(-> Vec3 (List Number Number Number)))\n  (doc 'description \"Convert Cartesian to spherical (r, θ, φ)\")\n  (let* ([x (vec3-x v)]\n         [y (vec3-y v)]\n         [z (vec3-z v)]\n         [r (vec3-length v)]\n         [theta (if (= r 0) 0 (acos (/ z r)))]\n         [phi (atan y x)])\n        (list r theta phi)))", "verify_expr": "(let* ([v (vec3 1 0 0)] [sph (vec3-to-spherical v)]) (and (< (abs (- (car sph) 1.0)) 0.001) (< (abs (- (cadr sph) 1.5708)) 0.001) (< (abs (caddr sph)) 0.001)))", "tags": ["tier0", "geometry", "spec-to-code", "vec3-to-spherical"], "split": "eval"}
{"id": "geometry_translation_148", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-vector`.\nReturn only the Scheme definition.\n\n```python\ndef transform_vector(mat, v):\n    \"\"\"Apply transformation to vector (no translation)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `transform-vector`.\nReturn only the Scheme definition.\n\n```python\ndef transform_vector(mat, v):\n    \"\"\"Apply transformation to vector (no translation)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "transform-vector"], "split": "eval"}
{"id": "geometry_translation_149", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-vector`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-vector\n  (lambda (mat v)\n    (let ([x (vec3-x v)]\n            [y (vec3-y v)]\n            [z (vec3-z v)])\n           (vec3 (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z))\n                 (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z))\n                 (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `transform-vector`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-transform-vector\n  (lambda (mat v)\n    (let ([x (vec3-x v)]\n            [y (vec3-y v)]\n            [z (vec3-z v)])\n           (vec3 (+ (* (matrix-ref mat 0 0) x)\n                    (* (matrix-ref mat 0 1) y)\n                    (* (matrix-ref mat 0 2) z))\n                 (+ (* (matrix-ref mat 1 0) x)\n                    (* (matrix-ref mat 1 1) y)\n                    (* (matrix-ref mat 1 2) z))\n                 (+ (* (matrix-ref mat 2 0) x)\n                    (* (matrix-ref mat 2 1) y)\n                    (* (matrix-ref mat 2 2) z))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "transform-vector"], "split": "eval"}
{"id": "geometry_translation_150", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-vector`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-vector\n    (lambda (mat v)\n      (let ([x (vec3-x v)]\n              [y (vec3-y v)]\n              [z (vec3-z v)])\n             (vec3 (+ (* (matrix-ref mat 0 0) x)\n                      (* (matrix-ref mat 0 1) y)\n                      (* (matrix-ref mat 0 2) z))\n                   (+ (* (matrix-ref mat 1 0) x)\n                      (* (matrix-ref mat 1 1) y)\n                      (* (matrix-ref mat 1 2) z))\n                   (+ (* (matrix-ref mat 2 0) x)\n                      (* (matrix-ref mat 2 1) y)\n                      (* (matrix-ref mat 2 2) z))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `transform-vector`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-transform-vector\n    (lambda (mat v)\n      (let ([x (vec3-x v)]\n              [y (vec3-y v)]\n              [z (vec3-z v)])\n             (vec3 (+ (* (matrix-ref mat 0 0) x)\n                      (* (matrix-ref mat 0 1) y)\n                      (* (matrix-ref mat 0 2) z))\n                   (+ (* (matrix-ref mat 1 0) x)\n                      (* (matrix-ref mat 1 1) y)\n                      (* (matrix-ref mat 1 2) z))\n                   (+ (* (matrix-ref mat 2 0) x)\n                      (* (matrix-ref mat 2 1) y)\n                      (* (matrix-ref mat 2 2) z))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (transform-vector mat v)\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "transform-vector"], "split": "eval"}
{"id": "geometry_translation_151", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-point`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_point(p1, p2):\n    \"\"\"Return Euclidean distance between two points\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-point`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_point(p1, p2):\n    \"\"\"Return Euclidean distance between two points\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-point"], "split": "eval"}
{"id": "geometry_translation_152", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-point`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-point\n  (lambda (p1 p2)\n    (vec3-length (vec3-sub p2 p1))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-point`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-point\n  (lambda (p1 p2)\n    (vec3-length (vec3-sub p2 p1))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-point"], "split": "eval"}
{"id": "geometry_translation_153", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-point`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-point\n    (lambda (p1 p2)\n      (vec3-length (vec3-sub p2 p1))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-point`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-point\n    (lambda (p1 p2)\n      (vec3-length (vec3-sub p2 p1))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-point p1 p2)\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-point"], "split": "eval"}
{"id": "geometry_translation_154", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-plane`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_plane(point, plane):\n    \"\"\"Return signed distance from point to plane (positive = in front)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-plane`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_plane(point, plane):\n    \"\"\"Return signed distance from point to plane (positive = in front)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_155", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-plane\n  (lambda (point plane)\n    (let ([n (plane3-normal plane)]\n            [d (plane3-d plane)])\n           (/ (+ (vec3-dot n point) d)\n              (vec3-magnitude n)))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-plane\n  (lambda (point plane)\n    (let ([n (plane3-normal plane)]\n            [d (plane3-d plane)])\n           (/ (+ (vec3-dot n point) d)\n              (vec3-magnitude n)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_156", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-plane\n    (lambda (point plane)\n      (let ([n (plane3-normal plane)]\n              [d (plane3-d plane)])\n             (/ (+ (vec3-dot n point) d)\n                (vec3-magnitude n)))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-plane\n    (lambda (point plane)\n      (let ([n (plane3-normal plane)]\n              [d (plane3-d plane)])\n             (/ (+ (vec3-dot n point) d)\n                (vec3-magnitude n)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-plane point plane)\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-plane"], "split": "eval"}
{"id": "geometry_translation_157", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-line`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_line(point, line):\n    \"\"\"Return distance from point to infinite line\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-line`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_line(point, line):\n    \"\"\"Return distance from point to infinite line\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-line"], "split": "eval"}
{"id": "geometry_translation_158", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-line`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-line\n  (lambda (point line)\n    (let* ([origin (line3-origin line)]\n             [dir (vec3-normalize (line3-direction line))]\n             [v (vec3-sub point origin)]\n             [proj (vec3-scale dir (vec3-dot v dir))]\n             [perp (vec3-sub v proj)])\n            (vec3-length perp))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-line`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-line\n  (lambda (point line)\n    (let* ([origin (line3-origin line)]\n             [dir (vec3-normalize (line3-direction line))]\n             [v (vec3-sub point origin)]\n             [proj (vec3-scale dir (vec3-dot v dir))]\n             [perp (vec3-sub v proj)])\n            (vec3-length perp))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-line"], "split": "eval"}
{"id": "geometry_translation_159", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-line`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-line\n    (lambda (point line)\n      (let* ([origin (line3-origin line)]\n               [dir (vec3-normalize (line3-direction line))]\n               [v (vec3-sub point origin)]\n               [proj (vec3-scale dir (vec3-dot v dir))]\n               [perp (vec3-sub v proj)])\n              (vec3-length perp))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-line`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-line\n    (lambda (point line)\n      (let* ([origin (line3-origin line)]\n               [dir (vec3-normalize (line3-direction line))]\n               [v (vec3-sub point origin)]\n               [proj (vec3-scale dir (vec3-dot v dir))]\n               [perp (vec3-sub v proj)])\n              (vec3-length perp))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-line point line)\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-line"], "split": "eval"}
{"id": "geometry_translation_160", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_sphere(point, sphere):\n    \"\"\"Return signed distance from point to sphere (negative if inside)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `distance-point-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef distance_point_sphere(point, sphere):\n    \"\"\"Return signed distance from point to sphere (negative if inside)\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "python-to-scheme", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_translation_161", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-sphere\n  (lambda (point sphere)\n    (- (distance-point-point point (sphere-center sphere))\n         (sphere-radius sphere))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `distance-point-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-distance-point-sphere\n  (lambda (point sphere)\n    (- (distance-point-point point (sphere-center sphere))\n         (sphere-radius sphere))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "chez-to-fold", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_translation_162", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-sphere\n    (lambda (point sphere)\n      (- (distance-point-point point (sphere-center sphere))\n           (sphere-radius sphere))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `distance-point-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-distance-point-sphere\n    (lambda (point sphere)\n      (- (distance-point-point point (sphere-center sphere))\n           (sphere-radius sphere))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_translation_163", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-plane`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_plane(ray, plane):\n    \"\"\"Return t parameter where ray intersects plane, or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-plane`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_plane(ray, plane):\n    \"\"\"Return t parameter where ray intersects plane, or #f\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_translation_164", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-plane\n  (lambda (ray plane)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [normal (plane3-normal plane)]\n             [denom (vec3-dot normal dir)])\n            (if (< (abs denom) 1e-10)\n                #f  ; Ray parallel to plane\n                (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                            denom)])\n                     (if (>= t 0) t #f))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-plane`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-plane\n  (lambda (ray plane)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [normal (plane3-normal plane)]\n             [denom (vec3-dot normal dir)])\n            (if (< (abs denom) 1e-10)\n                #f  ; Ray parallel to plane\n                (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                            denom)])\n                     (if (>= t 0) t #f))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_translation_165", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-plane\n    (lambda (ray plane)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [normal (plane3-normal plane)]\n               [denom (vec3-dot normal dir)])\n              (if (< (abs denom) 1e-10)\n                  #f  ; Ray parallel to plane\n                  (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                              denom)])\n                       (if (>= t 0) t #f))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-plane`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-plane\n    (lambda (ray plane)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [normal (plane3-normal plane)]\n               [denom (vec3-dot normal dir)])\n              (if (< (abs denom) 1e-10)\n                  #f  ; Ray parallel to plane\n                  (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                              denom)])\n                       (if (>= t 0) t #f))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_translation_166", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_sphere(ray, sphere):\n    \"\"\"Return (t1 t2) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-sphere`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_sphere(ray, sphere):\n    \"\"\"Return (t1 t2) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_translation_167", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-sphere\n  (lambda (ray sphere)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([center-val (sphere-center sphere)])\n             (let ([radius-val (sphere-radius sphere)])\n             (let ([oc-val (vec3-sub origin-val center-val)])\n             (let ([a-val (vec3-dot dir-val dir-val)])\n             (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n             (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n             (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n             (if (< discriminant-val 0)\n                #f\n                (let* ([sqrt-d-val (sqrt discriminant-val)]\n                       [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                       [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                      (if (or (>= t1-val 0) (>= t2-val 0))\n                          (list t1-val t2-val)\n                          #f))))))))))))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-sphere`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-sphere\n  (lambda (ray sphere)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([center-val (sphere-center sphere)])\n             (let ([radius-val (sphere-radius sphere)])\n             (let ([oc-val (vec3-sub origin-val center-val)])\n             (let ([a-val (vec3-dot dir-val dir-val)])\n             (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n             (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n             (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n             (if (< discriminant-val 0)\n                #f\n                (let* ([sqrt-d-val (sqrt discriminant-val)]\n                       [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                       [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                      (if (or (>= t1-val 0) (>= t2-val 0))\n                          (list t1-val t2-val)\n                          #f))))))))))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_translation_168", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-sphere\n    (lambda (ray sphere)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([center-val (sphere-center sphere)])\n               (let ([radius-val (sphere-radius sphere)])\n               (let ([oc-val (vec3-sub origin-val center-val)])\n               (let ([a-val (vec3-dot dir-val dir-val)])\n               (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n               (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n               (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n               (if (< discriminant-val 0)\n                  #f\n                  (let* ([sqrt-d-val (sqrt discriminant-val)]\n                         [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                         [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                        (if (or (>= t1-val 0) (>= t2-val 0))\n                            (list t1-val t2-val)\n                            #f))))))))))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-sphere`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-sphere\n    (lambda (ray sphere)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([center-val (sphere-center sphere)])\n               (let ([radius-val (sphere-radius sphere)])\n               (let ([oc-val (vec3-sub origin-val center-val)])\n               (let ([a-val (vec3-dot dir-val dir-val)])\n               (let ([b-val (* 2 (vec3-dot oc-val dir-val))])\n               (let ([c-val (- (vec3-dot oc-val oc-val) (* radius-val radius-val))])\n               (let ([discriminant-val (- (* b-val b-val) (* 4 a-val c-val))])\n               (if (< discriminant-val 0)\n                  #f\n                  (let* ([sqrt-d-val (sqrt discriminant-val)]\n                         [t1-val (/ (- (- b-val) sqrt-d-val) (* 2 a-val))]\n                         [t2-val (/ (+ (- b-val) sqrt-d-val) (* 2 a-val))])\n                        (if (or (>= t1-val 0) (>= t2-val 0))\n                            (list t1-val t2-val)\n                            #f))))))))))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_translation_169", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_aabb(ray, box):\n    \"\"\"Return (tmin tmax) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-aabb`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_aabb(ray, box):\n    \"\"\"Return (tmin tmax) intersection parameters, or #f\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_translation_170", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-aabb\n  (lambda (ray box)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([bmin-val (aabb-min box)])\n             (let ([bmax-val (aabb-max box)])\n             ; Helper to compute t-range for one axis\n            (define (slab-t dir-comp origin-comp box-min box-max)\n              (if (< (abs dir-comp) 1e-10)\n                  ; Ray parallel to slab - check if origin-val is within slab\n                  (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                      (list -1e10 1e10)  ; Effectively infinite range\n                      (list 1 -1))       ; Invalid range (will fail intersection)\n                  ; Normal case\n                  (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                         [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                         [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                        (if (< t1-val t2-val)\n                            (list t1-val t2-val)\n                            (list t2-val t1-val)))))\n            (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                   [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                   [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                   [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                   [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                  (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                      (list tmin-val tmax-val)\n                      #f))))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-aabb`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-aabb\n  (lambda (ray box)\n    (let ([origin-val (ray3-origin ray)])\n             (let ([dir-val (ray3-direction ray)])\n             (let ([bmin-val (aabb-min box)])\n             (let ([bmax-val (aabb-max box)])\n             ; Helper to compute t-range for one axis\n            (define (slab-t dir-comp origin-comp box-min box-max)\n              (if (< (abs dir-comp) 1e-10)\n                  ; Ray parallel to slab - check if origin-val is within slab\n                  (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                      (list -1e10 1e10)  ; Effectively infinite range\n                      (list 1 -1))       ; Invalid range (will fail intersection)\n                  ; Normal case\n                  (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                         [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                         [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                        (if (< t1-val t2-val)\n                            (list t1-val t2-val)\n                            (list t2-val t1-val)))))\n            (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                   [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                   [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                   [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                   [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                  (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                      (list tmin-val tmax-val)\n                      #f))))))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_translation_171", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-aabb\n    (lambda (ray box)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([bmin-val (aabb-min box)])\n               (let ([bmax-val (aabb-max box)])\n               ; Helper to compute t-range for one axis\n              (define (slab-t dir-comp origin-comp box-min box-max)\n                (if (< (abs dir-comp) 1e-10)\n                    ; Ray parallel to slab - check if origin-val is within slab\n                    (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                        (list -1e10 1e10)  ; Effectively infinite range\n                        (list 1 -1))       ; Invalid range (will fail intersection)\n                    ; Normal case\n                    (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                           [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                           [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                          (if (< t1-val t2-val)\n                              (list t1-val t2-val)\n                              (list t2-val t1-val)))))\n              (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                     [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                     [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                     [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                     [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                    (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                        (list tmin-val tmax-val)\n                        #f))))))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-aabb`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-aabb\n    (lambda (ray box)\n      (let ([origin-val (ray3-origin ray)])\n               (let ([dir-val (ray3-direction ray)])\n               (let ([bmin-val (aabb-min box)])\n               (let ([bmax-val (aabb-max box)])\n               ; Helper to compute t-range for one axis\n              (define (slab-t dir-comp origin-comp box-min box-max)\n                (if (< (abs dir-comp) 1e-10)\n                    ; Ray parallel to slab - check if origin-val is within slab\n                    (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                        (list -1e10 1e10)  ; Effectively infinite range\n                        (list 1 -1))       ; Invalid range (will fail intersection)\n                    ; Normal case\n                    (let* ([inv-dir-val (/ 1.0 dir-comp)]\n                           [t1-val (* (- box-min origin-comp) inv-dir-val)]\n                           [t2-val (* (- box-max origin-comp) inv-dir-val)])\n                          (if (< t1-val t2-val)\n                              (list t1-val t2-val)\n                              (list t2-val t1-val)))))\n              (let* ([x-range-val (slab-t (vec3-x dir-val) (vec3-x origin-val) (vec3-x bmin-val) (vec3-x bmax-val))]\n                     [y-range-val (slab-t (vec3-y dir-val) (vec3-y origin-val) (vec3-y bmin-val) (vec3-y bmax-val))]\n                     [z-range-val (slab-t (vec3-z dir-val) (vec3-z origin-val) (vec3-z bmin-val) (vec3-z bmax-val))]\n                     [tmin-val (max (car x-range-val) (car y-range-val) (car z-range-val))]\n                     [tmax-val (min (cadr x-range-val) (cadr y-range-val) (cadr z-range-val))])\n                    (if (and (<= tmin-val tmax-val) (>= tmax-val 0))\n                        (list tmin-val tmax-val)\n                        #f))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nres\n(list? res)\n```\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_translation_172", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-triangle`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_triangle(ray, tri):\n    \"\"\"Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `intersect-ray-triangle`.\nReturn only the Scheme definition.\n\n```python\ndef intersect_ray_triangle(ray, tri):\n    \"\"\"Return t parameter where ray intersects triangle (Möller-Trumbore), or #f\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nPreserve these observable behaviors in translation:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "python-to-scheme", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_translation_173", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-triangle`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-triangle\n  (lambda (ray tri)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)]\n             [h (vec3-cross dir edge2)]\n             [a (vec3-dot edge1 h)])\n            (if (< (abs a) 1e-10)\n                #f  ; Ray parallel to triangle\n                (let* ([f (/ 1.0 a)]\n                       [s (vec3-sub origin v0)]\n                       [u (* f (vec3-dot s h))])\n                      (if (or (< u 0.0) (> u 1.0))\n                          #f\n                          (let* ([q (vec3-cross s edge1)]\n                                 [v (* f (vec3-dot dir q))])\n                                (if (or (< v 0.0) (> (+ u v) 1.0))\n                                    #f\n                                    (let ([t (* f (vec3-dot edge2 q))])\n                                         (if (> t 1e-10) t #f))))))))\n  ))\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `intersect-ray-triangle`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-intersect-ray-triangle\n  (lambda (ray tri)\n    (let* ([origin (ray3-origin ray)]\n             [dir (ray3-direction ray)]\n             [v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [edge1 (vec3-sub v1 v0)]\n             [edge2 (vec3-sub v2 v0)]\n             [h (vec3-cross dir edge2)]\n             [a (vec3-dot edge1 h)])\n            (if (< (abs a) 1e-10)\n                #f  ; Ray parallel to triangle\n                (let* ([f (/ 1.0 a)]\n                       [s (vec3-sub origin v0)]\n                       [u (* f (vec3-dot s h))])\n                      (if (or (< u 0.0) (> u 1.0))\n                          #f\n                          (let* ([q (vec3-cross s edge1)]\n                                 [v (* f (vec3-dot dir q))])\n                                (if (or (< v 0.0) (> (+ u v) 1.0))\n                                    #f\n                                    (let ([t (* f (vec3-dot edge2 q))])\n                                         (if (> t 1e-10) t #f))))))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "chez-to-fold", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_translation_174", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-triangle`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-triangle\n    (lambda (ray tri)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)]\n               [h (vec3-cross dir edge2)]\n               [a (vec3-dot edge1 h)])\n              (if (< (abs a) 1e-10)\n                  #f  ; Ray parallel to triangle\n                  (let* ([f (/ 1.0 a)]\n                         [s (vec3-sub origin v0)]\n                         [u (* f (vec3-dot s h))])\n                        (if (or (< u 0.0) (> u 1.0))\n                            #f\n                            (let* ([q (vec3-cross s edge1)]\n                                   [v (* f (vec3-dot dir q))])\n                                  (if (or (< v 0.0) (> (+ u v) 1.0))\n                                      #f\n                                      (let ([t (* f (vec3-dot edge2 q))])\n                                           (if (> t 1e-10) t #f))))))))\n    ))\n\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `intersect-ray-triangle`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-intersect-ray-triangle\n    (lambda (ray tri)\n      (let* ([origin (ray3-origin ray)]\n               [dir (ray3-direction ray)]\n               [v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [edge1 (vec3-sub v1 v0)]\n               [edge2 (vec3-sub v2 v0)]\n               [h (vec3-cross dir edge2)]\n               [a (vec3-dot edge1 h)])\n              (if (< (abs a) 1e-10)\n                  #f  ; Ray parallel to triangle\n                  (let* ([f (/ 1.0 a)]\n                         [s (vec3-sub origin v0)]\n                         [u (* f (vec3-dot s h))])\n                        (if (or (< u 0.0) (> u 1.0))\n                            #f\n                            (let* ([q (vec3-cross s edge1)]\n                                   [v (* f (vec3-dot dir q))])\n                                  (if (or (< v 0.0) (> (+ u v) 1.0))\n                                      #f\n                                      (let ([t (* f (vec3-dot edge2 q))])\n                                           (if (> t 1e-10) t #f))))))))\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic checks for the translated function:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_translation_175", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-sphere?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_sphere_p(point, sphere):\n    \"\"\"Return #t iff point is inside or on sphere\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-sphere?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_sphere_p(point, sphere):\n    \"\"\"Return #t iff point is inside or on sphere\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "python-to-scheme", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_translation_176", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-sphere?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-sphere?\n  (lambda (point sphere)\n    (<= (distance-point-sphere point sphere) 0)\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-sphere?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-sphere?\n  (lambda (point sphere)\n    (<= (distance-point-sphere point sphere) 0)\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "chez-to-fold", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_translation_177", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-sphere?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-sphere?\n    (lambda (point sphere)\n      (<= (distance-point-sphere point sphere) 0)\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-sphere?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-sphere?\n    (lambda (point sphere)\n      (<= (distance-point-sphere point sphere) 0)\n    ))\n\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_translation_178", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_aabb_p(point, box):\n    \"\"\"Return #t iff point is inside or on aabb\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-aabb?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_aabb_p(point, box):\n    \"\"\"Return #t iff point is inside or on aabb\"\"\"\n    raise NotImplementedError\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nPreserve these observable behaviors in translation:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nPrefer Fold conventions while keeping the same observable behavior.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "python-to-scheme", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_179", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-aabb?\n  (lambda (point box)\n    (let ([p point]\n            [bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (and (>= (vec3-x p) (vec3-x bmin))\n                (<= (vec3-x p) (vec3-x bmax))\n                (>= (vec3-y p) (vec3-y bmin))\n                (<= (vec3-y p) (vec3-y bmax))\n                (>= (vec3-z p) (vec3-z bmin))\n                (<= (vec3-z p) (vec3-z bmax))))\n  ))\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-aabb?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-aabb?\n  (lambda (point box)\n    (let ([p point]\n            [bmin (aabb-min box)]\n            [bmax (aabb-max box)])\n           (and (>= (vec3-x p) (vec3-x bmin))\n                (<= (vec3-x p) (vec3-x bmax))\n                (>= (vec3-y p) (vec3-y bmin))\n                (<= (vec3-y p) (vec3-y bmax))\n                (>= (vec3-z p) (vec3-z bmin))\n                (<= (vec3-z p) (vec3-z bmax))))\n  ))\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "chez-to-fold", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_180", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-aabb?\n    (lambda (point box)\n      (let ([p point]\n              [bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (and (>= (vec3-x p) (vec3-x bmin))\n                  (<= (vec3-x p) (vec3-x bmax))\n                  (>= (vec3-y p) (vec3-y bmin))\n                  (<= (vec3-y p) (vec3-y bmax))\n                  (>= (vec3-z p) (vec3-z bmin))\n                  (<= (vec3-z p) (vec3-z bmax))))\n    ))\n\n```", "prompt": "Task mode: preserve behavior while translating syntax and naming.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-aabb?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-aabb?\n    (lambda (point box)\n      (let ([p point]\n              [bmin (aabb-min box)]\n              [bmax (aabb-max box)])\n             (and (>= (vec3-x p) (vec3-x bmin))\n                  (<= (vec3-x p) (vec3-x bmax))\n                  (>= (vec3-y p) (vec3-y bmin))\n                  (<= (vec3-y p) (vec3-y bmax))\n                  (>= (vec3-z p) (vec3-z bmin))\n                  (<= (vec3-z p) (vec3-z bmax))))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (point-in-aabb? point box)\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_translation_181", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Translate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-triangle?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_triangle_p(point, tri):\n    \"\"\"Return #t iff point is inside triangle (point must be coplanar)\"\"\"\n    raise NotImplementedError\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nTranslate this Python-like snippet into Fold-native Scheme.\nPreserve behavior and use the target name `point-in-triangle?`.\nReturn only the Scheme definition.\n\n```python\ndef point_in_triangle_p(point, tri):\n    \"\"\"Return #t iff point is inside triangle (point must be coplanar)\"\"\"\n    raise NotImplementedError\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "python-to-scheme", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_translation_182", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-triangle?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-triangle?\n  (lambda (point tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [bary (barycentric-coords point v0 v1 v2)]\n             [u (car bary)]\n             [v (cadr bary)]\n             [w (caddr bary)])\n            (and (>= u 0) (>= v 0) (>= w 0)\n                 (<= (+ u v w) 1.0001)))\n  ))\n```", "prompt": "Task mode: semantic translation into idiomatic Fold Scheme.\n\nConvert this Chez-style snippet to canonical Fold style.\nThe target function must be named `point-in-triangle?`.\nReturn only the final Fold definition.\n\n```scheme\n(define legacy-point-in-triangle?\n  (lambda (point tri)\n    (let* ([v0 (triangle3-p1 tri)]\n             [v1 (triangle3-p2 tri)]\n             [v2 (triangle3-p3 tri)]\n             [bary (barycentric-coords point v0 v1 v2)]\n             [u (car bary)]\n             [v (cadr bary)]\n             [w (caddr bary)])\n            (and (>= u 0) (>= v 0) (>= w 0)\n                 (<= (+ u v w) 1.0001)))\n  ))\n```\n\nTranslate semantics faithfully; adapt names to the requested target.\n\nSemantic equivalence is more important than token-level similarity.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "chez-to-fold", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_translation_183", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Extract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-triangle?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-triangle?\n    (lambda (point tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [bary (barycentric-coords point v0 v1 v2)]\n               [u (car bary)]\n               [v (cadr bary)]\n               [w (caddr bary)])\n              (and (>= u 0) (>= v 0) (>= w 0)\n                   (<= (+ u v w) 1.0001)))\n    ))\n\n```", "prompt": "Task mode: convert source-language logic to Fold-native form.\n\nExtract and normalize this geometry source excerpt.\nReturn only one Fold definition for `point-in-triangle?`.\nDrop metadata doc forms and preserve behavior.\n\n```scheme\n;;; lattice/geometry/geometry.ss excerpt\n(require 'vec3)\n(require 'matrix)\n\n(doc 'module 'geometry)\n(doc 'layer 'lattice)\n\n(define (legacy-helper x) x)\n\n  (define legacy-point-in-triangle?\n    (lambda (point tri)\n      (let* ([v0 (triangle3-p1 tri)]\n               [v1 (triangle3-p2 tri)]\n               [v2 (triangle3-p3 tri)]\n               [bary (barycentric-coords point v0 v1 v2)]\n               [u (car bary)]\n               [v (cadr bary)]\n               [w (caddr bary)])\n              (and (>= u 0) (>= v 0) (>= w 0)\n                   (<= (+ u v w) 1.0001)))\n    ))\n\n```\n\nKeep behavior exact while adopting Fold syntax.\n\nSemantic checks for the translated function:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nPreserve boundary conditions and error behavior from the source snippet.", "ground_truth": "(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "source-excerpt-to-fold", "doc-free-target", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_bugfix_050", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-vector mat v)\n  (error 'transform-vector \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (transform-vector mat v)\n  (error 'transform-vector \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-vector"], "split": "eval"}
{"id": "geometry_bugfix_051", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-point p1 p2)\n  (error 'distance-point-point \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-point p1 p2)\n  (error 'distance-point-point \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-point"], "split": "eval"}
{"id": "geometry_bugfix_052", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-plane point plane)\n  (error 'distance-point-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-plane point plane)\n  (error 'distance-point-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-plane"], "split": "eval"}
{"id": "geometry_bugfix_053", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-line point line)\n  (error 'distance-point-line \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-line point line)\n  (error 'distance-point-line \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-line"], "split": "eval"}
{"id": "geometry_bugfix_054", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  (error 'distance-point-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  (error 'distance-point-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_bugfix_055", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  (error 'intersect-ray-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  (error 'intersect-ray-plane \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_bugfix_056", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  (error 'intersect-ray-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  (error 'intersect-ray-sphere \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_bugfix_057", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (caddr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Accessor index shifted from second slot to third slot.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (caddr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\nres\n(list? res)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_bugfix_058", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 0.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 0.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_bugfix_059", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  (error 'point-in-sphere? \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  (error 'point-in-sphere? \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "bugfix", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_bugfix_060", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-aabb? point box)\n  (error 'point-in-aabb? \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-aabb? point box)\n  (error 'point-in-aabb? \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "bugfix", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_bugfix_061", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 0.0001))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 0.0001))))\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "bugfix", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_bugfix_089", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-vector", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-vector mat v)\n  mat)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `transform-vector` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (transform-vector mat v)\n  mat)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(< (abs (- (vec3-x r) 1)) 0.001)\n(< (abs (vec3-y r)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (transform-vector mat v)\n  (doc 'export #t)\n  (doc 'type '(-> Matrix Vec3 Vec3))\n  (doc 'description \"Apply transformation to vector (no translation)\")\n  (let ([x (vec3-x v)]\n        [y (vec3-y v)]\n        [z (vec3-z v)])\n       (vec3 (+ (* (matrix-ref mat 0 0) x)\n                (* (matrix-ref mat 0 1) y)\n                (* (matrix-ref mat 0 2) z))\n             (+ (* (matrix-ref mat 1 0) x)\n                (* (matrix-ref mat 1 1) y)\n                (* (matrix-ref mat 1 2) z))\n             (+ (* (matrix-ref mat 2 0) x)\n                (* (matrix-ref mat 2 1) y)\n                (* (matrix-ref mat 2 2) z)))))", "verify_expr": "(let* ([m (transform-translation (vec3 100 100 100))] [v (vec3 1 0 0)] [r (transform-vector m v)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (vec3-z r)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "transform-vector"], "split": "eval"}
{"id": "geometry_bugfix_090", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-point", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-point p1 p2)\n  p1)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-point` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-point p1 p2)\n  p1)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (distance-point-point p1 p2)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Point3 Number))\n  (vec3-length (vec3-sub p2 p1)))", "verify_expr": "(let* ([p1 (vec3 0 0 0)] [p2 (vec3 3 4 0)] [d (distance-point-point p1 p2)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-point"], "split": "eval"}
{"id": "geometry_bugfix_091", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-plane point plane)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-plane point plane)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distance-point-plane point plane)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Plane3 Number))\n  (doc 'description \"Signed distance (positive = in front of plane)\")\n  (doc 'note \"Handles non-unit normals correctly by dividing by magnitude\")\n  (let ([n (plane3-normal plane)]\n        [d (plane3-d plane)])\n       (/ (+ (vec3-dot n point) d)\n          (vec3-magnitude n))))", "verify_expr": "(let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-plane"], "split": "eval"}
{"id": "geometry_bugfix_092", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-line", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-line point line)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-line` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-line point line)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (distance-point-line point line)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Line3 Number))\n  (let* ([origin (line3-origin line)]\n         [dir (vec3-normalize (line3-direction line))]\n         [v (vec3-sub point origin)]\n         [proj (vec3-scale dir (vec3-dot v dir))]\n         [perp (vec3-sub v proj)])\n        (vec3-length perp)))", "verify_expr": "(let* ([pt (vec3 0 5 0)] [ln (line3 (vec3 0 0 0) (vec3 1 0 0))] [d (distance-point-line pt ln)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-line"], "split": "eval"}
{"id": "geometry_bugfix_093", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `distance-point-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (distance-point-sphere point sphere)\n  point)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))\n```\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (distance-point-sphere point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Number))\n  (doc 'description \"Negative if inside\")\n  (- (distance-point-point point (sphere-center sphere))\n     (sphere-radius sphere)))", "verify_expr": "(let* ([pt (vec3 15 0 0)] [sp (sphere (vec3 0 0 0) 10)] [d (distance-point-sphere pt sp)]) (< (abs (- d 5.0)) 0.001))", "tags": ["tier0", "geometry", "bugfix", "distance-point-sphere"], "split": "eval"}
{"id": "geometry_bugfix_094", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ray)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: minimal patch bug repair.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-plane` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-plane ray plane)\n  ray)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nRegression checks after fixing the bug:\n```scheme\nt\n(< (abs (- t 10.0)) 0.001)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-plane ray plane)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Plane3 (Or Number #f)))\n  (doc 'returns \"t parameter if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [normal (plane3-normal plane)]\n         [denom (vec3-dot normal dir)])\n        (if (< (abs denom) 1e-10)\n            #f  ; Ray parallel to plane\n            (let ([t (/ (- (+ (vec3-dot normal origin) (plane3-d plane)))\n                        denom)])\n                 (if (>= t 0) t #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-plane"], "split": "eval"}
{"id": "geometry_bugfix_095", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-sphere", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ray)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-sphere` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (intersect-ray-sphere ray sphere)\n  ray)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\nres\n(list? res)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-sphere ray sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Sphere (Or (List Number Number) #f)))\n  (doc 'returns \"(t1 t2) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [center (sphere-center sphere)]\n         [radius (sphere-radius sphere)]\n         [oc (vec3-sub origin center)]\n         [a (vec3-dot dir dir)]\n         [b (* 2 (vec3-dot oc dir))]\n         [c (- (vec3-dot oc oc) (* radius radius))]\n         [discriminant (- (* b b) (* 4 a c))])\n        (if (< discriminant 0)\n            #f\n            (let* ([sqrt-d (sqrt discriminant)]\n                   [t1 (/ (- (- b) sqrt-d) (* 2 a))]\n                   [t2 (/ (+ (- b) sqrt-d) (* 2 a))])\n                  (if (or (>= t1 0) (>= t2 0))\n                      (list t1 t2)\n                      #f)))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -20) (vec3 0 0 1))] [sp (sphere (vec3 0 0 0) 5)] [res (intersect-ray-sphere r sp)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 15.0)) 0.001) (< (abs (- (cadr res) 25.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-sphere"], "split": "eval"}
{"id": "geometry_bugfix_096", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 0.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-aabb` in `lattice/geometry/geometry.ss`.\nKnown issue: Important numeric constant changed to 0.0.\n\n```scheme\n(define (intersect-ray-aabb ray box)\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 0.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\nres\n(list? res)\n```\n\nFix root-cause behavior rather than masking symptoms.", "ground_truth": "(define (intersect-ray-aabb ray box)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 AABB (Or (List Number Number) #f)))\n  (doc 'returns \"(tmin tmax) if intersects, #f otherwise\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [bmin (aabb-min box)]\n         [bmax (aabb-max box)])\n        ; Helper to compute t-range for one axis\n        (define (slab-t dir-comp origin-comp box-min box-max)\n          (if (< (abs dir-comp) 1e-10)\n              ; Ray parallel to slab - check if origin is within slab\n              (if (and (>= origin-comp box-min) (<= origin-comp box-max))\n                  (list -1e10 1e10)  ; Effectively infinite range\n                  (list 1 -1))       ; Invalid range (will fail intersection)\n              ; Normal case\n              (let* ([inv-dir (/ 1.0 dir-comp)]\n                     [t1 (* (- box-min origin-comp) inv-dir)]\n                     [t2 (* (- box-max origin-comp) inv-dir)])\n                    (if (< t1 t2)\n                        (list t1 t2)\n                        (list t2 t1)))))\n        \n        (let* ([x-range (slab-t (vec3-x dir) (vec3-x origin) (vec3-x bmin) (vec3-x bmax))]\n               [y-range (slab-t (vec3-y dir) (vec3-y origin) (vec3-y bmin) (vec3-y bmax))]\n               [z-range (slab-t (vec3-z dir) (vec3-z origin) (vec3-z bmin) (vec3-z bmax))]\n               [tmin (max (car x-range) (car y-range) (car z-range))]\n               [tmax (min (cadr x-range) (cadr y-range) (cadr z-range))])\n              (if (and (<= tmin tmax) (>= tmax 0))\n                  (list tmin tmax)\n                  #f))))", "verify_expr": "(let* ([r (ray3 (vec3 0 0 -10) (vec3 0 0 1))] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))] [res (intersect-ray-aabb r box)]) (and res (list? res) (= (length res) 2) (< (abs (- (car res) 9.0)) 0.001) (< (abs (- (cadr res) 11.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-aabb"], "split": "eval"}
{"id": "geometry_bugfix_097", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (error 'intersect-ray-triangle \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `intersect-ray-triangle` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (intersect-ray-triangle ray tri)\n  (error 'intersect-ray-triangle \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: the current implementation violates required behavior.\n\nExpected behavior after patch:\n```scheme\nt\n(< (abs (- t 5.0)) 0.001)\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (intersect-ray-triangle ray tri)\n  (doc 'export #t)\n  (doc 'type '(-> Ray3 Triangle3 (Or Number #f)))\n  (doc 'description \"Möller-Trumbore algorithm\")\n  (let* ([origin (ray3-origin ray)]\n         [dir (ray3-direction ray)]\n         [v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [edge1 (vec3-sub v1 v0)]\n         [edge2 (vec3-sub v2 v0)]\n         [h (vec3-cross dir edge2)]\n         [a (vec3-dot edge1 h)])\n        (if (< (abs a) 1e-10)\n            #f  ; Ray parallel to triangle\n            (let* ([f (/ 1.0 a)]\n                   [s (vec3-sub origin v0)]\n                   [u (* f (vec3-dot s h))])\n                  (if (or (< u 0.0) (> u 1.0))\n                      #f\n                      (let* ([q (vec3-cross s edge1)]\n                             [v (* f (vec3-dot dir q))])\n                            (if (or (< v 0.0) (> (+ u v) 1.0))\n                                #f\n                                (let ([t (* f (vec3-dot edge2 q))])\n                                     (if (> t 1e-10) t #f)))))))))", "verify_expr": "(let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001)))", "tags": ["tier0", "geometry", "bugfix", "intersect-ray-triangle"], "split": "eval"}
{"id": "geometry_bugfix_098", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-sphere?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: localize and fix the behavioral defect.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-sphere?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-sphere? point sphere)\n  point)\n```\n\nReturn only the corrected definition.\n\nRepair the defect without broad refactoring.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (point-in-sphere? point sphere)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Sphere Bool))\n  (<= (distance-point-sphere point sphere) 0))", "verify_expr": "(let* ([pt (vec3 1 1 1)] [sp (sphere (vec3 0 0 0) 10)]) (point-in-sphere? pt sp))", "tags": ["tier0", "geometry", "bugfix", "point-in-sphere?"], "split": "eval"}
{"id": "geometry_bugfix_099", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-aabb?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-aabb? point box)\n  point)\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-aabb?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function incorrectly returns the first argument unchanged.\n\n```scheme\n(define (point-in-aabb? point box)\n  point)\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nKeep the original function signature unchanged.\n\nRegression checks after fixing the bug:\n```scheme\n(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))\n```\n\nRetain public contract while repairing the implementation fault.", "ground_truth": "(define (point-in-aabb? point box)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 AABB Bool))\n  (let ([p point]\n        [bmin (aabb-min box)]\n        [bmax (aabb-max box)])\n       (and (>= (vec3-x p) (vec3-x bmin))\n            (<= (vec3-x p) (vec3-x bmax))\n            (>= (vec3-y p) (vec3-y bmin))\n            (<= (vec3-y p) (vec3-y bmax))\n            (>= (vec3-z p) (vec3-z bmin))\n            (<= (vec3-z p) (vec3-z bmax)))))", "verify_expr": "(let* ([pt (vec3 0 0 0)] [box (aabb (vec3 -1 -1 -1) (vec3 1 1 1))]) (point-in-aabb? pt box))", "tags": ["tier0", "geometry", "bugfix", "point-in-aabb?"], "split": "eval"}
{"id": "geometry_bugfix_100", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (error 'point-in-triangle? \"intentional bug\"))\n```\n\nReturn only the corrected definition.", "prompt": "Task mode: surgical correction with unchanged intended API.\n\nFix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `point-in-triangle?` in `lattice/geometry/geometry.ss`.\nKnown issue: Function raises an error instead of implementing required behavior.\n\n```scheme\n(define (point-in-triangle? point tri)\n  (error 'point-in-triangle? \"intentional bug\"))\n```\n\nReturn only the corrected definition.\n\nApply the smallest coherent fix that restores expected behavior.\n\nBug report summary: \n\nExpected behavior after patch:\n```scheme\n(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))\n```\n\nActual behavior: the provided implementation fails the expectation above.\n\nKeep unrelated logic unchanged unless needed for correctness.", "ground_truth": "(define (point-in-triangle? point tri)\n  (doc 'export #t)\n  (doc 'type '(-> Point3 Triangle3 Bool))\n  (doc 'note \"Point must be coplanar with triangle\")\n  (let* ([v0 (triangle3-p1 tri)]\n         [v1 (triangle3-p2 tri)]\n         [v2 (triangle3-p3 tri)]\n         [bary (barycentric-coords point v0 v1 v2)]\n         [u (car bary)]\n         [v (cadr bary)]\n         [w (caddr bary)])\n        (and (>= u 0) (>= v 0) (>= w 0)\n             (<= (+ u v w) 1.0001))))", "verify_expr": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "tags": ["tier0", "geometry", "bugfix", "point-in-triangle?"], "split": "eval"}
{"id": "geometry_composition_001", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point3` on representative inputs.\n\nEnsure `point3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point3` on representative inputs.\n\nEnsure `point3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3)))", "verify_expr": "(equal? (let ([p (point3 1 2 3)]) (and (= (vec3-x p) 1) (= (vec3-y p) 2) (= (vec3-z p) 3))) #t)", "tags": ["tier0", "geometry", "composition", "point3", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_007", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "line3-origin", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-origin` on representative inputs.\n\nEnsure `line3-origin` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `line3-origin` on representative inputs.\n\nEnsure `line3-origin` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3))", "verify_expr": "(equal? (equal? (line3-origin (line3 (vec3 1 2 3) (vec3 0 1 0))) (vec3 1 2 3)) #t)", "tags": ["tier0", "geometry", "composition", "line3-origin", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_012", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([o (vec3 0 0 0)] [d (vec3 1 0 0)] [r (ray3 o d)]) (and (ray3? r) (equal? (ray3-origin r) o) (equal? (ray3-direction r) d))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_018", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "ray3-direction", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `ray3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-direction` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `ray3-direction` that returns `'ok` when expected behavior holds.\n\nEnsure `ray3-direction` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (ray3-direction (ray3 (vec3 0 0 0) (vec3 0 1 0))) (vec3 0 1 0)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "ray3-direction", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_024", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3?", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3?` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3?` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14))) 'ok 'bad)", "verify_expr": "(equal? (if (and (plane3? (plane3 (vec3 0 1 0) 0)) (not (plane3? '(not-a-plane))) (not (plane3? 3.14))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3?", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_030", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "plane3-from-point-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-point-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-point-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `plane3-from-point-normal` that returns `'ok` when expected behavior holds.\n\nEnsure `plane3-from-point-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([p (vec3 0 5 0)] [n (vec3 0 1 0)] [pl (plane3-from-point-normal p n)]) (and (plane3? pl) (< (abs (- (plane3-d pl) -5)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "plane3-from-point-normal", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_035", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3?` on representative inputs.\n\nEnsure `triangle3?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3?` on representative inputs.\n\nEnsure `triangle3?` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle))))", "verify_expr": "(equal? (and (triangle3? (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))) (not (triangle3? '(not-a-triangle)))) #t)", "tags": ["tier0", "geometry", "composition", "triangle3?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_041", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle3-p3", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p3` on representative inputs.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle3-p3` on representative inputs.\n\nEnsure `triangle3-p3` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9))", "verify_expr": "(equal? (equal? (triangle3-p3 (triangle3 (vec3 1 2 3) (vec3 4 5 6) (vec3 7 8 9))) (vec3 7 8 9)) #t)", "tags": ["tier0", "geometry", "composition", "triangle3-p3", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_047", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "circle-center", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-center` on representative inputs.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `circle-center` on representative inputs.\n\nEnsure `circle-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0))", "verify_expr": "(equal? (equal? (circle-center (circle (vec3 3 4 0) 10)) (vec3 3 4 0)) #t)", "tags": ["tier0", "geometry", "composition", "circle-center", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_053", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere?` on representative inputs.\n\nEnsure `sphere?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere?` on representative inputs.\n\nEnsure `sphere?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere)))", "verify_expr": "(equal? (and (sphere? (sphere (vec3 0 0 0) 1)) (not (sphere? '(not-a-sphere))) (not (sphere? 'sphere))) #t)", "tags": ["tier0", "geometry", "composition", "sphere?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_058", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-radius", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `sphere-radius` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-radius` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `sphere-radius` that returns `'ok` when expected behavior holds.\n\nEnsure `sphere-radius` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (= (sphere-radius (sphere (vec3 0 0 0) 15)) 15) 'ok 'bad)", "verify_expr": "(equal? (if (= (sphere-radius (sphere (vec3 0 0 0) 15)) 15) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "sphere-radius", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_064", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-min", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-min` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-min` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-min` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-min` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5)) 'ok 'bad)", "verify_expr": "(equal? (if (equal? (aabb-min (aabb (vec3 -5 -5 -5) (vec3 5 5 5))) (vec3 -5 -5 -5)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-min", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_070", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-extents", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-extents` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-extents` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-extents` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-extents` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let ([e (aabb-extents (aabb (vec3 0 0 0) (vec3 10 10 10)))]) (< (abs (- (vec3-x e) 5)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-extents", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_075", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "obb-center", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-center` on representative inputs.\n\nEnsure `obb-center` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `obb-center` on representative inputs.\n\nEnsure `obb-center` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3))", "verify_expr": "(equal? (equal? (obb-center (obb (vec3 1 2 3) (list (vec3 1 0 0)) (vec3 1 1 1))) (vec3 1 2 3)) #t)", "tags": ["tier0", "geometry", "composition", "obb-center", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_081", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-identity", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-identity` on representative inputs.\n\nEnsure `transform-identity` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-identity` on representative inputs.\n\nEnsure `transform-identity` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001)))", "verify_expr": "(equal? (let* ([m (transform-identity)] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 1)) 0.001) (< (abs (- (vec3-y r) 2)) 0.001) (< (abs (- (vec3-z r) 3)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-identity", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_087", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-x", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-x` on representative inputs.\n\nEnsure `transform-rotation-x` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-x` on representative inputs.\n\nEnsure `transform-rotation-x` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001)))", "verify_expr": "(equal? (let* ([angle (/ 3.141592653589793 2)] [m (transform-rotation-x angle)] [p (vec3 0 1 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (vec3-y r)) 0.001) (< (abs (- (vec3-z r) 1)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-rotation-x", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_093", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-rotation-axis", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-axis` on representative inputs.\n\nEnsure `transform-rotation-axis` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `transform-rotation-axis` on representative inputs.\n\nEnsure `transform-rotation-axis` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001)))", "verify_expr": "(equal? (let* ([axis (vec3 0 0 1)] [angle (/ 3.141592653589793 2)] [m (transform-rotation-axis axis angle)] [p (vec3 1 0 0)] [r (transform-point m p)]) (and (< (abs (vec3-x r)) 0.001) (< (abs (- (vec3-y r) 1)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "transform-rotation-axis", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_098", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "transform-point", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `transform-point` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-point` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `transform-point` that returns `'ok` when expected behavior holds.\n\nEnsure `transform-point` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([m (transform-translation (vec3 5 10 15))] [p (vec3 1 2 3)] [r (transform-point m p)]) (and (< (abs (- (vec3-x r) 6)) 0.001) (< (abs (- (vec3-y r) 12)) 0.001) (< (abs (- (vec3-z r) 18)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "transform-point", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_104", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "distance-point-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `distance-point-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `distance-point-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `distance-point-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(if (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pt (vec3 0 10 0)] [pl (plane3 (vec3 0 1 0) 0)] [d (distance-point-plane pt pl)]) (< (abs (- d 10.0)) 0.001)) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "distance-point-plane", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_110", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-plane", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-plane` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-plane` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-plane` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([r (ray3 (vec3 0 10 0) (vec3 0 -1 0))] [pl (plane3 (vec3 0 1 0) 0)] [t (intersect-ray-plane r pl)]) (and t (< (abs (- t 10.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "intersect-ray-plane", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_116", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-triangle", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-triangle` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-triangle` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `intersect-ray-triangle` that returns `'ok` when expected behavior holds.\n\nEnsure `intersect-ray-triangle` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nExpression-only output is required (no helper definitions).\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(if (let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([r (ray3 (vec3 0.25 0.25 -5) (vec3 0 0 1))] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [t (intersect-ray-triangle r tri)]) (and t (< (abs (- t 5.0)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "intersect-ray-triangle", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_121", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "point-in-triangle?", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-triangle?` on representative inputs.\n\nEnsure `point-in-triangle?` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: solve by expression synthesis over available functions.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `point-in-triangle?` on representative inputs.\n\nEnsure `point-in-triangle?` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse module APIs directly; avoid re-implementing internal logic.\n\nFavor direct API use over ad-hoc reimplementation.", "ground_truth": "(let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri))", "verify_expr": "(equal? (let* ([pt (vec3 0.25 0.25 0)] [tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))]) (point-in-triangle? pt tri)) #t)", "tags": ["tier0", "geometry", "composition", "point-in-triangle?", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_127", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "closest-point-on-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-aabb` on representative inputs.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `closest-point-on-aabb` on representative inputs.\n\nEnsure `closest-point-on-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001)))", "verify_expr": "(equal? (let* ([pt (vec3 20 5 5)] [box (aabb (vec3 0 0 0) (vec3 10 10 10))] [cp (closest-point-on-aabb pt box)]) (and (< (abs (- (vec3-x cp) 10)) 0.001) (< (abs (- (vec3-y cp) 5)) 0.001) (< (abs (- (vec3-z cp) 5)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "closest-point-on-aabb", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_133", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "sphere-surface-area", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-surface-area` on representative inputs.\n\nEnsure `sphere-surface-area` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `sphere-surface-area` on representative inputs.\n\nEnsure `sphere-surface-area` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001))", "verify_expr": "(equal? (let* ([sp (sphere (vec3 0 0 0) 1)] [a (sphere-surface-area sp)]) (< (abs (- a 12.56637)) 0.001)) #t)", "tags": ["tier0", "geometry", "composition", "sphere-surface-area", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_139", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-normal", "prompt_body": "Compose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle-normal` on representative inputs.\n\nEnsure `triangle-normal` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCompose geometry APIs to check canonical behavior for `triangle-normal` on representative inputs.\n\nEnsure `triangle-normal` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001)))", "verify_expr": "(equal? (let* ([tri (triangle3 (vec3 0 0 0) (vec3 1 0 0) (vec3 0 1 0))] [n (triangle-normal tri)]) (and (< (abs (vec3-x n)) 0.001) (< (abs (vec3-y n)) 0.001) (< (abs (- (vec3-z n) 1)) 0.001))) #t)", "tags": ["tier0", "geometry", "composition", "triangle-normal", "behavior-check", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_144", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "aabb-from-points", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `aabb-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-from-points` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `aabb-from-points` that returns `'ok` when expected behavior holds.\n\nEnsure `aabb-from-points` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nExpression-only output is required (no helper definitions).\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([pts (list (vec3 -1 5 2) (vec3 3 -2 8) (vec3 0 0 0))] [box (aabb-from-points pts)]) (and (< (abs (- (vec3-x (aabb-min box)) -1)) 0.001) (< (abs (- (vec3-x (aabb-max box)) 3)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "aabb-from-points", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_148", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "vec3-to-cylindrical", "prompt_body": "Compose geometry functions to solve this task.\n\nBuild an expression using `vec3-to-cylindrical` that returns `'ok` when expected behavior holds.\n\nEnsure `vec3-to-cylindrical` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: compose existing APIs into one expression.\n\nCompose geometry functions to solve this task.\n\nBuild an expression using `vec3-to-cylindrical` that returns `'ok` when expected behavior holds.\n\nEnsure `vec3-to-cylindrical` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(if (let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001))) 'ok 'bad)", "verify_expr": "(equal? (if (let* ([v (vec3 1 0 5)] [cyl (vec3-to-cylindrical v)]) (and (< (abs (- (car cyl) 1.0)) 0.001) (< (abs (cadr cyl)) 0.001) (< (abs (- (caddr cyl) 5)) 0.001))) 'ok 'bad) 'ok)", "tags": ["tier0", "geometry", "composition", "vec3-to-cylindrical", "behavior-signal", "auto-composition"], "split": "eval"}
{"id": "geometry_composition_149", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "intersect-ray-aabb", "prompt_body": "Compose geometry functions to solve this task.\n\nCast a +Z ray from z=-10 into an AABB and return the entry distance.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCast a +Z ray from z=-10 into an AABB and return the entry distance.\n\nEnsure `intersect-ray-aabb` is used in the expression.\nReturn only one executable Scheme expression.\n\nSolve with an expression that can be evaluated directly.\n\nUse provided module operations to satisfy the requested behavior.", "ground_truth": "(car (intersect-ray-aabb (ray3 (vec3 0 0 -10) (vec3 0 0 1)) (aabb (vec3 -1 -1 -1) (vec3 1 1 1))))", "verify_expr": "(< (abs (- (car (intersect-ray-aabb (ray3 (vec3 0 0 -10) (vec3 0 0 1)) (aabb (vec3 -1 -1 -1) (vec3 1 1 1)))) 9.0)) 0.001)", "tags": ["tier0", "geometry", "composition", "intersect-ray-aabb", "ray-box", "entry-distance"], "split": "eval"}
{"id": "geometry_composition_150", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/geometry/geometry.ss", "source_test": "lattice/geometry/test-geometry.ss", "source_function": "triangle-area", "prompt_body": "Compose geometry functions to solve this task.\n\nCreate a 3-4-5 right triangle in the XY plane and return its area.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.", "prompt": "Task mode: small integration task across module primitives.\n\nCompose geometry functions to solve this task.\n\nCreate a 3-4-5 right triangle in the XY plane and return its area.\n\nEnsure `triangle-area` is used in the expression.\nReturn only one executable Scheme expression.\n\nCompose from existing module functions where appropriate.\n\nKeep the answer as a concise executable expression.", "ground_truth": "(triangle-area (triangle3 (vec3 0 0 0) (vec3 3 0 0) (vec3 0 4 0)))", "verify_expr": "(< (abs (- (triangle-area (triangle3 (vec3 0 0 0) (vec3 3 0 0) (vec3 0 4 0))) 6.0)) 0.001)", "tags": ["tier0", "geometry", "composition", "triangle-area", "triangle", "area"], "split": "eval"}
