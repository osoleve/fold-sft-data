{"id": "algebra_poly_spec_to_code_076", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-make-monic`\nSpec: (poly-make-monic p) -> Polynomial - Scale polynomial so leading coefficient is 1\n\nWrite exactly one Scheme definition for `poly-make-monic`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-make-monic p)\n  (doc 'export #t)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-make-monic"], "split": "eval", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-make-monic`\nSpec: (poly-make-monic p) -> Polynomial - Scale polynomial so leading coefficient is 1\n\nWrite exactly one Scheme definition for `poly-make-monic`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_077", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-make-monic p)\n  ;; TODO: Scale by inverse of leading coefficient\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-make-monic`.", "ground_truth": "(define (poly-make-monic p)\n  (doc 'export #t)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-make-monic"], "split": "eval", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-make-monic p)\n  ;; TODO: Scale by inverse of leading coefficient\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-make-monic`."}
{"id": "algebra_poly_spec_to_code_078", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Implement `poly-make-monic` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-make-monic p) -> Polynomial - Scale polynomial so leading coefficient is 1\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-make-monic p)\n  (doc 'export #t)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-make-monic"], "split": "eval", "prompt": "Implement `poly-make-monic` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-make-monic p) -> Polynomial - Scale polynomial so leading coefficient is 1\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_079", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-extended-gcd`\nSpec: (poly-extended-gcd p1 p2) -> (Polynomial Polynomial Polynomial) - Extended Euclidean algorithm. Returns (gcd, s, t) such that gcd = s*p1 + t*p2\n\nWrite exactly one Scheme definition for `poly-extended-gcd`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-extended-gcd"], "split": "eval", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-extended-gcd`\nSpec: (poly-extended-gcd p1 p2) -> (Polynomial Polynomial Polynomial) - Extended Euclidean algorithm. Returns (gcd, s, t) such that gcd = s*p1 + t*p2\n\nWrite exactly one Scheme definition for `poly-extended-gcd`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_080", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-extended-gcd p1 p2)\n  ;; TODO: Extended Euclidean algorithm for Bezout coefficients\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-extended-gcd`.", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-extended-gcd"], "split": "eval", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-extended-gcd p1 p2)\n  ;; TODO: Extended Euclidean algorithm for Bezout coefficients\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-extended-gcd`."}
{"id": "algebra_poly_spec_to_code_081", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Implement `poly-extended-gcd` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-extended-gcd p1 p2) -> (Polynomial Polynomial Polynomial) - Extended Euclidean algorithm. Returns (gcd, s, t) such that gcd = s*p1 + t*p2\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-extended-gcd"], "split": "eval", "prompt": "Implement `poly-extended-gcd` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-extended-gcd p1 p2) -> (Polynomial Polynomial Polynomial) - Extended Euclidean algorithm. Returns (gcd, s, t) such that gcd = s*p1 + t*p2\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_091", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-square-free`\nSpec: (poly-square-free p) -> Polynomial - Square-free part: p / gcd(p, p'). Removes repeated roots.\n\nWrite exactly one Scheme definition for `poly-square-free`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-square-free p)\n  (doc 'export #t)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-square-free"], "split": "eval", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-square-free`\nSpec: (poly-square-free p) -> Polynomial - Square-free part: p / gcd(p, p'). Removes repeated roots.\n\nWrite exactly one Scheme definition for `poly-square-free`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_092", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-square-free p)\n  ;; TODO: Square-free part: p / GCD(p, p')\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-square-free`.", "ground_truth": "(define (poly-square-free p)\n  (doc 'export #t)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-square-free"], "split": "eval", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-square-free p)\n  ;; TODO: Square-free part: p / GCD(p, p')\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-square-free`."}
{"id": "algebra_poly_spec_to_code_093", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Implement `poly-square-free` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-square-free p) -> Polynomial - Square-free part: p / gcd(p, p'). Removes repeated roots.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-square-free p)\n  (doc 'export #t)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-square-free"], "split": "eval", "prompt": "Implement `poly-square-free` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-square-free p) -> Polynomial - Square-free part: p / gcd(p, p'). Removes repeated roots.\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_097", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-lagrange-interpolate`\nSpec: (poly-lagrange-interpolate F points) -> Polynomial - Lagrange interpolation through points [(x_0, y_0), ..., (x_n, y_n)]\n\nWrite exactly one Scheme definition for `poly-lagrange-interpolate`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-lagrange-interpolate`\nSpec: (poly-lagrange-interpolate F points) -> Polynomial - Lagrange interpolation through points [(x_0, y_0), ..., (x_n, y_n)]\n\nWrite exactly one Scheme definition for `poly-lagrange-interpolate`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_098", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-lagrange-interpolate F points)\n  ;; TODO: Lagrange interpolation through given points\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-lagrange-interpolate`.", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-lagrange-interpolate F points)\n  ;; TODO: Lagrange interpolation through given points\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-lagrange-interpolate`."}
{"id": "algebra_poly_spec_to_code_099", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Implement `poly-lagrange-interpolate` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-lagrange-interpolate F points) -> Polynomial - Lagrange interpolation through points [(x_0, y_0), ..., (x_n, y_n)]\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Implement `poly-lagrange-interpolate` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-lagrange-interpolate F points) -> Polynomial - Lagrange interpolation through points [(x_0, y_0), ..., (x_n, y_n)]\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_100", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-newton-interpolate`\nSpec: (poly-newton-interpolate F points) -> Polynomial - Newton interpolation using divided differences\n\nWrite exactly one Scheme definition for `poly-newton-interpolate`.\nReturn only code, no explanation.", "ground_truth": "(define (poly-newton-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "poly-newton-interpolate"], "split": "eval", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `poly-newton-interpolate`\nSpec: (poly-newton-interpolate F points) -> Polynomial - Newton interpolation using divided differences\n\nWrite exactly one Scheme definition for `poly-newton-interpolate`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_101", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-newton-interpolate F points)\n  ;; TODO: Newton interpolation using divided differences\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-newton-interpolate`.", "ground_truth": "(define (poly-newton-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "poly-newton-interpolate"], "split": "eval", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (poly-newton-interpolate F points)\n  ;; TODO: Newton interpolation using divided differences\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `poly-newton-interpolate`."}
{"id": "algebra_poly_spec_to_code_102", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Implement `poly-newton-interpolate` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-newton-interpolate F points) -> Polynomial - Newton interpolation using divided differences\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (poly-newton-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "poly-newton-interpolate"], "split": "eval", "prompt": "Implement `poly-newton-interpolate` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (poly-newton-interpolate F points) -> Polynomial - Newton interpolation using divided differences\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_spec_to_code_106", "family": "spec_to_code", "category": "implementation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `make-polynomial-ring`\nSpec: (make-polynomial-ring F) -> Ring - Construct polynomial ring F[x] over coefficient field F\n\nWrite exactly one Scheme definition for `make-polynomial-ring`.\nReturn only code, no explanation.", "ground_truth": "(define (make-polynomial-ring F)\n  (doc 'export #t)\n  (make-ring\n   '()\n   (lambda (p1 p2) (poly-add p1 p2))\n   (lambda (p1 p2) (poly-mul p1 p2))\n   (poly-zero-over F)\n   (poly-one-over F)\n   (lambda (p) (poly-neg p))\n   (lambda (p1 p2) (poly-equal? p1 p2))))", "verify_expr": "(let* ([R (make-polynomial-ring Q-field)] [x (poly-x Q-field)] [one (poly-one-over Q-field)]) (and (ring? R) (poly-equal? (ring-add R x (ring-neg R x)) (ring-zero R)) (poly-equal? (ring-mul R x one) x)))", "tags": ["tier0", "algebra", "polynomial", "spec-to-code", "make-polynomial-ring"], "split": "eval", "prompt": "Implement this polynomial algebra function in Fold-native Scheme.\n\nTarget module: lattice/algebra/polynomial.ss\nFunction: `make-polynomial-ring`\nSpec: (make-polynomial-ring F) -> Ring - Construct polynomial ring F[x] over coefficient field F\n\nWrite exactly one Scheme definition for `make-polynomial-ring`.\nReturn only code, no explanation."}
{"id": "algebra_poly_spec_to_code_107", "family": "spec_to_code", "category": "implementation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-polynomial-ring F)\n  ;; TODO: Create Ring structure with poly operations\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-polynomial-ring`.", "ground_truth": "(define (make-polynomial-ring F)\n  (doc 'export #t)\n  (make-ring\n   '()\n   (lambda (p1 p2) (poly-add p1 p2))\n   (lambda (p1 p2) (poly-mul p1 p2))\n   (poly-zero-over F)\n   (poly-one-over F)\n   (lambda (p) (poly-neg p))\n   (lambda (p1 p2) (poly-equal? p1 p2))))", "verify_expr": "(let* ([R (make-polynomial-ring Q-field)] [x (poly-x Q-field)] [one (poly-one-over Q-field)]) (and (ring? R) (poly-equal? (ring-add R x (ring-neg R x)) (ring-zero R)) (poly-equal? (ring-mul R x one) x)))", "tags": ["tier0", "algebra", "polynomial", "skeleton-completion", "make-polynomial-ring"], "split": "eval", "prompt": "Complete this Fold Scheme skeleton.\n\n```scheme\n(define (make-polynomial-ring F)\n  ;; TODO: Create Ring structure with poly operations\n  <TODO>)\n```\n\nReplace `<TODO>` and return only the completed definition for `make-polynomial-ring`."}
{"id": "algebra_poly_spec_to_code_108", "family": "spec_to_code", "category": "implementation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Implement `make-polynomial-ring` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (make-polynomial-ring F) -> Ring - Construct polynomial ring F[x] over coefficient field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition.", "ground_truth": "(define (make-polynomial-ring F)\n  (doc 'export #t)\n  (make-ring\n   '()\n   (lambda (p1 p2) (poly-add p1 p2))\n   (lambda (p1 p2) (poly-mul p1 p2))\n   (poly-zero-over F)\n   (poly-one-over F)\n   (lambda (p) (poly-neg p))\n   (lambda (p1 p2) (poly-equal? p1 p2))))", "verify_expr": "(let* ([R (make-polynomial-ring Q-field)] [x (poly-x Q-field)] [one (poly-one-over Q-field)]) (and (ring? R) (poly-equal? (ring-add R x (ring-neg R x)) (ring-zero R)) (poly-equal? (ring-mul R x one) x)))", "tags": ["tier0", "algebra", "polynomial", "contract-implementation", "make-polynomial-ring"], "split": "eval", "prompt": "Implement `make-polynomial-ring` from this contract.\n\nModule: `lattice/algebra/polynomial.ss`\nContract focus: (make-polynomial-ring F) -> Ring - Construct polynomial ring F[x] over coefficient field F\n\nRequirements:\n1. Keep the exact function name/signature.\n2. Preserve polynomial algebra semantics and edge behavior.\n3. Return only one production-ready definition."}
{"id": "algebra_poly_translation_076", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-make-monic`.\nReturn only the Scheme definition.\n\n```python\ndef make_monic(p):\n    if is_zero_polynomial(p):\n        return p\n    F = polynomial_field(p)\n    lc = polynomial_leading_coeff(p)\n    inv_lc = field_inv(F, lc)\n    return polynomial_scale(p, inv_lc)\n```", "ground_truth": "(define (poly-make-monic p)\n  (doc 'export #t)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-make-monic"], "split": "eval", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-make-monic`.\nReturn only the Scheme definition.\n\n```python\ndef make_monic(p):\n    if is_zero_polynomial(p):\n        return p\n    F = polynomial_field(p)\n    lc = polynomial_leading_coeff(p)\n    inv_lc = field_inv(F, lc)\n    return polynomial_scale(p, inv_lc)\n```"}
{"id": "algebra_poly_translation_077", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-make-monic`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-make-monic\n  (lambda (p)\n    (if (poly-zero? p)\n        p\n        (let* ([F (poly-field p)]\n               [lc (poly-leading-coeff p)]\n               [inv (field-inv F lc)])\n          (poly-scale p inv)))))\n```", "ground_truth": "(define (poly-make-monic p)\n  (doc 'export #t)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-make-monic"], "split": "eval", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-make-monic`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-make-monic\n  (lambda (p)\n    (if (poly-zero? p)\n        p\n        (let* ([F (poly-field p)]\n               [lc (poly-leading-coeff p)]\n               [inv (field-inv F lc)])\n          (poly-scale p inv)))))\n```"}
{"id": "algebra_poly_translation_078", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-make-monic`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-make-monic\n    (lambda (p)\n      (if (poly-zero? p)\n          p\n          (let* ([F (poly-field p)]\n                 [lc (poly-leading-coeff p)]\n                 [inv (field-inv F lc)])\n            (poly-scale p inv)))))\n\n```", "ground_truth": "(define (poly-make-monic p)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-make-monic"], "split": "eval", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-make-monic`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-make-monic\n    (lambda (p)\n      (if (poly-zero? p)\n          p\n          (let* ([F (poly-field p)]\n                 [lc (poly-leading-coeff p)]\n                 [inv (field-inv F lc)])\n            (poly-scale p inv)))))\n\n```"}
{"id": "algebra_poly_translation_079", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-extended-gcd`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_extended_gcd(p1, p2):\n    F = polynomial_field(p1)\n    def loop(r0, r1, s0, s1, t0, t1):\n        if is_zero_polynomial(r1):\n            if is_zero_polynomial(r0):\n                return (r0, s0, t0)\n            lc = polynomial_leading_coeff(r0)\n            inv_lc = field_inv(F, lc)\n            return (polynomial_scale(r0, inv_lc), polynomial_scale(s0, inv_lc), polynomial_scale(t0, inv_lc))\n        q, r2 = polynomial_divmod(r0, r1)\n        s2 = polynomial_sub(s0, polynomial_mul(q, s1))\n        t2 = polynomial_sub(t0, polynomial_mul(q, t1))\n        return loop(r1, r2, s1, s2, t1, t2)\n    return loop(p1, p2, one_polynomial_over(F), zero_polynomial_over(F), zero_polynomial_over(F), one_polynomial_over(F))\n```", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-extended-gcd"], "split": "eval", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-extended-gcd`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_extended_gcd(p1, p2):\n    F = polynomial_field(p1)\n    def loop(r0, r1, s0, s1, t0, t1):\n        if is_zero_polynomial(r1):\n            if is_zero_polynomial(r0):\n                return (r0, s0, t0)\n            lc = polynomial_leading_coeff(r0)\n            inv_lc = field_inv(F, lc)\n            return (polynomial_scale(r0, inv_lc), polynomial_scale(s0, inv_lc), polynomial_scale(t0, inv_lc))\n        q, r2 = polynomial_divmod(r0, r1)\n        s2 = polynomial_sub(s0, polynomial_mul(q, s1))\n        t2 = polynomial_sub(t0, polynomial_mul(q, t1))\n        return loop(r1, r2, s1, s2, t1, t2)\n    return loop(p1, p2, one_polynomial_over(F), zero_polynomial_over(F), zero_polynomial_over(F), one_polynomial_over(F))\n```"}
{"id": "algebra_poly_translation_080", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-extended-gcd`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-extended-gcd\n  (lambda (a b)\n    (let ([F (poly-field a)])\n      (poly-ext-gcd-loop a b\n                         (poly-one-over F) (poly-zero-over F)\n                         (poly-zero-over F) (poly-one-over F)\n                         F))))\n```", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-extended-gcd"], "split": "eval", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-extended-gcd`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-extended-gcd\n  (lambda (a b)\n    (let ([F (poly-field a)])\n      (poly-ext-gcd-loop a b\n                         (poly-one-over F) (poly-zero-over F)\n                         (poly-zero-over F) (poly-one-over F)\n                         F))))\n```"}
{"id": "algebra_poly_translation_081", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-extended-gcd`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-extended-gcd\n    (lambda (a b)\n      (let ([F (poly-field a)])\n        (poly-ext-gcd-loop a b\n                           (poly-one-over F) (poly-zero-over F)\n                           (poly-zero-over F) (poly-one-over F)\n                           F))))\n\n```", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-extended-gcd"], "split": "eval", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-extended-gcd`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'gcd)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-extended-gcd\n    (lambda (a b)\n      (let ([F (poly-field a)])\n        (poly-ext-gcd-loop a b\n                           (poly-one-over F) (poly-zero-over F)\n                           (poly-zero-over F) (poly-one-over F)\n                           F))))\n\n```"}
{"id": "algebra_poly_translation_091", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-square-free`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_square_free(p):\n    p_prime = polynomial_derivative(p)\n    if is_zero_polynomial(p_prime):\n        return p\n    return polynomial_div(p, polynomial_gcd(p, p_prime))\n```", "ground_truth": "(define (poly-square-free p)\n  (doc 'export #t)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-square-free"], "split": "eval", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-square-free`.\nReturn only the Scheme definition.\n\n```python\ndef polynomial_square_free(p):\n    p_prime = polynomial_derivative(p)\n    if is_zero_polynomial(p_prime):\n        return p\n    return polynomial_div(p, polynomial_gcd(p, p_prime))\n```"}
{"id": "algebra_poly_translation_092", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-square-free`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-square-free\n  (lambda (p)\n    (let ([dp (poly-derivative p)])\n      (if (poly-zero? dp)\n          p\n          (poly-div p (poly-gcd p dp))))))\n```", "ground_truth": "(define (poly-square-free p)\n  (doc 'export #t)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-square-free"], "split": "eval", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-square-free`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-square-free\n  (lambda (p)\n    (let ([dp (poly-derivative p)])\n      (if (poly-zero? dp)\n          p\n          (poly-div p (poly-gcd p dp))))))\n```"}
{"id": "algebra_poly_translation_093", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-square-free`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'factorization)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-square-free\n    (lambda (p)\n      (let ([dp (poly-derivative p)])\n        (if (poly-zero? dp)\n            p\n            (poly-div p (poly-gcd p dp))))))\n\n```", "ground_truth": "(define (poly-square-free p)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-square-free"], "split": "eval", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-square-free`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'factorization)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-square-free\n    (lambda (p)\n      (let ([dp (poly-derivative p)])\n        (if (poly-zero? dp)\n            p\n            (poly-div p (poly-gcd p dp))))))\n\n```"}
{"id": "algebra_poly_translation_097", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-lagrange-interpolate`.\nReturn only the Scheme definition.\n\n```python\ndef lagrange_interpolate(F, points):\n    if not points:\n        return zero_polynomial_over(F)\n    result = zero_polynomial_over(F)\n    xs = [pt[0] for pt in points]\n    ys = [pt[1] for pt in points]\n    for i, (xi, yi) in enumerate(zip(xs, ys)):\n        # Compute Lagrange basis polynomial L_i\n        Li = one_polynomial_over(F)\n        denom = field_one(F)\n        for j, xj in enumerate(xs):\n            if i != j:\n                # Li *= (x - xj)\n                factor = make_polynomial(F, [field_neg(F, xj), field_one(F)])\n                Li = polynomial_mul(Li, factor)\n                denom = field_mul(F, denom, field_sub(F, xi, xj))\n        Li = polynomial_scale(Li, field_div(F, yi, denom))\n        result = polynomial_add(result, Li)\n    return result\n```", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-lagrange-interpolate`.\nReturn only the Scheme definition.\n\n```python\ndef lagrange_interpolate(F, points):\n    if not points:\n        return zero_polynomial_over(F)\n    result = zero_polynomial_over(F)\n    xs = [pt[0] for pt in points]\n    ys = [pt[1] for pt in points]\n    for i, (xi, yi) in enumerate(zip(xs, ys)):\n        # Compute Lagrange basis polynomial L_i\n        Li = one_polynomial_over(F)\n        denom = field_one(F)\n        for j, xj in enumerate(xs):\n            if i != j:\n                # Li *= (x - xj)\n                factor = make_polynomial(F, [field_neg(F, xj), field_one(F)])\n                Li = polynomial_mul(Li, factor)\n                denom = field_mul(F, denom, field_sub(F, xi, xj))\n        Li = polynomial_scale(Li, field_div(F, yi, denom))\n        result = polynomial_add(result, Li)\n    return result\n```"}
{"id": "algebra_poly_translation_098", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-lagrange-interpolate`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-lagrange-interpolate\n  (lambda (F pts)\n    (if (null? pts)\n        (poly-zero-over F)\n        (let ([xs (map car pts)] [ys (map cdr pts)])\n          (poly-lagrange-sum F xs ys 0 (poly-zero-over F))))))\n```", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-lagrange-interpolate`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-lagrange-interpolate\n  (lambda (F pts)\n    (if (null? pts)\n        (poly-zero-over F)\n        (let ([xs (map car pts)] [ys (map cdr pts)])\n          (poly-lagrange-sum F xs ys 0 (poly-zero-over F))))))\n```"}
{"id": "algebra_poly_translation_099", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-lagrange-interpolate`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'interpolation)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-lagrange-interpolate\n    (lambda (F pts)\n      (if (null? pts)\n          (poly-zero-over F)\n          (let ([xs (map car pts)] [ys (map cdr pts)])\n            (poly-lagrange-sum F xs ys 0 (poly-zero-over F))))))\n\n```", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-lagrange-interpolate`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'interpolation)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-lagrange-interpolate\n    (lambda (F pts)\n      (if (null? pts)\n          (poly-zero-over F)\n          (let ([xs (map car pts)] [ys (map cdr pts)])\n            (poly-lagrange-sum F xs ys 0 (poly-zero-over F))))))\n\n```"}
{"id": "algebra_poly_translation_100", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-newton-interpolate`.\nReturn only the Scheme definition.\n\n```python\ndef newton_interpolate(F, points):\n    if not points:\n        return zero_polynomial_over(F)\n    xs = [pt[0] for pt in points]\n    ys = [pt[1] for pt in points]\n    # Compute divided differences\n    n = len(points)\n    table = list(ys)\n    coeffs = [table[0]]\n    for j in range(1, n):\n        for i in range(n - 1, j - 1, -1):\n            table[i] = field_div(F, field_sub(F, table[i], table[i-1]), field_sub(F, xs[i], xs[i-j]))\n        coeffs.append(table[j])\n    # Build Newton form\n    result = constant_polynomial(F, coeffs[-1])\n    for i in range(n - 2, -1, -1):\n        factor = make_polynomial(F, [field_neg(F, xs[i]), field_one(F)])\n        result = polynomial_add(constant_polynomial(F, coeffs[i]), polynomial_mul(factor, result))\n    return result\n```", "ground_truth": "(define (poly-newton-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "poly-newton-interpolate"], "split": "eval", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `poly-newton-interpolate`.\nReturn only the Scheme definition.\n\n```python\ndef newton_interpolate(F, points):\n    if not points:\n        return zero_polynomial_over(F)\n    xs = [pt[0] for pt in points]\n    ys = [pt[1] for pt in points]\n    # Compute divided differences\n    n = len(points)\n    table = list(ys)\n    coeffs = [table[0]]\n    for j in range(1, n):\n        for i in range(n - 1, j - 1, -1):\n            table[i] = field_div(F, field_sub(F, table[i], table[i-1]), field_sub(F, xs[i], xs[i-j]))\n        coeffs.append(table[j])\n    # Build Newton form\n    result = constant_polynomial(F, coeffs[-1])\n    for i in range(n - 2, -1, -1):\n        factor = make_polynomial(F, [field_neg(F, xs[i]), field_one(F)])\n        result = polynomial_add(constant_polynomial(F, coeffs[i]), polynomial_mul(factor, result))\n    return result\n```"}
{"id": "algebra_poly_translation_101", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-newton-interpolate`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-newton-interpolate\n  (lambda (F pts)\n    (if (null? pts)\n        (poly-zero-over F)\n        (let* ([xs (map car pts)]\n               [ys (map cdr pts)]\n               [coeffs (poly-divided-differences F xs ys)])\n          (poly-newton-form F xs coeffs))))))\n```", "ground_truth": "(define (poly-newton-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "poly-newton-interpolate"], "split": "eval", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `poly-newton-interpolate`.\nReturn only the final Fold definition.\n\n```scheme\n(define poly-newton-interpolate\n  (lambda (F pts)\n    (if (null? pts)\n        (poly-zero-over F)\n        (let* ([xs (map car pts)]\n               [ys (map cdr pts)]\n               [coeffs (poly-divided-differences F xs ys)])\n          (poly-newton-form F xs coeffs))))))\n```"}
{"id": "algebra_poly_translation_102", "family": "translation", "category": "translation", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-newton-interpolate`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'interpolation)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-newton-interpolate\n    (lambda (F pts)\n      (if (null? pts)\n          (poly-zero-over F)\n          (let* ([xs (map car pts)]\n                 [ys (map cdr pts)]\n                 [coeffs (poly-divided-differences F xs ys)])\n            (poly-newton-form F xs coeffs))))))\n\n```", "ground_truth": "(define (poly-newton-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "poly-newton-interpolate"], "split": "eval", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `poly-newton-interpolate`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'interpolation)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define poly-newton-interpolate\n    (lambda (F pts)\n      (if (null? pts)\n          (poly-zero-over F)\n          (let* ([xs (map car pts)]\n                 [ys (map cdr pts)]\n                 [coeffs (poly-divided-differences F xs ys)])\n            (poly-newton-form F xs coeffs))))))\n\n```"}
{"id": "algebra_poly_translation_106", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-polynomial-ring`.\nReturn only the Scheme definition.\n\n```python\ndef make_polynomial_ring(F):\n    return make_ring(\n        elements=[],  # Not enumerable\n        add_op=lambda p1, p2: polynomial_add(p1, p2),\n        mul_op=lambda p1, p2: polynomial_mul(p1, p2),\n        zero=zero_polynomial_over(F),\n        one=one_polynomial_over(F),\n        neg_fn=lambda p: polynomial_neg(p),\n        equal_fn=lambda p1, p2: polynomial_equal(p1, p2)\n    )\n```", "ground_truth": "(define (make-polynomial-ring F)\n  (doc 'export #t)\n  (make-ring\n   '()\n   (lambda (p1 p2) (poly-add p1 p2))\n   (lambda (p1 p2) (poly-mul p1 p2))\n   (poly-zero-over F)\n   (poly-one-over F)\n   (lambda (p) (poly-neg p))\n   (lambda (p1 p2) (poly-equal? p1 p2))))", "verify_expr": "(let* ([R (make-polynomial-ring Q-field)] [x (poly-x Q-field)] [one (poly-one-over Q-field)]) (and (ring? R) (poly-equal? (ring-add R x (ring-neg R x)) (ring-zero R)) (poly-equal? (ring-mul R x one) x)))", "tags": ["tier0", "algebra", "polynomial", "python-to-scheme", "make-polynomial-ring"], "split": "eval", "prompt": "Translate this Python function into Fold-native Scheme.\nPreserve behavior and keep the function name `make-polynomial-ring`.\nReturn only the Scheme definition.\n\n```python\ndef make_polynomial_ring(F):\n    return make_ring(\n        elements=[],  # Not enumerable\n        add_op=lambda p1, p2: polynomial_add(p1, p2),\n        mul_op=lambda p1, p2: polynomial_mul(p1, p2),\n        zero=zero_polynomial_over(F),\n        one=one_polynomial_over(F),\n        neg_fn=lambda p: polynomial_neg(p),\n        equal_fn=lambda p1, p2: polynomial_equal(p1, p2)\n    )\n```"}
{"id": "algebra_poly_translation_107", "family": "translation", "category": "translation", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-polynomial-ring`.\nReturn only the final Fold definition.\n\n```scheme\n(define make-polynomial-ring\n  (lambda (F)\n    (make-ring\n      '()\n      (lambda (x y) (poly-add x y))\n      (lambda (x y) (poly-mul x y))\n      (poly-zero-over F)\n      (poly-one-over F)\n      (lambda (x) (poly-neg x))\n      (lambda (x y) (poly-equal? x y)))))\n```", "ground_truth": "(define (make-polynomial-ring F)\n  (doc 'export #t)\n  (make-ring\n   '()\n   (lambda (p1 p2) (poly-add p1 p2))\n   (lambda (p1 p2) (poly-mul p1 p2))\n   (poly-zero-over F)\n   (poly-one-over F)\n   (lambda (p) (poly-neg p))\n   (lambda (p1 p2) (poly-equal? p1 p2))))", "verify_expr": "(let* ([R (make-polynomial-ring Q-field)] [x (poly-x Q-field)] [one (poly-one-over Q-field)]) (and (ring? R) (poly-equal? (ring-add R x (ring-neg R x)) (ring-zero R)) (poly-equal? (ring-mul R x one) x)))", "tags": ["tier0", "algebra", "polynomial", "chez-to-fold", "make-polynomial-ring"], "split": "eval", "prompt": "Convert this Chez-style snippet to canonical Fold style.\nThe target function must be named `make-polynomial-ring`.\nReturn only the final Fold definition.\n\n```scheme\n(define make-polynomial-ring\n  (lambda (F)\n    (make-ring\n      '()\n      (lambda (x y) (poly-add x y))\n      (lambda (x y) (poly-mul x y))\n      (poly-zero-over F)\n      (poly-one-over F)\n      (lambda (x) (poly-neg x))\n      (lambda (x y) (poly-equal? x y)))))\n```"}
{"id": "algebra_poly_translation_108", "family": "translation", "category": "translation", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-polynomial-ring`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'ring)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define make-polynomial-ring\n    (lambda (F)\n      (make-ring\n        '()\n        (lambda (x y) (poly-add x y))\n        (lambda (x y) (poly-mul x y))\n        (poly-zero-over F)\n        (poly-one-over F)\n        (lambda (x) (poly-neg x))\n        (lambda (x y) (poly-equal? x y)))))\n\n```", "ground_truth": "(define (make-polynomial-ring F)\n  (make-ring\n   '()\n   (lambda (p1 p2) (poly-add p1 p2))\n   (lambda (p1 p2) (poly-mul p1 p2))\n   (poly-zero-over F)\n   (poly-one-over F)\n   (lambda (p) (poly-neg p))\n   (lambda (p1 p2) (poly-equal? p1 p2))))", "verify_expr": "(let* ([R (make-polynomial-ring Q-field)] [x (poly-x Q-field)] [one (poly-one-over Q-field)]) (and (ring? R) (poly-equal? (ring-add R x (ring-neg R x)) (ring-zero R)) (poly-equal? (ring-mul R x one) x)))", "tags": ["tier0", "algebra", "polynomial", "source-excerpt-to-fold", "doc-free-target", "make-polynomial-ring"], "split": "eval", "prompt": "Extract and translate the target function from this source-style module excerpt.\nReturn only a single Fold definition for `make-polynomial-ring`.\nDrop metadata doc forms from the output and keep executable behavior unchanged.\n\n```scheme\n;;; lattice/algebra/polynomial.ss excerpt\n(require 'prelude)\n(require 'field)\n\n(doc 'module 'polynomial)\n(doc 'section 'ring)\n\n(define (poly-add-coeffs add c1 c2 zero) ...)\n\n  (define make-polynomial-ring\n    (lambda (F)\n      (make-ring\n        '()\n        (lambda (x y) (poly-add x y))\n        (lambda (x y) (poly-mul x y))\n        (poly-zero-over F)\n        (poly-one-over F)\n        (lambda (x) (poly-neg x))\n        (lambda (x y) (poly-equal? x y)))))\n\n```"}
{"id": "algebra_poly_bugfix_030", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-make-monic` in `lattice/algebra/polynomial.ss`.\nKnown issue: Scales by leading coefficient instead of its inverse - amplifies instead of normalizing.\n\n```scheme\n(define (poly-make-monic p)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)])\n        (poly-scale p lc))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-make-monic p)\n  (doc 'export #t)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-make-monic"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-make-monic` in `lattice/algebra/polynomial.ss`.\nKnown issue: Scales by leading coefficient instead of its inverse - amplifies instead of normalizing.\n\n```scheme\n(define (poly-make-monic p)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)])\n        (poly-scale p lc))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_031", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-make-monic", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-make-monic` in `lattice/algebra/polynomial.ss`.\nKnown issue: Negates the polynomial instead of scaling by inverse of leading coefficient.\n\n```scheme\n(define (poly-make-monic p)\n  (if (poly-zero? p)\n      p\n      (poly-neg p)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-make-monic p)\n  (doc 'export #t)\n  (if (poly-zero? p)\n      p\n      (let* ([F (poly-field p)]\n             [lc (poly-leading-coeff p)]\n             [inv-lc (field-inv F lc)])\n        (poly-scale p inv-lc))))", "verify_expr": "(let* ([p (make-polynomial Q-field '(2 4 2))] [m (poly-make-monic p)]) (and (= (poly-leading-coeff m) 1) (= (poly-coeff-at m 0) 1) (= (poly-coeff-at m 1) 2) (= (poly-coeff-at m 2) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-make-monic"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-make-monic` in `lattice/algebra/polynomial.ss`.\nKnown issue: Negates the polynomial instead of scaling by inverse of leading coefficient.\n\n```scheme\n(define (poly-make-monic p)\n  (if (poly-zero? p)\n      p\n      (poly-neg p)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_032", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-extended-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Not making gcd monic - should scale r0, s0, t0 by inverse of leading coeff.\n\n```scheme\n(define (poly-extended-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))\n\n(define (poly-ext-gcd-loop r0 r1 s0 s1 t0 t1 F)\n  (if (poly-zero? r1)\n      (list r0 s0 t0)\n      (let* ([qr (poly-divmod r0 r1)]\n             [q (car qr)]\n             [r2 (cdr qr)]\n             [s2 (poly-sub s0 (poly-mul q s1))]\n             [t2 (poly-sub t0 (poly-mul q t1))])\n        (poly-ext-gcd-loop r1 r2 s1 s2 t1 t2 F))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-extended-gcd"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-extended-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Not making gcd monic - should scale r0, s0, t0 by inverse of leading coeff.\n\n```scheme\n(define (poly-extended-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))\n\n(define (poly-ext-gcd-loop r0 r1 s0 s1 t0 t1 F)\n  (if (poly-zero? r1)\n      (list r0 s0 t0)\n      (let* ([qr (poly-divmod r0 r1)]\n             [q (car qr)]\n             [r2 (cdr qr)]\n             [s2 (poly-sub s0 (poly-mul q s1))]\n             [t2 (poly-sub t0 (poly-mul q t1))])\n        (poly-ext-gcd-loop r1 r2 s1 s2 t1 t2 F))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_033", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-extended-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Initial coefficients swapped - s0 should start at 1 and t0 at 0, not vice versa.\n\n```scheme\n(define (poly-extended-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-zero-over F) (poly-one-over F)\n                       (poly-one-over F) (poly-zero-over F)\n                       F)))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-extended-gcd p1 p2)\n  (doc 'export #t)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-one-over F) (poly-zero-over F)\n                       (poly-zero-over F) (poly-one-over F)\n                       F)))", "verify_expr": "(let* ([p1 (make-polynomial Q-field '(1 1))] [p2 (make-polynomial Q-field '(-1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (and (poly-equal? g lhs) (= (poly-leading-coeff g) 1)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-extended-gcd"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-extended-gcd` in `lattice/algebra/polynomial.ss`.\nKnown issue: Initial coefficients swapped - s0 should start at 1 and t0 at 0, not vice versa.\n\n```scheme\n(define (poly-extended-gcd p1 p2)\n  (let ([F (poly-field p1)])\n    (poly-ext-gcd-loop p1 p2\n                       (poly-zero-over F) (poly-one-over F)\n                       (poly-one-over F) (poly-zero-over F)\n                       F)))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_036", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-square-free` in `lattice/algebra/polynomial.ss`.\nKnown issue: Divides by derivative instead of by gcd(p, p') - gives wrong square-free decomposition.\n\n```scheme\n(define (poly-square-free p)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p p-prime))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-square-free p)\n  (doc 'export #t)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-square-free"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-square-free` in `lattice/algebra/polynomial.ss`.\nKnown issue: Divides by derivative instead of by gcd(p, p') - gives wrong square-free decomposition.\n\n```scheme\n(define (poly-square-free p)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p p-prime))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_037", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-square-free", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-square-free` in `lattice/algebra/polynomial.ss`.\nKnown issue: Returning GCD instead of quotient - should be (poly-div p (poly-gcd p p-prime)).\n\n```scheme\n(define (poly-square-free p)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-gcd p p-prime))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-square-free p)\n  (doc 'export #t)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-div p (poly-gcd p p-prime)))))", "verify_expr": "(let* ([xp1 (make-polynomial Q-field '(1 1))] [xm1 (make-polynomial Q-field '(-1 1))] [p (poly-mul (poly-mul xp1 xp1) xm1)] [sf (poly-square-free p)]) (= (poly-degree sf) 2))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-square-free"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-square-free` in `lattice/algebra/polynomial.ss`.\nKnown issue: Returning GCD instead of quotient - should be (poly-div p (poly-gcd p p-prime)).\n\n```scheme\n(define (poly-square-free p)\n  (let ([p-prime (poly-derivative p)])\n    (if (poly-zero? p-prime)\n        p\n        (poly-gcd p p-prime))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_038", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-lagrange-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Starting index at 1 instead of 0 - misses first point in interpolation.\n\n```scheme\n(define (poly-lagrange-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 1 (poly-zero-over F)))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-lagrange-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Starting index at 1 instead of 0 - misses first point in interpolation.\n\n```scheme\n(define (poly-lagrange-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 1 (poly-zero-over F)))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_039", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-lagrange-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Using car instead of cdr for ys - takes x values instead of y values.\n\n```scheme\n(define (poly-lagrange-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (poly-lagrange-sum F \n        (map car points) \n        (map car points)\n        0 \n        (poly-zero-over F))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-lagrange-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let ([n (length points)]\n            [xs (map car points)]\n            [ys (map cdr points)])\n        (poly-lagrange-sum F xs ys 0 (poly-zero-over F)))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 2) (2 . 5))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 2) (= (poly-eval p 2) 5)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-lagrange-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Using car instead of cdr for ys - takes x values instead of y values.\n\n```scheme\n(define (poly-lagrange-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (poly-lagrange-sum F \n        (map car points) \n        (map car points)\n        0 \n        (poly-zero-over F))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_040", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-newton-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Reversing xs breaks Newton form - should keep original order.\n\n```scheme\n(define (poly-newton-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F (reverse xs) coeffs))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-newton-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-newton-interpolate"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-newton-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Reversing xs breaks Newton form - should keep original order.\n\n```scheme\n(define (poly-newton-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F (reverse xs) coeffs))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_041", "family": "bugfix", "category": "debugging", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-newton-interpolate", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-newton-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Reversing coeffs is wrong - Newton form expects specific order from divided differences.\n\n```scheme\n(define (poly-newton-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [coeffs (reverse (poly-divided-differences F xs ys))])\n        (poly-newton-form F xs coeffs))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (poly-newton-interpolate F points)\n  (doc 'export #t)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [n (length points)]\n             [coeffs (poly-divided-differences F xs ys)])\n        (poly-newton-form F xs coeffs))))", "verify_expr": "(let* ([points '((0 . 1) (1 . 3) (3 . 10))] [p (poly-newton-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 3) (= (poly-eval p 3) 10)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "poly-newton-interpolate"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `poly-newton-interpolate` in `lattice/algebra/polynomial.ss`.\nKnown issue: Reversing coeffs is wrong - Newton form expects specific order from divided differences.\n\n```scheme\n(define (poly-newton-interpolate F points)\n  (if (null? points)\n      (poly-zero-over F)\n      (let* ([xs (map car points)]\n             [ys (map cdr points)]\n             [coeffs (reverse (poly-divided-differences F xs ys))])\n        (poly-newton-form F xs coeffs))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_bugfix_042", "family": "bugfix", "category": "debugging", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial-ring", "prompt_body": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-polynomial-ring` in `lattice/algebra/polynomial.ss`.\nKnown issue: Zero and one elements are swapped - ring-zero is actually 1 and ring-one is actually 0.\n\n```scheme\n(define (make-polynomial-ring F)\n  (make-ring\n   '()\n   (lambda (x y) (poly-add x y))\n   (lambda (x y) (poly-mul x y))\n   (poly-one-over F)\n   (poly-zero-over F)\n   (lambda (x) (poly-neg x))\n   (lambda (x y) (poly-equal? x y))))\n```\n\nReturn only the corrected definition.", "ground_truth": "(define (make-polynomial-ring F)\n  (doc 'export #t)\n  (make-ring\n   '()\n   (lambda (p1 p2) (poly-add p1 p2))\n   (lambda (p1 p2) (poly-mul p1 p2))\n   (poly-zero-over F)\n   (poly-one-over F)\n   (lambda (p) (poly-neg p))\n   (lambda (p1 p2) (poly-equal? p1 p2))))", "verify_expr": "(let* ([R (make-polynomial-ring Q-field)] [x (poly-x Q-field)] [one (poly-one-over Q-field)]) (and (ring? R) (poly-equal? (ring-add R x (ring-neg R x)) (ring-zero R)) (poly-equal? (ring-mul R x one) x)))", "tags": ["tier0", "algebra", "polynomial", "bugfix", "make-polynomial-ring"], "split": "eval", "prompt": "Fix the bug in this Fold Scheme function with minimal semantic changes.\nTarget: `make-polynomial-ring` in `lattice/algebra/polynomial.ss`.\nKnown issue: Zero and one elements are swapped - ring-zero is actually 1 and ring-one is actually 0.\n\n```scheme\n(define (make-polynomial-ring F)\n  (make-ring\n   '()\n   (lambda (x y) (poly-add x y))\n   (lambda (x y) (poly-mul x y))\n   (poly-one-over F)\n   (poly-zero-over F)\n   (lambda (x) (poly-neg x))\n   (lambda (x y) (poly-equal? x y))))\n```\n\nReturn only the corrected definition."}
{"id": "algebra_poly_composition_001", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "make-polynomial", "prompt_body": "Create a polynomial 2 + 3x + x^2 over Q, verify its degree and leading coefficient.\n\nEnsure `make-polynomial` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p (make-polynomial Q-field '(2 3 1))]) (and (= (poly-degree p) 2) (= (poly-leading-coeff p) 1)))", "verify_expr": "(equal? (let* ([p (make-polynomial Q-field '(2 3 1))]) (and (= (poly-degree p) 2) (= (poly-leading-coeff p) 1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "make-polynomial"], "split": "eval", "prompt": "Create a polynomial 2 + 3x + x^2 over Q, verify its degree and leading coefficient.\n\nEnsure `make-polynomial` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_007", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-leading-coeff", "prompt_body": "Compute leading coefficient of (2x+1)*(3x-1) and verify it equals 6.\n\nEnsure `poly-leading-coeff` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(-1 3))] [prod (poly-mul p1 p2)]) (= (poly-leading-coeff prod) 6))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 2))] [p2 (make-polynomial Q-field '(-1 3))] [prod (poly-mul p1 p2)]) (= (poly-leading-coeff prod) 6)) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-leading-coeff"], "split": "eval", "prompt": "Compute leading coefficient of (2x+1)*(3x-1) and verify it equals 6.\n\nEnsure `poly-leading-coeff` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_013", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-mul", "prompt_body": "Verify distributive property: a*(b+c) = a*b + a*c.\n\nEnsure `poly-mul` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([a (make-polynomial Q-field '(1 1))] [b (make-polynomial Q-field '(2 3))] [c (make-polynomial Q-field '(4 5))]) (poly-equal? (poly-mul a (poly-add b c)) (poly-add (poly-mul a b) (poly-mul a c))))", "verify_expr": "(equal? (let* ([a (make-polynomial Q-field '(1 1))] [b (make-polynomial Q-field '(2 3))] [c (make-polynomial Q-field '(4 5))]) (poly-equal? (poly-mul a (poly-add b c)) (poly-add (poly-mul a b) (poly-mul a c)))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-mul"], "split": "eval", "prompt": "Verify distributive property: a*(b+c) = a*b + a*c.\n\nEnsure `poly-mul` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_019", "family": "composition", "category": "usage", "difficulty": "hard", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-extended-gcd", "prompt_body": "Verify Bezout identity: for GCD result (g,s,t), check g = s*p1 + t*p2.\n\nEnsure `poly-extended-gcd` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p1 (make-polynomial Q-field '(1 2 1))] [p2 (make-polynomial Q-field '(1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (poly-equal? g lhs))", "verify_expr": "(equal? (let* ([p1 (make-polynomial Q-field '(1 2 1))] [p2 (make-polynomial Q-field '(1 1))] [result (poly-extended-gcd p1 p2)] [g (car result)] [s (cadr result)] [t (caddr result)] [lhs (poly-add (poly-mul s p1) (poly-mul t p2))]) (poly-equal? g lhs)) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-extended-gcd"], "split": "eval", "prompt": "Verify Bezout identity: for GCD result (g,s,t), check g = s*p1 + t*p2.\n\nEnsure `poly-extended-gcd` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_025", "family": "composition", "category": "usage", "difficulty": "medium", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-lagrange-interpolate", "prompt_body": "Interpolate through (0,1), (1,0), (2,1) and verify all three points.\n\nEnsure `poly-lagrange-interpolate` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([points '((0 . 1) (1 . 0) (2 . 1))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 0) (= (poly-eval p 2) 1)))", "verify_expr": "(equal? (let* ([points '((0 . 1) (1 . 0) (2 . 1))] [p (poly-lagrange-interpolate Q-field points)]) (and (= (poly-eval p 0) 1) (= (poly-eval p 1) 0) (= (poly-eval p 2) 1))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-lagrange-interpolate"], "split": "eval", "prompt": "Interpolate through (0,1), (1,0), (2,1) and verify all three points.\n\nEnsure `poly-lagrange-interpolate` is part of the composed solution.\nReturn only the final Fold expression."}
{"id": "algebra_poly_composition_031", "family": "composition", "category": "usage", "difficulty": "easy", "source_module": "lattice/algebra/polynomial.ss", "source_test": "lattice/algebra/test-polynomial.ss", "source_function": "poly-ring", "prompt_body": "Verify poly-ring is alias for poly-field by comparing results.\n\nEnsure `poly-ring` is part of the composed solution.\nReturn only the final Fold expression.", "ground_truth": "(let* ([p (make-polynomial Q-field '(1 2 3))]) (eq? (poly-ring p) (poly-field p)))", "verify_expr": "(equal? (let* ([p (make-polynomial Q-field '(1 2 3))]) (eq? (poly-ring p) (poly-field p))) #t)", "tags": ["tier0", "algebra", "polynomial", "composition", "poly-ring"], "split": "eval", "prompt": "Verify poly-ring is alias for poly-field by comparing results.\n\nEnsure `poly-ring` is part of the composed solution.\nReturn only the final Fold expression."}
